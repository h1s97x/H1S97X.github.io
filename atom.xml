<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-19T07:25:37.186Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/12/19/Machine-Learing/Regression/"/>
    <id>http://example.com/2023/12/19/Machine-Learing/Regression/</id>
    <published>2023-12-19T07:22:47.498Z</published>
    <updated>2023-12-19T07:25:37.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter-10-Regression"><a href="#Chapter-10-Regression" class="headerlink" title="Chapter 10 Regression"></a>Chapter 10 Regression</h2><p>本章概述<br>本章讲解的是线性模型，首先介绍了线性模型的基本定义和它的特点，并介绍了线性模型在回归和分类任务上如何使用。就线性判别分析这一经典模型介绍了其思想。接着，我们将二分类学习拓展到多分类学习，针对类别不平衡问题，给出了现在常用的方法。<br>3.1<br>基本定义<br>3.1.1<br>线性模型的形式<br>线性模型<br>：试图学得一个（通过属性的线性组合来预测输出值的）函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chapter-10-Regression&quot;&gt;&lt;a href=&quot;#Chapter-10-Regression&quot; class=&quot;headerlink&quot; title=&quot;Chapter 10 Regression&quot;&gt;&lt;/a&gt;Chapter 10 Regression&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/12/19/Machine-Learing/Lagrange-multiplier/"/>
    <id>http://example.com/2023/12/19/Machine-Learing/Lagrange-multiplier/</id>
    <published>2023-12-19T06:18:05.559Z</published>
    <updated>2023-12-19T06:20:53.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拉格朗日乘数简介"><a href="#拉格朗日乘数简介" class="headerlink" title="拉格朗日乘数简介"></a>拉格朗日乘数简介</h1><h3 id="作者：Steuard-Jensen"><a href="#作者：Steuard-Jensen" class="headerlink" title="作者：Steuard Jensen"></a>作者：Steuard Jensen</h3><p>拉格朗日乘子在多变量微积分中用于查找 受约束的函数的最大值和最小值（如“查找 沿给定路径的最高海拔“或”最小化成本 包含给定体积的盒子的材料“）。这是一个有用的 技术，但很多时候它教得很差，而且很差 理解。幸运的是，这个概述将有助于实现这个概念 它的应用更清晰一些。</p><p>以下是本次讨论的基本概述：</p><ul><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Basics">拉格朗日乘数何时为 有用？</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Milkmaid">一个典型的例子：“挤奶女工 问题”</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Graphical">图形灵感 方法</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Method">拉格朗日的数学 乘数</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Mathematical">形式化的数学 灵感</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#SeveralConstraints">几个约束条件 一次</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Meaning">乘数的含义</a>（受物理学和经济学的启发）</li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Examples">拉格朗日乘数的例子 行动</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#CalcVari">微积分中的拉格朗日乘子 变化（通常在物理学中）</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#NoSlip">举个例子：滚动没有 滑 倒</a></li></ul><h2 id="拉格朗日乘数何时为-有用？"><a href="#拉格朗日乘数何时为-有用？" class="headerlink" title="拉格朗日乘数何时为 有用？"></a>拉格朗日乘数何时为 有用？</h2><p>最常见的一种 微积分的问题是求最大值或最小值（在 一般，“extrema”）的函数，但通常很难为被极端化的函数找到一个封闭形式。这样 当人们希望最大化或最小化时，往往会出现困难功能受固定外部条件或约束的约束。拉格朗日乘子法是解决这一类问题的有力工具 ，无需显式解决 条件，并使用它们来消除额外的变量。</p><p>更简单地说，问“我该怎么做”通常是不够的 尽量减少制造这个罐头所需的铝？（答案 这显然是“做一个非常非常小的罐头！你需要 问，“我如何在<em>确保罐头的同时尽量减少铝 能装10盎司的汤</em>吗？或者类似地，“我该怎么做 最大化我工厂的利润，<em>因为我只有 15,000 美元 投资</em>？或者举一个更复杂的例子，“如何 假设过山车会很快<em>到达地面 留在赛道上</em>？一般来说，拉格朗日乘数是 当某些变量在最简单的描述中很有用 问题因约束而变得多余。</p><h2 id="一个典型的例子：-“挤奶女工问题”"><a href="#一个典型的例子：-“挤奶女工问题”" class="headerlink" title="一个典型的例子： “挤奶女工问题”"></a>一个典型的例子： “挤奶女工问题”</h2><p>为了给出这种具体、直观的例证 问题，我们将考虑一个经典的例子，我相信是 被称为“挤奶女工问题”。可以这样表述：</p><p><img src="http://www.slimy.com/~steuard/teaching/tutorials/Milkmaid1.gif" alt="挤奶女工和河边奶牛的照片。"></p><p>现在是农场的挤奶时间，挤奶女工已经 被送到田里去拿当天的牛奶。她急于 回来和一个英俊的年轻牧羊人约会，所以她 想尽快完成自己的工作。但是，在之前 她可以收集牛奶，她必须冲洗掉她的桶 附近的河流。</p><p>就在她到达 <strong>M</strong> 点时，我们的女主角发现了 牛，在<strong>C</strong>点向下。因为时间匆忙，所以她 想从她所在的地方走最短的路径 河，然后是牛。那么<strong>P</strong>上的最佳点是什么 河岸让她冲洗水桶？（为了简单起见， 我们假设场是平坦均匀的，并且所有点 在河岸上同样好。</p><p>用更数学的术语来说，挤奶女工想要 求总距离 <strong>f</strong>（<strong>P</strong>） 的点 P 是最小值，其中 f（<strong>P</strong>） 是距离的总和 d（<strong>M，P</strong>） 从 <strong>M</strong> 到 <strong>P</strong> 和距离 d（<strong>P，C</strong>） 从 <strong>P</strong> 到 <strong>C</strong>（一条直线是 平坦场地上两点之间的最短距离）。 然而，事情并没有那么简单：如果这就是全部 问题，那么我们可以在线上的任何位置选择 <strong>P</strong> 在<strong>M</strong>和<strong>C</strong>之间，挤奶女工会笔直地走 对奶牛。但是我们必须施加<em>一个约束</em>，<strong>即 P</strong> 是河岸上的一个点。</p><p>为了在方程中表达该约束，我们可以描述 河岸的形状作为曲线满足一些 函数 g（x，y） &#x3D; 0。（例如，如果河流是 我们可能选择的抛物线 g（x，y） &#x3D; y - x2.如果是相反的 我们可以选择半径为R的圆形湖泊 g（x，y） &#x3D; x 2 + y 2 - r2.） 因此，从形式上讲，我们必须最小化功能 f（<strong>P</strong>） &#x3D; d（<strong>M，P</strong>） + d（<strong>P</strong>， <strong>C</strong>），受以下约束 g（<strong>P</strong>） &#x3D; 0.</p><h2 id="图形灵感-方法"><a href="#图形灵感-方法" class="headerlink" title="图形灵感 方法"></a>图形灵感 方法</h2><p>我们对这个问题的第一种思考方式可以得到 直接来自图片本身。我们想想象一下 挤奶女工可以得到任何固定的总距离 f（<strong>P</strong>），并且 使用该可视化来定位最佳点 <strong>P</strong>。如果我们 只关心 <strong>P</strong> 到 <strong>M</strong> 的距离，我们可能 将其想象为一组同心圆（常数曲线 距离d（<strong>M，P</strong>）：5米、10米、15米、 等）。一旦其中一个圆圈大到足以触及 河流，我们会认出它接触的点是最近的 河岸指向 <strong>M</strong>（其半径为最小值 距离）。</p><p>当然，对于大多数问题，常数 f（<strong>P</strong>） 的曲线 比一堆同心圆还要复杂！（通常要复杂<em>得多</em>。但是我们的具体例子是 几何学中一个晦涩难懂的事实使它变得简单：对于给定椭圆上的每一个点 <strong>P</strong>，与一个焦点的总距离 椭圆到 <strong>P</strong>，然后到另一个焦点正好是 相同。（你不需要知道这个事实从何而来 理解这个例子！但是你可以看到它为自己工作 在两个钉子的帮助下画出一个近乎完美的椭圆，一个 铅笔和一圈绳子。</p><p>在我们的问题中，这意味着挤奶女工可以到达 牛通过给定椭圆上任意点的相同数量 时间：椭圆是常数 f（<strong>P</strong>） 的曲线。因此 要在河岸上找到所需的点 <strong>P</strong>，我们必须 只需找到最小的椭圆，<strong>M</strong> 和 <strong>C</strong> 为 与河流曲线相交的焦点。需要明确的是， 只有曲线的“常数 f（<strong>P</strong>）”属性才是真正的 重要;这些曲线是椭圆这一事实只是一个幸运 方便（椭圆很容易绘制）。同样的想法会奏效 无论常数 f（<strong>P</strong>） 的曲线发生在什么形状 是。</p><p><img src="http://www.slimy.com/~steuard/teaching/tutorials/Milkmaid.gif" alt="相同的图片，但周围有省略号  挤奶女工和奶牛。"></p><p>右图显示了一系列较大的椭圆 和较大的尺寸，其病灶是 <strong>M</strong> 和 <strong>C</strong>，结束 与河岸<em>相切</em>的那个。 这是一个非常有意义的词！从图片中可以明显看出 “完美”的椭圆和河流是真正切线的 在理想点 <strong>P</strong> 处相互对立。从数学上讲， 这意味着椭圆的法向量位于同一位置 方向作为河岸的法向量。几分钟 想想这样的照片会让你相信这 事实并非特定于此问题：它是一个一般属性 每当你有限制时。这就是洞察力 将我们引向拉格朗日乘数的方法。</p><h2 id="拉格朗日的数学-乘数"><a href="#拉格朗日的数学-乘数" class="headerlink" title="拉格朗日的数学 乘数"></a>拉格朗日的数学 乘数</h2><p>在多变量微积分中，函数 h 的梯度 （写成 ∇h） 是曲线的法向量（分为两个 尺寸）或表面（在更高的维度上），其中 h 位于 常数：<strong>n</strong> &#x3D; ∇h（<strong>P</strong>）。法线的长度 向量无关紧要：∇h（<strong>P</strong>） 的任何常数倍数 也是一个正常的向量。在我们的例子中，我们有两个函数，其 法向量是平行的，所以</p><p>∇f（<strong>P</strong>） &#x3D; λ ∇g（<strong>P</strong>）。</p><p>未知常数乘数 λ 为 是必要的，因为两个梯度的大小可能是 不同。（请记住，我们只知道他们的方向是 相同。</p><p>在 D 维中，我们现在有 D+1 未知数中的 D+1 方程。D 未知数是 <strong>P</strong> 的坐标（例如 x、y、 和 z 表示 D &#x3D; 3），另一个是新的未知数 常数 λ。上面推导的梯度公式为 一个向量方程，因此它提供了 D 个约束方程。我 一旦在这一点上卡在考试中：不要让它发生 你！原始约束方程 g（<strong>P</strong>） &#x3D; 0 为 系统中的最后一个方程。因此，一般来说，一个独特的 解决方案存在。</p><p>与许多最大&#x2F;最小问题一样，确实存在以下情况 多种解决方案。甚至可以有无限数量的 如果约束条件特别退化，则解决方案：想象一下 如果挤奶女工和奶牛都已经站在 例如，一条笔直的河岸。在许多情况下， 拉格朗日乘数的实际值并不有趣，但是 在某些情况下，它可以提供有用的信息 （<a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Meaning">如下</a>所述）。</p><p>就是这样：这就是拉格朗日乘数的全部内容。只 将要极化的函数的梯度设置为等于 约束函数的梯度。你会得到一个矢量的 （代数）方程的价值，以及原始 约束方程 它们决定了解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拉格朗日乘数简介&quot;&gt;&lt;a href=&quot;#拉格朗日乘数简介&quot; class=&quot;headerlink&quot; title=&quot;拉格朗日乘数简介&quot;&gt;&lt;/a&gt;拉格朗日乘数简介&lt;/h1&gt;&lt;h3 id=&quot;作者：Steuard-Jensen&quot;&gt;&lt;a href=&quot;#作者：Steuard-J</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Machine-Learing SVM</title>
    <link href="http://example.com/2023/12/19/Machine-Learing/Machine-Learing-SVM/"/>
    <id>http://example.com/2023/12/19/Machine-Learing/Machine-Learing-SVM/</id>
    <published>2023-12-19T06:06:44.000Z</published>
    <updated>2023-12-19T06:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习的一般框架：<br>训练集 &#x3D;&gt; 提取特征向量 &#x3D;&gt; 结合一定的算法（分类器：比如决策树、KNN）&#x3D;&gt;得到结果</p><h2 id="Chapter-9-Support-Vector-Machines（SVM）"><a href="#Chapter-9-Support-Vector-Machines（SVM）" class="headerlink" title="Chapter 9 Support Vector Machines（SVM）"></a>Chapter 9 Support Vector Machines（SVM）</h2><p>支持向量机（support vector machines，SVM）是一种二分类模型，它将实例的特征向量映射为空间中的一些点，SVM 的目的就是想要画出一条线，以 “最好地” 区分这两类点，以至如果以后有了新的点，这条线也能做出很好的分类。SVM 适合中小型数据样本、非线性、高维的分类问题。</p><p>SVM 最早是由 Vladimir N. Vapnik 和 Alexey Ya. Chervonenkis 在1963年提出，目前的版本（soft margin）是由 Corinna Cortes 和 Vapnik 在1993年提出，并在1995年发表。深度学习（2012）出现之前，SVM 被认为机器学习中近十几年来最成功，表现最好的算法。</p><h3 id="SVM-基本概念"><a href="#SVM-基本概念" class="headerlink" title="SVM 基本概念"></a>SVM 基本概念</h3><p>将实例的特征向量（以二维为例）映射为空间中的一些点，如下图的实心点和空心点，它们属于不同的两类。SVM 的目的就是想要画出一条线，以“最好地”区分这两类点，以至如果以后有了新的点，这条线也能做出很好的分类。</p><p>Q1：能够画出多少条线对样本点进行区分？<br>答：线是有无数条可以画的，区别就在于效果好不好，每条线都可以叫做一个划分超平面。比如上面的绿线就不好，蓝线还凑合，红线看起来就比较好。我们所希望找到的这条效果最好的线就是具有 “最大间隔的划分超平面”。</p><p>Q2：为什么要叫作“超平面”呢？<br>答：因为样本的特征很可能是高维的，此时样本空间的划分就不是一条线了。</p><p>Q3：画线的标准是什么？&#x2F; 什么才叫这条线的效果好？&#x2F; 哪里好？<br>答：SVM 将会寻找可以区分两个类别并且能使间隔（margin）最大的划分超平面。比较好的划分超平面，样本局部扰动时对它的影响最小、产生的分类结果最鲁棒、对未见示例的泛化能力最强。</p><p>Q4：间隔（margin）是什么？<br>答：对于任意一个超平面，其两侧数据点都距离它有一个最小距离（垂直距离），这两个最小距离的和就是间隔。比如下图中两条虚线构成的带状区域就是 margin，虚线是由距离中央实线最近的两个点所确定出来的（也就是由支持向量决定）。但此时 margin 比较小，如果用第二种方式画，margin 明显变大也更接近我们的目标。</p><p>Q5：为什么要让 margin 尽量大？<br>答：因为大 margin 犯错的几率比较小，也就是更鲁棒啦。</p><p>Q6：支持向量是什么？<br>答：从上图可以看出，虚线上的点到划分超平面的距离都是一样的，实际上只有这几个点共同确定了超平面的位置，因此被称作 “支持向量（support vectors）”，“支持向量机” 也是由此来的。</p><h2 id="拉格朗日乘子法："><a href="#拉格朗日乘子法：" class="headerlink" title="拉格朗日乘子法："></a>拉格朗日乘子法：</h2><ul><li>拉格朗日乘子法（Lagrange multipliers）是一种寻找多元函数<strong>在一组约束下</strong>的<strong>极值</strong>的方法。</li><li>通过引入拉格朗日乘子，可将有 <code>d</code> 个变量与 <code>k</code> 个约束条件的最优化问题转化为具有 �+� 个变量的无约束优化问题求解。</li></ul><p>举个例子：</p><ul><li>这是一个等式约束，即约束条件是等式。当然约束条件也可以是不等式。</li><li>像这种需要<strong>在约束条件下求极值</strong>的问题，我们就可以用拉格朗日乘子法来做。</li></ul><h3 id="线性可分的SVM"><a href="#线性可分的SVM" class="headerlink" title="线性可分的SVM"></a>线性可分的SVM</h3><p>SVM的终极目标还是要解决数据线性不可分的情况。解决这种线性不可分的情况基本的思路有两种：</p><ul><li>加入松弛变量和惩罚因子，找到相对“最好”超平面，这里的“最好”可以理解为尽可能地将数据正确分类；</li><li>使用核函数，将低维的数据映射到更高维的空间，使得在高维空间中数据是线性可分的，那么在高维空间使用线性分类模型即可；</li></ul><ol><li>松弛变量和惩罚因子<br>1.1 定义<br>所谓线性不可分，说得形象一些，就是“你中有我，或者我中有你”，我们找不到一个超平面，恰好能把两类数据严格地分开。举个例子，Fig.1(a)中，白色数据元组中有一个点比较“另类”（我用文字标了出来），它跑到人家黑色元组的区域中去了，显然，如果这个点直接被忽略掉，那么分类效果是很好的（比如Fig.1(a)中的蓝色虚线），但是现在的情况就让人很难受，因为我们找不到一个超平面，恰好能把黑白两类数据分开。</li></ol><p>还有一种情况也比较有意思，就是现在数据还是线性可分的，比如Fig.1(b)，但是存在一个“异常点”（SVM中称之为outlier），如果忽略它，最佳分离超平面的效果非常好，但是如果按正常的套路训练的话，我们只能得到一个“差强人意”的结果。如Fig.1(b)所示，有它或没它，超平面的训练效果是有很鲜明对比的。</p><p>针对上面这两种情况，最直接的解决思路就是能不能适当的放宽数据点和边缘侧面之间的关系？还记得之前线性可分情况下的约束条件是这样的：</p><h3 id="总体线性可分，存在噪点使得线性不可分-x2F-局部采样线性不可分"><a href="#总体线性可分，存在噪点使得线性不可分-x2F-局部采样线性不可分" class="headerlink" title="总体线性可分，存在噪点使得线性不可分&#x2F;局部采样线性不可分"></a>总体线性可分，存在噪点使得线性不可分&#x2F;局部采样线性不可分</h3><h3 id="线性不可分的SVM"><a href="#线性不可分的SVM" class="headerlink" title="线性不可分的SVM"></a>线性不可分的SVM</h3><p>非线性 SVM： 特征空间 </p><p>总体思路：原始输入空间可以映射到某个高维特征空间，其中训练集是可分离的</p><p><img src="/../img/Machine-Learning/Non-linear-svm.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;机器学习的一般框架：&lt;br&gt;训练集 &amp;#x3D;&amp;gt; 提取特征向量 &amp;#x3D;&amp;gt; 结合一定的算法（分类器：比如决策树、KNN）&amp;#x3D;&amp;gt;得到结果&lt;/p&gt;
&lt;h2 id=&quot;Chapter-9-Support-Vector-Machines（SVM）&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学原理与实践实验</title>
    <link href="http://example.com/2023/12/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2023/12/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-12-06T03:12:41.000Z</published>
    <updated>2023-12-06T03:12:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.byhy.net/">白月黑羽 (byhy.net)</a></p><h3 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>本课程实验跟过去有所不同，因为是基于新设备的实验，所以没有往届可以参考的内容。</p><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><ol><li>基于密码实验实践教学工具套件，结合软件工程，分析该系统存在的设计与实现问题，提出修改和改进完善的方案。</li><li>通过一系列密码算法的独立编码接口封装实现（可借助于开源代码），熟悉并掌握常规的分组对称密码算法、序列对称密码算法、HASH函数、MAC函数、数字签名算法的接口编制方法，并能够利用可用编程接口针对文件加解密实现一个实用工具设计，要求体现：</li></ol><p>（1）各种密码技术在方案设计中得到正确、合理、合适的集成应用；</p><p>（2）方案设计体现安全性与方便性的结合与平衡。</p><p>（3）可以针对任意类型、任意大小的文件操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.byhy.net/&quot;&gt;白月黑羽 (byhy.net)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;实验介绍&quot;&gt;&lt;a href=&quot;#实验介绍&quot; class=&quot;headerlink&quot; title=&quot;实验介绍&quot;&gt;&lt;/a&gt;实验介绍&lt;/h3&gt;&lt;h4 id</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件工程复习</title>
    <link href="http://example.com/2023/12/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2023/12/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/</id>
    <published>2023-12-04T02:19:01.000Z</published>
    <updated>2023-12-04T02:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://blog.csdn.net/m0_52100140/article/details/122176673">山东大学软件工程期末复习知识点总结-CSDN博客</a></p><p><a href="https://www.kdocs.cn/l/ctpzm2DAMXy6">09_软件工程_山软智库知识见解_V1.1(1) (kdocs.cn)</a></p><p><a href="https://so.csdn.net/so/search?q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B&t=blog&u=weixin_45781228">软件工程- CSDN搜索</a></p><p><a href="https://blog.csdn.net/qq_50740678/article/details/125111898">2022软件工程期末复习笔记_Stephen Haw King的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_44220394/article/details/111315161">山东大学软件学院2020-2021 软件工程考试纲要与考题回忆_山东大学软件学院考试大纲-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_37989980/article/details/104470064">UML一一 类图关系 (泛化、实现、依赖、关联、聚合、组合)_uml类图关系-CSDN博客</a></p><p><a href="https://luckyray-fan.github.io/2019/12/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#SE">软件工程 | luckyray (luckyray-fan.github.io)</a></p><h2 id="Chapter-1-软件工程概述"><a href="#Chapter-1-软件工程概述" class="headerlink" title="Chapter 1 软件工程概述"></a>Chapter 1 软件工程概述</h2><h3 id="1-软件工程的定义、目标、方法"><a href="#1-软件工程的定义、目标、方法" class="headerlink" title="1.软件工程的定义、目标、方法"></a>1.软件工程的定义、目标、方法</h3><p>定义：两个关键词</p><p>理解问题的<strong>本质（nature）</strong>，并给出<strong>解决方案（solution）</strong>。</p><p>也就是说，用系统科学的方法解决问题（problem-solution）。</p><p>目标：设计和开发高质量的软件。（付出较低开发成本；达到要求的功能；取得较好的性能；开发的软件易于移植；只需较低的维护费用；能按时完成开发任务，及时交付使用）</p><p>方法：面向过程、面向对象等</p><h3 id="2-错误（error）、缺陷（fault）、失效-x2F-故障（Failure）"><a href="#2-错误（error）、缺陷（fault）、失效-x2F-故障（Failure）" class="headerlink" title="2.错误（error）、缺陷（fault）、失效&#x2F;故障（Failure）"></a>2.错误（error）、缺陷（fault）、失效&#x2F;故障（Failure）</h3><p>错误(error)：是在软件开发过程中人为产生的错误（需求说明中的错误，代码中的错误）。</p><p>故障(fault)：软件功能实现过程中产生的问题，是错误导致的结果，是软件中一个错误的表现（一个错误可能产生多个故障，静态存在）。</p><p>失效(failure)：系统违背了它应有的行为（在系统交付前或交付后被发现，动态存在）。</p><p>联系：人为原因导致程序错误；该错误编译到系统中导致系统故障；用户使用该系统时，因故障导致失效。故障是系统内部视图，从开发者的角度看待问题；失效是系统外部视图，从用户角度看到的问题。而且并不是所有的故障会导致失效，只要不执行故障代码，或者不进入某个特定状态，那么故障就不会使代码失效。</p><p>A fault: occurs when a human makes a mistake, called an error, in performing some software activities （误解需求&gt;与意图不符&gt;其他故障）<br>A failure: is a departure from the system’s required behavior（交付前&#x2F;交付后&#x2F;测试&#x2F;维护）</p><h3 id="3-软件质量从哪几个方面进行评价？什么是好的软件"><a href="#3-软件质量从哪几个方面进行评价？什么是好的软件" class="headerlink" title="3.软件质量从哪几个方面进行评价？什么是好的软件"></a>3.软件质量从哪几个方面进行评价？什么是好的软件</h3><h4 id="软件质量（quality-of-software）"><a href="#软件质量（quality-of-software）" class="headerlink" title="软件质量（quality of software）"></a>软件质量（quality of software）</h4><ul><li>The quality of the product 软件产品的质量(用户、开发者)</li><li>The quality of the process 过程的质量(CMM和ISO9000)</li><li>The quality of the product in the context of the business environment 商业环境下的质量 (RoI)</li></ul><p>从三个方面考虑软件的质量：产品的质量、生产该产品的过程的质量以及在产品将使用的商业环境背景下的质量。<br>3.1 产品(product)的质量</p><p>用户：从失效的数目和类型等外部特性进行评价，如果软件具有足够的功能，并且易于学习和使用；或者虽然难以学习和使用，但是由于功能值得这些付出，用户就断定软件是高质量的。<br>开发者：从故障的数目和类型等内部特征来作为产品质量的依据。</p><p>3.2 过程(process)的质量</p><p>有很多过程都会影响到最终的产品质量，只要有活动出了差错，产品的质量就会受到影响；开发和维护过程的质量与产品的质量是同等重要的。<br>几个量化模型：CMM、ISO 9000、SPICE（了解）</p><p>3.3 商业(business)环境背景下的质量</p><p>(1) 技术价值与商业价值的联系与区别：<br>技术价值：技术指标（速度，正确的运行时间，维护成本等）。<br>商业价值：机构对软件是否与其战略利益相吻合的一种价值评估。误区：技术质量不会自动转化为商业价值。<br>(2) 目标<br>将技术价值和商业价值统一起来，改进过程所带来的商业价值。</p><h3 id="4-现代软件工程包含的阶段："><a href="#4-现代软件工程包含的阶段：" class="headerlink" title="4.现代软件工程包含的阶段："></a>4.现代软件工程包含的阶段：</h3><p>现代软件工程大致包含的几个阶段及各个阶段文档：</p><p>（1）需求分析与定义：包括问题定义、可行性研究、需求分析【《SRS》即《软件需求规格说明书》】与复审（所有人）。</p><p>（2）系统设计：包括用户界面的设计【《SAD》即《软件系统结构图》：如何制作软件】与复审（开发者与客户）。</p><p>（3）程序设计：包括模块功能算法与数据描述设计【相关文档】与复审（开发者）。</p><p>（4）程序实现：包括编程与 debug【源代码和注释】与复审（开发者、码农）。</p><p>（5）单元测试：模块功能测试与性能测试【测试报告】与复审（测试团队）。</p><p>（6）集成测试：按照结构图进行测试【测试报告】与复审（测试团队）。</p><p>（7）系统测试：系统级功能的正确性。按《SRS》对系统总体功能进行测试与复审（开发者与客户）。</p><p>（8）系统交付：直接交付&#x2F;逐渐交付。交付产品【用户手册和操作手册】与复审。</p><p>（9）系统维修：修改软件的过程，为改错或满足新需求【维修报告】与复审（维修团队）。</p><h3 id="5-使现代软件工程变化的关键因素："><a href="#5-使现代软件工程变化的关键因素：" class="headerlink" title="5.使现代软件工程变化的关键因素："></a>5.使现代软件工程变化的关键因素：</h3><p>1.Time to market 软件交付市场的紧迫性<br>2.计算成本的下降<br>3.桌面计算机性能的提高<br>4.网络技术的发展<br>5.面向对象技术的发展<br>6.用户图形界面系统的普及<br>7.瀑布模型存在的问题<br><img src="/img/reason.png"></p><p>◆使现代软件工程实践发生变化的七个关键因素(by Wasserman)<br>（1）商用产品投入市场时间的紧迫性<br>（2）计算技术在经济中的转变：更低的硬件成本，更高的开发、维护成本<br>（3）功能强大的桌面计算的可用性<br>（4）广泛的局域网和广域网<br>（5）面向对象技术的采用及其有效性<br>（6）使用窗口、图标、菜单和指示器的图形用户界面<br>（7）软件开发瀑布模型的不可预测性<br>说明（了解）：瀑布模型沿袭了传统系统工程的大规模批发制造的理念，假定生产活动为线性，这与现代软件的生产方式相矛盾。不再是有足够的灵活性和适应性来满足并行开发或并行运行这样的商业软件需求，因此不可预测。<br>结论（了解）：对一个系统进行划分，以便并行地开发其子系统，需要一个与瀑布模型有很大不同的开发模型。</p><h3 id="6-软件工程的-Wasserman-规范解决软件工程面临的挑战"><a href="#6-软件工程的-Wasserman-规范解决软件工程面临的挑战" class="headerlink" title="6.软件工程的 Wasserman 规范解决软件工程面临的挑战"></a>6.软件工程的 Wasserman 规范解决软件工程面临的挑战</h3><p>(1) 抽象(abstraction)：基于某种概念层次上对问题的描述。它使我们将注意力集中在问题的关键方面而非细节。<br>(2) 分析、设计方法和符号描述系统：<br>使用标准表示来对程序进行描述。利于交流，利于建模并检查其完整性和一致性，利于对需求和设计部件进行重用。<br>(3) 用户界面原型化(prototyping)：<br>建立系统的小型版, 通常具有有限的关键功能,以利于用户评价和选择，证明设计或方法的可行性。<br>(4) 软件体系结构：定义一组体系结构单元及其相互关系集来描述软件系统。<br>单元分解的方法<br>（以下了解）<br>（1）基于功能的模块化分解: 基于指派到模块的功能。（2）基于数据的分解: 基于外部数据结构。<br>（3）面向事件的分解：基于系统必须处理的事件。（4）由外到内的分解：基于系统用户的输入。<br>（5）面向对象的设计：基于标识的对象的类以及它们之间的相互关系。<br>(5) 软件过程：软件开发活动中的各种组织及规范方法。<br>（以下了解）<br>因应用类型和组织文化之间的巨大差异,故难以对软件过程本身进行预先指定,也就是说:使过程本身规范化是不可能的.软件过程不可能以抽象和模块化的方式作为软件工程的基础。</p><p>(6) 重用或复用(reuse)：重复采用以前开发的软件系统中具有共性的部件, 用到新的开发项目中去 (注: 这里的重用绝不仅仅是源代码的重用)。<br>(7) 测度或度量(measurement)：通用的评价方法和体系，有助于使过程和产品的特定特性更加可见，包括量化描述系统、量化审核系统。<br>(8) 工具和集成环境：通过框架比较软件工程环境提供的服务，以决定其好坏。工具：由于厂商很少针对整个开发生命周期，因此对于工具的比较集中于小的活动集，例如测试或设计。<br>（以下了解）<br>工具集成中必须处理的五个问题：(by Wasserman)<br>平台集成、表示继承、过程集成、数据集成、控制集成。<br>总结：以上八个概念将软件工程作为一门科学学科，也是本书的八个线索。</p><h2 id="Chapter-2-建模过程和生命周期"><a href="#Chapter-2-建模过程和生命周期" class="headerlink" title="Chapter 2 建模过程和生命周期"></a>Chapter 2 建模过程和生命周期</h2><h3 id="1-软件过程："><a href="#1-软件过程：" class="headerlink" title="1.软件过程："></a>1.软件过程：</h3><p>什么是过程（process）？软件过程的重要性是什么？软件生命周期？</p><p>过程：软件开发过程中产生某种期望结果的一系列有序任务，涉及活动、约束和资源。</p><p>重要性：</p><p>1、通用性：软件过程可以让一系列开发活动保持一致性和结构性，因而具有了通用性。</p><p>2、指导性：软件过程使我们可以分析、检查、理解、控制和改善软件开发活动。</p><p>3、可以把获得的经验传递给其他人。</p><p>定义：<br>一组有序的任务，它涉及活动、约束和资源使用的一系列步骤，用于产生某种想要的输出。</p><p>重要性：</p><p>（1）它强制活动具有一致性和一定的结构。<br>（2）过程结构帮助开发人员分析、理解、控制和改进开发过程。<br>（3）有助于开发人员获取经验并把经验传授给他人。</p><h3 id="2-软件生命周期："><a href="#2-软件生命周期：" class="headerlink" title="2.软件生命周期："></a>2.软件生命周期：</h3><p>软件开发过程描述了软件产品从概念到实现、交付、使用和维护的整个过程，因此，有时把软件开发过程称为软件生命周期。</p><h3 id="3-软件过程模型："><a href="#3-软件过程模型：" class="headerlink" title="3.软件过程模型："></a>3.软件过程模型：</h3><h4 id="3-1-瀑布模型："><a href="#3-1-瀑布模型：" class="headerlink" title="3.1 瀑布模型："></a>3.1 瀑布模型：</h4><p>线性的安排每一个阶段，将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段。一个开发阶段必须在另一个开发阶段开始之前完成。</p><p>过程：</p><p><img src="/img/software-engineering/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png"></p><p>优点：</p><p>1、<strong>简单性</strong>：很容易向用户解释。</p><p>2、基础性：是其他更复杂模型的基础（通过加入额外的开发活动和循环）。</p><p>3、<strong>过程可观，方便监控</strong>。每一个过程活动都有与其相关联的里程碑和可交付产品，<strong>便于评估项目进度</strong>。</p><p>缺点：<br>（1）用户可能并不清楚所有的需求。<br>（2）没有迭代。软件是一个创造的过程, 不是一个制造的过程。软件变动时, 该模型无法处理实际过程中的重复开发问题。<br>（2）文档转换有困难。它说明了每一个活动的产品（例如，需求、设计或代码），但没有揭示一个活动如何把一种制品转化为另外一种制品（例如，从需求文档转化为设计文档）。</p><h4 id="3-2阶段化开发模型"><a href="#3-2阶段化开发模型" class="headerlink" title="3.2阶段化开发模型"></a>3.2阶段化开发模型</h4><p>定义：<br>系统被设计成部分提交, 每次用户只能得到部分功能, 而其他部分处于开发过程中。<br>产品 -&gt; 分阶段&#x2F;分功能 -&gt; 一部分一部分的交付</p><p>特点：<br>（1）大幅度缩短开发周期。从需求到系统交付的时间短 快速抢占市场 早些获得反馈，可以对产品进行修改。</p><p>（2）因为一边开发一边交付，所以有两个系统在并行运行。<br>运行系统&#x2F;产品系统：当前正在被客户和用户使用的系统。开发系统：准备代替现行产品系统的下一个版本。</p><p>分类：增量开发和迭代开发<br>①增量开发：系统需求按照功能分成若干子系统，开始建造的版本是规模小的、部分功能的系统，后续版本添加包含新功能的子系统，最后版本是包含全部功能的子系统集。<br>②迭代开发：系统开始就提供了整体框架，但是各部分功能都不够完善，后续版本会完善各部分的功能。</p><h4 id="3-3螺旋模型"><a href="#3-3螺旋模型" class="headerlink" title="3.3螺旋模型"></a>3.3螺旋模型</h4><p>含义：</p><p>有些类似于迭代开发模型，结合了迭代的思想，同时也结合了原型化的思想。将开发活动与风险管理结合起来, 以降低和控制风险。</p><p>适用范围于较大型软件工程项目。</p><p><img src="/img/software-engineering/spiral-model.png"></p><p>第一轮迭代产生操作概念，第二轮是需求，后面依次是设计和测试。<br>每轮都进行风险分析，评估不同选择，通过原型验证可行性，并决定如何消除或降低风险。<br>一圈代表一次迭代 。每一次迭代都根据需求和约束进行风险分析，以权衡不同选择，并且在确定选择之前，通过原型化验证可行性和期望度。</p><p><em><strong>*螺旋模型四个象限的任务及四重循环的含义？*</strong></em></p><p>螺旋模型每次迭代有四个任务，依次是（四个象限）：</p><p>计划、目标&#x2F;可选方案、风险评估、 开发与测试。</p><p>螺旋模型共有四次迭代，依次是（每个象限的四重循环）：</p><p>操作概念、软件需求、软件设计、开发与测试。</p><h4 id="3-4敏捷开发："><a href="#3-4敏捷开发：" class="headerlink" title="3.4敏捷开发："></a>3.4敏捷开发：</h4><p>敏捷方法的四条原则：<br>①个体和交互的价值胜过过程和工具。<br>②可以工作的软件胜过面面俱到的文档。<br>③客户合作胜过合同谈判。<br>④响应变化胜过遵循计划。</p><p>强调敏捷方法的四个特性：交流、简单性、勇气以及反馈</p><p>敏捷开发过程的几种方法：<br>①极限编程(XP)：激发人员创造性，使管理负担最小的一组技术，是敏捷方法中最主<br>要的流派。（稍后有详细介绍）<br>②Crystal （水晶球法）：每一个不同的项目都需要一套不同的策略、约定和方法论。<br>③SCRUM（并列争球法）：使用迭代的方法，其中把每 30 天一次的迭代称为一个“冲刺”，并按需求的优先级别来实现产品。<br>④Adaptive Software Development(ASD) (自适应软件开发)</p><h4 id="3-5-统一软件开发过程（Rational-Unified-Process-RUP"><a href="#3-5-统一软件开发过程（Rational-Unified-Process-RUP" class="headerlink" title="3.5 统一软件开发过程（Rational Unified Process,RUP)"></a>3.5 统一软件开发过程（Rational Unified Process,RUP)</h4><p>迭代开发的一种变体模型。</p><p>描述了如何有效利用商业的、可靠的方法开发和deploy，是一种重量级的过程。</p><p>什么是UP， RUP，进化式迭代等市场流行的过程模型?</p><p>UP模型即统一过程模型，是一种用例驱动的，以基础架构为中心的，迭代式，增量式的软件开发模型。</p><p>该模型的四个阶段：</p><p>开始阶段、确立阶段、构建阶段和移交阶段。</p><p>该模型的六道核心工序：</p><p>业务模型工序、需求工序、分析设计工序、实现工序、测试工序和部署工序。</p><p>RUP模型是IBM提出的提供支持和包装的UP模型。</p><p>迭代开发是统一过程模型（RUP）的关键实践。</p><p>开发被组织成一系列固定的短期小项目。</p><p>每次迭代都产生经过测试、集成并可执行的局部系统。</p><p>每次迭代都具有各自的需求分析、设计、实现和测试。</p><p>随着时间和一次次迭代，系统增量式完善。</p><h2 id="Chapter-3-计划和管理项目"><a href="#Chapter-3-计划和管理项目" class="headerlink" title="Chapter 3 计划和管理项目"></a>Chapter 3 计划和管理项目</h2><h3 id="1-关键概念介绍"><a href="#1-关键概念介绍" class="headerlink" title="1.关键概念介绍"></a>1.关键概念介绍</h3><p><strong>项目进度（Project Schedule）</strong><br>列举项目各个阶段 -&gt; 分解成离散的任务或者活动，来描述特定项目的软件开发周期。以及对各个活动完成时间及整个项目完成时间的初步估算。</p><p><strong>活动</strong><br>是项目的一部分，在一段时间内发生。</p><p><strong>里程碑</strong><br>是活动的完成，就是每一个特定的时刻，向开发人员和客户指明项目已经进展到了可测量的级别。</p><p>按照活动和里程碑的概念，可以把开发分为阶段，阶段包含步骤，步骤包含活动。<br>每个活动都是一个可测量事件，这样我们可以确定活动完成的客观标准。<br>任何一个活动的终止都可以是一个里程碑。</p><h3 id="2-项目活动图"><a href="#2-项目活动图" class="headerlink" title="2.项目活动图"></a>2.项目活动图</h3><p>含义：描述了不同活动之间的依赖性，表明了活动的执行顺序。</p><p><img src="/img/software-engineering/%E9%A1%B9%E7%9B%AE%E6%B4%BB%E5%8A%A8%E5%9B%BE.png"></p><ul><li><p>Real time (actual time) 真实时间：完成活动所需要的时间</p></li><li><p>Available time 可用时间：完成活动可用的时间量</p></li></ul><p><strong>关键路径</strong>：从起点到终点花费最长时间的路径。</p><p>冗余时间：在不耽误总体进度的前提下，最早开始工作和最晚开始工作时间的差值。</p><p>求关键路径：先求每个结点的最早开始时间，求出整个项目的最长花费时间。再用最长花费时间倒退，从最后一个结点开始，求每个结点的最晚开始时间。用最晚开始时间减去最短开始时间得到时间差，时间差为0的在关键路径上。</p><h3 id="3-团队组织的构成"><a href="#3-团队组织的构成" class="headerlink" title="3.团队组织的构成"></a>3.团队组织的构成</h3><p>(1) 主程序员负责制（Chief Programmer Team）<br>由一个主程序员负责系统设计和开发，其他的成员向其汇报，主程序员对每一个决定有绝对决策权。<br>优势：<br>使交流最小化<br>迅速做出决定</p><p>缺点：<br>创造性低<br>对主程序员要求高，个人主观性强<br>(2) 忘我方法（Egoless Approach）<br>每个成员平等的承担责任，而且过程与个人是分开的；批评是针对产品和结果的，不针对个人的。</p><h3 id="4-工作量估算"><a href="#4-工作量估算" class="headerlink" title="4.工作量估算"></a>4.工作量估算</h3><p><strong>COCOMO 模型</strong>的三个阶段的基本工作原理和含义：</p><p>构建成本模型。COCOMO 模型的关键在于针对项目开发的不同阶段来设置工作量的衡量标准，逐步细化，逐渐准确。: E &#x3D; bSc m(X)</p><p>阶段一：应用组合&#x2F;组装。用原型化项目来解决高风险相关的活动。通常构建原型以解决包含用户界面、软件和系统交互、性能和技术成熟性等方面在内的高风险问题。在阶段一，COCOMOⅡ用<strong>应用点</strong>来估算规模。<br>阶段二：早期设计阶段。探索几种可选的体系结构和操作的概念。在阶段二，COCOMOⅡ使用<strong>功能点</strong>对规模进行测量。<br>阶段三：即后体系结构阶段，开发已经开始，而且已经知道了更多的信息。在这个阶段，可以根据功能点或<strong>代码行</strong>来进行规模估算，而且可以较为轻松地估算很多成本因素。</p><h3 id="5-软件风险"><a href="#5-软件风险" class="headerlink" title="5.软件风险"></a>5.软件风险</h3><p>概念：软件生产过程中不希望看到的，有负面结果的事件<br>方面：风险损失，风险概率（相乘为风险暴露（Risk Exposure），即数学期望）</p><h4 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h4><p>风险评估：风险识别（checklist），风险分析，风险优先级分配<br>风险控制：风险降低，风险管理计划，风险化解</p><p>降低风险的策略：</p><p>1、避免风险：改变功能和性能需求，使风险没机会发生。</p><p>2、转移风险：通过把风险分配到其他系统中，或者购买保险以便在风险成为事实时弥补经济上的损失。</p><p>3、假设风险：用项目资源，接受并控制风险。比如在开发时主动有意识地进行测试。</p><h3 id="典型例题："><a href="#典型例题：" class="headerlink" title="典型例题："></a>典型例题：</h3><p>a.名词解释：<br>项目进度（Project Schedule）<br>b. 简述题：<br>COCOMO2 模型的工作原理<br>主程序员负责制的优缺点<br>c. 综合应用题：<br>找出关键路径，最早，最晚开始时间（解析见重点内容解析部分）</p><h2 id="Chapter-4-需求获取"><a href="#Chapter-4-需求获取" class="headerlink" title="Chapter 4 需求获取"></a>Chapter 4 需求获取</h2><h3 id="1-需求的含义"><a href="#1-需求的含义" class="headerlink" title="1.需求的含义"></a>1.需求的含义</h3><p>定义：需求是对****来自用户*<em><strong>的</strong></em>*关于软件系统的期望行为****的综合描述，涉及系统的对象、状态、 约束、功能等。<br>任务：理解客户的问题和需求，针对的是客户和问题，不是问题和实现</p><h3 id="2-需求过程"><a href="#2-需求过程" class="headerlink" title="2.需求过程"></a>2.需求过程</h3><p><img src="/img/software-engineering/capture-requirement-process.png"></p><p>①原始需求获取：客户给出的需求<br>②问题分析：理解需求并通过建模或模型化方式进行描述<br>③规格说明草稿：利用符号描述系统将定义规范化表示<br>④需求核准：开发人员与客户进行核准<br>⑤形成<strong>软件规格说明</strong>（SRS）</p><h3 id="3-需求的优先级划分"><a href="#3-需求的优先级划分" class="headerlink" title="3.需求的优先级划分"></a>3.需求的优先级划分</h3><p><em><strong>*举例说明获取需求时，若有冲突发生时，如何考虑*</strong></em></p><p>当进行需求的引出时，可能会碰到大家对“需求是什么”存在分歧，此时采用对需求进行优先级划分的方法是有效的</p><p>①必须要被满足的需求<br>②非常值得做但是不是必须的需求<br>③可选的需求（可做可不做）</p><h3 id="4-需求的分类"><a href="#4-需求的分类" class="headerlink" title="4.需求的分类"></a>4.需求的分类</h3><p>①功能需求：描述系统<strong>内部功能</strong>或系统与<strong>外部功能</strong>的交互作用，涉及系统输入应对、实体状态变化、输出结果、设计约束、过程约束等。<br>②设计约束：已经做出的设计决策或限制问题解决方案集的设计决策。涵盖<strong>物理环境、接口、用户</strong>等方面。<br>③过程约束：对用于构建系统的技术和资源的限制，涵盖<strong>资源、文档</strong>等方面。<br>④非功能需求：描述软件方案必须具备的某些质量特征，例如<strong>系统性能、安全性、响应时间</strong>等。</p><h3 id="5-需求文档分类"><a href="#5-需求文档分类" class="headerlink" title="5.需求文档分类"></a>5.需求文档分类</h3><p>(1) 需求定义<br>完整罗列了客户期望的需求</p><p>(2) 需求规格说明（SRS）<br>将需求重述为关于<strong>要构建的系统将如何运转</strong>的规格说明。</p><h3 id="6-UML图"><a href="#6-UML图" class="headerlink" title="6. UML图"></a>6. UML图</h3><h4 id="1-数据流图"><a href="#1-数据流图" class="headerlink" title="1.数据流图"></a>1.数据流图</h4><p>数据流图（DFD）：<br>目标：描述数据进入、转换、离开系统，重点在于<strong>数据流</strong>，而不是控制流</p><p>图符：</p><p>椭圆表示一个加工或功能，它转换数据。<br>箭头表示数据流，其中，进入椭圆的箭头表示其功能的输入，从椭圆输出的箭头表示其功能的输出。<br>持久性数据保存在数据存储中，它是一个正式的库或信息库，表示为两个平行线。<br>数据源或者数据接收器表示为矩形，称为参与者，提供输入数据或接受输出结果的实体。</p><p><img src="/img/software-engineering/DFD-%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png"></p><h4 id="2-UML活动图"><a href="#2-UML活动图" class="headerlink" title="2.UML活动图"></a>2.UML活动图</h4><p>用于系统功能建模，强调的是对象间的<strong>控制流</strong>。</p><h4 id="3-UML类图"><a href="#3-UML类图" class="headerlink" title="3. UML类图"></a>3. UML类图</h4><p>强调系统结构的图形表示范型，对系统的词汇建模，简单协作以及对逻辑数据库模式进行建模</p><h4 id="4-UML状态图"><a href="#4-UML状态图" class="headerlink" title="4. UML状态图"></a>4. UML状态图</h4><p>展示对象可能的状态，以及由于各种原因的状态转移。</p><p>对接口、类、协作行为进行建模。</p><h4 id="5-掌握用例图的组成和画法，用例的几个要素的含义。-x2F-x2F-掌握用例图的实例解析方法"><a href="#5-掌握用例图的组成和画法，用例的几个要素的含义。-x2F-x2F-掌握用例图的实例解析方法" class="headerlink" title="5.掌握用例图的组成和画法，用例的几个要素的含义。 &#x2F;&#x2F;掌握用例图的实例解析方法"></a>5.掌握用例图的组成和画法，用例的几个要素的含义。 &#x2F;&#x2F;掌握用例图的实例解析方法</h4><p>用例图：表示一个用户、外部系统或其他实体和在开发系统的关系<br>①用例<br>描述系统提供的特定功能，用椭圆表示：<br>②执行者<br>和系统交互的实体（用户、设备或其他），用小人表示：<br>③包含<br>对已定义用例的复用，用以提取公共行为，用带箭头的实线表示：<br>④扩展<br>对一个用例的扩展使用，用以下图标</p><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>短暂的非结构画的使用关系。只有在调用方法时才存在依赖关系，也就是说其生命周期在软件运行期间才存在。</p><ul><li>依赖关系：指的是类与类之间的联接。依赖关系表示<code>一个类依赖于另一个类的定义</code>。一般而言，依赖关系在Java语言中体现为<code>成员变量、局域变量、方法的形参、方法返回值</code>，或者对<strong>静态方法的调用。</strong></li></ul><p>对象约束语言（OCL）<br>定义：表述对象模型（例如，ER 图）上的约束<br>示例：此处 OCL 要求 pno&gt;&#x3D;0</p><h3 id="Chapter-5-设计体系结构"><a href="#Chapter-5-设计体系结构" class="headerlink" title="Chapter 5 设计体系结构"></a>Chapter 5 设计体系结构</h3><h4 id="1-软件体系结构"><a href="#1-软件体系结构" class="headerlink" title="1. 软件体系结构"></a>1. 软件体系结构</h4><p>软件体系结构：一种软件的解决方案，用于将系统分解为单元子系统，以及这些单元如何相互关联，还包括这些单元所有的外部特性。</p><p><em>IEEE610. 12—1990：体系结构是以构件、构件之间的关系、构件与环境之间的关系为内容的某一系统的基本组织以及指导上述内容设计与演化的原理，即*<em>软件体系结构&#x3D;{构件，连接件，环境，原理}</em></em></p><p><em>Bass的定义：系统的一个或多个结构，包括*<em>软件构件、构件的外部可视属性和构件之间的关系</em></em></p><p>*国内普遍认可的看法：可以将体系结构定义为构件、连接件和约束。软件体系结构指可预制和可重构的软件框架结构。<br><strong>体系结构(Architecture)&#x3D;构件(Components)+连接件(Connectors)+约束(Constraints)</strong></p><h4 id="2-设计模式？设计公约？设计？"><a href="#2-设计模式？设计公约？设计？" class="headerlink" title="2. 设计模式？设计公约？设计？"></a>2. 设计模式？设计公约？设计？</h4><p>设计：将需求中的问题转变成软件解决方案的创造性过程。</p><p>设计模式：针对单个软件模块给出的一般性解决方案，提供较低层次的设计决策。</p><p>设计公约：一系列设计和决策的集合，用于提高系统某方面的设计质量。</p><p>创造性设计：脑海中突然闪现的idea</p><p>设计原则：对好的设计的特征描述，而不是如何进行设计的说明性建议。</p><h4 id="3-软件设计过程模型的几个阶段"><a href="#3-软件设计过程模型的几个阶段" class="headerlink" title="3. 软件设计过程模型的几个阶段"></a>3. 软件设计过程模型的几个阶段</h4><p><img src="/img/software-engineering/SAD.png"></p><p>1、建模：尝试可能的分解，根据需求描述的系统的关键特性等确定软件体系结构。</p><p>2、分析：分析初步的体系结构，主要关注系统级别的决策，如软件的质量、性能等。</p><p>3、文档化：确定各个不同的模型视图。</p><p>4、复审：检查文档是否满足了所有需求。<strong>（意义：大幅降低软件开发的维修成本）</strong></p><p>5、最终产出：软件体系结构文档，即SAD。用来和开发团队中其他人员交流系统级别设计决策的有力工具。</p><h5 id="软件过程中复审的概念，设计复审的重要性。"><a href="#软件过程中复审的概念，设计复审的重要性。" class="headerlink" title="软件过程中复审的概念，设计复审的重要性。"></a>软件过程中复审的概念，设计复审的重要性。</h5><p>复审定义：检查文档是否满足所有功能及质量需求。</p><p>(1) 验证 verification：确保设计遵循良好的设计原则，设计文档满足阅读者的需要。验证检查某样东西是否符合之前已定好的标准，就是要用数据证明我们是不是在正确的制造产品。更注重过程正确性，强调做得正确</p><p>(2)确认 validation：确认设计能够满足用户需求。确认检查软件在最终的运行环境上是否达到预期的目标，就是要用数据证明我们是不是制造了正确的产品。更注重结果正确性，强调做的东西正确。</p><p>(3) 验证更多是从开发商角度来做评审、测试来验证产品需求、架构设计等方面是否和用户要求一致，确认更多是从用户的角度或者可以是模拟用户角度来验证产品是否和自己想要的一致。</p><p>重要性：</p><p>(1) 复审中批评和讨论是“忘我”的，能将开发人员更好地团结在一起，提倡并增强了成员之间的交流</p><p>(2) 在评审过程中故障的改正还比较容易，成本还不高，在这时候发现故障和问题会使每一个人受益。</p><p>重要性：</p><p>1、可以和用户一起检查软件的概要设计。</p><p>2、可以向开发者呈现并明确软件的技术设计。</p><p>3、程序员通过复审可以在下一阶段的工程实施前得到本阶段工作的反馈。</p><h4 id="4-论述设计用户界面应考虑的问题。-非重要"><a href="#4-论述设计用户界面应考虑的问题。-非重要" class="headerlink" title="4. 论述设计用户界面应考虑的问题。*非重要"></a>4. 论述设计用户界面应考虑的问题。*非重要</h4><p>设计界面要注意解决的要素:</p><p>1、隐喻：可识别和学习的基本术语、图像和概念等。</p><p>2、思维模型：数据、功能、任务的组织与表示。</p><p>3、模型的导航规则：怎样在数据、功能、活动和角色中移动及切换。</p><p>4、外观：系统向用户传输信息的外观特征。</p><p>5、感觉：向用户提供有吸引力的体验的交互技术。</p><p>文化问题：</p><p>设计界面时需要考虑使用系统的用户的信仰、价值观、道德规范和传统等因素。</p><p>1、使用国际设计&#x2F;无偏见设计，排除特定的文化参考或偏见。</p><p>2、采用定制界面，使不同用户看到不同的界面 。</p><p>用户偏好：</p><p>为具有不同偏好的人选择备选界面。</p><h3 id="Chapter-6-模块设计"><a href="#Chapter-6-模块设计" class="headerlink" title="Chapter 6 模块设计"></a>Chapter 6 模块设计</h3><h4 id="1-面向对象设计的基本原则"><a href="#1-面向对象设计的基本原则" class="headerlink" title="1. 面向对象设计的基本原则"></a>1. 面向对象设计的基本原则</h4><ul><li>Modularity 模块化（耦合、内聚）</li><li>Interfaces 接口</li><li>Information hiding 信息隐藏</li><li>Incremental development 增量式开发</li><li>Abstraction 抽象</li><li>Generality 通用性</li></ul><h4 id="2-模块独立性、耦合与内聚的概念及各个层次划分？"><a href="#2-模块独立性、耦合与内聚的概念及各个层次划分？" class="headerlink" title="2.模块独立性、耦合与内聚的概念及各个层次划分？"></a>2.模块独立性、耦合与内聚的概念及各个层次划分？</h4><p>模块的独立性取决于两个部分：内聚和耦合，我们追求的是高内聚低耦合。</p><p>内聚是软件内部组成成分的关联程度。</p><p>耦合指的是两个软件间的关联程度。</p><h4 id="3-举例说明耦合与内聚的基本分类。以及各个分类的含义与特征"><a href="#3-举例说明耦合与内聚的基本分类。以及各个分类的含义与特征" class="headerlink" title="3.举例说明耦合与内聚的基本分类。以及各个分类的含义与特征"></a>3.举例说明耦合与内聚的基本分类。以及各个分类的含义与特征</h4><p>内聚：</p><p><img src="/img/software-engineering/Cohesion.png"></p><p>1、偶然内聚：模块各部分不相关，只为方便或偶然性原因放入同一模块。比如强行放入一个类中没有任何关系的方法。</p><p>2、逻辑内聚：模块中各部分只通过代码的逻辑结构相关联，会共享程序状态和代码结构，但相对于数据、功能和目标的内聚比较弱。 比如因为有相同的某个计算步骤而放在?一起的两个没有关系的计算。</p><p>3、时间内聚：部件各部分要求在同一时间完成或被同一任务使用而形成联系。比如初始化模块中需要完成变量赋值、打开某文件等工作。</p><p>4、过程内聚：要求必须按照某个确定的顺序执行一系列功能，模块内功能组合在一起只是为了确保这个顺序。其与时间性内聚相比优点在于其功能总是涉及相关活动和针对相关目标，如写数据-&gt;检查数据-&gt;操作数据这一过程。</p><p>5、通讯内聚：各部分访问和操作同一数据集，如来自于同一传感器的所有不相干数据。</p><p>6、顺序内聚 ：各部分有输入输出关系，操作同一数据集，并且操作有顺序。</p><p>7、功能内聚：理想情况，各部分组成单一功能，且每个处理元素对功能都是必须的，每个元素执行且只执行设计功能，如一个简单的输出程序。</p><p>8、信息内聚：在功能内聚的基础上，进行数据抽象化和基于对象的设计。</p><p>耦合：</p><p><img src="/img/software-engineering/coupling.png"></p><p>1、内容耦合：A模块实际上修改了B模块，B模块完全依赖于A模块。</p><p>2、公共耦合：不同模块可以从公共数据存储区来访问和修改数据。</p><p>3、控制耦合：一个模块通过传递参数或返回代码来控制另一个模块的活动。</p><p>4、标记&#x2F;特征耦合：使用一个复杂的数据结构进行模块间传递消息，并且传递的是该数据结构本身。比如将一个数组传递给另一个模块，数组仅用于计算而非控制。</p><p>5、数据耦合：模块间传递的是数据值，是最受欢迎的耦合。</p><p>6、非耦合：模块相互之间没有信息传递，但是不太现实。</p><p>什么是设计模式？</p><p>设计模式：</p><p>一种针对软件模块给出的一般性解决方案，提供较低层次的设计决策。</p><p>面向对象设计模式分为：</p><p>模板方法模式 抽象类定义模板方法来实现一个操作中共同的步骤，并声明抽象的原语操 作来表示变化的部分</p><p>工厂方法模式 封装创建对象的代码</p><p>策略模式 在运行时选择算法。运行结束根据结果选择最好的算法</p><p>装饰者模式 运行时扩展对象的功能。给对象添加的新功能放入装饰者类</p><p>观察者模式 类似于管程思想</p><p>组合模式 异构的对象的汇集</p><p>访问者模式  将组合对象的新功能集中并封装于自身的类中</p><p>OO设计的基本原则？</p><p>1、单一职责原则</p><p>2、重用原则</p><p>3、开闭原则</p><p>4、里氏替换原则</p><p>5、依赖倒转原则</p><p>6、接口隔离原则</p><p>7、迪米特法则</p><p>OO开发有何优势？</p><p>1、语言的一致性：</p><p>采用相同的语义结构（类、对象、接口、属性、行为）描述问题和解决方案。</p><p>2、软件开发过程的一致性：</p><p>从需求分析和定义、高层设计、底层设计到编码和测试等，所有的过程都采用相同的语义结构。</p><p>OO开发过程有几个步骤？</p><p>1、面向对象需求分析。</p><p>2、面向对象高层设计。</p><p>3、面向对象底层设计。</p><p>4、面向对象编程。OOP</p><p>5、面向对象测试。</p><h3 id="Chapter-7-编写程序"><a href="#Chapter-7-编写程序" class="headerlink" title="Chapter 7 编写程序"></a>Chapter 7 编写程序</h3><h4 id="1-一般性的编程原则应该从哪三个方面考虑？"><a href="#1-一般性的编程原则应该从哪三个方面考虑？" class="headerlink" title="1. 一般性的编程原则应该从哪三个方面考虑？"></a>1. 一般性的编程原则应该从哪三个方面考虑？</h4><p>编程原则应该从控制结构，算法和数据结构三方面来考虑。</p><p>控制结构：程序如何传递数据。</p><p>算法：程序如何处理数据。</p><p>数据结构：程序如何储存数据。</p><h4 id="2-在编写程序内部文档时，除了HCB头注释块header-comment-block外，还应添加什么注释信息？注意什么？"><a href="#2-在编写程序内部文档时，除了HCB头注释块header-comment-block外，还应添加什么注释信息？注意什么？" class="headerlink" title="2. 在编写程序内部文档时，除了HCB头注释块header comment block外，还应添加什么注释信息？注意什么？"></a>2. 在编写程序内部文档时，除了HCB头注释块header comment block外，还应添加什么注释信息？注意什么？</h4><p>（1） 头注释块（header comment block，HCB）<br>将一组注释信息放在每个构件的开始部分，包含构件名，作者，配置在整个系统设计的哪个部分上，何时编写和修改的，为什么要有该构件，构件是如何使用数据结构，算法和控制的。</p><p>（2） 其他程序注释——</p><ul><li>解释性注释：本段源代码是在做什么的注释。</li><li>分解性注释：通过注释将代码分解成多个段。</li><li>版本注释：随着时间进行修改的记录。</li></ul><p>（3） 有意义的变量名和语句标记<br>命名时尽量用有意义的变量名进行命名</p><p>（4） 排版格式以增强理解<br>注意缩进和间隔来反映基本的控制结构。</p><p>（5）文档化数据</p><p>注意的问题：</p><p>1、分段注释</p><p>2、注释和代码要一并更改。</p><p>3、注释要有意义。</p><p>4、一边写代码一边写注释，不要写完代码回过头来添加注释。</p><h4 id="3-什么是极限编程-XP-以及派对编程？"><a href="#3-什么是极限编程-XP-以及派对编程？" class="headerlink" title="3. 什么是极限编程(XP)? 以及派对编程？"></a>3. 什么是极限编程(XP)? 以及派对编程？</h4><p>极限编程：</p><p>极限编程（XP）是一种<strong>轻量级的软件开发方法</strong>，属于敏捷开发方法。</p><p>主要特征：适应环境变化和需求变化，充分发挥开发人员的主动精神。</p><p>它将复杂的开发过程分解为一个个相对比较简单的小周期，通过交流、反馈等方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。</p><p>派对编程：</p><p>主要的敏捷开发方法之一，其开发方式是<strong>两个程序员共同开发程序，且角色分工明确</strong>。一个负责编写程序，另一个负责复审与测试。两人<strong>定期交换角色</strong>。</p><h3 id="Chapter-8-测试程序"><a href="#Chapter-8-测试程序" class="headerlink" title="Chapter 8  测试程序"></a>Chapter 8  测试程序</h3><h4 id="1-产生缺陷的原因"><a href="#1-产生缺陷的原因" class="headerlink" title="1. 产生缺陷的原因"></a>1. 产生缺陷的原因</h4><p>(1)软件本身：错误的设计、错误的代码、错误的设计实现。</p><p>(2)客户不清晰的需求：需求错误、Missing需求、不可实现的需求；</p><p>(3)其他原因，如项目的规模，众多的参与者导致的复杂性。</p><h4 id="2-有几种主要的缺陷类型？"><a href="#2-有几种主要的缺陷类型？" class="headerlink" title="2. 有几种主要的缺陷类型？"></a>2. 有几种主要的缺陷类型？</h4><p>1、算法缺陷</p><p>算法的某些处理步骤或逻辑有问题，以至于软件部件对给定的输入数据无法产生正确的输出。</p><p>2、计算和精度缺陷</p><p>算法或公式在实现时出现错误，或计算结果的精度达不到要求。</p><p>3、文档缺陷</p><p>文档和实际实现程序不一致。</p><p>4、过载缺陷&#x2F;压力缺陷</p><p>程序运行时，对数据结构的使用超过了其承载能力。（数组越界、缓冲区溢出等）</p><p>5、能力缺陷&#x2F;边界缺陷</p><p>程序活动到达极限时，系统性能会变得不可接受。</p><p>6、计时缺陷&#x2F;协调缺陷</p><p>多个同时执行或者一个仔细定义的顺序执行的进程之间（管理）协调不当。</p><p>7、硬件和系统软件缺陷</p><p>提供的硬件或者系统软件并没有按照文档中的操作条件或步骤运作。</p><p>8、代码的标准和过程缺陷。</p><p>代码没有遵循组织机构的标准和过程。</p><h4 id="3-什么是正交缺陷分类？"><a href="#3-什么是正交缺陷分类？" class="headerlink" title="3. 什么是正交缺陷分类？"></a>3. 什么是正交缺陷分类？</h4><p>被分类的任何一项故障都只属于一个类别，则分类方案是正交的。如果故障属于不止一个类，则失去了度量的意义。</p><h4 id="4-测试的各个阶段及其任务？"><a href="#4-测试的各个阶段及其任务？" class="headerlink" title="4. 测试的各个阶段及其任务？"></a>4. 测试的各个阶段及其任务？</h4><p>1、单元测试：将每个程序构件与系统中的其他构件隔离，对其本身进行测试。</p><p>2、集成测试：验证系统构件是否能够按照系统和程序设计规格说明中描述的那样共同工作的过程。</p><p>3、功能测试：对系统进行评估，以确定集成的系统是否确实执行了需求规格说明中描述的功能，其结果是一个可运转的系统。</p><p>4、性能测试：测试系统的软硬件性能是否符合需求规格说明文档。 其结果是一个确认的系统。</p><p>5、验收测试：确定系统是按照用户的期望运转的。</p><p>6、安装测试：确保系统在实际环境中按照应有的方式运转。</p><p>7、系统测试：功能测试、性能测试、验收测试和安装测试统称为系统测试。</p><p><img src="/img/software-engineering/Testing-step.png"></p><h4 id="5-黑盒、白盒测试"><a href="#5-黑盒、白盒测试" class="headerlink" title="5.黑盒、白盒测试"></a>5.黑盒、白盒测试</h4><p><img src="/img/software-engineering/Testing-method.png"></p><p>（1）黑盒测试：将测试的对象看作是一个密闭的黑盒，我们的测试就是向闭盒提供输入的数据，并记录产生的输出。测试的目标是确保针对每种输入，观察到的输出与预期的输出相匹配。黑盒测试参考的文档是系统设计和程序设计阶段的文档。</p><p>优点：偏向于功能性的测试。不受内部逻辑约束。</p><p>缺点：不完备。黑盒法以 SRS 为依据，有一定的盲目性和不确定性，不可能揭示所有的错误。</p><p>黑盒测试方法：</p><p>1、<strong>等价分类法</strong>：将输入域划分为若干等价类。每个测试用例都代表了一类与它等价的其他例子。</p><p>2、<strong>边界值分析法</strong>：把测试值选在等价类的边界上进行测试。</p><p>3、错误猜测法：猜测程序中哪些地方容易出错，并据此设计测试用例。</p><p>4、因果图法：适用于被测试程序有很多输入条件，程序的输出又依赖输入条件的各种组 合的情况。</p><p>（2）白盒测试：将测试对象看作一个白盒，然后根据测试对象的结构用不同的方式进行测试。（已知结构）</p><p>优点：测试面广，可以测试一个模块的细节。</p><p>缺点：工作量大。</p><p>白盒测试方法:</p><ul><li>语句覆盖 + 判定(分支)覆盖一个判断 + 条件覆盖：要求判定中的每个条件均按照“真”、“假”两种结果至少执行一次。</li><li>条件组合覆盖：要求所有条件结果的组合都至少出现一次(比如 A&amp;&amp;B，两个条件，那么就有四种条件的组合)。</li><li>路径测试法</li></ul><h4 id="6-测试用例"><a href="#6-测试用例" class="headerlink" title="6. 测试用例"></a>6. 测试用例</h4><p>测试用例(Test Case)，是以测试程序为目标而挑选的输入数据，包括对应的期望结果。以便测试某个程序路径或核实是否满足某个特定需求。</p><p>是一组四元偶**&lt;输入数据、前置条件、测试步骤、预期输出&gt;**。</p><h4 id="7-传统测试和OO测试有何不同"><a href="#7-传统测试和OO测试有何不同" class="headerlink" title="7.传统测试和OO测试有何不同"></a>7.传统测试和OO测试有何不同</h4><p>（1）需求分析与验证不同</p><p>（2）测试用例的生成不一样</p><p>（3）源代码分析不一样</p><p>（4）覆盖分析不一样</p><h4 id="8-集成测试及其主要方法的分类？"><a href="#8-集成测试及其主要方法的分类？" class="headerlink" title="8.集成测试及其主要方法的分类？"></a>8.集成测试及其主要方法的分类？</h4><p>1、自底向上集成</p><p>先测试系统最底层的模块，接着测试调用这些底层模块的模块，直到测试完毕。</p><p>2、自顶向下集成</p><p>先测试系统最上层的模块，接着测试顶层模块调用的下层模块，直到测试完毕。</p><p>3、一次性集成</p><p>先测试每一个模块，之后将所有模块一并集成。</p><p>4、三明治集成</p><p>将系统分成三层，目标层处于中间、目标层上有一层，目标层下有一层。在顶层采用自顶向下的方式集成，在较低层采用自底向上的方式集成，测试集中于目标层。</p><p><strong>课件例题：</strong></p><p><strong>某城市的电话号码由 3 部分组成。这 3 个部分的名称与内容分别是:</strong><br><strong>地区码：空白或 3 位数字；前缀：非’0’或’1’开头的 3 位数字；后缀：4 位数字。</strong><br><strong>假定被测程序能接受一切符合上述规定的电话号码，拒绝所有不符合规定的号码，请使 用等价类的思路设计测试用例。</strong></p><p>驱动，桩的概念</p><p>驱动程序：调用特定构件并向其传递测试用例的程序，即代替上层模块的调用程序。</p><p>桩：一种专用程序，用于模拟测试时缺少构件时的活动。桩应答调用序列，并传回输出数据，使测试能够正常的进行下去，即代替下级模块的仿真程序。</p><p>什么是单元测试？ 什么是走查和检查？</p><p>将每个程序构件与系统中的其他构件隔离，对其本身进行测试。</p><p>走查：不正式的的代码评审。</p><p>检查：正式的代码评审，事先准备问题清单，依据清单比对代码和文档的一致性。</p><h3 id="Chapter-9-系统测试"><a href="#Chapter-9-系统测试" class="headerlink" title="Chapter 9 系统测试"></a>Chapter 9 系统测试</h3><h4 id="1-系统测试的主要步骤及各自含义？"><a href="#1-系统测试的主要步骤及各自含义？" class="headerlink" title="1. 系统测试的主要步骤及各自含义？"></a>1. 系统测试的主要步骤及各自含义？</h4><p>1、功能测试：根据SRS测试系统功能。</p><p>2、性能测试：根据SRS测试系统性能。</p><p>3、验收测试：根据客户的需求定义，由客户和用户一起测试。</p><p>4、安装测试：在用户环境下进行测试。</p><h4 id="2-什么是回归测试？"><a href="#2-什么是回归测试？" class="headerlink" title="2. 什么是回归测试？"></a>2. 什么是回归测试？</h4><p>回归测试是用于新的版本或者改进版本的一种测试，以验证与旧版本相比，软件是否仍然以同样的方式执行同样的功能。</p><h4 id="3-确认测试概念，确认测试分类？（基准测试、引导测试、并行测试）"><a href="#3-确认测试概念，确认测试分类？（基准测试、引导测试、并行测试）" class="headerlink" title="3.确认测试概念，确认测试分类？（基准测试、引导测试、并行测试）"></a>3.确认测试概念，确认测试分类？（基准测试、引导测试、并行测试）</h4><p>确认测试：由用户检查软件系统是否满足了他们的需求的测试。</p><p>Pilot test: install on experimental basis<br>Alpha test: in-house test<br>Beta test: customer pilot<br>Parallel testing: new system operates in parallel with old system</p><p>1、基准测试：</p><p>由用户准备典型测试用例，在实际安装后的系统运作并由用户对系统执行情况进行评估。</p><p>2、引导测试：</p><p>在假设系统已经永久安装的前提下执行系统。它依赖系统的日常工作进行测试，相对基准测试不是非常的正式与结构化。</p><h4 id="4-什么是alpha测试？β测试？"><a href="#4-什么是alpha测试？β测试？" class="headerlink" title="4. 什么是alpha测试？β测试？"></a>4. 什么是alpha测试？β测试？</h4><p>α测试：内部测试。客户进行实际的测试前，先自己组织团队（或者委托其他团队）测试这个系统。</p><p>β测试：公测。客户实际进行的测试。</p><p><img src="/img/software-engineering/alpha-beta-test.png"></p><ol><li>α测试</li></ol><p>就是把用户请到公司内部进行测试使用。</p><p>α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试；</p><p>目的：是评价软件产品的FLURPS(即功能、局域化、可使用性、可靠性、性能和支持)。</p><p>注意！α测试不能由程序员或测试员完成。</p><ol start="2"><li>β测试</li></ol><p>用户在不同场所进行测试。</p><p>β测试是一种验收测试。β测试由软件的终用户们在一个或多个场所进行。</p><h3 id="考试题型"><a href="#考试题型" class="headerlink" title="考试题型"></a>考试题型</h3><p>1.名词解释（10&#x2F;20分）</p><p>2.判断题（10&#x2F;10分）</p><p>3.选择题（20&#x2F;20分）</p><p>4.综合题（2&#x2F;20分）</p><p>5.简述题（5&#x2F;30分根据理解解释）</p><p>16周考试</p><p>老师联系地址：科研楼 215</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考网站&quot;&gt;&lt;a href=&quot;#参考网站&quot; class=&quot;headerlink&quot; title=&quot;参考网站&quot;&gt;&lt;/a&gt;参考网站&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_52100140/article/details/122</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学整合</title>
    <link href="http://example.com/2023/11/22/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B4%E5%90%88/"/>
    <id>http://example.com/2023/11/22/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B4%E5%90%88/</id>
    <published>2023-11-22T07:05:46.000Z</published>
    <updated>2023-11-22T07:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前已经学过密码相关的课程：</p><p>1.信息安全导论</p><p>2.信息安全数学基础</p><p>3.密码学原理与实践</p><p>4.Python与密码学</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>为什么写这样一篇整合性的文章，因为看书时突发奇想，发现之前学过的内容之间都存在不小的联系，如果能将脑中混杂的理论盒思想整合一下，即可以给自己之后的复习与重温产生极大的效益，同时也能发布到网络上，让他人受益，并在其他人的审视下纠正我的错误。</p><h2 id="密码学综述"><a href="#密码学综述" class="headerlink" title="密码学综述"></a>密码学综述</h2><h3 id="密码的起源"><a href="#密码的起源" class="headerlink" title="密码的起源"></a>密码的起源</h3><p>从远古时代起，人类就能感知身边各种自然现象所隐含的信息。在狩猎和劳作的过程中，人类开发出属于自己的各种复杂系统——语言、数字、文字系统，用来表示一些抽象的概念，创造出人类最初的密码。例如，云的特征隐藏了不同的信息，远古人类通过观察云的特征来解密天气信息，以预测是否会刮风或下雨；狩猎时人类学习“解密“信息最初的实践之一，猎人在狩猎的过程中，会根据猎物遗留的足印、活动痕迹、啃食的草木等迹象，解读其中隐藏的信息，以判断猎物的种类、踪迹和活动规律等。</p><h3 id="密码学的发展"><a href="#密码学的发展" class="headerlink" title="密码学的发展"></a>密码学的发展</h3><p>古代岩画，将一些象征性图案以莫重方式排列组合来传达不同的信息，这是人类通过图形化符号来传递信息的最早手段之一。著名的有法国拉斯科洞窟壁画，挪威的阿尔塔岩画，我国宁夏银川的贺兰山岩画，古人类将当时人类的生活和劳动信息隐藏于岩画之中，现代才得以通过解读这些信息，还原远古人类所处的生活环境和一系列生活场景。技术与书写的抽象思维使得人类的发展史得以记载流传，玛雅数字，巴比伦数字，阿拉伯数字，罗马数字，楔形文字，还有菲斯托斯圆盘上记载的古希腊文字，这些抽象的符号表达记录着当时人类的生活。</p><p>早在公元前7世纪，密码棒就在古希腊的军事重镇斯巴达得到广泛应用。这就是斯巴达密码棒。古斯巴达人用一条带子缠绕在一根木棍上，沿木棍纵轴方向写好明文，解下来的带子上就只有杂乱无章的密文字母。解密者只需找到相同直径的木棍，再把带子缠上去，沿木棍纵轴方向即可读出有意义的明文。这种方式在现代密码学中仍有体现——行列变换。</p><p>密码史与人类文明发展史相生相伴，从古人类的符号标记，古文字的形成与解读，再到斯巴达密码棒等等，这些五彩斑斓的创作，体现了古人在秘密传递上的智慧，将密码学一步一步推向了以数学为基础的古典密码时代。</p><h4 id="古典密码："><a href="#古典密码：" class="headerlink" title="古典密码："></a>古典密码：</h4><p>这一时期的密码学更像是一门艺术，其核心手段是代换和置换。代换是指明文中的每一个字符被替换成密文中的另一个字符，接收者对密文做反向替换便可恢复出明文；置换是密文和明文字母保持相同，但顺序被打乱。代换密码的著名例子有古罗马的凯撒密码（公元前1世纪）和法国的维吉尼亚密码（16世纪）。</p><h5 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h5><p>公元前1世纪，著名的凯撒密码，被用于高卢战争中，这是一种简单易行的单字母替代密码，这种加密方法就是将明文的字母按照字母顺序，往后依次递推相同的字母，就可以得到加密的密文，而解密的过程正好和加密的过程相反。</p><h5 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h5><p>维吉尼亚密码是多表置换密码的一个典型代表，这种方法即一个明文字母可以表示为多个密文字母，多表密码加密算法结果将使得对单表置换用的简单频率分析方法失效。维吉尼亚密码使用一个词组（语句）作为密钥，词组中每一个字母都作为移位替换密码密钥确定一个替换表，维吉尼亚密码循环的使用每一个替换表完成明文字母到密文字母的变换，最后所得到的密文字母序列即为加密得到的密文。维吉尼亚是古典密码理论发展上的一个重要里程碑。</p><p>置换密码也是古典密码的重要一员，通过一定的规则重新排列明文，打破明文的结构，而不改变明文的内容，仅仅是对明文字母的重新排序，就可以实现加密。虽然设计思想简单，但其贡献不可磨灭。</p><p>一次一密费纳姆密码作为绝对安全密码，其保密性在理论意义上绝对安全，虽然真正实现困难，但它对现代序列密码的设计的影响意义深远。</p><p>中国古代兵书《六韬》中的阴符和阴书:《六韬》又称《太公六韬》或《太公兵法》,据说是由西周的开国功臣太公望(又名吕尚或姜子牙,约公元前1128—公元前1015)所著。书中以周文王和周武王与太公问答的形式阐述军事理论,其中《龙韬•阴符》篇和《龙韬•阴书》篇,讲述了君主如何在战争中与在外的将领进行保密通信。</p><p>以下是关于“阴符”使用方法对话的译文。</p><p>武王问太公说:领兵深入敌国境内,军队突然遇到紧急情况,战事或有利,或失利。我要与各军远近相通,内外相应,保持密切的联系,以便及时应对战场上军队的需求,应该怎么办呢?</p><p>太公回答说:国君与主将之间用阴符秘密联络。阴符共有八种:一种长一尺,表示大获全胜,摧毁敌人;一种长九寸,表示攻破敌军,杀敌主将;一种长八寸,表示守城的敌人已投降,我军已占领该城;一种长七寸,表示敌军已败退,远传捷报;一种长六寸,表示我军将誓死坚守城邑;一种长五寸,表示请拨运军粮,增派援军;一种长四寸,表示军队战败,主将阵亡;一种长三寸,表示战事失利,全军伤亡惨重。如奉命传递阴符的使者延误传递,则处死;如阴符的秘密被泄露,则无论无意泄密者或有意传告者也处死。只有国君和主将知道这八种阴符的秘密。这就是不会泄露朝廷与军队之间相互联系内容的秘密通信语言。敌人再聪明也不能识破它。</p><p>在计算机时代来临之前，古典密码的破译还是一个困难问题，但随着计算机的发明，破译这些古典密码在今天看来轻而易举，但古典密码的设计思想给现代密码的设计产生了不可磨灭的影响，其工作原理——代换和置换，仍然是构造现代对称密码算法的最重要核心技术。</p><h4 id="近代密码"><a href="#近代密码" class="headerlink" title="近代密码"></a>近代密码</h4><p>近代密码是指从第一次世界大战、第二次世界大战到1976年这段时期密码的发展阶段。</p><p>电报的出现第一次使远距离快速传递信息成为可能,事实上,它增强了西方各国的通讯能力;20世纪初,意大利物理学家奎里亚摩•马可尼发明了无线电报,让无线电波成为新的通讯手段,它实现了远距离通讯的即时传输,但是通过无线电波送出的每条信息不仅传给了己方,也传送给了敌方,因此这就意味着必须给每条信息加密,随着第一次世界大战的爆发,对密码和解码人员的需求急剧上升,一场秘密通讯的全球战役打响了。</p><p>公元20世纪初,第一次世界大战进行到关键时刻,英国破译密码的专门机构“40号房间”利用缴获的德国密码本破译了著名的“齐默尔曼电报”,促使美国放弃中立参战,改变了战争进程。</p><p>随着计算机科学的发展,快速电子计算机和现代数学方法一方面为加密技术提供了新的方法、新的概念和新的工具,另一方面也为破译者提供了有力的武器。计算机和电子时代的到来给密码设计者们带来了前所未有的自由,他们可以轻松地减少原先用铅笔和纸在做手工设计时易犯的错误,也不用再担心使用电子机械方式实现密码机的高额费用。总之,利用电子和计算机技术可以设计出更加复杂的密码体系。</p><p>这一阶段真正开始源于香农在20世纪40年代末发表的一系列论文，特别是1949年的《保密系统通信理论》，把已有数千年历史的密码学推向了基于信息论的科学轨道。近代密码发展中一个重要突破是“数据加密标准”（DES）的出现。DES密码的意义在于，首先，其出现使密码学得以从政府走向民间，其设计主要由IBM公司完成，国家安全局等政府部门只是参与其中，最终经美国国家标准局公开征集遴选后，确定为联邦信息处理标准。其次，DES密码设计中的很多思想（Feistel结构、S盒等），被后来大多数分组密码所采用。再次，DES出现之后，不仅在美国联邦部门中使用，而且风行世界，并在金融等商业领域广泛使用。</p><p>密码学的发展直接影响了二战的战局。Arthur Scherbius于1919年设计出了历史上最著名的密码机—德国的Enigma机,它的设计结合了机械系统与电子系统。它被证明是有史以来最为可靠的加密系统之一,从而使得二战期间德军的保密通讯技术处于当时的领先地位。随着Enigma的破译,人们意识到其实真正保证密码安全的往往不是算法,而是密钥。即使算法外泄,但只要密钥保密,密码就不会失效。</p><p>荷兰密码学家Kerckhoffs于1883年在其名著作《军事密码学》中提出密码学的基本假设:密码系统中的算法即使为密码分析者所知,对推导出明文或密钥也没有帮助。也就是说,密码系统的安全性应只取决于可随时改变的密钥,而不应取决于不易被改变的事物(算法)。</p><p>在二次世界大战中,印第安纳瓦霍土著语言被美军用作密码,美国二战时候特别征摹使用印第安纳瓦霍通信兵。在二次世界大战日美的太平洋战场上,美国海军军部让北墨西哥和亚历桑那印第安纳瓦霍族人使用纳瓦霍语进行情报传递。纳瓦霍语的语法、音调及词汇都极为独特,不为世人所知道,当时纳瓦霍族以外的美国人中,能听懂这种语言的也就一二十人。这是密码学和语言学的成功结合,纳瓦霍语密码成为历史上从未被破译的密码。</p><h4 id="现代密码"><a href="#现代密码" class="headerlink" title="现代密码"></a>现代密码</h4><p>现代密码学的发展与计算机技术、电子通信技术密切相关。在这一阶段,密码理论得到了蓬勃发展,密码算法的设计与分析互相促进,从而出现了大量的加密算法和各种分析方法。除此之外,密码的使用扩张到各个领域,而且出现了许多通用的加密标准,从而促进了网络和技术的发展。</p><p>现代密码学有两个重要标志：一是美国制定并于1977年1月15日批准公布了公用数据加密标准DES。二是1976年，美国密码学家迪菲和赫尔曼在“密码学的新方向”的文章，首次提出公钥密码体制的构想和理论方法。即不仅加密算法本身可以公开，甚至加密用的密钥也可以公开，但这并不意味着保密程度的降低，因为加密密钥和解密密钥不一样，将解密密钥保密就可以，这就是著名的公钥密码体制。若存在这样的公钥体制，都可以将加密密钥像电话簿一样公开，任何用户想经其他用户传送一加密信息时，都可以从这本密钥薄中查到该 用户的公开密钥，用它来加密，而接收者能用只有它所具有的 解密密钥得到明文，任何第三者不能获得明文。1978年，美国麻省理工学院的里维斯特、沙米尔和阿德曼提出了RSA公钥密码体制，它是第一个成熟的、迄今为止理论上最成功的公钥密码体制。它的安全性是基于数论中的大整数因子分解。该问题是数论中的一个困难问题，至今没有有效的算法，这使得该体制具有较高的保密性。在现代密码学中，除了信息保密外，还有另一方面的要求，即信息安全体制还要能抵抗对手的主动攻击。所谓主动 攻击指的是攻击者可以在信息通道中注入自己伪造的消息，以骗取合法接收者的相信。主动攻击可能窜改信息，也可能冒名顶替，这就产生了现代密码学中的认证体制。该体制的 目的就是保证用户收到一个信息时，能验证消息是否来自 合法发送者，同时还能验证该信息是否被窜改。在许多场合中，如电子汇款，能对抗主动攻击的认证体制甚至比信息保密还重要。</p><h3 id="编码与密码"><a href="#编码与密码" class="headerlink" title="编码与密码"></a>编码与密码</h3><h5 id="摩尔斯电码"><a href="#摩尔斯电码" class="headerlink" title="摩尔斯电码"></a>摩尔斯电码</h5><p><a href="https://morsecode.bmcx.com/">摩尔斯电码对照表</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前已经学过密码相关的课程：&lt;/p&gt;
&lt;p&gt;1.信息安全导论&lt;/p&gt;
&lt;p&gt;2.信息安全数学基础&lt;/p&gt;
&lt;p&gt;3.密码学原理与实践&lt;/p&gt;
&lt;p&gt;4.Python与密码学&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>近来的苦恼</title>
    <link href="http://example.com/2023/11/02/%E8%BF%91%E6%9D%A5%E7%9A%84%E8%8B%A6%E6%81%BC/"/>
    <id>http://example.com/2023/11/02/%E8%BF%91%E6%9D%A5%E7%9A%84%E8%8B%A6%E6%81%BC/</id>
    <published>2023-11-02T08:26:01.000Z</published>
    <updated>2023-11-02T08:26:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近的烦心事不可谓不多，写这篇也是临时起意，将这些事情记录下来，也是给自己这大学两年多以来的经历进行总结教训。</p><p>总说大学大学，大不了自学。听起来很对，但真要到身体力行，则深感道阻且长，学习上的事，从小学以来基本都是老师讲，我听，我记，我做，不断重复然后形成知识体系，于我，上课听懂多少基本就是我学了多少；但到了大学，老师讲的东西，要么听不懂，要么听懂一部分，剩下就茫然了，尝试看书，有时会有很好的发现，可一旦落笔，则又瞬间什么又不懂了。我不知道怎么做，我不知道怎么学，我不知道怎么问，我不知道怎么解决。</p><p>大二转了专业，到了软院，数据结构瞬间打回原形，大一学的只有一节课相关，但本身上课就稀里糊涂，而且还不是一个版本，数据结构用C++编程，只学了一点C，连PPT的示例代码都看不懂，更别说自己写了。于是重新走上老路，上课不听去自学C++ Prime plus，但这本书将近千页，平时还有别的课程，没时间一次看完，一次看一点的方式完全行不通。这就是第一个烦心事。</p><p>接下来说说最近的，认识实习，原定第八周，推迟到了第九周，也就是本周，这周也马上过去了，明天也有web课程设计的考试，可项目又停滞了一个多月，当了团队的leader，一开始三番五次向其他成员说明，让他们要报告自己的进展，好安排任务，但是，他们完全没有团队意识，而我又很忙，9月底还找了一份实习的工作，已经做了一个多月了，该怎么办？第十四周就要提交了，本周末肯定要抓紧完成初步的项目，但还有别的任务，别的实验课，别的考试，我该怎么办？这就是第二个烦心事。</p><p>认识实习这几天，学校的安排给我感觉很差劲，先是把我们班级拆成两个组，并到其他组里去，然后和我同组的另一个班，计划变更也不说明，也不能按时抵达（有时是我们班其他人），联系的时候还联系不上，不提前站队查人，导致上车后等半天，虽然这些都是小事，但给我的感受就是很不好受，行政管理低下导致的问题。这些其实都不是什么重点，重点是即将结束的大学生活，课程设计、实验、毕业设计、考研还是找工作？考研自然毫不必问，可问题是方向还有能力，就目前而言，我有很多想做的事情，可这些需要时间，还有指导！大学以来，很少在学习上有过指点，坑是自己踩的，活是自己干的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近的烦心事不可谓不多，写这篇也是临时起意，将这些事情记录下来，也是给自己这大学两年多以来的经历进行总结教训。&lt;/p&gt;
&lt;p&gt;总说大学大学，大不了自学。听起来很对，但真要到身体力行，则深感道阻且长，学习上的事，从小学以来基本都是老师讲，我听，我记，我做，不断重复然后形成知识</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/24/net-attack&amp;defence-doc/bof-password/"/>
    <id>http://example.com/2023/10/24/net-attack&amp;defence-doc/bof-password/</id>
    <published>2023-10-24T03:36:42.819Z</published>
    <updated>2023-10-24T03:36:33.333Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/24/net-attack&amp;defence-doc/x-windows/"/>
    <id>http://example.com/2023/10/24/net-attack&amp;defence-doc/x-windows/</id>
    <published>2023-10-24T03:35:43.113Z</published>
    <updated>2023-10-24T00:59:56.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="X-windows"><a href="#X-windows" class="headerlink" title="X-windows"></a>X-windows</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p> X Windows 是 UNIX 和所有类 UNIX （包括Linux）操作系统的标准图形接口，有时也称为X Windows、X Window 或者 X。由于它是在 W 窗口系统之后开发成功的，故称为 X 系统。X Window 系统可以在许多系统上运行，具有可移植性、对彩色处理的多样性，以及在网络上操作的透明性等特点，使得 X 成为一个工业标准。因此，严格来说，X Window 系统并不是一个软件，而是一个协议（protocal），定义了一个系统成品必须具备的功能。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.bilibili.com/read/cv8087543/">【Linux图形环境】何为X Windows系统（图形环境）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;X-windows&quot;&gt;&lt;a href=&quot;#X-windows&quot; class=&quot;headerlink&quot; title=&quot;X-windows&quot;&gt;&lt;/a&gt;X-windows&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/23/web-doc/vue-%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/"/>
    <id>http://example.com/2023/10/23/web-doc/vue-%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/</id>
    <published>2023-10-23T03:27:58.434Z</published>
    <updated>2023-10-24T03:18:58.630Z</updated>
    
    <content type="html"><![CDATA[<h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p><code>暗黑模式/白天模式</code>的主题切换功能</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/7134594122391748615">前端主题切换方案 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;想法&quot;&gt;&lt;a href=&quot;#想法&quot; class=&quot;headerlink&quot; title=&quot;想法&quot;&gt;&lt;/a&gt;想法&lt;/h3&gt;&lt;p&gt;&lt;code&gt;暗黑模式/白天模式&lt;/code&gt;的主题切换功能&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;hea</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/23/web-doc/vue-markdown/"/>
    <id>http://example.com/2023/10/23/web-doc/vue-markdown/</id>
    <published>2023-10-23T03:02:44.369Z</published>
    <updated>2023-10-23T03:27:39.306Z</updated>
    
    <content type="html"><![CDATA[<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>首先需要使用npm引入三个包</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i markdown-loader html-loader marked --save</span><br></pre></td></tr></table></figure><p>说明：<code>markdown-loader</code>、<code>html- loader</code>是为了让<code>vue</code>能够解析<code>md</code>格式的文件，读取出来，然后使用<code>marked</code>将读取出来的数据转换成<code>html</code>格式渲染到页面上。使用<code>marked</code>是为了使用更方便。</p><p>下一步准备引入 *.md 文件，但是引入之前还需要做一个规则配置，如果没有配置的话会报无法解析“#”的错误。配置好后就可以引入md文件了。</p><h4 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h4><p>在vue.config.js里进行配置,<strong>如果使用的是 vue-cli 3 以上版本则在vue.config.js中配置</strong></p><p>webpack.base.conf.js 配置：在 module &gt; rules 中添加一条规则</p><figure class="highlight javascript"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        <span class="comment">// 配置读取 *.md 文件的规则</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.md$/</span>,</span><br><span class="line">             <span class="attr">use</span>: [</span><br><span class="line">                &#123; <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">loader</span>: <span class="string">&#x27;markdown-loader&#x27;</span>, <span class="attr">options</span>: &#123;&#125; &#125;</span><br><span class="line">             ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vue.config.js 配置：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        // 配置读取 *.md 文件的规则</span><br><span class="line">        &#123;</span><br><span class="line">          test: /\.md$/,</span><br><span class="line">          use: [</span><br><span class="line">            &#123; loader: &quot;html-loader&quot; &#125;,</span><br><span class="line">            &#123; loader: &quot;markdown-loader&quot;, options: &#123;&#125; &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="页面引入和渲染"><a href="#页面引入和渲染" class="headerlink" title="页面引入和渲染"></a>页面引入和渲染</h4><p>在需要使用的地方，引入 marked，再将 md 文档交给它来解析，获得到解析后的 HTML 格式内容，再将解析后的内容渲染到页面上</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;文档&lt;/div&gt;</span><br><span class="line">    &lt;div v-html=&quot;articalContent&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">​</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const marked = require(&quot;marked&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      articalContent: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.$axios.get(&quot;/articles/test.md&quot;).then(res =&gt; &#123;</span><br><span class="line">        const htmlMD = marked(res.data);</span><br><span class="line">​</span><br><span class="line">        this.articalContent = htmlMD;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这时，md格式的数据就被解析成了html格式的数据，我们只需要将html格式的数据渲染上去就行了。</p><h4 id="MD样式未渲染"><a href="#MD样式未渲染" class="headerlink" title="MD样式未渲染"></a>MD样式未渲染</h4><p>到现在为止，只是将文档正确解析并显示到了页面上，但是没有任何样式，我们可以再给渲染的内容加上样式，比如使用 github 的样式：</p><p>这时候就需要我们下载另外一个依赖</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install github-markdown-css</span><br></pre></td></tr></table></figure><p>然后在main.js中将md文件的样式引入</p><figure class="highlight arduino"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;github-markdown-css&#x27;</span>;</span><br></pre></td></tr></table></figure><p>最后给页面的div盒子加上样式的class</p><figure class="highlight css"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> v-<span class="selector-tag">html</span>=&quot;md&quot; class=&quot;markdown-<span class="selector-tag">body</span>&quot; &gt;</span><br><span class="line"> </span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p>注：可能页面有些不一样因为样式不同</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/weixin_44702572/article/details/107321909">Vue解析 markdown 文件_vue 解析markdown-CSDN博客</a></p><p><a href="https://juejin.cn/post/7034048009000189960">vue引入并解析md文件 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;依赖&quot;&gt;&lt;a href=&quot;#依赖&quot; class=&quot;headerlink&quot; title=&quot;依赖&quot;&gt;&lt;/a&gt;依赖&lt;/h4&gt;&lt;p&gt;首先需要使用npm引入三个包&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;input class=&quot;b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/23/assets/markdownhere/"/>
    <id>http://example.com/2023/10/23/assets/markdownhere/</id>
    <published>2023-10-23T02:31:49.970Z</published>
    <updated>2023-10-23T02:36:14.051Z</updated>
    
    <content type="html"><![CDATA[/*markdown here 的全局配置*/.markdown-here-wrapper {    font-size: 16px;    line-height: 1.8em;    /*em指的是相对单位，当前对象内字体的尺寸，默认浏览器16px*/    /*http://www.w3school.com.cn/cssref/css_units.asp*/    letter-spacing: 0.1em;  }    pre, code {       /*,逗号连接是并集选择器*/    font-size: 14px;    font-family: Roboto, 'Courier New', Consolas, Inconsolata, Courier, monospace;    margin: auto 5px;  }    /*设置pre 和code的整体属性，pre可以把div中的/r/n保存下来显示，而code则用浏览器的方式渲染*/  code {    white-space: pre-wrap;    border-radius: 2px;    display: inline;  }  /*display 的属性为指定元素框的类型*/  /*margin： 0为默认值，auto为浏览器自动计算的外边距，外边距属性*/  /*border-radius: div元素的圆角框*/  /*write-space:如何处理元素内空白行，回车or忽略,nowrap不换行，pre-wrap换行*/  /*http://www.w3school.com.cn/cssref/pr_text_white-space.asp*/      pre {      /*pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。*/    font-size: 15px;    line-height: 1.4em;    display: block; !important;  /*在ie6以上的浏览器中，设置优先级，覆盖预先设置的属性 !important*/  }    pre code {  /*空格连接是后代选择器，外层在前内层在后； >连接是子元素选择器*/    white-space: pre;    overflow: auto;   /*内容益处元素框时候的行为*/    border-radius: 3px;    padding: 1px 1px;    display: block !important;  }    /*各种选择器：https://blog.csdn.net/m0_38070602/article/details/69950795*/  /*pre code 的解释：http://www.cnblogs.com/lizonghui/archive/2012/09/18/2692355.html*/  strong, b{      /*strong表示强调，用<b>粗体显示，也可以自定义自己的强调方式*/    color: #BF360C;  }    em, i {      /*em表示强调，用<i>标签斜体显示，也可以自定义自己的强调方式*/    color: #009688;  }    hr {       /*水平线分割---*/    border: 1px solid #BF360C;    margin: 1.5em auto;  }    p {      /*段落选择器*/    margin: 1.5em 5px !important;    /*颜色*/    /*color:#d6a841;*/       /*字体*/    font-family:'微软雅黑';    /*字号*/    font-size:15px;    /*行间距，可用百分比，数值倍数，像素设置，还包括text-indent缩进、letter-spacing字间距、*/    line-height:100%  2  100px;    /*段间距，一般用margin属性调整*/    margin-bottom:20px;    /*页边距用padding属性调整*/  }    /*表格和*/  table, pre, dl, blockquote, q, ul, ol {    margin: 10px 5px;    /*并集选择器：表格、预格式化、定义列表、块引用、短引用、无序列表、有序列表*/  }    ul, ol {      /*无序、有序列表*/    padding-left: 15px;  }    li {      /* 定义列表中的项目*/    margin: 10px;  }    li p {      /*li列表元素中的后代选择器，包含选择器，应用于li中的p*/    margin: 10px 0 !important;  }    ul ul, ul ol, ol ul, ol ol {        /*各个后代选择器一起添加属性*/    margin: 0;    padding-left: 10px;  }    ul {    list-style-type: circle;  }  /*无序列表的前缀，circle,square,好多种,同样有序列表ol也可以设置不同的标记*/  /*http://www.w3school.com.cn/cssref/pr_list-style-type.asp*/    dl {    padding: 0;  }    dl dt {    font-size: 1em;    font-weight: bold;      /*加粗  意大利斜体*/    font-style: italic;  }    dl dd {    margin: 0 0 10px;    padding: 0 10px;  }  /*各种表格的包含选择器定义，用空格连接*/      blockquote, q {    border-left: 2px solid #009688;    padding: 0 10px;      /*上右下左的排序，可输入四个值*/    color: #777;    quotes: none;    margin-left: 1em;  }  /*块引用和短引用的样式*/    blockquote::before, blockquote::after, q::before, q::after {    content: none;  }  /*before 和after属于css伪元素，:before在元素之前插入相应。：after在之后插入*/  /*伪元素用::，伪类用：参考ref。。https://blog.csdn.net/qq_25292481/article/details/52577320*/      /*--------同时设置六级标题的属性，其中！important用于指定优先级>ie6--------------*/  h1, h2, h3, h4, h5, h6 {    margin: 20px 0 10px;    padding: 0;    font-style: bold !important;    color: #009688 !important;    text-align: center !important;    margin: 1.5em 5px !important;    padding: 0.5em 1em !important;  }    h1 {    font-size: 24px !important;    border-bottom: 1px solid #ddd !important;  }    h2 {    font-size: 20px !important;    border-bottom: 1px solid #B3B3B3 !important;  }    h3 {    font-size: 18px;  }    h4 {    font-size: 16px;    /*可以针对自己的标题做出个性化设置*/    color:#d6a841   /*16进制颜色*/    font-style: bold /*加粗？倾斜*/    /*---------各种居中方式---------*/    margin: 0, auto;        /*块级元素居中*/    text-align: center;    /*行内居中*/    justify-content: center;  /*对齐*/    vertical-align: middle;  /*垂直居中*/    /*ref:   https://www.jianshu.com/p/61c431fd924a*/    }    /*-------------表格元素的设置-----------------*/  table {    padding: 0;    border-collapse: collapse;  /*合并边框属性*/    border-spacing: 0;      font-size: 1em;    font: inherit;    border: 0;    margin: 0 auto;  }    tbody {    margin: 0;    padding: 0;    border: 0;  }    table tr {    border: 0;    border-top: 1px solid #CCC;    background-color: white;    margin: 0;    padding: 0;  }    table tr:nth-child(2n) {    background-color: #F8F8F8;  }    table tr th, table tr td {    font-size: 16px;    border: 1px solid #CCC;    margin: 0;    padding: 5px 10px;  }    table tr th {  /*表格。tableraw，tableheader*/    font-weight: bold;    color: #eee;    border: 1px solid #009688;    background-color: #009688;  }      /* ----------  可根据markdown的实现自己的**个性化**标记 */  @strong-char: "**";  /*可以将着重符号替换为自己的个性化符号*/  strong:before, strong:after {      content: @strong-char;      display: inline;  }  @em-char: "*";     em:before, em:after {      content: @em-char;      display: inline;  }    ]]></content>
    
    
      
      
    <summary type="html">/*markdown here 的全局配置*/
.markdown-here-wrapper {
    font-size: 16px;
    line-height: 1.8em;
    /*em指的是相对单位，当前对象内字体的尺寸，默认浏览器16px*/
    /*h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Web前端框架</title>
    <link href="http://example.com/2023/10/19/Web%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2023/10/19/Web%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</id>
    <published>2023-10-19T13:18:02.000Z</published>
    <updated>2023-10-19T13:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue 的核心功能是声明式渲染：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应该是什么样子的。当状态改变时，HTML 会自动更新。</p><h3 id="plugin-插件"><a href="#plugin-插件" class="headerlink" title="plugin 插件"></a>plugin 插件</h3><p><a href="https://juejin.cn/post/6966106927990308872">Volar - vue终极开发神器！ - 掘金 (juejin.cn)</a></p><p><a href="https://cn.vitejs.dev/config/">配置 Vite | Vite 官方中文文档 (vitejs.dev)</a></p><p>能在改变时触发更新的状态被认为是响应式的(AJAX)。在 Vue 中，响应式状态被保存在组件中。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">  // 组件选项</span><br><span class="line">  // 此处声明一些响应式状态</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello World!&#x27;,</span><br><span class="line">      // 复合属性用对象表示 &#x27;x.x_value&#x27;</span><br><span class="line">      counter: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Count is: &#123;&#123; counter.count &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>message 属性可以在模板中使用。下面展示了我们如何使用双花括号法，根据 message 的值来渲染动态文本。</p><p>在 Vue 中，mustache 语法 (即双大括号) 只能用于文本插值。为了给 attribute 绑定一个动态值，需要使用 <code>v-bind</code> 指令：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line">// 简写写法</span><br></pre></td></tr></table></figure><p>指令是由 v- 开头的一种特殊 attribute。它们是 Vue 模板语法的一部分。和文本插值类似，指令的值是可以访问组件状态的 JavaScript 表达式。<br>冒号后面的部分 (:id) 是指令的“参数”。此处，元素的 id <code>attribute</code> 将与组件状态里的 <code>dynamicId</code> 属性保持同步。<br><strong>v-bind绑定属性变量dynamicId，属性变量的值才是实际的class</strong></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      titleClass: &#x27;title&#x27; //titleClass是属性变量，title是属性值</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 :class=&quot;titleClass&quot;&gt;&#123;&#123;titleClass&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">// 跟属性值相同</span><br><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/torchstar/p/11799394.html">vue中v-on支持的事件总结</a><br>我们可以使用 <code>v-on</code> 指令监听 DOM 事件：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">// 简写写法</span><br><span class="line">&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>此处，increment 引用了一个使用 methods 选项声明的函数</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 组件选项 方法体</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      // 更新组件状态</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><strong>表单绑定</strong><br>我们可以同时使用 v-bind 和 v-on 来在表单的输入元素上创建双向绑定：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input :value=&quot;text&quot; @input=&quot;onInput&quot;&gt;</span><br></pre></td></tr></table></figure><p>这里，我们使用 v-bind:value 将 text 属性绑定到 <code>&lt;input&gt;</code> 元素的 value 属性上。每当用户在 <code>&lt;input&gt;</code> 元素中输入时，浏览器都会触发 input 事件并调用 onInput 方法。在这个方法中，我们更新组件状态的 text 属性。</p><p>为了简化双向绑定，Vue 提供了一个 <code>v-model</code> 指令，它实际上是上述操作的语法糖：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;text&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      text: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onInput(e) &#123;</span><br><span class="line">      this.text = e.target.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input :value=&quot;text&quot; @input=&quot;onInput&quot; placeholder=&quot;Type here&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>试着在文本框里输入——你会看到 <code>&lt;p&gt;</code> 里的文本也随着你的输入更新了。</p><p>我们可以使用 <code>v-if</code> 指令来有条件地渲染元素：<br>这个 <code>&lt;h1&gt;</code> 标签只会在 awesome 的值为真值 (Truthy) 时渲染。若 awesome 更改为假值 (Falsy)，它将被从 DOM 中移除。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p><strong>列表渲染</strong><br>我们可以使用 <code>v-for</code> 指令来渲染一个基于源数组的列表：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>这里的 todo 是一个局部变量，表示当前正在迭代的数组元素。它只能在 v-for 所绑定的元素上或是其内部访问，就像函数的作用域一样。</p><p>注意，我们还给每个 todo 对象设置了唯一的 id，并且将它作为特殊的 key attribute 绑定到每个 <code>&lt;li&gt;</code>。key 使得 Vue 能够精确的移动每个 <code>&lt;li&gt;</code>，以匹配对应的对象在数组中的位置。这个 key attribute 也是 Vue 为了性能而做的一个必要的优化。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 给每个 todo 对象一个唯一的 id</span><br><span class="line">let id = 0</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      newTodo: &#x27;&#x27;,</span><br><span class="line">      todos: [</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn HTML&#x27; &#125;,</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn JavaScript&#x27; &#125;,</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn Vue&#x27; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodo() &#123;</span><br><span class="line">      this.todos.push(&#123; id: id++, text: this.newTodo &#125;)</span><br><span class="line">      this.newTodo = &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeTodo(todo) &#123;</span><br><span class="line">      this.todos = this.todos.filter((t) =&gt; t !== todo)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;form @submit.prevent=&quot;addTodo&quot;&gt;</span><br><span class="line">    &lt;input v-model=&quot;newTodo&quot;&gt;</span><br><span class="line">    &lt;button&gt;Add Todo&lt;/button&gt;    </span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">      &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>(t) &#x3D;&gt; t !&#x3D;&#x3D; todo 可以转变成以下形式</p><p>function(t){<br>    return t!&#x3D;&#x3D;todo<br>}</p><p>介绍一个新概念：计算属性。我们可以使用 computed 选项声明一个响应式的属性，它的值由其他属性计算而来：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: &#123;</span><br><span class="line">    filteredTodos() &#123;</span><br><span class="line">      // 根据 `this.hideCompleted` 返回过滤后的 todo 项目</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">let id = 0</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      newTodo: &#x27;&#x27;,</span><br><span class="line">      hideCompleted: false,</span><br><span class="line">      todos: [</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn HTML&#x27;, done: true &#125;,</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn JavaScript&#x27;, done: true &#125;,</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn Vue&#x27;, done: false &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    filteredTodos() &#123;</span><br><span class="line">      return this.hideCompleted</span><br><span class="line">        ? this.todos.filter((t) =&gt; !t.done)</span><br><span class="line">        : this.todos</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodo() &#123;</span><br><span class="line">      this.todos.push(&#123; id: id++, text: this.newTodo, done: false &#125;)</span><br><span class="line">      this.newTodo = &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeTodo(todo) &#123;</span><br><span class="line">      this.todos = this.todos.filter((t) =&gt; t !== todo)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;form @submit.prevent=&quot;addTodo&quot;&gt;</span><br><span class="line">    &lt;input v-model=&quot;newTodo&quot;&gt;</span><br><span class="line">    &lt;button&gt;Add Todo&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;todo in filteredTodos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;</span><br><span class="line">      &lt;span :class=&quot;&#123; done: todo.done &#125;&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;button @click=&quot;hideCompleted = !hideCompleted&quot;&gt;</span><br><span class="line">    &#123;&#123; hideCompleted ? &#x27;Show all&#x27; : &#x27;Hide completed&#x27; &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.done &#123;</span><br><span class="line">  text-decoration: line-through;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>怎么实现的隐藏？</p><p>手动操作 DOM。</p><p>这时我们需要使用模板引用——也就是指向模板中一个 DOM 元素的 ref。我们需要通过这个特殊的 ref attribute 来实现模板引用：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p ref=&quot;pElementRef&quot;&gt;hello&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>此元素将作为 this.$refs.pElementRef 暴露在 this.$refs 上。然而，你只能在组件挂载之后访问它。</p><p>要在挂载之后执行代码，我们可以使用 mounted 选项：<br>这被称为生命周期钩子——它允许我们注册一个在组件的特定生命周期调用的回调函数。还有一些其他的钩子如 created 和 updated。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 此时组件已经挂载。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.$refs.pElementRef.textContent = &#x27;mounted!&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p ref=&quot;pElementRef&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>侦听器<br>有时我们需要响应性地执行一些“副作用”——例如，当一个数字改变时将其输出到控制台。我们可以通过侦听器来实现它：<br>一个比在控制台输出更加实际的例子是当 ID 改变时抓取新的数据。在下边的例子中就是这样一个组件。该组件被挂载时，会从模拟 API 中抓取 todo 数据，同时还有一个按钮可以改变要抓取的 todo 的 ID。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      todoId: 1,</span><br><span class="line">      todoData: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async fetchData() &#123;</span><br><span class="line">      this.todoData = null</span><br><span class="line">      const res = await fetch(</span><br><span class="line">        `https://jsonplaceholder.typicode.com/todos/$&#123;this.todoId&#125;`</span><br><span class="line">      )</span><br><span class="line">      this.todoData = await res.json()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.fetchData()</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    todoId() &#123;</span><br><span class="line">      this.fetchData()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;Todo id: &#123;&#123; todoId &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button @click=&quot;todoId++&quot;&gt;Fetch next todo&lt;/button&gt;</span><br><span class="line">  &lt;p v-if=&quot;!todoData&quot;&gt;Loading...&lt;/p&gt;</span><br><span class="line">  &lt;pre v-else&gt;&#123;&#123; todoData &#125;&#125;&lt;/pre&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>组件<br>目前为止，我们只使用了单个组件。真正的 Vue 应用往往是由嵌套组件创建的。</p><p>父组件可以在模板中渲染另一个组件作为子组件。要使用子组件，我们需要先导入它：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要使用 components 选项注册组件。这里我们使用对象属性的简写形式在 ChildComp 键下注册 ChildComp 组件。</p><p>然后我们就可以在模板中使用组件，就像这样：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComp /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;Child component&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>Props<br>子组件可以通过 props 从父组件接受动态数据。首先，需要声明它所接受的 props：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在子组件中</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦声明，msg prop 就会暴露在 this 上，并可以在子组件的模板中使用。</p><p>父组件可以像声明 HTML attributes 一样传递 props。若要传递动态值，也可以使用 v-bind 语法：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComp :msg=&quot;greeting&quot; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      greeting: &#x27;Hello from parent&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp :msg=&quot;greeting&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123; msg || &#x27;No props passed yet&#x27; &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>Emits<br>除了接收 props，子组件还可以向父组件触发事件：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  // 声明触发的事件</span><br><span class="line">  emits: [&#x27;response&#x27;],</span><br><span class="line">  created() &#123;</span><br><span class="line">    // 带参数触发</span><br><span class="line">    this.$emit(&#x27;response&#x27;, &#x27;hello from child&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.$emit() 的第一个参数是事件的名称。其他所有参数都将传递给事件监听器。</p><p>父组件可以使用 v-on 监听子组件触发的事件——这里的处理函数接收了子组件触发事件时的额外参数并将它赋值给了本地状态：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp @response=&quot;(msg) =&gt; childMsg = msg&quot; /&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; childMsg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>插槽<br>除了通过 props 传递数据外，父组件还可以通过插槽 (slots) 将模板片段传递给子组件：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComp&gt;</span><br><span class="line">  This is some slot content!</span><br><span class="line">&lt;/ChildComp&gt;</span><br></pre></td></tr></table></figure><p>在子组件中，可以使用 <slot> 元素作为插槽出口 (slot outlet) 渲染父组件中的插槽内容 (slot content)：<br><slot> 插口中的内容将被当作“默认”内容：它会在父组件没有传递任何插槽内容时显示</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在子组件的模板中 --&gt;</span><br><span class="line">&lt;slot&gt;Fallback content&lt;/slot&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;from parent&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/ChildComp&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;slot&gt;Fallback content&lt;/slot&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;script setup&gt;</code> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。当同时使用 SFC 与组合式 API 时该语法是默认推荐。相比于普通的 <code>&lt;script&gt;</code> 语法，它具有更多优势：<br>里面的代码会被编译成组件 setup() 函数的内容。这意味着与普通的 <script> 只在组件被首次引入的时候执行一次不同，<script setup> 中的代码会在每次组件实例被创建的时候执行。</p><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h2&gt;&lt;p&gt;Vue 的核心功能是声明式渲染：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络防范</title>
    <link href="http://example.com/2023/10/19/%E7%BD%91%E7%BB%9C%E9%98%B2%E8%8C%83/"/>
    <id>http://example.com/2023/10/19/%E7%BD%91%E7%BB%9C%E9%98%B2%E8%8C%83/</id>
    <published>2023-10-19T03:31:30.000Z</published>
    <updated>2023-10-19T03:31:30.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>CE修改器入门</title>
    <link href="http://example.com/2023/10/19/CE%E4%BF%AE%E6%94%B9%E5%99%A8%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2023/10/19/CE%E4%BF%AE%E6%94%B9%E5%99%A8%E5%85%A5%E9%97%A8/</id>
    <published>2023-10-19T00:53:08.000Z</published>
    <updated>2023-10-19T00:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新手教程"><a href="#新手教程" class="headerlink" title="新手教程"></a>新手教程</h2><p><a href="https://cheatengine.org/">cheat engine 官网</a></p><p>附加<code>Tutorial-i386.exe进程</code>后,我们点击教程的下一步按钮，接着继续第二关，第二关的作用还是很简单的，主要目的是遍历出我们想要的动态数据，比如角色的生命，人物的魔法等，都会用到精确扫描，可以说这一关是既简单又实用的东西，也是今后制作中最常用的环节，接着我们看下<code>Tutorial-i386.exe程序</code>对这一关通关流程的描述:</p><blockquote><p>步骤 2: 精确值扫描 (密码&#x3D;090453)</p><p>现在你已经在 Cheat Engine 中打开了训练程序，为我们下一步的练习做好了准备。<br>本窗口的左下方显示的”健康:XXX”，在你每次点击”打我”按钮时，它的值便会减少。<br>要进入下一关，你必须找到这个数值并把它改成 1000 。<br>很多方法都可以找到这个数值的位置，但我将告诉你一个最简单的方法，”精确数值”扫描：</p></blockquote><p>上面的简单描述的意思就是,需要将100这个数值修改为1000则本关就算通过，看下面具体的步骤</p><p>1.首先游戏规则是每次我们点击<code>打我</code>按钮则健康值则会减一,我们首先搜索这个<code>100</code>看能不能找到些什么.</p><p><img src="/img/CE/CE-simple-scan-1.png"></p><p>现在开始搜索精确数值 <code>100</code>  数值中<code>输入100</code> 点击 <code>首次扫描</code> 按钮</p><p><img src="/img/CE/CE-simple-scan-2.png"></p><p>默认情况下一般游戏就是4字节，这里不需要改动<code>扫描类型和数值类型</code>，默认就好了.</p><p>这次扫描我们得到 35 个结果，里面肯定有我们要找的那个血值，不过好像太多了,没关系继续往下看.</p><p><img src="/img/CE/CE-simple-scan-3.png"></p><p>关键一步：为了找到更加精确的数据，我们回到 Tutorial 点击 <code>打我</code> 按钮，此时血值已有变化了：</p><p><img src="/img/CE/CE-simple-scan-4.png"></p><p>我们再输入 <code>95</code> 点击 <code>再次扫描</code> 按钮 结果只剩1个（这就是我们要找的），我们双击此地址将其添加到地址栏：</p><p><img src="/img/CE/CE-simple-scan-5.png"></p><p>此时地址栏里面只有1个结果了，这个就是我们要找的内存地址，双击将其加入到地址栏</p><p><img src="/img/CE/CE-simple-scan-6.png"></p><p>在数值95上面双击，并修改把 95 改成 1000 点击<code>确定</code>按钮,此时通关.</p><p><img src="/img/CE/CE-simple-scan-7.png"></p><p>此时回到Tutorial-i386.exe程序，会发现教程的 <code>下一步</code> 按钮变成可用,再次点击打我按钮，数值变大了，继续点击下一步进入第三关…</p><p><img src="/img/CE/CE-simple-scan-8.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新手教程&quot;&gt;&lt;a href=&quot;#新手教程&quot; class=&quot;headerlink&quot; title=&quot;新手教程&quot;&gt;&lt;/a&gt;新手教程&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://cheatengine.org/&quot;&gt;cheat engine 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>外挂分析与实现</title>
    <link href="http://example.com/2023/10/19/%E5%A4%96%E6%8C%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/10/19/%E5%A4%96%E6%8C%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-10-19T00:39:59.000Z</published>
    <updated>2023-10-19T00:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PVZ辅助"><a href="#PVZ辅助" class="headerlink" title="PVZ辅助"></a>PVZ辅助</h2><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/tree/main">PlantsVsZombies-Cheat: 植物大战僵尸逆向分析与辅助开发系列教程(github.com)</a></p><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><h4 id="OnlyDbg使用"><a href="#OnlyDbg使用" class="headerlink" title="OnlyDbg使用"></a>OnlyDbg使用</h4><p><a href="https://www.bilibili.com/video/BV1cE411f7sE/?p=6&spm_id_from=pageDriver&vd_source=206a091077ff783d662b49e64cc9589d">06.常用断点之硬件断点原理解析_哔哩哔哩_bilibili</a></p><p><a href="https://www.cnblogs.com/xueyoo/articles/4938538.html">OllyDBG完美教程(超强入门级) - xueyoo - 博客园 (cnblogs.com)</a></p><p><strong>OllyDBG界面认识</strong><br><img src="/img/Network-attack/OB-desktop.png"></p><ul><li><p>反汇编窗口：显示被调试程序的反汇编代码。用鼠标左键点击注释标签可以切换注释显示的方式。如果需要修改代码，直接在这里在修改，比如“使用NOP填充”。</p></li><li><p>寄存器窗口：显示当前所选线程的CPU寄存器内容。点击标签寄存器(FPU)可以切换显示寄存器的方式。</p></li><li><p>信息窗口：显示反汇编窗口中当前选中的第一条命令的参数及一些跳转目标地址、字串等（一般动态加密解密字串等会在此出现）。</p></li><li><p>数据窗口：显示内存或文件的内容。直接点击ASCII数据可以切换编码显示方式。</p></li><li><p>堆栈窗口：显示当前线程的堆栈数据。比如程序初始化的一些常量、变量之类的数据。</p></li><li><p>菜单窗口：一些常用调试命令以及操作。一般把鼠标移到菜单窗口的某按钮后，界面最左下角会出现一些命令提示，比如单步步入（F7），单步步过F8，运行程序（F9）等。</p></li><li><p>命令行窗口：用来下断点等相关命令。</p></li></ul><p><strong>调试方法</strong></p><p><img src="/img/Network-attack/debug-shortcut-key.png"></p><p>F2：设置断点。只要在光标定位的位置（上图中灰色条）按F2键即可，再按一次F2键则会删除断点。（相当于 SoftICE 中的 F9）<br>F8：单步跳过。每按一次这个键执行一条反汇编窗口中的一条指令，遇到 CALL 等子程序不进入其代码。（相当于 SoftICE 中的 F10）<br>F7：单步步入。功能同单步步过(F8)类似，区别是遇到 CALL 等子程序时会进入其中，进入后首先会停留在子程序的第一条指令上。（相当于 SoftICE 中的 F8）<br>F4：运行到选定位置。作用就是直接运行到光标所在位置处暂停。（相当于 SoftICE 中的 F7）<br>F9：运行。按下这个键如果没有设置相应断点的话，被调试的程序将直接开始运行。（相当于 SoftICE 中的 F5）<br>CTR + F9：执行到返回。此命令在执行到一个 ret (返回指令)指令时暂停，常用于从系统领空返回到我们调试的程序领空。（相当于 SoftICE 中的 F12）<br>ALT + F9：执行到用户代码。可用于从系统领空快速返回到我们调试的程序领空。（相当于 SoftICE 中的 F11） </p><p><strong>常用断点</strong></p><p><a href="https://www.cnblogs.com/LyShark/p/13071792.html">Windows 下的常用调试API断点 - lyshark - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq1084283172/article/details/47733849">OD调试程序常用断点大全_od 创建进程 断点-CSDN博客</a></p><p>[<a href="https://cloud.tencent.com/developer/article/1910265">系统安全] 二十四.逆向分析之OD调试INT3断点、反调试、硬件断点与内存断点-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><strong>汇编指令</strong></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cmp a,b 比较a与b</span><br><span class="line"></span><br><span class="line">mov a,b 把b的值送给a</span><br><span class="line"></span><br><span class="line">ret 返回主程序</span><br><span class="line"></span><br><span class="line">nop 无作用,英文“no operation”的简写，意思是“do nothing”(机器码90)</span><br><span class="line">(解释:ultraedit打开编辑exe文件时你看到90,等同于汇编语句nop)</span><br><span class="line"></span><br><span class="line">call 调用子程序</span><br><span class="line"></span><br><span class="line">je 或jz 若相等则跳(机器码74 或0F84)</span><br><span class="line"></span><br><span class="line">jne或jnz 若不相等则跳(机器码75或0F85)</span><br><span class="line"></span><br><span class="line">jmp 无条件跳(机器码EB)</span><br><span class="line"></span><br><span class="line">jb 若小于则跳</span><br><span class="line"></span><br><span class="line">ja 无符-若大于则跳</span><br><span class="line"></span><br><span class="line">jg 有符-若大于则跳</span><br><span class="line"></span><br><span class="line">jge 若大于等于则跳</span><br><span class="line"></span><br><span class="line">jl 若小于则跳</span><br><span class="line"></span><br><span class="line">jle 若小于等于则跳</span><br><span class="line"></span><br><span class="line">pop 出栈</span><br><span class="line"></span><br><span class="line">push 压栈</span><br></pre></td></tr></table></figure><p>1.E语言在OD里面的入口特征（OEP）<br>E语言的入口其实和VC++基本差不多，所以 在OD里面Ctrl+B 输入 FF 25<br>​2.E语言的按钮事件<br>FF 55 FC 5F 5E，这个就是E语言的按钮在OD中的特征码，搜索它就直接可以找到按钮事件在OD的Call的位置<br>3.E语言常用断点</p><ul><li>MessageBoxA  消息框断点</li><li>ShellExecuteA&#x2F;W   WinExec    弹网页</li><li>CreateProcessA&#x2F;W  创建进程</li><li>ExitProcess       退出进程</li></ul><h4 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h4><p><a href="https://www.52pojie.cn/thread-1646466-1-1.html">练习笔记之手撕常见压缩壳 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.52pojie.cn/thread-1641368-1-1.html">关于压缩壳脱壳步骤详解！看这一篇足够。 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.cnblogs.com/hongren/p/12633232.html">ESP定律脱壳——NsPack3.x脱壳 - 红刃 - 博客园 (cnblogs.com)</a><br><a href="https://www.52pojie.cn/thread-941671-1-1.html">手脱NsPack 壳，新手看看</a><br>什么是壳：<br>壳是一种概念上的东西，人们为了保护软件不会被轻易的修改或者反编译，希望软件能够获得一种保护，能如同乌龟壳保护乌龟一般，能有一个东西保护自己，于是壳就出现了。<br>关于壳的作用：<br>壳的初始作用是保护软件，但后来发展的方向不一就出现了各种各样的壳，大致有压缩壳、加密壳、VM 壳的分类。压缩壳故名思意，主要作用是用于压缩方面，可以有效的减小软件的大小；加密壳，其主要作用是保护软件；VM 壳是一种很特殊的壳，它利用了虚拟机技术，可以很有效的保护指定地址代码，但很大的牺牲了效率，所以一般只在关键代码处使用。</p><p><strong>ESP定律法 （80%的压缩壳可脱）</strong><br>ESP 定律法是脱壳的利器，是应用频率最高的脱壳方法之一。ESP 定律的原理在于程序中堆栈平衡的合理利用。由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器内容压栈，如使用 pushad，在解压结束后，会将之前的寄存器值出栈，如使用 popad。因此在寄存器出栈时，往往程序代码被自动恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的 OEP 位置。</p><p>具体操作步骤：pushad开头，F8一次以后，8个寄存器只有ESP是红色时候，就可以使用该定律。<br>右键ESP 选择数据窗口跟随，数据窗口下硬件访问断点，F9运行，此时已经接近OEP。<br><img src="/img/Network-attack/pvz-shell.png"></p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>可以看到这个辅助的功能有很多，接下来就跟我一起解密这些按钮在点击后发生了什么。</p><blockquote><p>之前分析的时候一直没开游戏只对辅助od，结果破壳破了好久也没成功，但就算破壳也无法直接获取到源码，只能看汇编，破解还是要在游戏中去进行，辅助修改游戏的内存，只要对写内存操作打断点就可以观察具体的修改。踩了这样一个坑，希望引以为戒。</p></blockquote><p><img src="/img/Network-attack/PVZ-analysis-1.png"></p><h4 id="阳光修改"><a href="#阳光修改" class="headerlink" title="阳光修改"></a>阳光修改</h4><p>1.首先我们找出阳光的动态地址，找到之后我们双击这个地址，将其加入到地址列表中，阳光的查找技巧相信你已经能够掌握了，这里就不再罗嗦了。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718105016029-754750877.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718105016029-754750877.png" alt="img"></a></p><p>2.接着我们选择最下方的地址列表，然后按下<code>F6键</code>，也就是下一个硬件写入断点，然后回到游戏等待阳光出现并点击阳光，此时CE会出现以下代码，我们只需要记下<code>00430A11</code>这个内存地址，然后直接关闭CE吧，短期内用不到了。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718105234187-230098721.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718105234187-230098721.png" alt="img"></a></p><p>3.打开OD，然后我们直接附加植物大战僵尸的游戏进程，点击<code>文件</code>然后点击<code>附加</code>选择植物大战僵尸进程就好。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110121994-224028383.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110121994-224028383.png" alt="img"></a></p><p>4.附加完成后，我们的游戏会被OD暂停运行，此时我们直接按下<code>F12</code>让游戏正常的运行，默认情况下会停在系统领空，我们直接按下<code>Ctrl + G</code>输入<code>00401000</code>来到程序领空。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110558599-2081305956.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110558599-2081305956.png" alt="img"></a></p><p>5.接着我们按下<code>Ctrl + G</code>输入<code>00430A11</code>跳转到刚才找到的代码位置，过去以后直接<code>F2</code>下一个断点</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110754502-1706128416.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110754502-1706128416.png" alt="img"></a></p><p>6.紧接着我们回到游戏，然后等待阳光的出现，当阳光出现后我们点击阳光，OD会自动断在00430A11的位置，其中ecx就是要增加的阳光数。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718111426062-1841073246.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718111426062-1841073246.png" alt="img"></a></p><p>上图并没有CALL调用，应该是在外部，我们直接回朔到上一层<code>Ctrl+F9</code>执行到返回，<code>F8</code>直接出CALL.</p><p>7.我们在JNZ和CALL的两处位置下断点，然后运行程序，当我们点击阳光时会断在JNZ的位置，如果把JNZ用NOP填充的话，会发现当我们再次点击阳光的时候阳光会迅速的被回收没有了动画。</p><p>也就是说，JNZ如果成立的话则会有回收阳光的动画，当不成立的时候则会执行<code>call 004309d0</code>显然这就是回收阳光的关键CALL，但我们可猜测，再回收阳光的时候一定会判断是否回收，所以回收的判断应该在上一层。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718111754966-828351196.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718111754966-828351196.png" alt="img"></a></p><p>8.首先我们回到游戏，等待出现阳光然后点击阳光，OD会断下，断下后我们取消这两处的断点，然后跟着OD单步<code>F8</code>向下走，直接出这个CALL，出CALL后会看到如下代码，我们直接下三个断点。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718112814057-159772692.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718112814057-159772692.png" alt="img"></a></p><p>9.下好断点，回到游戏等待阳光下落我们回收，此时OD会断下，我们运行OD发现会一直被断在<code>0043158F</code>只要阳光没有收回就会一直断下，此处的跳转并没有实现，因为我们没有去点击阳光，这里可以得出如果点击了阳光JNZ则会跳转成立，否则不成立等待用户点击回收阳光。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718113135132-2026175107.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718113135132-2026175107.png" alt="img"></a></p><p>10.我们取消所有的断点，然后尝试把JNZ跳转改成JMP无条件跳转，让其只要一出现阳光就自动的触发回收的CALL试试。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718113425831-2135275106.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718113425831-2135275106.png" alt="img"></a></p><p>改完以后我们回到游戏，会发现只要阳光出现了会被立即回收。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718130615227-2143845712.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718130615227-2143845712.png" alt="img"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PVZ辅助&quot;&gt;&lt;a href=&quot;#PVZ辅助&quot; class=&quot;headerlink&quot; title=&quot;PVZ辅助&quot;&gt;&lt;/a&gt;PVZ辅助&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/follow-the-vine-to-get-to-the-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>外挂分析与实现</title>
    <link href="http://example.com/2023/10/19/net-attack&amp;defence-doc/%E5%A4%96%E6%8C%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/10/19/net-attack&amp;defence-doc/%E5%A4%96%E6%8C%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-10-19T00:39:59.000Z</published>
    <updated>2023-10-19T00:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PVZ辅助"><a href="#PVZ辅助" class="headerlink" title="PVZ辅助"></a>PVZ辅助</h2><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/tree/main">PlantsVsZombies-Cheat: 植物大战僵尸逆向分析与辅助开发系列教程(github.com)</a></p><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><h4 id="OnlyDbg使用"><a href="#OnlyDbg使用" class="headerlink" title="OnlyDbg使用"></a>OnlyDbg使用</h4><p><a href="https://www.bilibili.com/video/BV1cE411f7sE/?p=6&spm_id_from=pageDriver&vd_source=206a091077ff783d662b49e64cc9589d">06.常用断点之硬件断点原理解析_哔哩哔哩_bilibili</a></p><p><a href="https://www.cnblogs.com/xueyoo/articles/4938538.html">OllyDBG完美教程(超强入门级) - xueyoo - 博客园 (cnblogs.com)</a></p><p><strong>OllyDBG界面认识</strong><br><img src="/img/Network-attack/OB-desktop.png"></p><ul><li><p>反汇编窗口：显示被调试程序的反汇编代码。用鼠标左键点击注释标签可以切换注释显示的方式。如果需要修改代码，直接在这里在修改，比如“使用NOP填充”。</p></li><li><p>寄存器窗口：显示当前所选线程的CPU寄存器内容。点击标签寄存器(FPU)可以切换显示寄存器的方式。</p></li><li><p>信息窗口：显示反汇编窗口中当前选中的第一条命令的参数及一些跳转目标地址、字串等（一般动态加密解密字串等会在此出现）。</p></li><li><p>数据窗口：显示内存或文件的内容。直接点击ASCII数据可以切换编码显示方式。</p></li><li><p>堆栈窗口：显示当前线程的堆栈数据。比如程序初始化的一些常量、变量之类的数据。</p></li><li><p>菜单窗口：一些常用调试命令以及操作。一般把鼠标移到菜单窗口的某按钮后，界面最左下角会出现一些命令提示，比如单步步入（F7），单步步过F8，运行程序（F9）等。</p></li><li><p>命令行窗口：用来下断点等相关命令。</p></li></ul><p><strong>调试方法</strong></p><p><img src="/img/Network-attack/debug-shortcut-key.png"></p><p>F2：设置断点。只要在光标定位的位置（上图中灰色条）按F2键即可，再按一次F2键则会删除断点。（相当于 SoftICE 中的 F9）<br>F8：单步跳过。每按一次这个键执行一条反汇编窗口中的一条指令，遇到 CALL 等子程序不进入其代码。（相当于 SoftICE 中的 F10）<br>F7：单步步入。功能同单步步过(F8)类似，区别是遇到 CALL 等子程序时会进入其中，进入后首先会停留在子程序的第一条指令上。（相当于 SoftICE 中的 F8）<br>F4：运行到选定位置。作用就是直接运行到光标所在位置处暂停。（相当于 SoftICE 中的 F7）<br>F9：运行。按下这个键如果没有设置相应断点的话，被调试的程序将直接开始运行。（相当于 SoftICE 中的 F5）<br>CTR + F9：执行到返回。此命令在执行到一个 ret (返回指令)指令时暂停，常用于从系统领空返回到我们调试的程序领空。（相当于 SoftICE 中的 F12）<br>ALT + F9：执行到用户代码。可用于从系统领空快速返回到我们调试的程序领空。（相当于 SoftICE 中的 F11） </p><p><strong>常用断点</strong></p><p><a href="https://www.cnblogs.com/LyShark/p/13071792.html">Windows 下的常用调试API断点 - lyshark - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq1084283172/article/details/47733849">OD调试程序常用断点大全_od 创建进程 断点-CSDN博客</a></p><p>[<a href="https://cloud.tencent.com/developer/article/1910265">系统安全] 二十四.逆向分析之OD调试INT3断点、反调试、硬件断点与内存断点-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><strong>汇编指令</strong></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cmp a,b 比较a与b</span><br><span class="line"></span><br><span class="line">mov a,b 把b的值送给a</span><br><span class="line"></span><br><span class="line">ret 返回主程序</span><br><span class="line"></span><br><span class="line">nop 无作用,英文“no operation”的简写，意思是“do nothing”(机器码90)</span><br><span class="line">(解释:ultraedit打开编辑exe文件时你看到90,等同于汇编语句nop)</span><br><span class="line"></span><br><span class="line">call 调用子程序</span><br><span class="line"></span><br><span class="line">je 或jz 若相等则跳(机器码74 或0F84)</span><br><span class="line"></span><br><span class="line">jne或jnz 若不相等则跳(机器码75或0F85)</span><br><span class="line"></span><br><span class="line">jmp 无条件跳(机器码EB)</span><br><span class="line"></span><br><span class="line">jb 若小于则跳</span><br><span class="line"></span><br><span class="line">ja 无符-若大于则跳</span><br><span class="line"></span><br><span class="line">jg 有符-若大于则跳</span><br><span class="line"></span><br><span class="line">jge 若大于等于则跳</span><br><span class="line"></span><br><span class="line">jl 若小于则跳</span><br><span class="line"></span><br><span class="line">jle 若小于等于则跳</span><br><span class="line"></span><br><span class="line">pop 出栈</span><br><span class="line"></span><br><span class="line">push 压栈</span><br></pre></td></tr></table></figure><p>1.E语言在OD里面的入口特征（OEP）<br>E语言的入口其实和VC++基本差不多，所以 在OD里面Ctrl+B 输入 FF 25<br>​2.E语言的按钮事件<br>FF 55 FC 5F 5E，这个就是E语言的按钮在OD中的特征码，搜索它就直接可以找到按钮事件在OD的Call的位置<br>3.E语言常用断点</p><ul><li>MessageBoxA  消息框断点</li><li>ShellExecuteA&#x2F;W   WinExec    弹网页</li><li>CreateProcessA&#x2F;W  创建进程</li><li>ExitProcess       退出进程</li></ul><h4 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h4><p><a href="https://www.52pojie.cn/thread-1646466-1-1.html">练习笔记之手撕常见压缩壳 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.52pojie.cn/thread-1641368-1-1.html">关于压缩壳脱壳步骤详解！看这一篇足够。 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.cnblogs.com/hongren/p/12633232.html">ESP定律脱壳——NsPack3.x脱壳 - 红刃 - 博客园 (cnblogs.com)</a><br><a href="https://www.52pojie.cn/thread-941671-1-1.html">手脱NsPack 壳，新手看看</a><br>什么是壳：<br>壳是一种概念上的东西，人们为了保护软件不会被轻易的修改或者反编译，希望软件能够获得一种保护，能如同乌龟壳保护乌龟一般，能有一个东西保护自己，于是壳就出现了。<br>关于壳的作用：<br>壳的初始作用是保护软件，但后来发展的方向不一就出现了各种各样的壳，大致有压缩壳、加密壳、VM 壳的分类。压缩壳故名思意，主要作用是用于压缩方面，可以有效的减小软件的大小；加密壳，其主要作用是保护软件；VM 壳是一种很特殊的壳，它利用了虚拟机技术，可以很有效的保护指定地址代码，但很大的牺牲了效率，所以一般只在关键代码处使用。</p><p><strong>ESP定律法 （80%的压缩壳可脱）</strong><br>ESP 定律法是脱壳的利器，是应用频率最高的脱壳方法之一。ESP 定律的原理在于程序中堆栈平衡的合理利用。由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器内容压栈，如使用 pushad，在解压结束后，会将之前的寄存器值出栈，如使用 popad。因此在寄存器出栈时，往往程序代码被自动恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的 OEP 位置。</p><p>具体操作步骤：pushad开头，F8一次以后，8个寄存器只有ESP是红色时候，就可以使用该定律。<br>右键ESP 选择数据窗口跟随，数据窗口下硬件访问断点，F9运行，此时已经接近OEP。<br><img src="/img/Network-attack/pvz-shell.png"></p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>可以看到这个辅助的功能有很多，接下来就跟我一起解密这些按钮在点击后发生了什么。</p><blockquote><p>之前分析的时候一直没开游戏只对辅助od，结果破壳破了好久也没成功，但就算破壳也无法直接获取到源码，只能看汇编，破解还是要在游戏中去进行，辅助修改游戏的内存，只要对写内存操作打断点就可以观察具体的修改。踩了这样一个坑，希望引以为戒。</p></blockquote><p><img src="/img/Network-attack/PVZ-analysis-1.png"></p><h4 id="阳光修改"><a href="#阳光修改" class="headerlink" title="阳光修改"></a>阳光修改</h4><p>1.首先我们找出阳光的动态地址，找到之后我们双击这个地址，将其加入到地址列表中，阳光的查找技巧相信你已经能够掌握了，这里就不再罗嗦了。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718105016029-754750877.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718105016029-754750877.png" alt="img"></a></p><p>2.接着我们选择最下方的地址列表，然后按下<code>F6键</code>，也就是下一个硬件写入断点，然后回到游戏等待阳光出现并点击阳光，此时CE会出现以下代码，我们只需要记下<code>00430A11</code>这个内存地址，然后直接关闭CE吧，短期内用不到了。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718105234187-230098721.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718105234187-230098721.png" alt="img"></a></p><p>3.打开OD，然后我们直接附加植物大战僵尸的游戏进程，点击<code>文件</code>然后点击<code>附加</code>选择植物大战僵尸进程就好。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110121994-224028383.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110121994-224028383.png" alt="img"></a></p><p>4.附加完成后，我们的游戏会被OD暂停运行，此时我们直接按下<code>F12</code>让游戏正常的运行，默认情况下会停在系统领空，我们直接按下<code>Ctrl + G</code>输入<code>00401000</code>来到程序领空。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110558599-2081305956.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110558599-2081305956.png" alt="img"></a></p><p>5.接着我们按下<code>Ctrl + G</code>输入<code>00430A11</code>跳转到刚才找到的代码位置，过去以后直接<code>F2</code>下一个断点</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110754502-1706128416.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110754502-1706128416.png" alt="img"></a></p><p>6.紧接着我们回到游戏，然后等待阳光的出现，当阳光出现后我们点击阳光，OD会自动断在00430A11的位置，其中ecx就是要增加的阳光数。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718111426062-1841073246.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718111426062-1841073246.png" alt="img"></a></p><p>上图并没有CALL调用，应该是在外部，我们直接回朔到上一层<code>Ctrl+F9</code>执行到返回，<code>F8</code>直接出CALL.</p><p>7.我们在JNZ和CALL的两处位置下断点，然后运行程序，当我们点击阳光时会断在JNZ的位置，如果把JNZ用NOP填充的话，会发现当我们再次点击阳光的时候阳光会迅速的被回收没有了动画。</p><p>也就是说，JNZ如果成立的话则会有回收阳光的动画，当不成立的时候则会执行<code>call 004309d0</code>显然这就是回收阳光的关键CALL，但我们可猜测，再回收阳光的时候一定会判断是否回收，所以回收的判断应该在上一层。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718111754966-828351196.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718111754966-828351196.png" alt="img"></a></p><p>8.首先我们回到游戏，等待出现阳光然后点击阳光，OD会断下，断下后我们取消这两处的断点，然后跟着OD单步<code>F8</code>向下走，直接出这个CALL，出CALL后会看到如下代码，我们直接下三个断点。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718112814057-159772692.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718112814057-159772692.png" alt="img"></a></p><p>9.下好断点，回到游戏等待阳光下落我们回收，此时OD会断下，我们运行OD发现会一直被断在<code>0043158F</code>只要阳光没有收回就会一直断下，此处的跳转并没有实现，因为我们没有去点击阳光，这里可以得出如果点击了阳光JNZ则会跳转成立，否则不成立等待用户点击回收阳光。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718113135132-2026175107.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718113135132-2026175107.png" alt="img"></a></p><p>10.我们取消所有的断点，然后尝试把JNZ跳转改成JMP无条件跳转，让其只要一出现阳光就自动的触发回收的CALL试试。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718113425831-2135275106.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718113425831-2135275106.png" alt="img"></a></p><p>改完以后我们回到游戏，会发现只要阳光出现了会被立即回收。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718130615227-2143845712.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718130615227-2143845712.png" alt="img"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PVZ辅助&quot;&gt;&lt;a href=&quot;#PVZ辅助&quot; class=&quot;headerlink&quot; title=&quot;PVZ辅助&quot;&gt;&lt;/a&gt;PVZ辅助&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/follow-the-vine-to-get-to-the-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络攻防实验</title>
    <link href="http://example.com/2023/10/18/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2023/10/18/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-10-18T09:26:59.000Z</published>
    <updated>2023-10-18T09:26:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络扫描"><a href="#网络扫描" class="headerlink" title="网络扫描"></a>网络扫描</h3><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 7</span><br><span class="line">连接本机7号端口</span><br><span class="line">netstat -na | more</span><br><span class="line">查看本机提供的服务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ls /bin /usr/bin |wc</span><br><span class="line">linux 命令查看</span><br></pre></td></tr></table></figure><p>telnet service:</p><p>控制面板——程序——启动或关闭windows功能——勾上telnet client</p><p>简单TCP&#x2F;IP service：</p><p>控制面板——程序——启动或关闭windows功能——勾上 simple TCP&#x2F;IP service</p><p> (1)Echo<br>   RFC862 端口 7<br>   回显在该服务器端口上接收到的任何消息中的数据。<br>   作为网络调试和监视工具可能非常有用。<br> (2)Discard<br>   RFC863 端口 9<br>   放弃该端口上接收到的所有消息，而不响应或确认。<br>   在网络设置和配置过程中，可以用作空端口来接收和路由 TCP&#x2F;IP 测试消息，或者在某些情况下，程序可将其用作为消息放弃函数。<br> (3)Character Generator<br>   RFC864 端口 19<br>   所发送数据包含一组 95 个可打印的 ASCII 字符。<br>   作为测试或解决行打印机问题的调试工具非常有用。<br> (4)Quote of the Day<br>   RFC865 端口 17<br>   在消息中以一行或多行文本的形式返回报价。<br>   报价从以下文件中随机提取：%SYSTEMROOT%\System32\Drivers\Etc\Quotes。<br>   示例报价文件会与简单的 TCP&#x2F;IP 服务一起安装。如果该文件丢失，则报价服务会失败。<br> (5)Daytime<br>   RFC867 端口 13<br>   返回包含星期几、月、天、年、当前时间（以 hh:mm:ss 格式表示）和时区信息的消息。<br>   某些程序可能会将该服务的输出用于调试或监视系统时钟时间中或不同主机上的变化。</p><p><strong>ntop</strong>服务</p><p>nmap script 漏洞 heartbleed </p><p>TCP keep-alive 删除死连接</p><p><a href="https://cloud.tencent.com/developer/article/2104021">心脏出血（Heartbleed）漏洞浅析、复现-腾讯云开发者社区-腾讯云 (tencent.com)</a> </p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">telnet 211.87.227.229 4433    </span><br><span class="line">git服务器</span><br><span class="line">127.28.11.31</span><br><span class="line">靶机服务器</span><br></pre></td></tr></table></figure><h2 id="FAKE-WIFI实验"><a href="#FAKE-WIFI实验" class="headerlink" title="FAKE-WIFI实验"></a>FAKE-WIFI实验</h2><p>无线网卡还在路上~</p><p>2023.10.23 更新<br>1.1. 建立wifi热点<br>使用一个usb无线网卡，可以建立一个WIFI热点。</p><p>安装驱动：<a href="https://wkqd.lanzouu.com/s/wkqd">https://wkqd.lanzouu.com/s/wkqd</a></p><blockquote><p>目前状况：第一步就卡住了，网卡不支持承载网络。</p><p>看了几个贴子，给出的方法包括但不限于：1.更新驱动。2.开启“移动热点”功能，新的网卡驱动不再支持使用托管网络，而这也是许多教程要求使用旧版本驱动的原因。3.[在 Windows 中设置无线网络 - Microsoft 支持](<a href="https://support.microsoft.com/zh-cn/windows/%E5%9C%A8-windows-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C-97914e31-3aa4-406d-cef6-f1629e2c3721#:~:text=%E5%9C%A8Windows">https://support.microsoft.com/zh-cn/windows/在-windows-中设置无线网络-97914e31-3aa4-406d-cef6-f1629e2c3721#:~:text=在Windows</a> 10 中 ，选择 “开始”，然后选择”设置&gt; Internet %26”&gt;”状态&gt;”网络和共享中心”。,在Windows 11 中，选择”开始”，键入”控制面板”，然后选择”控制面板”&gt;”网络和 Internet&gt;”网络和共享中心”。 选择“设置新的连接或网络”。 选择“设置新网络”，然后选择“下一步”。 该向导将指导你创建网络名称和安全密钥。)</p><p>未能解决问题，可能是网卡本身就不支持，白折腾半天，问商家也不回消息，踩坑(T_T)</p></blockquote><p>Windows&#x2F;CMD中，配合两行命令(管理员权限)：<br>netsh wlan set hostednetwork mode&#x3D;allow<br>netsh wlan set hostednetwork mode&#x3D;allow ssid&#x3D;fake1 key&#x3D;12345678<br>netsh wlan start hostednetwork<br>如此设置后，手机即可通过该热点“fake1”上网了。<br>其他有用的命令：<br>netsh wlan stop hostednetwork  # 停止<br>NETSH WLAN show drivers  #显示参数等</p><p><img src="/img/Network-attack/fake-wifi-1.png"></p><p>1.2. 加入dns欺骗</p><h2 id="课程项目1：网络攻防安全扫描集成平台"><a href="#课程项目1：网络攻防安全扫描集成平台" class="headerlink" title="课程项目1：网络攻防安全扫描集成平台"></a>课程项目1：网络攻防安全扫描集成平台</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.   介绍"></a>1.   介绍</h3><p>进行网络安全扫描，和对文件系统进行杀毒扫描一样，杀毒扫描需要病毒特征库，网络安全扫描需要漏洞攻击库，而且这些库都在各自更新，除了可以自由使用的版本，有的还有昂贵的商业版本。因此，仅用一款扫描工具是不够的，要尽量多找不同的工具、使用不同来源的漏洞攻击库。因此，需要建立一个综合各种扫描工具、支持多种漏洞攻击库的集成系统，服务于生产，也可以服务教学需求。</p><h3 id="2-扫描工具"><a href="#2-扫描工具" class="headerlink" title="2.   扫描工具"></a>2.   扫描工具</h3><p>根据不同的目的、功能、用途，网络安全方面的扫描器可以分为很多种。</p><p>下面是几款漏洞扫描软件的介绍、试用以及实测结果，包括nmap、nessus、Metasploit、OpenVAS、W3AF等。</p><h4 id="I-Nmap-org"><a href="#I-Nmap-org" class="headerlink" title="I. Nmap.org"></a>I. <a href="https://nmap.org/">Nmap.org</a></h4><p><a href="https://blog.csdn.net/m0_46588765/article/details/107417808">nmap扫描与tcpdump抓包工具_nmap是抓包工具的吗-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_43510203/article/details/107596158">Nmap端口扫描+Nmap脚本扫描漏洞（学习笔记）_nmap漏洞扫描分析脚本文件-CSDN博客</a></p><p><a href="https://www.cnblogs.com/rtnb/p/15595210.html">tcpdump抓包与nmap扫描 - 不会跳舞的胖子 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/day0713/article/details/123171655">网络攻防技术——端口扫描_2)对本机(关闭防火墙)的开放端口和非开放端口完成半连接、ack、fin、null、xmas、_啦啦啦啦啦啦啦噜噜的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_51459513/article/details/117263932">网络攻防之网络扫描_unicornscan_程序猿cxy的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/smli_ng/article/details/105964486">nmap详细参数 -CSDN博客</a></p><p>Nmap是开放开源的，比较小巧，用法简单而直接，尤其适合对大IP范围内的主机进行初步扫描以确定重点攻击目标，因此是入侵者最常用的前期预扫描工具。<a href="http://nmap.org/">http://nmap.org/</a> </p><p>端口扫描是<a href="https://so.csdn.net/so/search?q=Nmap&spm=1001.2101.3001.7020">Nmap</a>最基本最核心的功能，用于确定目标主机的TCP&#x2F;UDP端口的开放情况。 默认情况下，Nmap会扫描<strong>1000</strong>个最有可能开放的TCP端口。</p><p>利用nmap能测试和发现：</p><ul><li>目标主机（IP）是否开机，安装了什么操作系统，有哪些端口开着，是什么服务，哪种服务程序，什么版本；</li><li>能规避防火墙的防护规则，能根据脚本自动、批量的扫描有哪些漏洞；</li></ul><p>Nmap具体功能：端口扫描，协议扫描，漏洞扫描，绕过防护，漏洞利用等。</p><h5 id="nmap测试"><a href="#nmap测试" class="headerlink" title="nmap测试"></a>nmap测试</h5><p>nmap的基本用法:</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 【扫描类型】 【选项】 【扫描目标…】</span><br></pre></td></tr></table></figure><p>常用的扫描类型：</p><ul><li>-sS ：TCP，SYN扫描(半开) 半开扫描意思就是，客户端向服务器请求连接，当服务器给与回应时，客户端又不响应服务器。这就是典型的DDOS攻击</li><li>-sT ： TCP连接扫描(全开) 全开扫描表示执行完三次握手</li><li>-sU ： UDP扫描</li><li>-sP： ICMP扫描</li><li>-A ：目标系统全面分析</li></ul><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 默认TCP扫描</span><br><span class="line">$ nmap 10.27.214.21</span><br><span class="line">Starting Nmap 7.94 ( https://nmap.org ) at 2023-10-18 11:52 EDT</span><br><span class="line">Nmap scan report for 10.27.214.21</span><br><span class="line">Host is up (0.0096s latency).</span><br><span class="line">Not shown: 993 filtered tcp ports (no-response)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">25/tcp   open  smtp</span><br><span class="line">110/tcp  open  pop3</span><br><span class="line">135/tcp  open  msrpc</span><br><span class="line">139/tcp  open  netbios-ssn</span><br><span class="line">445/tcp  open  microsoft-ds</span><br><span class="line">912/tcp  open  apex-mesh</span><br><span class="line">3306/tcp open  mysql</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#扫描本机开了什么端口，默认TCP扫描</span><br><span class="line">$ nmap 127.0.0.1   </span><br><span class="line">Starting Nmap 7.94 ( https://nmap.org ) at 2023-10-18 12:03 EDT</span><br><span class="line">Nmap scan report for localhost (127.0.0.1)</span><br><span class="line">Host is up (0.000025s latency).</span><br><span class="line">All 1000 scanned ports on localhost (127.0.0.1) are in ignored states.</span><br><span class="line">Not shown: 1000 closed tcp ports (reset)                     </span><br></pre></td></tr></table></figure><ul><li><p><input disabled="" type="checkbox"> 为什么扫描结果不一致？</p></li><li><p><input disabled="" type="checkbox"> ipconfig的结果</p></li><li><p><input disabled="" type="checkbox"> eth0</p></li></ul><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**抓取指定协议的数据包**</span><br><span class="line">#另外打开一个虚拟机ping host50主机</span><br><span class="line">$ ping -c 1 192.168.4.50</span><br><span class="line">PING 192.168.4.50 (192.168.4.50) 56(84) bytes of data.</span><br><span class="line"> </span><br><span class="line">--- 192.168.4.50 ping statistics ---</span><br><span class="line">1 packets transmitted, 0 received, 100% packet loss, time 0ms</span><br><span class="line"></span><br><span class="line">#这时host 50主机就可以抓到相应的ping包</span><br><span class="line">#抓取经过eth0上的数据包</span><br><span class="line">$ tcpdump  -i eth0 icmp</span><br><span class="line">tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">12:13:19.839665 IP 192.168.122.129 &gt; 192.168.4.50: ICMP echo request, id 53883, seq 1, length 64</span><br><span class="line"></span><br><span class="line">#node2为源地址，host50为目标地址</span><br><span class="line">IP [host50] &gt; [node2]: ICMP echo [request], id [7227], seq [1], length [64]</span><br></pre></td></tr></table></figure><p><img src="/img/Network-attack/tcpdump-use-1.png"></p><p>Nmap端口扫描<br>端口状态：</p><p>1、Open：端口开启，有程序监听此端口</p><p>2、Closed：端口关闭，数据能到达主机，但是没有程序监听此端口</p><p>3、Filtered：数据未能到达主机</p><p>4、Unfiltered：数据能到达主机，但是Nmap无法判断端口开启还是关闭</p><p>5、Open | filtered：端口没返回值，主要出现在UDP，IP，FIN，NULL和Xmas扫描</p><p>6、Closed | filtered：只出现在IP ID idle 扫描</p><p>单个扫描：nmap xxx.xxx.xxx.xxx</p><p>多个扫描：nmap 192.168.1.1 192.168.1.2</p><p>网段扫描：nmap 192.168.2.1-192.168.2.100</p><p>导入扫描：nmap -iL [LIST.TXT]</p><p><strong>nmap的扫描脚本</strong></p><p>nmap提供了大量不同种类的脚本，方便不同的用途。按照不同的主题分类主要有：</p><p>  auth: 负责处理鉴权证书（绕开鉴权）的脚本<br>  broadcast: 在局域网内探查更多服务开启状况，如dhcp&#x2F;dns&#x2F;sqlserver等服务<br>  brute: 提供暴力破解方式，针对常见的应用如http&#x2F;snmp等<br>  default:  使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力<br>  discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等<br>  dos: 用于进行拒绝服务攻击<br>  exploit: 利用已知的漏洞入侵系统<br>  external: 利用第三方的数据库或资源，例如进行whois解析<br>  fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞<br>  intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS&#x2F;IPS的记录或屏蔽<br>  malware: 探测目标机是否感染了病毒、开启了后门等信息<br>  safe: 此类与intrusive相反，属于安全性脚本<br>  version: 负责增强服务与版本扫描（Version Detection）功能的脚本<br>  vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067  </p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#默认脚本扫描，主要搜索各种应用服务的信息，收集后，可再针对具体服务进行攻击</span><br><span class="line">nmap --script=default 192.168.88.131</span><br><span class="line"></span><br><span class="line">#检查是否存在常见漏洞</span><br><span class="line">nmap --script=vuln 192.168.1.104</span><br><span class="line"></span><br><span class="line">#提供暴力破解的方式，可对数据库、smb、snmp等进行简单密码的暴力猜解</span><br><span class="line">nmap --script=brute 192.168.88.131</span><br><span class="line"></span><br><span class="line">#利用FTP指定脚本对目标特定FTP协议进行密码爆破</span><br><span class="line">nmap --script=ftp-brute.nse 192.168.88.131</span><br><span class="line"></span><br><span class="line">#利用第三方的数据库或资源，例如进行whoise解析</span><br><span class="line">nmap --script=external 192.168.88.131</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="nmap脚本"><a href="#nmap脚本" class="headerlink" title="nmap脚本"></a>nmap脚本</h5><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat ping.sh </span><br><span class="line">#!/bin/bash</span><br><span class="line">yum -y install nmap &gt; /dev/null</span><br><span class="line">read -p &quot;输入整个网段例如104.233.105.0/24：&quot; ip</span><br><span class="line">nmap -n -sP $ip  &gt; /root/ping.test  # -n表示不做主机名解析</span><br><span class="line">num=$(cat /root/ping.test | tail -1 | awk &#x27;&#123;print $3&#125;&#x27;)</span><br><span class="line">setup=$(cat /root/ping.test | tail -1 | awk &#x27;&#123;print $6&#125;&#x27;)</span><br><span class="line">echo &quot;扫描到$num个IP&quot;</span><br><span class="line">echo &quot;有$setup个可以通信&quot;</span><br><span class="line">rm -rf /root/ping.test</span><br></pre></td></tr></table></figure><h5 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h5><p><strong>ipconfig</strong> </p><blockquote><p>ipconfig &#x2F;all：显示本机TCP&#x2F;IP配置的详细信息；<br>ipconfig &#x2F;release：DHCP客户端手工释放IP地址；<br>ipconfig &#x2F;renew：DHCP客户端手工向服务器刷新请求；<br>ipconfig &#x2F;flushdns：清除本地DNS缓存内容；<br>ipconfig &#x2F;displaydns：显示本地DNS内容；<br>ipconfig &#x2F;registerdns：DNS客户端手工向服务器进行注册；<br>ipconfig &#x2F;showclassid：显示网络适配器的DHCP类别信息；<br>ipconfig &#x2F;setclassid：设置网络适配器的DHCP类别。<br>ipconfig &#x2F;renew “Local Area Connection”：更新“本地连接”适配器的由 DHCP 分配 IP 地址的配置<br>ipconfig &#x2F;showclassid Local*：显示名称以 Local 开头的所有适配器的 DHCP 类别 ID<br>ipconfig &#x2F;setclassid “Local Area Connection” TEST：将“本地连接”适配器的 DHCP 类别 ID 设置为 TEST</p></blockquote><figure class="highlight bash"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示所有当前的 TCP/IP 网络配置值，并刷新动态主机配置协议 (DHCP) 和域名系统 (DNS) 设置。 在没有参数的情况下使用时，ipconfig 会显示 Internet 协议版本 4 (IPv4) 和 IPv6 地址、子网掩码以及所有适配器的默认网关。</span></span><br><span class="line">&gt; ipconfig </span><br><span class="line">无线局域网适配器 WLAN:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::8aa0:535b:4042:fe90%8</span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : 10.27.214.21</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : 255.255.192.0</span><br><span class="line">   默认网关. . . . . . . . . . . . . : 10.27.255.254</span><br></pre></td></tr></table></figure><p><strong>tcpdump</strong></p><p><strong>语法：</strong></p><figure class="highlight text"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tcpdump [ -AdDefIJKlLnNOpqRStuUvxX ] [ -B buffer_size ] [ -c count ]</span><br><span class="line">               [ -C file_size ] [ -G rotate_seconds ] [ -F file ]</span><br><span class="line">               [ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M secret ]</span><br><span class="line">               [ -Q|-P in|out|inout ]</span><br><span class="line">               [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]</span><br><span class="line">               [ -W filecount ]</span><br><span class="line">               [ -E spi@ipaddr algo:secret,...  ]</span><br><span class="line">               [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ]</span><br><span class="line">               [ expression ]</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><p>-c 在收到指定的数量的分组后，tcpdump就会停止<br>-i 指定监听的网络接口<br>-r 从指定的文件中读取包(这些包一般通过-w选项产生)。<br>-w 直接将分组写入文件中，而不是不分析并打印出来。</p><p><strong>过滤条件：</strong><br>类型：host、net、port、portange<br>方向：src、dst<br>协议：tcp、dup、ip、wlan、arp…<br>多条件组合：and、or、not…</p><p><strong>示例：</strong></p><figure class="highlight text"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 无参数：抓取所有网络包，并在`terminal`中显示抓取的结果，将包以十六进制的形式显示。</span><br><span class="line">tcpdump</span><br></pre></td></tr></table></figure><figure class="highlight text"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 抓取所有的经过`eth0`网卡的网络包</span><br><span class="line">tcpdump -i eth0 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 想要截获所有192.168.1.100的主机收到的和发出的所有的数据包：</span><br><span class="line">tcpdump host 192.168.1.100</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 抓取经过 eth0 网卡的源 ip 是 192.168.1.100 数据包，src参数表示源。</span><br><span class="line">tcpdump -i eth0 -vnn src host 192.168.1.100</span><br><span class="line"></span><br><span class="line"># 抓取经过 eth0 网卡目的 ip 是 192.168.1.100 数据包，dst参数表示目的。</span><br><span class="line">tcpdump -i eth0 -vnn dst host 192.168.1.100</span><br></pre></td></tr></table></figure><h4 id="II-vuls"><a href="#II-vuls" class="headerlink" title="II. vuls"></a>II. vuls</h4><p><a href="https://github.com/future-architect/vuls">vuls - github</a></p><h4 id="III．legion"><a href="#III．legion" class="headerlink" title="III．legion"></a>III．legion</h4><p><strong>介绍</strong><br><a href="https://govanguard.com/legion">legoin 官网</a><br><a href="https://github.com/GoVanguard/legion">GitHub项目地址</a><br>Legion是SECFORCE的Sparta的分支，是一个开源，易于使用，超扩展和半自动化的网络渗透测试框架，针对发现，侦察和利用漏洞的信息系统。 Legion由GoVanguard开发和维护。</p><h5 id="legoin-测试"><a href="#legoin-测试" class="headerlink" title="legoin 测试"></a>legoin 测试</h5><p><strong>安装与使用</strong><br>kali取消了自带的Sparta而是改为legion，kali下的安装会方便的多；除此之外也可以尝试docker安装。kali终端直接输入legion即可启动。</p><p>填写的目标可为ip、可为网段、也可为域。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.0/24</span><br><span class="line">10.10.10.10-20</span><br><span class="line">1.2.3.4</span><br><span class="line">bing.com</span><br></pre></td></tr></table></figure><p><img src="/img/Network-attack/legoin-use-1.png"></p><h3 id="3-Docker打包"><a href="#3-Docker打包" class="headerlink" title="3.Docker打包"></a>3.Docker打包</h3><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html">Go 语言</a> 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络扫描&quot;&gt;&lt;a href=&quot;#网络扫描&quot; class=&quot;headerlink&quot; title=&quot;网络扫描&quot;&gt;&lt;/a&gt;网络扫描&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;input class=&quot;btn-copy&quot; type=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CTF - 网络安全夺旗赛</title>
    <link href="http://example.com/2023/10/18/CTF-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%BA%E6%97%97%E8%B5%9B/"/>
    <id>http://example.com/2023/10/18/CTF-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%BA%E6%97%97%E8%B5%9B/</id>
    <published>2023-10-17T16:11:10.000Z</published>
    <updated>2023-10-17T16:11:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><p><a href="https://zhuanlan.zhihu.com/p/631613398">2023最全CTF入门指南（建议收藏） - 知乎 (zhihu.com)</a></p><p>CTF在线练习场:<br><a href="https://zhuanlan.zhihu.com/p/407953508">https://zhuanlan.zhihu.com/p/407953508</a></p><p>【1】萌新_密码1<br>密文：<br>53316C6B5A6A42684D3256695A44566A4E47526A4D5459774C5556375A6D49324D32566C4D4449354F4749345A6A526B4F48303D<br>提交格式：KEY{XXXXXXXXXXXXXX}</p><p><strong>[WriteUp]</strong><br>hex-&gt;字符串-&gt;base64解密-&gt;栅栏解密<br>分析题目，密文看起来符合16进制特征，所以先尝试Hex decode 得到</p><blockquote><p>S1lkZjBhM2ViZDVjNGRjMTYwLUV7ZmI2M2VlMDI5OGI4ZjRkOH0&#x3D;</p></blockquote><p>有点像Base64加密特征，我们尝试Base64 decode发现</p><blockquote><p>KYdf0a3ebd5c4dc160-E{fb63ee0298b8f4d8}</p></blockquote><p>然后再使用对方提供的tool工具箱中的<em>栅栏密码加解密1.10</em>解码,将数据填进去，发现栏数只有两个选择：2和19。</p><p>我们从2栏开始解密得</p><blockquote><p>KEY{dffb06a33eeeb0d259c84bd8cf146d08-} 符合提交格式</p></blockquote><p>再试试19栏</p><blockquote><p>Kd03b54c6-{b3e28848Yfaedcd10Ef6e09bfd}</p></blockquote><p>【3】萌新_密码2<br>出题人已累，随便敲了几下键盘。。。 rdcvbg 2qase3 6tghu7</p><p><strong>[WriteUp]</strong><br>观察这三组字符串在键盘上的排列，能够发现规律这三组每一组都围绕着一个字符，得到flag{fwy}<br>【4】萌新 密码3<br>题目名称：我想吃培根<br>题目描述： – — .-. … . ..–.- .. … ..–.- -.-. — — .-.. ..–.- -… ..- - ..–.- -… .- -.-. — -. ..–.- .. … ..–.- -.-. — — .-.. . .-. ..–.- – – -.. -.. – -.. – -.. – – – -.. -.. -.. &#x2F;– -.. – -.. -.. –&#x2F; – – – – – &#x2F;– -.. -.. – -.. – &#x2F;– -.. -.. –<br>格式：flag{***********}<br><strong>[WriteUp]</strong><br>解题思路</p><p>首先题目中最先出现的是 – — .-. … . .，这样的内容，判断为摩斯电码</p><p>通过对摩斯电码进行解密，获得:</p><blockquote><p>MORSE_IS_COOL_BUT_BACON_IS_COOLER_MMDDMDMDMMMDDDMDMDDMMMMMMMDDMDMMDDM</p></blockquote><p>结合题目中出现的培根，可以了解到存在培根密码这样的一种加密方式。即将a-z，加密成AB两种组合，类似与二进制。</p><p>这里摘出MMDDMDMDMMMDDDMDMDDMMMMMMMDDMDMMDDM，将其转换成AB</p><p>AABBABABAAABBBABABBAAAAAAABBABAABBA ，对其进行培根解码可得</p><p>GUOWANG<br>【4】萌新 密码4<br>QW8obWdIWF5FKUFSQW5URihKXWZAJmx0OzYiLg&#x3D;&#x3D;<br>提示：比base64还大的base<br><strong>[WriteUp]</strong></p><p>密文一看就是base系列，而且提示里面也说明了base64，那么从base64解码看看得到如下：</p><blockquote><p>Ao(mgHX^E)ARAnTF(J]f@&lt;6”.</p></blockquote><p>这个显然不是flag，仍然需要解，那么比base64大的就是base85了</p><p>利用base85在线工具解除一下</p><p>发现一个很有意思的状况</p><blockquote><p><a href="http://www.atoolbox.net/Tool.php?Id=934">http://www.atoolbox.net/Tool.php?Id=934</a> 这个得出flag{base_base_b</p></blockquote><blockquote><p><a href="https://ctf.bugku.com/tool/base85">https://ctf.bugku.com/tool/base85</a> 这个显示Server Error</p></blockquote><blockquote><p><a href="https://try8.cn/tool/code/base85">https://try8.cn/tool/code/base85</a> 这个显示乱码�����fg���%��g�</p></blockquote><blockquote><p><a href="http://www.hiencode.com/base85.html">http://www.hiencode.com/base85.html</a> 这个显示解码失败</p></blockquote><blockquote><p><a href="https://gongjumi.com/encrypt/ascii85">https://gongjumi.com/encrypt/ascii85</a> 这个显示flag{base_base_b&#96;�LlAa（用RWA解码，其他解码标准要么没反应，要么乱码）</p></blockquote><blockquote><p><a href="https://www.rfctools.com/base85-decoder/">https://www.rfctools.com/base85-decoder/</a> 这个显示flag{base_base_b&#96;獿lAa</p></blockquote><p>总之我查到的base85解码网站，解码出来的状况千奇百怪，可能解码时用的编号标准是不一样的？所以查到最后，我用第一个的flag{base_base_b，来推测一下，看看后面是不是base，结果被我试出来了，但还是感觉一头雾水，于是又看了别人的WP，又从百度和谷歌找了很多资料，下面说一下对这道题的想法</p><p>说是Ao(mgHX^E)ARAnTF(J]f@&lt;6”.里面的【&lt;】是一个HTML字符实体，表示小于号【&lt;】，为什么不直接用&lt;来表示呢，因为如果直接用&lt;游览器会误以为这是一个HTML标签,而不是小于号。</p><p>于是我尝试将从base64解出来的字符串放到一个TXT文件并把它转换成HTML格式，通过游览器打开后，它显示了一个正确的可完整的被base85解码出来的字符串。</p><p>Ao(mgHX^E)ARAnTF(J]f@&lt;6”.</p><p>尝试放到上面的列出的各项base85解码网站，很神奇的是有些依然乱码，但大部分是可被正确解码出来的，我想可能是因为字符集用的不一样吧？</p><p>flag{base_base_base}</p><p>【5】萌新 密码5<br>小明心爱的图片在压缩包中，可是小明夜深人静的时候，孤枕难眠，想打开图片排遣寂寞，可是忘记了密码了，小米依稀记得9位的密码都是数字，前3位是372，你能帮助小明吗？</p><p>格式：flag{372XXXXXX}<br><strong>[WriteUp]</strong></p><p>已知总位数是9，同时已知全为数字，且前三位已经给出，暴力破解在十万-百万层级，时间不会很长，使用作者提供的工具，在攻击类型栏里选择掩码，并在暴力范围选项中只选择所有数字，在掩码框中写入“372??????”，进行破解即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CTF&quot;&gt;&lt;a href=&quot;#CTF&quot; class=&quot;headerlink&quot; title=&quot;CTF&quot;&gt;&lt;/a&gt;CTF&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/631613398&quot;&gt;2023最全CTF入门指南（建议收</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>python密码学实验</title>
    <link href="http://example.com/2023/10/17/python%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2023/10/17/python%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-10-17T02:17:02.000Z</published>
    <updated>2023-10-17T02:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验一：熟悉Python开发环境，凯撒密码与仿射密码"><a href="#实验一：熟悉Python开发环境，凯撒密码与仿射密码" class="headerlink" title="实验一：熟悉Python开发环境，凯撒密码与仿射密码"></a>实验一：熟悉Python开发环境，凯撒密码与仿射密码</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li><p>熟悉Pycharm&#x2F; Python Idle开发</p></li><li><p>完成Casear密码的编程。</p></li></ul><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>1、安装Python、Pycharm；了解Idle的应用；学会pip安装命令，将Cryptography gmpy2库安装到python中。</p><p>2、编写Casear密码程序，扩展到仿射密码、以及Casear密码的破译程序。</p><h4 id="caesar密码python实现"><a href="#caesar密码python实现" class="headerlink" title="caesar密码python实现"></a>caesar密码python实现</h4><p><a href="https://www.w3schools.cn/cryptography_with_python/cryptography_with_python_affine_cipher.html">Python 密码学教程 - w3schools</a></p><p>第一版代码：</p><p>两个函数分别实现对Caesar密码的加密和解密，关键的操作公式是相同的，只是对密钥进行加减操作。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in message:</span><br><span class="line">ciphertext += (chr(ord(i) + k)) # 将明文汉字转换为对应ASCLL数值或Unicode数值（ord函数），然后在此数值上+3，再将该值返回汉字（chr函数）</span><br></pre></td></tr></table></figure><p>第二版代码：</p><p>同样是两个函数分别实现对Caesar密码的加密和解密，将公式进行修改，第一版并不能把密码限制在26个字母。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in range(len(text)):</span><br><span class="line">    char = text[i]</span><br><span class="line">    if (char.isupper()):</span><br><span class="line">        ciphertext += chr((ord(char) + key - ord(&#x27;a&#x27;)) % 26 + ord(&#x27;a&#x27;))</span><br><span class="line">    else:</span><br><span class="line">        ciphertext += chr((ord(char) + key - ord(&#x27;A&#x27;)) % 26 + ord(&#x27;A&#x27;))</span><br></pre></td></tr></table></figure><p>第三版：</p><p>能够自定义</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SYMBOLS = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#x27;</span><br><span class="line">def caesar_encrypt(mode, message, key):</span><br><span class="line">    if mode[0] == &#x27;d&#x27;:</span><br><span class="line">        key = -key</span><br><span class="line">    ciphertext = &#x27;&#x27;</span><br><span class="line">    for symbol in message:</span><br><span class="line">        if symbol.isalpha():</span><br><span class="line">          num = ord(symbol)+key</span><br><span class="line">          if symbol.isupper():  # 所有密文字母是大写</span><br><span class="line">              if num &gt; ord(&#x27;Z&#x27;):</span><br><span class="line">                  num -= 26</span><br><span class="line">              elif num &lt; ord(&#x27;A&#x27;):</span><br><span class="line">                  num += 26</span><br><span class="line">          elif symbol.islower():</span><br><span class="line">              if num &gt; ord(&#x27;z&#x27;):</span><br><span class="line">                  num -= 26</span><br><span class="line">              elif num &lt; ord(&#x27;a&#x27;):</span><br><span class="line">                  num += 26</span><br><span class="line">        ciphertext += chr(num)</span><br><span class="line">        else:</span><br><span class="line">            ciphertext += symbol</span><br><span class="line">    return ciphertext</span><br></pre></td></tr></table></figure><p>暴力破解</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def caesar_decrypt(message):</span><br><span class="line">    LETTERS = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span><br><span class="line">    letters = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">    for key in range(26):</span><br><span class="line">        translated = &#x27;&#x27;</span><br><span class="line">        for symbol in message:</span><br><span class="line">            if symbol in LETTERS:</span><br><span class="line">                num = LETTERS.find(symbol)</span><br><span class="line">                num = num - key</span><br><span class="line">                if num &lt; 0:</span><br><span class="line">                    num = num + len(LETTERS)</span><br><span class="line">                translated = translated + LETTERS[num]</span><br><span class="line">            elif symbol in letters:</span><br><span class="line">                num = letters.find(symbol)</span><br><span class="line">                num = num - key</span><br><span class="line">                if num &lt; 0:</span><br><span class="line">                    num = num + len(letters)</span><br><span class="line">                translated = translated + letters[num]</span><br><span class="line">            else:</span><br><span class="line">                translated = translated + symbol</span><br><span class="line">        print(&#x27;Hacking key #%s: %s&#x27; % (key, translated))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h4><p><a href="https://www.cnblogs.com/clwsec/p/10198428.html">仿射密码Python实现</a><br>仿射密码是一种替换密码。它是利用加密函数一个字母对一个字母的加密。</p><p>加密函数是E(x)&#x3D; (ax + b) (mod m)，其中，a和m互质，m是字符集的大小。<br>（例如，26即是以26个字母作为编码，当m是26时，a必须是1，3，5，7，9，11，15，17，19，21，23，25其中之一）</p><p>解密函数为D(x) &#x3D; a<sup>-1</sup>(x - b) (mod m)，其中a<sup>-1</sup>是a在Zm群的乘法逆元。</p><blockquote><p><strong>乘法逆元</strong><br>群G中任意一个元素a，都在G中有唯一的逆元a’，具有性质aa’ &#x3D; a’a &#x3D; e，其中e为群的单位元。</p></blockquote><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">仿射密码</span><br><span class="line">(a,b)</span><br><span class="line">m = 26，字符集为小写字母</span><br><span class="line">加密函数是E(x)= (ax + b) (mod m)</span><br><span class="line">解密函数为D(x) = (a^-1)(x - b) (mod m)，其中a^-1是a的乘法逆元</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">#通过一个简单的遍历得到a的乘法逆元，也可以通过gmpy2库中的invert函数实现</span><br><span class="line">def get_inverse(a):</span><br><span class="line">    for i in range(1,27):</span><br><span class="line">        if a*i%26==1:</span><br><span class="line">            return i</span><br><span class="line"></span><br><span class="line">#加密</span><br><span class="line">def encipher(a, b, p):</span><br><span class="line">    c=[]</span><br><span class="line">    for i in p:</span><br><span class="line">        temp=((ord(i)-97)*a+b)%26+97</span><br><span class="line">        c.append(chr(temp))</span><br><span class="line">    print(&#x27;&#x27;.join(c))</span><br><span class="line"></span><br><span class="line">#解密</span><br><span class="line">def decipher(a, b, c):</span><br><span class="line">    a_inv = get_inverse(a)</span><br><span class="line">    p=[]</span><br><span class="line">    for i in c:</span><br><span class="line">        temp=(((ord(i)-97)-b)*a_inv)%26+97</span><br><span class="line">        p.append(chr(temp))</span><br><span class="line">    print(&#x27;&#x27;.join(p))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    a = 11</span><br><span class="line">    b = 6</span><br><span class="line">    message = &#x27;sorcery&#x27;</span><br><span class="line">    encipher(a,b,message)</span><br><span class="line">    #decipher(a,b,message)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">仿射密码</span><br><span class="line">m = 52</span><br><span class="line">字符集为小写和大写字母</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">import string</span><br><span class="line">def encrypt(k1,k2,message):</span><br><span class="line">    dic = string.ascii_letters</span><br><span class="line">    c = []</span><br><span class="line">    for i in message:</span><br><span class="line">        if i.islower():</span><br><span class="line">            num = ord(i)-ord(&#x27;a&#x27;)</span><br><span class="line">            c.append(dic[(num*k1+k2)%52])</span><br><span class="line">        elif i.isupper():</span><br><span class="line">            num = ord(i)-ord(&#x27;A&#x27;)+26</span><br><span class="line">            c.append(dic[(num*k1+k2)%52])</span><br><span class="line">        else:</span><br><span class="line">            c.append(i)</span><br><span class="line">    print(&#x27;&#x27;.join(c))</span><br><span class="line"></span><br><span class="line">def decrypt(k1,k2,message):</span><br><span class="line">    for i in range(52):</span><br><span class="line">        if k1*i%52==1:</span><br><span class="line">            inv = i</span><br><span class="line">            break</span><br><span class="line">    dic = string.ascii_letters</span><br><span class="line">    m = []</span><br><span class="line">    for i in message:</span><br><span class="line">        if i.islower():</span><br><span class="line">            num = ord(i)-ord(&#x27;a&#x27;)</span><br><span class="line">            m.append(dic[inv*(num-k2)%52])</span><br><span class="line">        elif i.isupper():</span><br><span class="line">            num = ord(i)-ord(&#x27;A&#x27;)+26</span><br><span class="line">            m.append(dic[inv*(num-k2)%52])</span><br><span class="line">        else:</span><br><span class="line">            m.append(i)</span><br><span class="line">    print(&#x27;&#x27;.join(m))</span><br><span class="line"></span><br><span class="line">message = &#x27;gVEXGT iDIT&#x27; #待加密或解密的消息</span><br><span class="line">a = 5 # key的范围0~51之间</span><br><span class="line">b = 29 # key的范围0~51之间</span><br><span class="line"># encrypt(a,b,message)</span><br><span class="line">decrypt(a,b,message)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Affine(object):</span><br><span class="line">    DIE = 128</span><br><span class="line">    KEY = (7, 3, 55)</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def encryptChar(self, char):</span><br><span class="line">        K1, K2, kI = self.KEY</span><br><span class="line">        return chr((K1 * ord(char) + K2) % self.DIE)</span><br><span class="line"></span><br><span class="line">    def encrypt(self, string):</span><br><span class="line">        return &quot;&quot;.join(map(self.encryptChar, string))</span><br><span class="line"></span><br><span class="line">    def decryptChar(self, char):</span><br><span class="line">        K1, K2, KI = self.KEY</span><br><span class="line">        return chr(KI * (ord(char) - K2) % self.DIE)</span><br><span class="line"></span><br><span class="line">    def decrypt(self, string):</span><br><span class="line">        return &quot;&quot;.join(map(self.decryptChar, string))</span><br><span class="line"></span><br><span class="line">affine = Affine()</span><br><span class="line">print(affine.encrypt(&#x27;Affine Cipher&#x27;))</span><br><span class="line">print(affine.decrypt(&#x27;*18?FMT&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实验二：哈希函数"><a href="#实验二：哈希函数" class="headerlink" title="实验二：哈希函数"></a>实验二：哈希函数</h3><p>1、编程实现生成空字符串、‘Alice’、‘Bob’的md5、sha256的哈希值；</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">def hash_md5():</span><br><span class="line">    alice = hashlib.md5(b&quot;Alice&quot;)</span><br><span class="line">    bob = hashlib.md5(b&quot;Bob&quot;)</span><br><span class="line">    print(&#x27;&quot;Alice&quot; md5:&#x27; + alice.hexdigest())</span><br><span class="line">    print(&#x27;&quot;Bob&quot; md5:&#x27; + bob.hexdigest())</span><br><span class="line"></span><br><span class="line">def hash_sha256():</span><br><span class="line">    alice = hashlib.sha256(b&quot;Alice&quot;)</span><br><span class="line">    bob = hashlib.sha256(b&quot;Bob&quot;)</span><br><span class="line">    print(&#x27;&quot;Alice&quot; sha256:&#x27; + alice.hexdigest())</span><br><span class="line">    print(&#x27;&quot;Bob&quot; sha256:&#x27; + bob.hexdigest())</span><br></pre></td></tr></table></figure><p>2、编程实现生成自己名字的哈希值，注意编码的转换；</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def myhash(str = &quot;Yangjiaqing&quot;):</span><br><span class="line">    res = hashlib.md5(str.encode(encoding=&quot;utf-8&quot;))</span><br><span class="line">    print(str + &quot; md5: &quot; + res.hexdigest())</span><br></pre></td></tr></table></figure><p>3、编写体现哈希雪崩的代码，哈希值用二进制表示； 参考Listing2-5 代码；<br><a href="https://huaweicloud.csdn.net/63807e39dacf622b8df88c1c.html#:~:text=%23%20%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%20%23%20author%3Amarxycj%20%23%20date%3A2021-10-29%20from%20hashlib,%27__main__%27%20%3A%20md5_value%20%3D%20input%20%28%29%20brute_md5%20%28md5_value%29">Python 哈希函数与消息认证实验</a><br><a href="https://www.wolfram.com/language/12/cryptography/demonstrate-the-avalanche-effect-of-a-hash-function.html.zh">展示散列函数的雪崩效应</a></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def cmpcount(str1, str2):</span><br><span class="line">    count = 0</span><br><span class="line">    for i in range(0, len(str1)):</span><br><span class="line">        if str1[i] != str2[i]:</span><br><span class="line">            count += 1</span><br><span class="line">    return count</span><br><span class="line"></span><br><span class="line">def avalanche(str1 = &#x27;bob&#x27;, str2 = &#x27;aob&#x27;):</span><br><span class="line">    bin1 = str1.encode(&#x27;utf-8&#x27;)</span><br><span class="line">    bin2 = str2.encode(&#x27;utf-8&#x27;)</span><br><span class="line">    hexstring1 = hashlib.md5(bin1).hexdigest()</span><br><span class="line">    binstring1 = &#x27;&#123;:08b&#125;&#x27;.format(int(hexstring1, 16))</span><br><span class="line">    # binstring1 = bin(int(hexstring1, 16))</span><br><span class="line">    hexstring2 = hashlib.md5(bin2).hexdigest()</span><br><span class="line">    binstring2 = &#x27;&#123;:08b&#125;&#x27;.format(int(hexstring2, 16))</span><br><span class="line">    # binstring2 = bin(int(hexstring2, 16))</span><br><span class="line">    print(int(hexstring1, 16))</span><br><span class="line">    print(int(hexstring2, 16))</span><br><span class="line">    print(str1 + &quot; md5:&quot; + binstring1)</span><br><span class="line">    print(str2 + &quot; md5:&quot; + binstring2)</span><br><span class="line">    print(&quot;两个哈希值不同的位数：&quot; + str(cmpcount(binstring1, binstring2)))</span><br></pre></td></tr></table></figure><p>4、利用scrypt密钥派生函数，实现口令加盐，生成更加安全的密钥（口令）；<br><a href="https://deepinout.com/python/python-qa/169_python_creating_a_salt_in_python.html#:~:text=Python%203.6%2B%20%E7%9A%84%20secrets%20%E6%A8%A1%E5%9D%97%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E7%A7%8D%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E3%80%82%20%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BD%BF%E7%94%A8%20secrets%20%E6%A8%A1%E5%9D%97%E7%94%9F%E6%88%90%E7%9B%90%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A,16%20salt%20%3D%20secrets.token_hex%28salt_length%29%20print%28salt%29%20%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E5%B0%86%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E9%95%BF%E5%BA%A6%E4%B8%BA%2016%20%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E7%9B%90%E3%80%82">创建一个 Python 盐</a><br>Scrypt介绍<br>Scrypt 是一个强大的密钥派生函数，其通过内存密集的计算方式来抵抗 GPU、ASIC、FPGA 这类密码破解硬件的攻击。</p><p>Scrypt 接收多个输入参数，进行计算后输出密钥：</p><p>key &#x3D; Scrypt(password, salt, N, r, p, derived-key-len)<br>其中的参数被称为” Scrypt 配置参数”，说明如下：</p><blockquote><p>N - 迭代次数，将影响 CPU 和内存用量，例：16384 、2048 ；<br>r - 块大小，将影响 CPU 和内存用量，例：8 ；<br>p - 并行因数 （并行运行的线程数，将影响 CPU 和内存用量），通常为 1 ；<br>password - 输入的密码（推荐至少为 8 - 10 个字符）；<br>salt - 安全产生的随机字节序列（最小为 64 位，推荐 128 位）；<br>derived-key-len - 输出的密钥要有多少字节长，例如 32 （256 位）<br>Scrypt 的输出密钥长度可以是 128 位到 512 位，但是通常为 256 位。</p></blockquote><p>Salt 用使用 secrets 模块生成，也可以用os.urandom()随机生成</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def hash_password(password = b&#x27;p@$Sw0rD~7&#x27;):</span><br><span class="line">    salt_length = 16</span><br><span class="line">    salt = secrets.token_bytes(salt_length)</span><br><span class="line">    key = pyscrypt.hash(password, salt, 2048, 8, 1, 32)</span><br><span class="line">    return key.hex()</span><br></pre></td></tr></table></figure><p>5、实现区块链中的工作量证明编程，通过设置不同的难度，体会生成符合要求哈希值需要时间长短的不同；<br><a href="https://zhuanlan.zhihu.com/p/29903461">从零开始构建一个区块链（二）： 工作量证明</a><br><a href="https://blog.csdn.net/xiaobing1994/article/details/87967693">使用python实现简版区块链-工作量证明</a><br><a href="https://github.com/xiaobing94/pysimpleblockchain/tree/part2">区块链的简单实现 - github</a></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import hashlib</span><br><span class="line">class NonceNotFoundError(Exception):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def encode(str, code=&#x27;utf-8&#x27;):</span><br><span class="line">    return str.encode(code)</span><br><span class="line"></span><br><span class="line">def decode(bytes, code=&#x27;utf-8&#x27;):</span><br><span class="line">    return bytes.decode(code)</span><br><span class="line"></span><br><span class="line">def sum256_hex(*args):</span><br><span class="line">    m = hashlib.sha256()</span><br><span class="line">    for arg in args:</span><br><span class="line">        if isinstance(arg, str):</span><br><span class="line">            m.update(arg.encode())</span><br><span class="line">        else:</span><br><span class="line">            m.update(arg)</span><br><span class="line">    return m.hexdigest()</span><br><span class="line"></span><br><span class="line">def sum256_byte(*args):</span><br><span class="line">    m = hashlib.sha256()</span><br><span class="line">    for arg in args:</span><br><span class="line">        if isinstance(arg, str):</span><br><span class="line">            m.update(arg.encode())</span><br><span class="line">        else:</span><br><span class="line">            m.update(arg)</span><br><span class="line">    return m.digest()</span><br><span class="line"></span><br><span class="line">class ProofOfWork(object):</span><br><span class="line">    _N_BITS = 20</span><br><span class="line">    MAX_BITS = 256</span><br><span class="line">    MAX_SIZE = sys.maxsize</span><br><span class="line">    def __init__(self, n_bits=_N_BITS):</span><br><span class="line">        self._n_bits = n_bits</span><br><span class="line">        self._target_bits = 1 &lt;&lt; (self.MAX_BITS - n_bits)</span><br><span class="line">    def _prepare_data(self, nonce):</span><br><span class="line">        data_lst = [str(nonce)]</span><br><span class="line">        return encode(&#x27;&#x27;.join(data_lst))</span><br><span class="line">    def run(self):</span><br><span class="line">        nonce = 0</span><br><span class="line">        found = False</span><br><span class="line">        hash_hex = None</span><br><span class="line">        print(&#x27;Mining a new block&#x27;)</span><br><span class="line">        while nonce &lt; self.MAX_SIZE:</span><br><span class="line">            data = self._prepare_data(nonce)</span><br><span class="line">            hash_hex = sum256_hex(data)</span><br><span class="line">            hash_val = int(hash_hex, 16)</span><br><span class="line">            sys.stdout.write(&quot;try nonce == %d hash_hex == %s \r&quot; % (nonce, hash_hex))</span><br><span class="line">            if (hash_val &lt; self._target_bits):</span><br><span class="line">                found = True</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            nonce += 1</span><br><span class="line">        if found: </span><br><span class="line">            print(&#x27;Found nonce == %d&#x27; % nonce)</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;Not Found nonce&#x27;)</span><br><span class="line">            raise NonceNotFoundError(&#x27;nonce not found&#x27;)</span><br><span class="line">        return nonce, hash_hex</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    bc = ProofOfWork()</span><br><span class="line">    bc.run()</span><br></pre></td></tr></table></figure><h3 id="实验三：实现对称加密编程"><a href="#实验三：实现对称加密编程" class="headerlink" title="实验三：实现对称加密编程"></a>实验三：实现对称加密编程</h3><p><a href="https://zhuanlan.zhihu.com/p/364772865">分组密码的五大工作模式</a></p><p><a href="https://zhuanlan.zhihu.com/p/23276413">使用cryptography进行AES的cbc模式加密 - 知乎 (zhihu.com)</a></p><p><a href="https://github.com/istommao/cryptokit/tree/main">istommao&#x2F;cryptokit: cryptokit is a cryptography kit (github.com)</a></p><p>4、练习3-12 手工CBC:编程应用AES的ECB模式实现CBC模式</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def ecbTocbc(self, data):</span><br><span class="line">    if not isinstance(data, bytes):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    cipher = Cipher(algorithms.AES(self.aes_key),</span><br><span class="line">                    modes.ECB(),</span><br><span class="line">                    backend=default_backend())</span><br><span class="line">    dataList = []</span><br><span class="line">    cipherText = []</span><br><span class="line">    padded_data = self.pkcs7_padding(data)</span><br><span class="line">    binary_data = bin((int(padded_data.hex(), 16)))[2:]</span><br><span class="line">    while len(binary_data) / 128 &gt;= 0:</span><br><span class="line">        if len(binary_data) / 128 == 0 &amp; len(binary_data) % 128 == 0:</span><br><span class="line">            break</span><br><span class="line">        elif len(binary_data) / 128 == 0 &amp; len(binary_data) % 128 != 0:</span><br><span class="line">            dataList.append(binary_data[0:])</span><br><span class="line">            dataList.remove()</span><br><span class="line">        else:</span><br><span class="line">            dataList.append(binary_data[0:128])</span><br><span class="line">            binary_data = binary_data[128:]</span><br><span class="line"></span><br><span class="line">    c = &quot;&#123;:08b&#125;&quot;.format(int(self.aes_iv.hex(), 16))</span><br><span class="line">    for i in dataList:</span><br><span class="line">        ci = cipher.encryptor().update(bytes(i^c))</span><br><span class="line">        cipherText.append(ci)</span><br><span class="line">        c = ci.decode()</span><br><span class="line">        print(c)</span><br><span class="line">    m = &#x27;&#x27;.join([c.hex() for c in cipherText])</span><br><span class="line">    return m</span><br></pre></td></tr></table></figure><p>5、练习3-13 简单CTR模式：编程应用AES的ECB模式实现CTR模式</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def ecbToctr(self, data):</span><br><span class="line">    if not isinstance(data, bytes):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    iv = self.aes_iv</span><br><span class="line">    cipher = Cipher(algorithms.AES(self.aes_key),</span><br><span class="line">                    modes.ECB(),</span><br><span class="line">                    backend=default_backend())</span><br><span class="line"></span><br><span class="line">    dataList = []</span><br><span class="line">    cipherText = []</span><br><span class="line">    padded_data = self.pkcs7_padding(data)</span><br><span class="line">    binary_data = &quot;&#123;:08b&#125;&quot;.format(int(padded_data.hex(), 16)) + &#x27;0&#x27;</span><br><span class="line">    while len(binary_data) / 128 &gt;= 0:</span><br><span class="line">        if len(binary_data) / 128 == 0 &amp; len(binary_data) % 128 == 0:</span><br><span class="line">            break</span><br><span class="line">        elif len(binary_data) / 128 == 0 &amp; len(binary_data) % 128 != 0:</span><br><span class="line">            dataList.append(binary_data[0:])</span><br><span class="line">            dataList.remove()</span><br><span class="line">        else:</span><br><span class="line">            dataList.append(binary_data[0:128])</span><br><span class="line">            binary_data = binary_data[128:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for i in dataList:</span><br><span class="line">        ci = cipher.encryptor().update(iv) ^ i.encode()</span><br><span class="line">        iv += 1</span><br><span class="line">        cipherText.append(ci)</span><br><span class="line">        print(ci)</span><br><span class="line">    m = &#x27;&#x27;.join(cipherText)</span><br><span class="line">    return m</span><br></pre></td></tr></table></figure><h3 id="实验四：实现非对称加密编程"><a href="#实验四：实现非对称加密编程" class="headerlink" title="实验四：实现非对称加密编程"></a>实验四：实现非对称加密编程</h3><p><a href="https://cloud.tencent.com/developer/article/2186122">非对称密钥沉思系列（1）：RSA专题之PKCSv1.5填充模式下的选择性密文攻击概述-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实验一：熟悉Python开发环境，凯撒密码与仿射密码&quot;&gt;&lt;a href=&quot;#实验一：熟悉Python开发环境，凯撒密码与仿射密码&quot; class=&quot;headerlink&quot; title=&quot;实验一：熟悉Python开发环境，凯撒密码与仿射密码&quot;&gt;&lt;/a&gt;实验一：熟悉Py</summary>
      
    
    
    
    
  </entry>
  
</feed>
