<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <author>
    <name>H1S97X</name>
  </author>
  <generator uri="https://hexo.io/">Hexo</generator>
  <icon>https://h1s97x.github.io/favicon.ico</icon>
  <id>https://h1s97x.github.io/</id>
  <link href="https://h1s97x.github.io/" rel="alternate"/>
  <link href="https://h1s97x.github.io/atom.xml" rel="self"/>
  <rights>All rights reserved 2026, H1S97X</rights>
  <subtitle>技术分享与生活记录 | 或有月下赏花人 应无所憾</subtitle>
  <title>H1S97X</title>
  <updated>2026-02-14T09:49:10.718Z</updated>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2026/02/14/hello-world/</id>
    <link href="https://h1s97x.github.io/blog/2026/02/14/hello-world/"/>
    <published>2026-02-14T09:49:10.718Z</published>
    <summary>
      <![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you]]>
    </summary>
    <title>Hello World</title>
    <updated>2026-02-14T09:49:10.718Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h1 id="HTTrack-简单使用"><a href="#HTTrack-简单使用" class="headerlink" title="HTTrack 简单使用"></a>HTTrack 简单使用</h1><ul><li><strong>本文作者：</strong> 李钰璕</li><li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack 简单使用.html</a></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>HTTrack</code> 是一个免费的（GPL，自由软件）和易于使用的离线浏览器工具。它可以爬取整站的网页，用于离线浏览，减少与目标系统交互。它可从 <code>Internet</code> 上下载万维网站点到本地目录，递归地构建所有目录，从服务器获取 <code>HTML</code>、图像和其他文件到本地。<code>HTTrack</code> 安排原始网站的相关链接结构。只需在浏览器中打开 “镜像” 网站的页面，即可从链接到链接浏览网站，就像在线查看网站一样。<code>HTTrack</code> 也可以更新现有的镜像站点，并恢复中断的下载。<code>HTTrack</code> 完全可配置，并具有集成的帮助系统。</p><h1 id="HTTrack-安装"><a href="#HTTrack-安装" class="headerlink" title="HTTrack 安装"></a><code>HTTrack</code> 安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# apt-get install httrack</span><br></pre></td></tr></table></figure><h1 id="HTTrack-交互模式使用步骤"><a href="#HTTrack-交互模式使用步骤" class="headerlink" title="HTTrack 交互模式使用步骤"></a><code>HTTrack</code> 交互模式使用步骤</h1><ol><li><p>创建目录存储复制网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# mkdir mywebsite</span><br></pre></td></tr></table></figure><p>[# HTTrack 简单使用</p></li></ol><ul><li><strong>本文作者：</strong> 李钰璕</li><li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack 简单使用.html</a></li></ul><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h1><p><code>HTTrack</code> 是一个免费的（GPL，自由软件）和易于使用的离线浏览器工具。它可以爬取整站的网页，用于离线浏览，减少与目标系统交互。它可从 <code>Internet</code> 上下载万维网站点到本地目录，递归地构建所有目录，从服务器获取 <code>HTML</code>、图像和其他文件到本地。<code>HTTrack</code> 安排原始网站的相关链接结构。只需在浏览器中打开 “镜像” 网站的页面，即可从链接到链接浏览网站，就像在线查看网站一样。<code>HTTrack</code> 也可以更新现有的镜像站点，并恢复中断的下载。<code>HTTrack</code> 完全可配置，并具有集成的帮助系统。</p><h1 id="HTTrack-安装-1"><a href="#HTTrack-安装-1" class="headerlink" title="HTTrack 安装"></a><code>HTTrack</code> 安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# apt-get install httrack</span><br></pre></td></tr></table></figure><h1 id="HTTrack-交互模式使用步骤-1"><a href="#HTTrack-交互模式使用步骤-1" class="headerlink" title="HTTrack 交互模式使用步骤"></a><code>HTTrack</code> 交互模式使用步骤</h1><ol><li><p>创建目录存储复制网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# mkdir mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png" alt="img"></a></p></li><li><p>启动 <code>HTTrack</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# httrack</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png" alt="img"></a></p></li><li><p>输入项目名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter project name : blog//blog为项目名称</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png" alt="img"></a></p></li><li><p>选择存储网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base path (return=/root/websites/) :/root/mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png" alt="img"></a></p></li><li><p>输入网站的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter URLs (separated by commas or blank spaces) :www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png" alt="img"></a></p></li><li><p>选择操作 (此处选择 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action:</span><br><span class="line">(enter) 1Mirror Web Site(s)//直接镜像站点</span><br><span class="line">        2Mirror Web Site(s) with Wizard//用向导完成镜像</span><br><span class="line">        3Just Get Files Indicated//只get某种特定的文件</span><br><span class="line">        4Mirror ALL links in URLs (Multiple Mirror)//镜像在这个url下所有的链接</span><br><span class="line">        5Test Links In URLs (Bookmark Test)//测试在这个url下的链接</span><br><span class="line">        0Quit//退出</span><br><span class="line">: </span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png" alt="img"></a></p></li><li><p>指定是否在实施攻击时使用代理 (此处默认输入 none，不使用代理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png" alt="img"></a></p></li><li><p>定义字符，爬取特定类型的数据 (此处输入 <code>*</code> 表示爬取全部类型数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip</span><br><span class="line">Wildcards (return=none) :*</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png" alt="img"></a></p></li><li><p>设置更多选项，可以使用 <code>help</code> 查看 (此处选择默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png" alt="img"></a></p></li><li><p>开始克隆网站</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png" alt="img"></a></p></li><li><p>查看克隆的文件</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png" alt="img"></a></p></li></ol><p>备注：<code>httrack</code> 只能用于克隆静态内容，并且无法完全复制网站上的动态内容、中间部分 (数据库) 等内容。</p><h1 id="HTTrack-一般模式使用步骤"><a href="#HTTrack-一般模式使用步骤" class="headerlink" title="HTTrack 一般模式使用步骤"></a><code>HTTrack</code> 一般模式使用步骤</h1><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack &lt;URLs&gt; [-option] [+&lt;URL_FILTER&gt;] [-&lt;URL_FILTER&gt;] [+&lt;mime:MIME_FILTER&gt;] [-&lt;mime:MIME_FILTER&gt;]</span><br></pre></td></tr></table></figure><p>选项如下：（* 为默认值）</p><h2 id="一般选项"><a href="#一般选项" class="headerlink" title="一般选项"></a>一般选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O  镜像路径/缓存和日志文件路径</span><br><span class="line">-O 镜像路径[,缓存和日志文件路径] (--path &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="行为选项"><a href="#行为选项" class="headerlink" title="行为选项"></a>行为选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w  *镜像网站 (--mirror)</span><br><span class="line">W镜像网站，半自动 (asks questions) (--mirror-wizard)</span><br><span class="line">g只获取文件（保存在当前目录中） (--get-files)</span><br><span class="line">i使用缓存继续中断的镜像 (--continue)</span><br><span class="line">Y镜像所有位于第一级页面的链接 (镜像链接) (--mirrorlinks)</span><br></pre></td></tr></table></figure><h2 id="代理选项"><a href="#代理选项" class="headerlink" title="代理选项"></a>代理选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   代理使用 (-P proxy:port or -P user:pass@proxy:port) (--proxy &lt;param&gt;)</span><br><span class="line">%f *使用ftp代理 (f0 don&#x27;t use) (--httpproxy-ftp[=N])</span><br><span class="line">%b  使用此本地主机名发出/发送请求 (-%b 主机名) (--bind &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="限制选项"><a href="#限制选项" class="headerlink" title="限制选项"></a>限制选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rN  将“镜像深度”设置为N (* r9999) (--depth[=N])</span><br><span class="line">%eN   将“外部链接深度”设置为N (* %e0) (--ext-depth[=N])</span><br><span class="line">mN    将非HTML文件的最大文件长度设置为N (--max-files[=N])</span><br><span class="line">mN,N2 将非HTML文件的最大文件长度设置为N、将HTML文件的最大文件长度设置为N2</span><br><span class="line">MN    将可上传/扫描的最大总长度设置为N (--max-size[=N])</span><br><span class="line">EN    将最大镜像传输时间设置为N秒 (60=1 minute, 3600=1 hour) (--max-time[=N])</span><br><span class="line">AN    将最大传输速率设置为N字节/秒 (1000=1KB/s max) (--max-rate[=N])</span><br><span class="line">%cN   将最大连接数设置为N个/秒 (*%c10) (--connection-per-second[=N])</span><br><span class="line">GN    设置如果达到N个字节，则暂停传输，并等待锁定文件被删除 (--max-pause[=N])</span><br></pre></td></tr></table></figure><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cN  设置连接数为N (*c8) (--sockets[=N])</span><br><span class="line">TN  设置关闭无响应链接N秒后超时 (--timeout)</span><br><span class="line">RN  设置超时或非致命错误情况下的重试次数为N (*R1) (--retries[=N])</span><br><span class="line">JN  流量阻塞控制，设置链路允许的最小传输速率为N字节/秒 (--min-rate[=N])</span><br><span class="line">HN  如果：0=从不、1=超时、2=慢、3=超时或慢，则放弃主机 (--host-control[=N])</span><br></pre></td></tr></table></figure><h2 id="链接选项"><a href="#链接选项" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%P        *扩展解析，尝试解析所有链接，即使是未知标记或Javascript标记 (%P0 don&#x27;t use) (--extended-parsing[=N])</span><br><span class="line">n          在html文件附近获取非html文件 (例如：位于外部的图像) (--near)</span><br><span class="line">t          测试所有url（即使url被禁止） (--test)</span><br><span class="line">%L &lt;file&gt;  添加位于此文本文件中的所有URL（每行一个URL）  (--list &lt;param&gt;)</span><br><span class="line">%S &lt;file&gt;  添加位于此文本文件中的所有扫描规则（每行一个扫描规则） (--urllist &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="构建选项"><a href="#构建选项" class="headerlink" title="构建选项"></a>构建选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NN结构类型 (0 *原始结构, 1+: 详见下文) (--structure[=N])</span><br><span class="line">    或用户定义的结构 (-N &quot;%h%p/%n%q.%t&quot;)</span><br><span class="line">%N  延迟类型检查，不进行任何链接测试，而是等待文件下载开始（实验性的）(N0 不使用，%N1 用于未知扩展名，*%N2 始终使用)</span><br><span class="line">%D  缓存的延迟类型检查，不要在更新期间等待远程类型，以加快更新速度 (%D0 等待, * %D1 不等待) (--cached-delayed-type-check)</span><br><span class="line">%M  生成RFC MIME封装的完整存档 (.mht) (--mime-html)</span><br><span class="line">LN长名称 (L1 *长名称 / L0 8-3 转换 / L2 ISO9660 兼容) (--long-names[=N])</span><br><span class="line">KN保留原始链接 (e.g. http://www.adr/link) (K0 *相对链接, K 绝对链接, K4 原始链接, K3 绝对URI链接, K5 透明代理链接) (--keep-links[=N])</span><br><span class="line">x用错误页替换外部html链接 (--replace-external)</span><br><span class="line">%x不包括受外部密码保护的网站的任何密码 (%x0 包括) (--disable-passwords)</span><br><span class="line">%q *包含本地文件的查询字符串 (无用,仅供参考) (%q0 不包含) (--include-query-string)</span><br><span class="line">o  *出错时生成输出html文件 (404..) (o0 不生成) (--generate-errors)</span><br><span class="line">X  *更新后清除旧文件 (X0 保持删除) (--purge-old[=N])</span><br><span class="line">%p保留html文件“原样” (与&#x27;-K4 -%F &quot;&quot;&#x27;相同) (--preserve)</span><br><span class="line">%T链接转换为UTF-8 (--utf8-conversion)</span><br></pre></td></tr></table></figure><h2 id="蜘蛛选项"><a href="#蜘蛛选项" class="headerlink" title="蜘蛛选项"></a>蜘蛛选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bN接受cookies.txt中的cookies (0=不接受,* 1=接受) (--cookies[=N])</span><br><span class="line">u检查未知文档类型 (cgi,asp..) (u0 不检查, * u1 检查除了 /, u2 始终检查) (--check-type[=N])</span><br><span class="line">j  *解析JAVA类 (j0 不解析, 位掩码: |1 解析默认值, |2 不解析.class文件 |4 不解析.js文件 |8 不越界解析) (--parse-java[=N])</span><br><span class="line">sN遵循robots.txt和meta robots标记 (0=never,1=sometimes,* 2=always, 3=always (even strict rules)) (--robots[=N])</span><br><span class="line">%h  强制HTTP/1请求 (仅针对旧服务器或代理减少更新特性) (--http-10)</span><br><span class="line">%k尽可能使用keep alive，大大减少小文件和测试请求的延迟 (%k0 不使用) (--keep-alive)</span><br><span class="line">%B  容忍请求 (在某些服务器上接受虚假响应，但不是标准的!) (--tolerant)</span><br><span class="line">%s  更新非法入侵：在更新时限制重新传输的各种非法入侵(相同大小，虚假响应…) (--updatehack)</span><br><span class="line">%u  url非法入侵：限制重复url的各种非法入侵 (strip //, www.foo.com==foo.com..) (--urlhack)</span><br><span class="line">%A  假设一个类型(cgi,asp..)总是与一个mime类型链接 (-%A php3,cgi=text/html;dat,bin=application/x-zip) (--assume &lt;param&gt;)</span><br><span class="line">     快捷方式：&#x27;--assume standard&#x27;相当于-%A php2 php3 php4 php cgi asp jsp pl cfm nsf=text/html</span><br><span class="line">     也可以用于强制特定的文件类型：-assume foo.cgi=text/html</span><br><span class="line">@iNinternet协议 (0=both ipv6+ipv4, 4=ipv4 only, 6=ipv6 only) (--protocol[=N])</span><br><span class="line">%w  禁用特定的外部mime模块 (-%w htsswf -%w htsjava) (--disable-module &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="浏览器-ID"><a href="#浏览器-ID" class="headerlink" title="浏览器 ID"></a>浏览器 ID</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F   在HTTP头中发送的用户代理字段 (-F &quot;user-agent name&quot;) (--user-agent &lt;param&gt;)</span><br><span class="line">%R  在HTTP头中发送的默认referer字段 (--referer &lt;param&gt;)</span><br><span class="line">%E  从以HTTP头发送的电子邮件地址 (--from &lt;param&gt;)</span><br><span class="line">%F  Html代码中的页脚字符串 (-%F &quot;Mirrored [from host %s [file %s [at %s]]]&quot; (--footer &lt;param&gt;)</span><br><span class="line">%l  首选语言 (-%l &quot;fr, en, jp, *&quot; (--language &lt;param&gt;)</span><br><span class="line">%a  接受格式 (-%a &quot;text/html,image/png;q=0.9,*/*;q=0.1&quot; (--accept &lt;param&gt;)</span><br><span class="line">%X  附加的HTTP标题行 (-%X &quot;X-Magic: 42&quot; (--headers &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="日志、索引、缓存"><a href="#日志、索引、缓存" class="headerlink" title="日志、索引、缓存"></a>日志、索引、缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C   创建/使用缓存进行更新和重试 (C0 无缓存,C1 缓存优先,* C2 测试更新前) (--cache[=N])</span><br><span class="line">k   将所有文件存储在缓存中 (如果文件在磁盘上，则此功能不可用) (--store-all-in-cache)</span><br><span class="line">%n  不能重新下载本地删除的文件 (--do-not-recatch)</span><br><span class="line">%v  在屏幕上显示下载的文件名(实时) - * %v1 缩写版 - %v2 完整 (--display)</span><br><span class="line">Q   无日志-安静模式  (--do-not-log)</span><br><span class="line">q   无问题-安静模式 (--quiet)</span><br><span class="line">z   日志-附加信息 (--extra-log)</span><br><span class="line">Z   日志-debug (--debug-log)</span><br><span class="line">v   登录屏幕 (--verbose)</span><br><span class="line">f  *登录文件 (--file-log)</span><br><span class="line">f2  一个单一日志文件(--single-log)</span><br><span class="line">I  *编制索引 (I0 不编制索引) (--index)</span><br><span class="line">%i  为项目文件夹创建顶级索引 (* %i0 不创建) (--build-top-index)</span><br><span class="line">%I  为此镜像创建可搜索索引 (* %I0 不创建) (--search-index)</span><br></pre></td></tr></table></figure><h2 id="专家选项"><a href="#专家选项" class="headerlink" title="专家选项"></a>专家选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pN  优先模式: (* p3) (--priority[=N])</span><br><span class="line">     p0 只扫描，不保存任何内容 (用于检查链接)</span><br><span class="line">     p1 只保存html文件</span><br><span class="line">     p2 只保存非html文件</span><br><span class="line">    *p3 保存所有文件</span><br><span class="line">     p7 先获取html文件，然后处理其他文件</span><br><span class="line">S   保持在同一个目录 (--stay-on-same-dir)</span><br><span class="line">D  *只能进入子目录 (--can-go-down)</span><br><span class="line">U   只能进入父目录 (--can-go-up)</span><br><span class="line">B   可以上下进入目录结构 (--can-go-up-and-down)</span><br><span class="line">a  *保持在同一地址 (--stay-on-same-address)</span><br><span class="line">d   保持在同一主域 (--stay-on-same-domain)</span><br><span class="line">l   保持相同的TLD (eg: .com) (--stay-on-same-tld)</span><br><span class="line">e   go everywhere on the web (--go-everywhere)</span><br><span class="line">%H  在日志文件中调试HTTP头 (--debug-headers)</span><br></pre></td></tr></table></figure><h2 id="权威选项"><a href="#权威选项" class="headerlink" title="权威选项"></a>权威选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#X  *使用优化引擎 (有限内存边界检查) (--fast-engine)</span><br><span class="line">#0   过滤测试 (-#0 &#x27;*.gif&#x27; &#x27;www.bar.com/foo.gif&#x27;) (--debug-testfilters &lt;param&gt;)</span><br><span class="line">#1   简化测试 (-#1 ./foo/bar/../foobar)</span><br><span class="line">#2   类型测试 (-#2 /foo/bar.php)</span><br><span class="line">#C   换成列表 (-#C &#x27;*.com/spider*.gif&#x27; (--debug-cache &lt;param&gt;)</span><br><span class="line">#R   缓存修复 (损坏缓存) (--repair-cache)</span><br><span class="line">#d   调试分析器 (--debug-parsing)</span><br><span class="line">#E   在meta.zip中提取new.zip缓存元数据</span><br><span class="line">#f   总是刷新日志文件 (--advanced-flushlogs)</span><br><span class="line">#FN  过滤器的最大过滤数目 (--advanced-maxfilters[=N])</span><br><span class="line">#h   版本信息 (--version)</span><br><span class="line">#K   扫描标准输入 (debug) (--debug-scanstdin)</span><br><span class="line">#L   最大链接数 (-#L1000000) (--advanced-maxlinks[=N])</span><br><span class="line">#p   显示进度信息 (--advanced-progressinfo)</span><br><span class="line">#P   抓取URL (--catch-url)</span><br><span class="line">#R   旧的FTP例程 (debug) (--repair-cache)</span><br><span class="line">#T   每分钟生成一次传输操作日志 (--debug-xfrstats)</span><br><span class="line">#u   等待时间 (--advanced-wait)</span><br><span class="line">#Z   每分钟生成传输速率的静态数据 (--debug-ratestats)</span><br></pre></td></tr></table></figure><h2 id="危险选项"><a href="#危险选项" class="headerlink" title="危险选项"></a>危险选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%!  绕过旨在避免带宽滥用的内置安全限制 (带宽，并发连接) (--disable-security-limits)</span><br></pre></td></tr></table></figure><p>危险选项，仅适用于专家；</p><p>谨慎使用；</p><h2 id="命令行特定选项"><a href="#命令行特定选项" class="headerlink" title="命令行特定选项"></a>命令行特定选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V   执行每个文件后的系统命令 ($0 is the filename: -V &quot;rm \$0&quot;) (--userdef-cmd &lt;param&gt;)</span><br><span class="line">%W  使用外部库函数作为包装器 (-%W myfoo.so[,myparameters]) (--callback &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="选项-N-详情"><a href="#选项-N-详情" class="headerlink" title="选项 N 详情"></a>选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N0 站点结构 (默认)</span><br><span class="line">N1 HTML in web/, images/other files in web/images/</span><br><span class="line">N2 HTML in web/HTML, images/other in web/images</span><br><span class="line">N3 HTML in web/,  images/other in web/</span><br><span class="line">N4 HTML in web/, images/other in web/xxx, where xxx is the file extension (all gif will be placed onto web/gif, for example)</span><br><span class="line">N5 Images/other in web/xxx and HTML in web/HTML</span><br><span class="line">N99 All files in web/, with random names (gadget !)</span><br><span class="line">N100 站点结构，不包括www.domain.xxx/</span><br><span class="line">N101 Identical to N1 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N102 Identical to N2 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N103 Identical to N3 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N104 Identical to N4 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N105 Identical to N5 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N199 Identical to N99 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N1001 Identical to N1 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1002 Identical to N2 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1003 Identical to N3 exept that there is no &quot;web&quot; directory (option set for g option)</span><br><span class="line">N1004 Identical to N4 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1005 Identical to N5 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1099 Identical to N99 exept that there is no &quot;web&quot; directory</span><br></pre></td></tr></table></figure><h2 id="用户定义选项-N-详情"><a href="#用户定义选项-N-详情" class="headerlink" title="用户定义选项 N 详情"></a>用户定义选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;%n&#x27; 没有文件类型的文件名 (ex: image)</span><br><span class="line">&#x27;%N&#x27; 文件名，包括文件类型 (ex: image.gif)</span><br><span class="line">&#x27;%t&#x27; 文件类型 (ex: gif)</span><br><span class="line">&#x27;%p&#x27; 路径 [无结尾 /] (ex: /someimages)</span><br><span class="line">&#x27;%h&#x27; 主机名 (ex: www.someweb.com)</span><br><span class="line">&#x27;%M&#x27; URL MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%Q&#x27; 查询字符串MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%k&#x27; 完整查询字符串</span><br><span class="line">&#x27;%r&#x27; 协议名 (ex: http)</span><br><span class="line">&#x27;%q&#x27; 短查询字符串 (16位，4个ascii字节)</span><br><span class="line"> &#x27;%s?&#x27; 短名称版本 (ex: %sN)</span><br><span class="line">&#x27;%[param]&#x27; 查询字符串中的param变量</span><br><span class="line">&#x27;%[param:before:after:empty:notfound]&#x27; 高级变量提取</span><br></pre></td></tr></table></figure><h2 id="用户定义的选项-N-和高级变量提取详情"><a href="#用户定义的选项-N-和高级变量提取详情" class="headerlink" title="用户定义的选项 N 和高级变量提取详情"></a>用户定义的选项 N 和高级变量提取详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%[param:before:after:empty:notfound]</span><br><span class="line">param    参数名称</span><br><span class="line">before   如果找到参数，则在其前面加上字符串</span><br><span class="line">after    找到参数后要追加的字符串</span><br><span class="line">notfound 如果找不到参数，则替换字符串</span><br><span class="line">empty    如果参数为空，则替换字符串</span><br></pre></td></tr></table></figure><p>除第一个字段（参数名）外，所有字段都可以为空</p><h2 id="选项-K-详情"><a href="#选项-K-详情" class="headerlink" title="选项 K 详情"></a>选项 K 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K0  foo.cgi?q=45  -&gt;  foo4B54.html?q=45 (relative URI, default)</span><br><span class="line">K                 -&gt;  http://www.foobar.com/folder/foo.cgi?q=45 (absolute URL) (--keep-links[=N])</span><br><span class="line">K3                -&gt;  /folder/foo.cgi?q=45 (absolute URI)</span><br><span class="line">K4                -&gt;  foo.cgi?q=45 (original URL)</span><br><span class="line">K5                -&gt;  http://www.foobar.com/folder/foo4B54.html?q=45 (transparent proxy URL)</span><br></pre></td></tr></table></figure><h2 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--mirror      &lt;URLs&gt; *制作站点的镜像 (default)</span><br><span class="line">--get         &lt;URLs&gt;  获取指定的文件，不要查找其他URL (-qg)</span><br><span class="line">--list   &lt;text file&gt;  添加此文本文件中的所有URL (-%L)</span><br><span class="line">--mirrorlinks &lt;URLs&gt;  镜像一级页面中的所有链接 (-Y)</span><br><span class="line">--testlinks   &lt;URLs&gt;  测试页面中的链接 (-r1p0C0I0t)</span><br><span class="line">--spider      &lt;URLs&gt;  爬取站点，用于测试链接:报告错误和警告 (-p0C0I0t)</span><br><span class="line">--testsite    &lt;URLs&gt;  与--spider相同</span><br><span class="line">--skeleton    &lt;URLs&gt;  创建镜像，但只获取html文件 (-p1)</span><br><span class="line">--update              更新镜像，无需确认 (-iC2)</span><br><span class="line">--continue            继续镜像，无需确认 (-iC1)</span><br><span class="line"></span><br><span class="line">--catchurl            创建一个临时代理来捕获一个URL或一个表单post URL</span><br><span class="line">--clean               删除缓存和日志文件</span><br><span class="line"></span><br><span class="line">--http10              强制http/1.0请求 (-%h)</span><br></pre></td></tr></table></figure><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><ol><li><p>只镜像站点 <code>www.someweb.com/bob/</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/</span><br></pre></td></tr></table></figure></li><li><p>将两个站点镜像在一起（带有共享链接），并接受.com 站点上的任何.jpg 文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/ www.anothertest.com/mike/ +*.com/*.jpg -mime:application/*</span><br></pre></td></tr></table></figure></li><li><p>从 bobby.html 开始获取所有文件，具有 6 个链接深度，并且可以在 web 上到处访问；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html +* -r6</span><br></pre></td></tr></table></figure></li><li><p>使用代理在 <code>www.someweb.com/bob/bobby.html</code> 上运行爬虫；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html --spider -P proxy.myhost.com:8080</span><br></pre></td></tr></table></figure></li><li><p>更新当前文件夹中的镜像 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --update</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹中继续镜像；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --continue</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.httrack.com/html/fcguide.html">Httrack Users Guide</a></p><ol start="2"><li><p>启动 <code>HTTrack</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# httrack</span><br></pre></td></tr></table></figure><p>[# HTTrack 简单使用</p></li></ol><ul><li><strong>本文作者：</strong> 李钰璕</li><li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack 简单使用.html</a></li></ul><h1 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h1><p><code>HTTrack</code> 是一个免费的（GPL，自由软件）和易于使用的离线浏览器工具。它可以爬取整站的网页，用于离线浏览，减少与目标系统交互。它可从 <code>Internet</code> 上下载万维网站点到本地目录，递归地构建所有目录，从服务器获取 <code>HTML</code>、图像和其他文件到本地。<code>HTTrack</code> 安排原始网站的相关链接结构。只需在浏览器中打开 “镜像” 网站的页面，即可从链接到链接浏览网站，就像在线查看网站一样。<code>HTTrack</code> 也可以更新现有的镜像站点，并恢复中断的下载。<code>HTTrack</code> 完全可配置，并具有集成的帮助系统。</p><h1 id="HTTrack-安装-2"><a href="#HTTrack-安装-2" class="headerlink" title="HTTrack 安装"></a><code>HTTrack</code> 安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# apt-get install httrack</span><br></pre></td></tr></table></figure><h1 id="HTTrack-交互模式使用步骤-2"><a href="#HTTrack-交互模式使用步骤-2" class="headerlink" title="HTTrack 交互模式使用步骤"></a><code>HTTrack</code> 交互模式使用步骤</h1><ol><li><p>创建目录存储复制网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# mkdir mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png" alt="img"></a></p></li><li><p>启动 <code>HTTrack</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# httrack</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png" alt="img"></a></p></li><li><p>输入项目名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter project name : blog//blog为项目名称</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png" alt="img"></a></p></li><li><p>选择存储网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base path (return=/root/websites/) :/root/mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png" alt="img"></a></p></li><li><p>输入网站的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter URLs (separated by commas or blank spaces) :www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png" alt="img"></a></p></li><li><p>选择操作 (此处选择 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action:</span><br><span class="line">(enter) 1Mirror Web Site(s)//直接镜像站点</span><br><span class="line">        2Mirror Web Site(s) with Wizard//用向导完成镜像</span><br><span class="line">        3Just Get Files Indicated//只get某种特定的文件</span><br><span class="line">        4Mirror ALL links in URLs (Multiple Mirror)//镜像在这个url下所有的链接</span><br><span class="line">        5Test Links In URLs (Bookmark Test)//测试在这个url下的链接</span><br><span class="line">        0Quit//退出</span><br><span class="line">: </span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png" alt="img"></a></p></li><li><p>指定是否在实施攻击时使用代理 (此处默认输入 none，不使用代理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png" alt="img"></a></p></li><li><p>定义字符，爬取特定类型的数据 (此处输入 <code>*</code> 表示爬取全部类型数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip</span><br><span class="line">Wildcards (return=none) :*</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png" alt="img"></a></p></li><li><p>设置更多选项，可以使用 <code>help</code> 查看 (此处选择默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png" alt="img"></a></p></li><li><p>开始克隆网站</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png" alt="img"></a></p></li><li><p>查看克隆的文件</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png" alt="img"></a></p></li></ol><p>备注：<code>httrack</code> 只能用于克隆静态内容，并且无法完全复制网站上的动态内容、中间部分 (数据库) 等内容。</p><h1 id="HTTrack-一般模式使用步骤-1"><a href="#HTTrack-一般模式使用步骤-1" class="headerlink" title="HTTrack 一般模式使用步骤"></a><code>HTTrack</code> 一般模式使用步骤</h1><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack &lt;URLs&gt; [-option] [+&lt;URL_FILTER&gt;] [-&lt;URL_FILTER&gt;] [+&lt;mime:MIME_FILTER&gt;] [-&lt;mime:MIME_FILTER&gt;]</span><br></pre></td></tr></table></figure><p>选项如下：（* 为默认值）</p><h2 id="一般选项-1"><a href="#一般选项-1" class="headerlink" title="一般选项"></a>一般选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O  镜像路径/缓存和日志文件路径</span><br><span class="line">-O 镜像路径[,缓存和日志文件路径] (--path &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="行为选项-1"><a href="#行为选项-1" class="headerlink" title="行为选项"></a>行为选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w  *镜像网站 (--mirror)</span><br><span class="line">W镜像网站，半自动 (asks questions) (--mirror-wizard)</span><br><span class="line">g只获取文件（保存在当前目录中） (--get-files)</span><br><span class="line">i使用缓存继续中断的镜像 (--continue)</span><br><span class="line">Y镜像所有位于第一级页面的链接 (镜像链接) (--mirrorlinks)</span><br></pre></td></tr></table></figure><h2 id="代理选项-1"><a href="#代理选项-1" class="headerlink" title="代理选项"></a>代理选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   代理使用 (-P proxy:port or -P user:pass@proxy:port) (--proxy &lt;param&gt;)</span><br><span class="line">%f *使用ftp代理 (f0 don&#x27;t use) (--httpproxy-ftp[=N])</span><br><span class="line">%b  使用此本地主机名发出/发送请求 (-%b 主机名) (--bind &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="限制选项-1"><a href="#限制选项-1" class="headerlink" title="限制选项"></a>限制选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rN  将“镜像深度”设置为N (* r9999) (--depth[=N])</span><br><span class="line">%eN   将“外部链接深度”设置为N (* %e0) (--ext-depth[=N])</span><br><span class="line">mN    将非HTML文件的最大文件长度设置为N (--max-files[=N])</span><br><span class="line">mN,N2 将非HTML文件的最大文件长度设置为N、将HTML文件的最大文件长度设置为N2</span><br><span class="line">MN    将可上传/扫描的最大总长度设置为N (--max-size[=N])</span><br><span class="line">EN    将最大镜像传输时间设置为N秒 (60=1 minute, 3600=1 hour) (--max-time[=N])</span><br><span class="line">AN    将最大传输速率设置为N字节/秒 (1000=1KB/s max) (--max-rate[=N])</span><br><span class="line">%cN   将最大连接数设置为N个/秒 (*%c10) (--connection-per-second[=N])</span><br><span class="line">GN    设置如果达到N个字节，则暂停传输，并等待锁定文件被删除 (--max-pause[=N])</span><br></pre></td></tr></table></figure><h2 id="流量控制-1"><a href="#流量控制-1" class="headerlink" title="流量控制"></a>流量控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cN  设置连接数为N (*c8) (--sockets[=N])</span><br><span class="line">TN  设置关闭无响应链接N秒后超时 (--timeout)</span><br><span class="line">RN  设置超时或非致命错误情况下的重试次数为N (*R1) (--retries[=N])</span><br><span class="line">JN  流量阻塞控制，设置链路允许的最小传输速率为N字节/秒 (--min-rate[=N])</span><br><span class="line">HN  如果：0=从不、1=超时、2=慢、3=超时或慢，则放弃主机 (--host-control[=N])</span><br></pre></td></tr></table></figure><h2 id="链接选项-1"><a href="#链接选项-1" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%P        *扩展解析，尝试解析所有链接，即使是未知标记或Javascript标记 (%P0 don&#x27;t use) (--extended-parsing[=N])</span><br><span class="line">n          在html文件附近获取非html文件 (例如：位于外部的图像) (--near)</span><br><span class="line">t          测试所有url（即使url被禁止） (--test)</span><br><span class="line">%L &lt;file&gt;  添加位于此文本文件中的所有URL（每行一个URL）  (--list &lt;param&gt;)</span><br><span class="line">%S &lt;file&gt;  添加位于此文本文件中的所有扫描规则（每行一个扫描规则） (--urllist &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="构建选项-1"><a href="#构建选项-1" class="headerlink" title="构建选项"></a>构建选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NN结构类型 (0 *原始结构, 1+: 详见下文) (--structure[=N])</span><br><span class="line">    或用户定义的结构 (-N &quot;%h%p/%n%q.%t&quot;)</span><br><span class="line">%N  延迟类型检查，不进行任何链接测试，而是等待文件下载开始（实验性的）(N0 不使用，%N1 用于未知扩展名，*%N2 始终使用)</span><br><span class="line">%D  缓存的延迟类型检查，不要在更新期间等待远程类型，以加快更新速度 (%D0 等待, * %D1 不等待) (--cached-delayed-type-check)</span><br><span class="line">%M  生成RFC MIME封装的完整存档 (.mht) (--mime-html)</span><br><span class="line">LN长名称 (L1 *长名称 / L0 8-3 转换 / L2 ISO9660 兼容) (--long-names[=N])</span><br><span class="line">KN保留原始链接 (e.g. http://www.adr/link) (K0 *相对链接, K 绝对链接, K4 原始链接, K3 绝对URI链接, K5 透明代理链接) (--keep-links[=N])</span><br><span class="line">x用错误页替换外部html链接 (--replace-external)</span><br><span class="line">%x不包括受外部密码保护的网站的任何密码 (%x0 包括) (--disable-passwords)</span><br><span class="line">%q *包含本地文件的查询字符串 (无用,仅供参考) (%q0 不包含) (--include-query-string)</span><br><span class="line">o  *出错时生成输出html文件 (404..) (o0 不生成) (--generate-errors)</span><br><span class="line">X  *更新后清除旧文件 (X0 保持删除) (--purge-old[=N])</span><br><span class="line">%p保留html文件“原样” (与&#x27;-K4 -%F &quot;&quot;&#x27;相同) (--preserve)</span><br><span class="line">%T链接转换为UTF-8 (--utf8-conversion)</span><br></pre></td></tr></table></figure><h2 id="蜘蛛选项-1"><a href="#蜘蛛选项-1" class="headerlink" title="蜘蛛选项"></a>蜘蛛选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bN接受cookies.txt中的cookies (0=不接受,* 1=接受) (--cookies[=N])</span><br><span class="line">u检查未知文档类型 (cgi,asp..) (u0 不检查, * u1 检查除了 /, u2 始终检查) (--check-type[=N])</span><br><span class="line">j  *解析JAVA类 (j0 不解析, 位掩码: |1 解析默认值, |2 不解析.class文件 |4 不解析.js文件 |8 不越界解析) (--parse-java[=N])</span><br><span class="line">sN遵循robots.txt和meta robots标记 (0=never,1=sometimes,* 2=always, 3=always (even strict rules)) (--robots[=N])</span><br><span class="line">%h  强制HTTP/1请求 (仅针对旧服务器或代理减少更新特性) (--http-10)</span><br><span class="line">%k尽可能使用keep alive，大大减少小文件和测试请求的延迟 (%k0 不使用) (--keep-alive)</span><br><span class="line">%B  容忍请求 (在某些服务器上接受虚假响应，但不是标准的!) (--tolerant)</span><br><span class="line">%s  更新非法入侵：在更新时限制重新传输的各种非法入侵(相同大小，虚假响应…) (--updatehack)</span><br><span class="line">%u  url非法入侵：限制重复url的各种非法入侵 (strip //, www.foo.com==foo.com..) (--urlhack)</span><br><span class="line">%A  假设一个类型(cgi,asp..)总是与一个mime类型链接 (-%A php3,cgi=text/html;dat,bin=application/x-zip) (--assume &lt;param&gt;)</span><br><span class="line">     快捷方式：&#x27;--assume standard&#x27;相当于-%A php2 php3 php4 php cgi asp jsp pl cfm nsf=text/html</span><br><span class="line">     也可以用于强制特定的文件类型：-assume foo.cgi=text/html</span><br><span class="line">@iNinternet协议 (0=both ipv6+ipv4, 4=ipv4 only, 6=ipv6 only) (--protocol[=N])</span><br><span class="line">%w  禁用特定的外部mime模块 (-%w htsswf -%w htsjava) (--disable-module &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="浏览器-ID-1"><a href="#浏览器-ID-1" class="headerlink" title="浏览器 ID"></a>浏览器 ID</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F   在HTTP头中发送的用户代理字段 (-F &quot;user-agent name&quot;) (--user-agent &lt;param&gt;)</span><br><span class="line">%R  在HTTP头中发送的默认referer字段 (--referer &lt;param&gt;)</span><br><span class="line">%E  从以HTTP头发送的电子邮件地址 (--from &lt;param&gt;)</span><br><span class="line">%F  Html代码中的页脚字符串 (-%F &quot;Mirrored [from host %s [file %s [at %s]]]&quot; (--footer &lt;param&gt;)</span><br><span class="line">%l  首选语言 (-%l &quot;fr, en, jp, *&quot; (--language &lt;param&gt;)</span><br><span class="line">%a  接受格式 (-%a &quot;text/html,image/png;q=0.9,*/*;q=0.1&quot; (--accept &lt;param&gt;)</span><br><span class="line">%X  附加的HTTP标题行 (-%X &quot;X-Magic: 42&quot; (--headers &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="日志、索引、缓存-1"><a href="#日志、索引、缓存-1" class="headerlink" title="日志、索引、缓存"></a>日志、索引、缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C   创建/使用缓存进行更新和重试 (C0 无缓存,C1 缓存优先,* C2 测试更新前) (--cache[=N])</span><br><span class="line">k   将所有文件存储在缓存中 (如果文件在磁盘上，则此功能不可用) (--store-all-in-cache)</span><br><span class="line">%n  不能重新下载本地删除的文件 (--do-not-recatch)</span><br><span class="line">%v  在屏幕上显示下载的文件名(实时) - * %v1 缩写版 - %v2 完整 (--display)</span><br><span class="line">Q   无日志-安静模式  (--do-not-log)</span><br><span class="line">q   无问题-安静模式 (--quiet)</span><br><span class="line">z   日志-附加信息 (--extra-log)</span><br><span class="line">Z   日志-debug (--debug-log)</span><br><span class="line">v   登录屏幕 (--verbose)</span><br><span class="line">f  *登录文件 (--file-log)</span><br><span class="line">f2  一个单一日志文件(--single-log)</span><br><span class="line">I  *编制索引 (I0 不编制索引) (--index)</span><br><span class="line">%i  为项目文件夹创建顶级索引 (* %i0 不创建) (--build-top-index)</span><br><span class="line">%I  为此镜像创建可搜索索引 (* %I0 不创建) (--search-index)</span><br></pre></td></tr></table></figure><h2 id="专家选项-1"><a href="#专家选项-1" class="headerlink" title="专家选项"></a>专家选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pN  优先模式: (* p3) (--priority[=N])</span><br><span class="line">     p0 只扫描，不保存任何内容 (用于检查链接)</span><br><span class="line">     p1 只保存html文件</span><br><span class="line">     p2 只保存非html文件</span><br><span class="line">    *p3 保存所有文件</span><br><span class="line">     p7 先获取html文件，然后处理其他文件</span><br><span class="line">S   保持在同一个目录 (--stay-on-same-dir)</span><br><span class="line">D  *只能进入子目录 (--can-go-down)</span><br><span class="line">U   只能进入父目录 (--can-go-up)</span><br><span class="line">B   可以上下进入目录结构 (--can-go-up-and-down)</span><br><span class="line">a  *保持在同一地址 (--stay-on-same-address)</span><br><span class="line">d   保持在同一主域 (--stay-on-same-domain)</span><br><span class="line">l   保持相同的TLD (eg: .com) (--stay-on-same-tld)</span><br><span class="line">e   go everywhere on the web (--go-everywhere)</span><br><span class="line">%H  在日志文件中调试HTTP头 (--debug-headers)</span><br></pre></td></tr></table></figure><h2 id="权威选项-1"><a href="#权威选项-1" class="headerlink" title="权威选项"></a>权威选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#X  *使用优化引擎 (有限内存边界检查) (--fast-engine)</span><br><span class="line">#0   过滤测试 (-#0 &#x27;*.gif&#x27; &#x27;www.bar.com/foo.gif&#x27;) (--debug-testfilters &lt;param&gt;)</span><br><span class="line">#1   简化测试 (-#1 ./foo/bar/../foobar)</span><br><span class="line">#2   类型测试 (-#2 /foo/bar.php)</span><br><span class="line">#C   换成列表 (-#C &#x27;*.com/spider*.gif&#x27; (--debug-cache &lt;param&gt;)</span><br><span class="line">#R   缓存修复 (损坏缓存) (--repair-cache)</span><br><span class="line">#d   调试分析器 (--debug-parsing)</span><br><span class="line">#E   在meta.zip中提取new.zip缓存元数据</span><br><span class="line">#f   总是刷新日志文件 (--advanced-flushlogs)</span><br><span class="line">#FN  过滤器的最大过滤数目 (--advanced-maxfilters[=N])</span><br><span class="line">#h   版本信息 (--version)</span><br><span class="line">#K   扫描标准输入 (debug) (--debug-scanstdin)</span><br><span class="line">#L   最大链接数 (-#L1000000) (--advanced-maxlinks[=N])</span><br><span class="line">#p   显示进度信息 (--advanced-progressinfo)</span><br><span class="line">#P   抓取URL (--catch-url)</span><br><span class="line">#R   旧的FTP例程 (debug) (--repair-cache)</span><br><span class="line">#T   每分钟生成一次传输操作日志 (--debug-xfrstats)</span><br><span class="line">#u   等待时间 (--advanced-wait)</span><br><span class="line">#Z   每分钟生成传输速率的静态数据 (--debug-ratestats)</span><br></pre></td></tr></table></figure><h2 id="危险选项-1"><a href="#危险选项-1" class="headerlink" title="危险选项"></a>危险选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%!  绕过旨在避免带宽滥用的内置安全限制 (带宽，并发连接) (--disable-security-limits)</span><br></pre></td></tr></table></figure><p>危险选项，仅适用于专家；</p><p>谨慎使用；</p><h2 id="命令行特定选项-1"><a href="#命令行特定选项-1" class="headerlink" title="命令行特定选项"></a>命令行特定选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V   执行每个文件后的系统命令 ($0 is the filename: -V &quot;rm \$0&quot;) (--userdef-cmd &lt;param&gt;)</span><br><span class="line">%W  使用外部库函数作为包装器 (-%W myfoo.so[,myparameters]) (--callback &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="选项-N-详情-1"><a href="#选项-N-详情-1" class="headerlink" title="选项 N 详情"></a>选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N0 站点结构 (默认)</span><br><span class="line">N1 HTML in web/, images/other files in web/images/</span><br><span class="line">N2 HTML in web/HTML, images/other in web/images</span><br><span class="line">N3 HTML in web/,  images/other in web/</span><br><span class="line">N4 HTML in web/, images/other in web/xxx, where xxx is the file extension (all gif will be placed onto web/gif, for example)</span><br><span class="line">N5 Images/other in web/xxx and HTML in web/HTML</span><br><span class="line">N99 All files in web/, with random names (gadget !)</span><br><span class="line">N100 站点结构，不包括www.domain.xxx/</span><br><span class="line">N101 Identical to N1 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N102 Identical to N2 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N103 Identical to N3 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N104 Identical to N4 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N105 Identical to N5 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N199 Identical to N99 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N1001 Identical to N1 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1002 Identical to N2 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1003 Identical to N3 exept that there is no &quot;web&quot; directory (option set for g option)</span><br><span class="line">N1004 Identical to N4 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1005 Identical to N5 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1099 Identical to N99 exept that there is no &quot;web&quot; directory</span><br></pre></td></tr></table></figure><h2 id="用户定义选项-N-详情-1"><a href="#用户定义选项-N-详情-1" class="headerlink" title="用户定义选项 N 详情"></a>用户定义选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;%n&#x27; 没有文件类型的文件名 (ex: image)</span><br><span class="line">&#x27;%N&#x27; 文件名，包括文件类型 (ex: image.gif)</span><br><span class="line">&#x27;%t&#x27; 文件类型 (ex: gif)</span><br><span class="line">&#x27;%p&#x27; 路径 [无结尾 /] (ex: /someimages)</span><br><span class="line">&#x27;%h&#x27; 主机名 (ex: www.someweb.com)</span><br><span class="line">&#x27;%M&#x27; URL MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%Q&#x27; 查询字符串MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%k&#x27; 完整查询字符串</span><br><span class="line">&#x27;%r&#x27; 协议名 (ex: http)</span><br><span class="line">&#x27;%q&#x27; 短查询字符串 (16位，4个ascii字节)</span><br><span class="line"> &#x27;%s?&#x27; 短名称版本 (ex: %sN)</span><br><span class="line">&#x27;%[param]&#x27; 查询字符串中的param变量</span><br><span class="line">&#x27;%[param:before:after:empty:notfound]&#x27; 高级变量提取</span><br></pre></td></tr></table></figure><h2 id="用户定义的选项-N-和高级变量提取详情-1"><a href="#用户定义的选项-N-和高级变量提取详情-1" class="headerlink" title="用户定义的选项 N 和高级变量提取详情"></a>用户定义的选项 N 和高级变量提取详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%[param:before:after:empty:notfound]</span><br><span class="line">param    参数名称</span><br><span class="line">before   如果找到参数，则在其前面加上字符串</span><br><span class="line">after    找到参数后要追加的字符串</span><br><span class="line">notfound 如果找不到参数，则替换字符串</span><br><span class="line">empty    如果参数为空，则替换字符串</span><br></pre></td></tr></table></figure><p>除第一个字段（参数名）外，所有字段都可以为空</p><h2 id="选项-K-详情-1"><a href="#选项-K-详情-1" class="headerlink" title="选项 K 详情"></a>选项 K 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K0  foo.cgi?q=45  -&gt;  foo4B54.html?q=45 (relative URI, default)</span><br><span class="line">K                 -&gt;  http://www.foobar.com/folder/foo.cgi?q=45 (absolute URL) (--keep-links[=N])</span><br><span class="line">K3                -&gt;  /folder/foo.cgi?q=45 (absolute URI)</span><br><span class="line">K4                -&gt;  foo.cgi?q=45 (original URL)</span><br><span class="line">K5                -&gt;  http://www.foobar.com/folder/foo4B54.html?q=45 (transparent proxy URL)</span><br></pre></td></tr></table></figure><h2 id="快捷操作-1"><a href="#快捷操作-1" class="headerlink" title="快捷操作"></a>快捷操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--mirror      &lt;URLs&gt; *制作站点的镜像 (default)</span><br><span class="line">--get         &lt;URLs&gt;  获取指定的文件，不要查找其他URL (-qg)</span><br><span class="line">--list   &lt;text file&gt;  添加此文本文件中的所有URL (-%L)</span><br><span class="line">--mirrorlinks &lt;URLs&gt;  镜像一级页面中的所有链接 (-Y)</span><br><span class="line">--testlinks   &lt;URLs&gt;  测试页面中的链接 (-r1p0C0I0t)</span><br><span class="line">--spider      &lt;URLs&gt;  爬取站点，用于测试链接:报告错误和警告 (-p0C0I0t)</span><br><span class="line">--testsite    &lt;URLs&gt;  与--spider相同</span><br><span class="line">--skeleton    &lt;URLs&gt;  创建镜像，但只获取html文件 (-p1)</span><br><span class="line">--update              更新镜像，无需确认 (-iC2)</span><br><span class="line">--continue            继续镜像，无需确认 (-iC1)</span><br><span class="line"></span><br><span class="line">--catchurl            创建一个临时代理来捕获一个URL或一个表单post URL</span><br><span class="line">--clean               删除缓存和日志文件</span><br><span class="line"></span><br><span class="line">--http10              强制http/1.0请求 (-%h)</span><br></pre></td></tr></table></figure><h1 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h1><ol><li><p>只镜像站点 <code>www.someweb.com/bob/</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/</span><br></pre></td></tr></table></figure></li><li><p>将两个站点镜像在一起（带有共享链接），并接受.com 站点上的任何.jpg 文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/ www.anothertest.com/mike/ +*.com/*.jpg -mime:application/*</span><br></pre></td></tr></table></figure></li><li><p>从 bobby.html 开始获取所有文件，具有 6 个链接深度，并且可以在 web 上到处访问；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html +* -r6</span><br></pre></td></tr></table></figure></li><li><p>使用代理在 <code>www.someweb.com/bob/bobby.html</code> 上运行爬虫；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html --spider -P proxy.myhost.com:8080</span><br></pre></td></tr></table></figure></li><li><p>更新当前文件夹中的镜像 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --update</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹中继续镜像；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --continue</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.httrack.com/html/fcguide.html">Httrack Users Guide</a></p><ol start="3"><li><p>输入项目名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter project name : blog//blog为项目名称</span><br></pre></td></tr></table></figure><p>[# HTTrack 简单使用</p></li></ol><ul><li><strong>本文作者：</strong> 李钰璕</li><li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack 简单使用.html</a></li></ul><h1 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h1><p><code>HTTrack</code> 是一个免费的（GPL，自由软件）和易于使用的离线浏览器工具。它可以爬取整站的网页，用于离线浏览，减少与目标系统交互。它可从 <code>Internet</code> 上下载万维网站点到本地目录，递归地构建所有目录，从服务器获取 <code>HTML</code>、图像和其他文件到本地。<code>HTTrack</code> 安排原始网站的相关链接结构。只需在浏览器中打开 “镜像” 网站的页面，即可从链接到链接浏览网站，就像在线查看网站一样。<code>HTTrack</code> 也可以更新现有的镜像站点，并恢复中断的下载。<code>HTTrack</code> 完全可配置，并具有集成的帮助系统。</p><h1 id="HTTrack-安装-3"><a href="#HTTrack-安装-3" class="headerlink" title="HTTrack 安装"></a><code>HTTrack</code> 安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# apt-get install httrack</span><br></pre></td></tr></table></figure><h1 id="HTTrack-交互模式使用步骤-3"><a href="#HTTrack-交互模式使用步骤-3" class="headerlink" title="HTTrack 交互模式使用步骤"></a><code>HTTrack</code> 交互模式使用步骤</h1><ol><li><p>创建目录存储复制网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# mkdir mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png" alt="img"></a></p></li><li><p>启动 <code>HTTrack</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# httrack</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png" alt="img"></a></p></li><li><p>输入项目名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter project name : blog//blog为项目名称</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png" alt="img"></a></p></li><li><p>选择存储网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base path (return=/root/websites/) :/root/mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png" alt="img"></a></p></li><li><p>输入网站的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter URLs (separated by commas or blank spaces) :www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png" alt="img"></a></p></li><li><p>选择操作 (此处选择 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action:</span><br><span class="line">(enter) 1Mirror Web Site(s)//直接镜像站点</span><br><span class="line">        2Mirror Web Site(s) with Wizard//用向导完成镜像</span><br><span class="line">        3Just Get Files Indicated//只get某种特定的文件</span><br><span class="line">        4Mirror ALL links in URLs (Multiple Mirror)//镜像在这个url下所有的链接</span><br><span class="line">        5Test Links In URLs (Bookmark Test)//测试在这个url下的链接</span><br><span class="line">        0Quit//退出</span><br><span class="line">: </span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png" alt="img"></a></p></li><li><p>指定是否在实施攻击时使用代理 (此处默认输入 none，不使用代理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png" alt="img"></a></p></li><li><p>定义字符，爬取特定类型的数据 (此处输入 <code>*</code> 表示爬取全部类型数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip</span><br><span class="line">Wildcards (return=none) :*</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png" alt="img"></a></p></li><li><p>设置更多选项，可以使用 <code>help</code> 查看 (此处选择默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png" alt="img"></a></p></li><li><p>开始克隆网站</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png" alt="img"></a></p></li><li><p>查看克隆的文件</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png" alt="img"></a></p></li></ol><p>备注：<code>httrack</code> 只能用于克隆静态内容，并且无法完全复制网站上的动态内容、中间部分 (数据库) 等内容。</p><h1 id="HTTrack-一般模式使用步骤-2"><a href="#HTTrack-一般模式使用步骤-2" class="headerlink" title="HTTrack 一般模式使用步骤"></a><code>HTTrack</code> 一般模式使用步骤</h1><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack &lt;URLs&gt; [-option] [+&lt;URL_FILTER&gt;] [-&lt;URL_FILTER&gt;] [+&lt;mime:MIME_FILTER&gt;] [-&lt;mime:MIME_FILTER&gt;]</span><br></pre></td></tr></table></figure><p>选项如下：（* 为默认值）</p><h2 id="一般选项-2"><a href="#一般选项-2" class="headerlink" title="一般选项"></a>一般选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O  镜像路径/缓存和日志文件路径</span><br><span class="line">-O 镜像路径[,缓存和日志文件路径] (--path &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="行为选项-2"><a href="#行为选项-2" class="headerlink" title="行为选项"></a>行为选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w  *镜像网站 (--mirror)</span><br><span class="line">W镜像网站，半自动 (asks questions) (--mirror-wizard)</span><br><span class="line">g只获取文件（保存在当前目录中） (--get-files)</span><br><span class="line">i使用缓存继续中断的镜像 (--continue)</span><br><span class="line">Y镜像所有位于第一级页面的链接 (镜像链接) (--mirrorlinks)</span><br></pre></td></tr></table></figure><h2 id="代理选项-2"><a href="#代理选项-2" class="headerlink" title="代理选项"></a>代理选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   代理使用 (-P proxy:port or -P user:pass@proxy:port) (--proxy &lt;param&gt;)</span><br><span class="line">%f *使用ftp代理 (f0 don&#x27;t use) (--httpproxy-ftp[=N])</span><br><span class="line">%b  使用此本地主机名发出/发送请求 (-%b 主机名) (--bind &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="限制选项-2"><a href="#限制选项-2" class="headerlink" title="限制选项"></a>限制选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rN  将“镜像深度”设置为N (* r9999) (--depth[=N])</span><br><span class="line">%eN   将“外部链接深度”设置为N (* %e0) (--ext-depth[=N])</span><br><span class="line">mN    将非HTML文件的最大文件长度设置为N (--max-files[=N])</span><br><span class="line">mN,N2 将非HTML文件的最大文件长度设置为N、将HTML文件的最大文件长度设置为N2</span><br><span class="line">MN    将可上传/扫描的最大总长度设置为N (--max-size[=N])</span><br><span class="line">EN    将最大镜像传输时间设置为N秒 (60=1 minute, 3600=1 hour) (--max-time[=N])</span><br><span class="line">AN    将最大传输速率设置为N字节/秒 (1000=1KB/s max) (--max-rate[=N])</span><br><span class="line">%cN   将最大连接数设置为N个/秒 (*%c10) (--connection-per-second[=N])</span><br><span class="line">GN    设置如果达到N个字节，则暂停传输，并等待锁定文件被删除 (--max-pause[=N])</span><br></pre></td></tr></table></figure><h2 id="流量控制-2"><a href="#流量控制-2" class="headerlink" title="流量控制"></a>流量控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cN  设置连接数为N (*c8) (--sockets[=N])</span><br><span class="line">TN  设置关闭无响应链接N秒后超时 (--timeout)</span><br><span class="line">RN  设置超时或非致命错误情况下的重试次数为N (*R1) (--retries[=N])</span><br><span class="line">JN  流量阻塞控制，设置链路允许的最小传输速率为N字节/秒 (--min-rate[=N])</span><br><span class="line">HN  如果：0=从不、1=超时、2=慢、3=超时或慢，则放弃主机 (--host-control[=N])</span><br></pre></td></tr></table></figure><h2 id="链接选项-2"><a href="#链接选项-2" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%P        *扩展解析，尝试解析所有链接，即使是未知标记或Javascript标记 (%P0 don&#x27;t use) (--extended-parsing[=N])</span><br><span class="line">n          在html文件附近获取非html文件 (例如：位于外部的图像) (--near)</span><br><span class="line">t          测试所有url（即使url被禁止） (--test)</span><br><span class="line">%L &lt;file&gt;  添加位于此文本文件中的所有URL（每行一个URL）  (--list &lt;param&gt;)</span><br><span class="line">%S &lt;file&gt;  添加位于此文本文件中的所有扫描规则（每行一个扫描规则） (--urllist &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="构建选项-2"><a href="#构建选项-2" class="headerlink" title="构建选项"></a>构建选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NN结构类型 (0 *原始结构, 1+: 详见下文) (--structure[=N])</span><br><span class="line">    或用户定义的结构 (-N &quot;%h%p/%n%q.%t&quot;)</span><br><span class="line">%N  延迟类型检查，不进行任何链接测试，而是等待文件下载开始（实验性的）(N0 不使用，%N1 用于未知扩展名，*%N2 始终使用)</span><br><span class="line">%D  缓存的延迟类型检查，不要在更新期间等待远程类型，以加快更新速度 (%D0 等待, * %D1 不等待) (--cached-delayed-type-check)</span><br><span class="line">%M  生成RFC MIME封装的完整存档 (.mht) (--mime-html)</span><br><span class="line">LN长名称 (L1 *长名称 / L0 8-3 转换 / L2 ISO9660 兼容) (--long-names[=N])</span><br><span class="line">KN保留原始链接 (e.g. http://www.adr/link) (K0 *相对链接, K 绝对链接, K4 原始链接, K3 绝对URI链接, K5 透明代理链接) (--keep-links[=N])</span><br><span class="line">x用错误页替换外部html链接 (--replace-external)</span><br><span class="line">%x不包括受外部密码保护的网站的任何密码 (%x0 包括) (--disable-passwords)</span><br><span class="line">%q *包含本地文件的查询字符串 (无用,仅供参考) (%q0 不包含) (--include-query-string)</span><br><span class="line">o  *出错时生成输出html文件 (404..) (o0 不生成) (--generate-errors)</span><br><span class="line">X  *更新后清除旧文件 (X0 保持删除) (--purge-old[=N])</span><br><span class="line">%p保留html文件“原样” (与&#x27;-K4 -%F &quot;&quot;&#x27;相同) (--preserve)</span><br><span class="line">%T链接转换为UTF-8 (--utf8-conversion)</span><br></pre></td></tr></table></figure><h2 id="蜘蛛选项-2"><a href="#蜘蛛选项-2" class="headerlink" title="蜘蛛选项"></a>蜘蛛选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bN接受cookies.txt中的cookies (0=不接受,* 1=接受) (--cookies[=N])</span><br><span class="line">u检查未知文档类型 (cgi,asp..) (u0 不检查, * u1 检查除了 /, u2 始终检查) (--check-type[=N])</span><br><span class="line">j  *解析JAVA类 (j0 不解析, 位掩码: |1 解析默认值, |2 不解析.class文件 |4 不解析.js文件 |8 不越界解析) (--parse-java[=N])</span><br><span class="line">sN遵循robots.txt和meta robots标记 (0=never,1=sometimes,* 2=always, 3=always (even strict rules)) (--robots[=N])</span><br><span class="line">%h  强制HTTP/1请求 (仅针对旧服务器或代理减少更新特性) (--http-10)</span><br><span class="line">%k尽可能使用keep alive，大大减少小文件和测试请求的延迟 (%k0 不使用) (--keep-alive)</span><br><span class="line">%B  容忍请求 (在某些服务器上接受虚假响应，但不是标准的!) (--tolerant)</span><br><span class="line">%s  更新非法入侵：在更新时限制重新传输的各种非法入侵(相同大小，虚假响应…) (--updatehack)</span><br><span class="line">%u  url非法入侵：限制重复url的各种非法入侵 (strip //, www.foo.com==foo.com..) (--urlhack)</span><br><span class="line">%A  假设一个类型(cgi,asp..)总是与一个mime类型链接 (-%A php3,cgi=text/html;dat,bin=application/x-zip) (--assume &lt;param&gt;)</span><br><span class="line">     快捷方式：&#x27;--assume standard&#x27;相当于-%A php2 php3 php4 php cgi asp jsp pl cfm nsf=text/html</span><br><span class="line">     也可以用于强制特定的文件类型：-assume foo.cgi=text/html</span><br><span class="line">@iNinternet协议 (0=both ipv6+ipv4, 4=ipv4 only, 6=ipv6 only) (--protocol[=N])</span><br><span class="line">%w  禁用特定的外部mime模块 (-%w htsswf -%w htsjava) (--disable-module &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="浏览器-ID-2"><a href="#浏览器-ID-2" class="headerlink" title="浏览器 ID"></a>浏览器 ID</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F   在HTTP头中发送的用户代理字段 (-F &quot;user-agent name&quot;) (--user-agent &lt;param&gt;)</span><br><span class="line">%R  在HTTP头中发送的默认referer字段 (--referer &lt;param&gt;)</span><br><span class="line">%E  从以HTTP头发送的电子邮件地址 (--from &lt;param&gt;)</span><br><span class="line">%F  Html代码中的页脚字符串 (-%F &quot;Mirrored [from host %s [file %s [at %s]]]&quot; (--footer &lt;param&gt;)</span><br><span class="line">%l  首选语言 (-%l &quot;fr, en, jp, *&quot; (--language &lt;param&gt;)</span><br><span class="line">%a  接受格式 (-%a &quot;text/html,image/png;q=0.9,*/*;q=0.1&quot; (--accept &lt;param&gt;)</span><br><span class="line">%X  附加的HTTP标题行 (-%X &quot;X-Magic: 42&quot; (--headers &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="日志、索引、缓存-2"><a href="#日志、索引、缓存-2" class="headerlink" title="日志、索引、缓存"></a>日志、索引、缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C   创建/使用缓存进行更新和重试 (C0 无缓存,C1 缓存优先,* C2 测试更新前) (--cache[=N])</span><br><span class="line">k   将所有文件存储在缓存中 (如果文件在磁盘上，则此功能不可用) (--store-all-in-cache)</span><br><span class="line">%n  不能重新下载本地删除的文件 (--do-not-recatch)</span><br><span class="line">%v  在屏幕上显示下载的文件名(实时) - * %v1 缩写版 - %v2 完整 (--display)</span><br><span class="line">Q   无日志-安静模式  (--do-not-log)</span><br><span class="line">q   无问题-安静模式 (--quiet)</span><br><span class="line">z   日志-附加信息 (--extra-log)</span><br><span class="line">Z   日志-debug (--debug-log)</span><br><span class="line">v   登录屏幕 (--verbose)</span><br><span class="line">f  *登录文件 (--file-log)</span><br><span class="line">f2  一个单一日志文件(--single-log)</span><br><span class="line">I  *编制索引 (I0 不编制索引) (--index)</span><br><span class="line">%i  为项目文件夹创建顶级索引 (* %i0 不创建) (--build-top-index)</span><br><span class="line">%I  为此镜像创建可搜索索引 (* %I0 不创建) (--search-index)</span><br></pre></td></tr></table></figure><h2 id="专家选项-2"><a href="#专家选项-2" class="headerlink" title="专家选项"></a>专家选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pN  优先模式: (* p3) (--priority[=N])</span><br><span class="line">     p0 只扫描，不保存任何内容 (用于检查链接)</span><br><span class="line">     p1 只保存html文件</span><br><span class="line">     p2 只保存非html文件</span><br><span class="line">    *p3 保存所有文件</span><br><span class="line">     p7 先获取html文件，然后处理其他文件</span><br><span class="line">S   保持在同一个目录 (--stay-on-same-dir)</span><br><span class="line">D  *只能进入子目录 (--can-go-down)</span><br><span class="line">U   只能进入父目录 (--can-go-up)</span><br><span class="line">B   可以上下进入目录结构 (--can-go-up-and-down)</span><br><span class="line">a  *保持在同一地址 (--stay-on-same-address)</span><br><span class="line">d   保持在同一主域 (--stay-on-same-domain)</span><br><span class="line">l   保持相同的TLD (eg: .com) (--stay-on-same-tld)</span><br><span class="line">e   go everywhere on the web (--go-everywhere)</span><br><span class="line">%H  在日志文件中调试HTTP头 (--debug-headers)</span><br></pre></td></tr></table></figure><h2 id="权威选项-2"><a href="#权威选项-2" class="headerlink" title="权威选项"></a>权威选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#X  *使用优化引擎 (有限内存边界检查) (--fast-engine)</span><br><span class="line">#0   过滤测试 (-#0 &#x27;*.gif&#x27; &#x27;www.bar.com/foo.gif&#x27;) (--debug-testfilters &lt;param&gt;)</span><br><span class="line">#1   简化测试 (-#1 ./foo/bar/../foobar)</span><br><span class="line">#2   类型测试 (-#2 /foo/bar.php)</span><br><span class="line">#C   换成列表 (-#C &#x27;*.com/spider*.gif&#x27; (--debug-cache &lt;param&gt;)</span><br><span class="line">#R   缓存修复 (损坏缓存) (--repair-cache)</span><br><span class="line">#d   调试分析器 (--debug-parsing)</span><br><span class="line">#E   在meta.zip中提取new.zip缓存元数据</span><br><span class="line">#f   总是刷新日志文件 (--advanced-flushlogs)</span><br><span class="line">#FN  过滤器的最大过滤数目 (--advanced-maxfilters[=N])</span><br><span class="line">#h   版本信息 (--version)</span><br><span class="line">#K   扫描标准输入 (debug) (--debug-scanstdin)</span><br><span class="line">#L   最大链接数 (-#L1000000) (--advanced-maxlinks[=N])</span><br><span class="line">#p   显示进度信息 (--advanced-progressinfo)</span><br><span class="line">#P   抓取URL (--catch-url)</span><br><span class="line">#R   旧的FTP例程 (debug) (--repair-cache)</span><br><span class="line">#T   每分钟生成一次传输操作日志 (--debug-xfrstats)</span><br><span class="line">#u   等待时间 (--advanced-wait)</span><br><span class="line">#Z   每分钟生成传输速率的静态数据 (--debug-ratestats)</span><br></pre></td></tr></table></figure><h2 id="危险选项-2"><a href="#危险选项-2" class="headerlink" title="危险选项"></a>危险选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%!  绕过旨在避免带宽滥用的内置安全限制 (带宽，并发连接) (--disable-security-limits)</span><br></pre></td></tr></table></figure><p>危险选项，仅适用于专家；</p><p>谨慎使用；</p><h2 id="命令行特定选项-2"><a href="#命令行特定选项-2" class="headerlink" title="命令行特定选项"></a>命令行特定选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V   执行每个文件后的系统命令 ($0 is the filename: -V &quot;rm \$0&quot;) (--userdef-cmd &lt;param&gt;)</span><br><span class="line">%W  使用外部库函数作为包装器 (-%W myfoo.so[,myparameters]) (--callback &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="选项-N-详情-2"><a href="#选项-N-详情-2" class="headerlink" title="选项 N 详情"></a>选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N0 站点结构 (默认)</span><br><span class="line">N1 HTML in web/, images/other files in web/images/</span><br><span class="line">N2 HTML in web/HTML, images/other in web/images</span><br><span class="line">N3 HTML in web/,  images/other in web/</span><br><span class="line">N4 HTML in web/, images/other in web/xxx, where xxx is the file extension (all gif will be placed onto web/gif, for example)</span><br><span class="line">N5 Images/other in web/xxx and HTML in web/HTML</span><br><span class="line">N99 All files in web/, with random names (gadget !)</span><br><span class="line">N100 站点结构，不包括www.domain.xxx/</span><br><span class="line">N101 Identical to N1 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N102 Identical to N2 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N103 Identical to N3 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N104 Identical to N4 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N105 Identical to N5 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N199 Identical to N99 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N1001 Identical to N1 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1002 Identical to N2 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1003 Identical to N3 exept that there is no &quot;web&quot; directory (option set for g option)</span><br><span class="line">N1004 Identical to N4 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1005 Identical to N5 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1099 Identical to N99 exept that there is no &quot;web&quot; directory</span><br></pre></td></tr></table></figure><h2 id="用户定义选项-N-详情-2"><a href="#用户定义选项-N-详情-2" class="headerlink" title="用户定义选项 N 详情"></a>用户定义选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;%n&#x27; 没有文件类型的文件名 (ex: image)</span><br><span class="line">&#x27;%N&#x27; 文件名，包括文件类型 (ex: image.gif)</span><br><span class="line">&#x27;%t&#x27; 文件类型 (ex: gif)</span><br><span class="line">&#x27;%p&#x27; 路径 [无结尾 /] (ex: /someimages)</span><br><span class="line">&#x27;%h&#x27; 主机名 (ex: www.someweb.com)</span><br><span class="line">&#x27;%M&#x27; URL MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%Q&#x27; 查询字符串MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%k&#x27; 完整查询字符串</span><br><span class="line">&#x27;%r&#x27; 协议名 (ex: http)</span><br><span class="line">&#x27;%q&#x27; 短查询字符串 (16位，4个ascii字节)</span><br><span class="line"> &#x27;%s?&#x27; 短名称版本 (ex: %sN)</span><br><span class="line">&#x27;%[param]&#x27; 查询字符串中的param变量</span><br><span class="line">&#x27;%[param:before:after:empty:notfound]&#x27; 高级变量提取</span><br></pre></td></tr></table></figure><h2 id="用户定义的选项-N-和高级变量提取详情-2"><a href="#用户定义的选项-N-和高级变量提取详情-2" class="headerlink" title="用户定义的选项 N 和高级变量提取详情"></a>用户定义的选项 N 和高级变量提取详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%[param:before:after:empty:notfound]</span><br><span class="line">param    参数名称</span><br><span class="line">before   如果找到参数，则在其前面加上字符串</span><br><span class="line">after    找到参数后要追加的字符串</span><br><span class="line">notfound 如果找不到参数，则替换字符串</span><br><span class="line">empty    如果参数为空，则替换字符串</span><br></pre></td></tr></table></figure><p>除第一个字段（参数名）外，所有字段都可以为空</p><h2 id="选项-K-详情-2"><a href="#选项-K-详情-2" class="headerlink" title="选项 K 详情"></a>选项 K 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K0  foo.cgi?q=45  -&gt;  foo4B54.html?q=45 (relative URI, default)</span><br><span class="line">K                 -&gt;  http://www.foobar.com/folder/foo.cgi?q=45 (absolute URL) (--keep-links[=N])</span><br><span class="line">K3                -&gt;  /folder/foo.cgi?q=45 (absolute URI)</span><br><span class="line">K4                -&gt;  foo.cgi?q=45 (original URL)</span><br><span class="line">K5                -&gt;  http://www.foobar.com/folder/foo4B54.html?q=45 (transparent proxy URL)</span><br></pre></td></tr></table></figure><h2 id="快捷操作-2"><a href="#快捷操作-2" class="headerlink" title="快捷操作"></a>快捷操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--mirror      &lt;URLs&gt; *制作站点的镜像 (default)</span><br><span class="line">--get         &lt;URLs&gt;  获取指定的文件，不要查找其他URL (-qg)</span><br><span class="line">--list   &lt;text file&gt;  添加此文本文件中的所有URL (-%L)</span><br><span class="line">--mirrorlinks &lt;URLs&gt;  镜像一级页面中的所有链接 (-Y)</span><br><span class="line">--testlinks   &lt;URLs&gt;  测试页面中的链接 (-r1p0C0I0t)</span><br><span class="line">--spider      &lt;URLs&gt;  爬取站点，用于测试链接:报告错误和警告 (-p0C0I0t)</span><br><span class="line">--testsite    &lt;URLs&gt;  与--spider相同</span><br><span class="line">--skeleton    &lt;URLs&gt;  创建镜像，但只获取html文件 (-p1)</span><br><span class="line">--update              更新镜像，无需确认 (-iC2)</span><br><span class="line">--continue            继续镜像，无需确认 (-iC1)</span><br><span class="line"></span><br><span class="line">--catchurl            创建一个临时代理来捕获一个URL或一个表单post URL</span><br><span class="line">--clean               删除缓存和日志文件</span><br><span class="line"></span><br><span class="line">--http10              强制http/1.0请求 (-%h)</span><br></pre></td></tr></table></figure><h1 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h1><ol><li><p>只镜像站点 <code>www.someweb.com/bob/</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/</span><br></pre></td></tr></table></figure></li><li><p>将两个站点镜像在一起（带有共享链接），并接受.com 站点上的任何.jpg 文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/ www.anothertest.com/mike/ +*.com/*.jpg -mime:application/*</span><br></pre></td></tr></table></figure></li><li><p>从 bobby.html 开始获取所有文件，具有 6 个链接深度，并且可以在 web 上到处访问；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html +* -r6</span><br></pre></td></tr></table></figure></li><li><p>使用代理在 <code>www.someweb.com/bob/bobby.html</code> 上运行爬虫；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html --spider -P proxy.myhost.com:8080</span><br></pre></td></tr></table></figure></li><li><p>更新当前文件夹中的镜像 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --update</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹中继续镜像；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --continue</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.httrack.com/html/fcguide.html">Httrack Users Guide</a></p><ol start="4"><li><p>选择存储网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base path (return=/root/websites/) :/root/mywebsite</span><br></pre></td></tr></table></figure><p>[# HTTrack 简单使用</p></li></ol><ul><li><strong>本文作者：</strong> 李钰璕</li><li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack 简单使用.html</a></li></ul><h1 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h1><p><code>HTTrack</code> 是一个免费的（GPL，自由软件）和易于使用的离线浏览器工具。它可以爬取整站的网页，用于离线浏览，减少与目标系统交互。它可从 <code>Internet</code> 上下载万维网站点到本地目录，递归地构建所有目录，从服务器获取 <code>HTML</code>、图像和其他文件到本地。<code>HTTrack</code> 安排原始网站的相关链接结构。只需在浏览器中打开 “镜像” 网站的页面，即可从链接到链接浏览网站，就像在线查看网站一样。<code>HTTrack</code> 也可以更新现有的镜像站点，并恢复中断的下载。<code>HTTrack</code> 完全可配置，并具有集成的帮助系统。</p><h1 id="HTTrack-安装-4"><a href="#HTTrack-安装-4" class="headerlink" title="HTTrack 安装"></a><code>HTTrack</code> 安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# apt-get install httrack</span><br></pre></td></tr></table></figure><h1 id="HTTrack-交互模式使用步骤-4"><a href="#HTTrack-交互模式使用步骤-4" class="headerlink" title="HTTrack 交互模式使用步骤"></a><code>HTTrack</code> 交互模式使用步骤</h1><ol><li><p>创建目录存储复制网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# mkdir mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png" alt="img"></a></p></li><li><p>启动 <code>HTTrack</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# httrack</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png" alt="img"></a></p></li><li><p>输入项目名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter project name : blog//blog为项目名称</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png" alt="img"></a></p></li><li><p>选择存储网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base path (return=/root/websites/) :/root/mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png" alt="img"></a></p></li><li><p>输入网站的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter URLs (separated by commas or blank spaces) :www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png" alt="img"></a></p></li><li><p>选择操作 (此处选择 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action:</span><br><span class="line">(enter) 1Mirror Web Site(s)//直接镜像站点</span><br><span class="line">        2Mirror Web Site(s) with Wizard//用向导完成镜像</span><br><span class="line">        3Just Get Files Indicated//只get某种特定的文件</span><br><span class="line">        4Mirror ALL links in URLs (Multiple Mirror)//镜像在这个url下所有的链接</span><br><span class="line">        5Test Links In URLs (Bookmark Test)//测试在这个url下的链接</span><br><span class="line">        0Quit//退出</span><br><span class="line">: </span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png" alt="img"></a></p></li><li><p>指定是否在实施攻击时使用代理 (此处默认输入 none，不使用代理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png" alt="img"></a></p></li><li><p>定义字符，爬取特定类型的数据 (此处输入 <code>*</code> 表示爬取全部类型数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip</span><br><span class="line">Wildcards (return=none) :*</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png" alt="img"></a></p></li><li><p>设置更多选项，可以使用 <code>help</code> 查看 (此处选择默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png" alt="img"></a></p></li><li><p>开始克隆网站</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png" alt="img"></a></p></li><li><p>查看克隆的文件</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png" alt="img"></a></p></li></ol><p>备注：<code>httrack</code> 只能用于克隆静态内容，并且无法完全复制网站上的动态内容、中间部分 (数据库) 等内容。</p><h1 id="HTTrack-一般模式使用步骤-3"><a href="#HTTrack-一般模式使用步骤-3" class="headerlink" title="HTTrack 一般模式使用步骤"></a><code>HTTrack</code> 一般模式使用步骤</h1><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack &lt;URLs&gt; [-option] [+&lt;URL_FILTER&gt;] [-&lt;URL_FILTER&gt;] [+&lt;mime:MIME_FILTER&gt;] [-&lt;mime:MIME_FILTER&gt;]</span><br></pre></td></tr></table></figure><p>选项如下：（* 为默认值）</p><h2 id="一般选项-3"><a href="#一般选项-3" class="headerlink" title="一般选项"></a>一般选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O  镜像路径/缓存和日志文件路径</span><br><span class="line">-O 镜像路径[,缓存和日志文件路径] (--path &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="行为选项-3"><a href="#行为选项-3" class="headerlink" title="行为选项"></a>行为选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w  *镜像网站 (--mirror)</span><br><span class="line">W镜像网站，半自动 (asks questions) (--mirror-wizard)</span><br><span class="line">g只获取文件（保存在当前目录中） (--get-files)</span><br><span class="line">i使用缓存继续中断的镜像 (--continue)</span><br><span class="line">Y镜像所有位于第一级页面的链接 (镜像链接) (--mirrorlinks)</span><br></pre></td></tr></table></figure><h2 id="代理选项-3"><a href="#代理选项-3" class="headerlink" title="代理选项"></a>代理选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   代理使用 (-P proxy:port or -P user:pass@proxy:port) (--proxy &lt;param&gt;)</span><br><span class="line">%f *使用ftp代理 (f0 don&#x27;t use) (--httpproxy-ftp[=N])</span><br><span class="line">%b  使用此本地主机名发出/发送请求 (-%b 主机名) (--bind &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="限制选项-3"><a href="#限制选项-3" class="headerlink" title="限制选项"></a>限制选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rN  将“镜像深度”设置为N (* r9999) (--depth[=N])</span><br><span class="line">%eN   将“外部链接深度”设置为N (* %e0) (--ext-depth[=N])</span><br><span class="line">mN    将非HTML文件的最大文件长度设置为N (--max-files[=N])</span><br><span class="line">mN,N2 将非HTML文件的最大文件长度设置为N、将HTML文件的最大文件长度设置为N2</span><br><span class="line">MN    将可上传/扫描的最大总长度设置为N (--max-size[=N])</span><br><span class="line">EN    将最大镜像传输时间设置为N秒 (60=1 minute, 3600=1 hour) (--max-time[=N])</span><br><span class="line">AN    将最大传输速率设置为N字节/秒 (1000=1KB/s max) (--max-rate[=N])</span><br><span class="line">%cN   将最大连接数设置为N个/秒 (*%c10) (--connection-per-second[=N])</span><br><span class="line">GN    设置如果达到N个字节，则暂停传输，并等待锁定文件被删除 (--max-pause[=N])</span><br></pre></td></tr></table></figure><h2 id="流量控制-3"><a href="#流量控制-3" class="headerlink" title="流量控制"></a>流量控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cN  设置连接数为N (*c8) (--sockets[=N])</span><br><span class="line">TN  设置关闭无响应链接N秒后超时 (--timeout)</span><br><span class="line">RN  设置超时或非致命错误情况下的重试次数为N (*R1) (--retries[=N])</span><br><span class="line">JN  流量阻塞控制，设置链路允许的最小传输速率为N字节/秒 (--min-rate[=N])</span><br><span class="line">HN  如果：0=从不、1=超时、2=慢、3=超时或慢，则放弃主机 (--host-control[=N])</span><br></pre></td></tr></table></figure><h2 id="链接选项-3"><a href="#链接选项-3" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%P        *扩展解析，尝试解析所有链接，即使是未知标记或Javascript标记 (%P0 don&#x27;t use) (--extended-parsing[=N])</span><br><span class="line">n          在html文件附近获取非html文件 (例如：位于外部的图像) (--near)</span><br><span class="line">t          测试所有url（即使url被禁止） (--test)</span><br><span class="line">%L &lt;file&gt;  添加位于此文本文件中的所有URL（每行一个URL）  (--list &lt;param&gt;)</span><br><span class="line">%S &lt;file&gt;  添加位于此文本文件中的所有扫描规则（每行一个扫描规则） (--urllist &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="构建选项-3"><a href="#构建选项-3" class="headerlink" title="构建选项"></a>构建选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NN结构类型 (0 *原始结构, 1+: 详见下文) (--structure[=N])</span><br><span class="line">    或用户定义的结构 (-N &quot;%h%p/%n%q.%t&quot;)</span><br><span class="line">%N  延迟类型检查，不进行任何链接测试，而是等待文件下载开始（实验性的）(N0 不使用，%N1 用于未知扩展名，*%N2 始终使用)</span><br><span class="line">%D  缓存的延迟类型检查，不要在更新期间等待远程类型，以加快更新速度 (%D0 等待, * %D1 不等待) (--cached-delayed-type-check)</span><br><span class="line">%M  生成RFC MIME封装的完整存档 (.mht) (--mime-html)</span><br><span class="line">LN长名称 (L1 *长名称 / L0 8-3 转换 / L2 ISO9660 兼容) (--long-names[=N])</span><br><span class="line">KN保留原始链接 (e.g. http://www.adr/link) (K0 *相对链接, K 绝对链接, K4 原始链接, K3 绝对URI链接, K5 透明代理链接) (--keep-links[=N])</span><br><span class="line">x用错误页替换外部html链接 (--replace-external)</span><br><span class="line">%x不包括受外部密码保护的网站的任何密码 (%x0 包括) (--disable-passwords)</span><br><span class="line">%q *包含本地文件的查询字符串 (无用,仅供参考) (%q0 不包含) (--include-query-string)</span><br><span class="line">o  *出错时生成输出html文件 (404..) (o0 不生成) (--generate-errors)</span><br><span class="line">X  *更新后清除旧文件 (X0 保持删除) (--purge-old[=N])</span><br><span class="line">%p保留html文件“原样” (与&#x27;-K4 -%F &quot;&quot;&#x27;相同) (--preserve)</span><br><span class="line">%T链接转换为UTF-8 (--utf8-conversion)</span><br></pre></td></tr></table></figure><h2 id="蜘蛛选项-3"><a href="#蜘蛛选项-3" class="headerlink" title="蜘蛛选项"></a>蜘蛛选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bN接受cookies.txt中的cookies (0=不接受,* 1=接受) (--cookies[=N])</span><br><span class="line">u检查未知文档类型 (cgi,asp..) (u0 不检查, * u1 检查除了 /, u2 始终检查) (--check-type[=N])</span><br><span class="line">j  *解析JAVA类 (j0 不解析, 位掩码: |1 解析默认值, |2 不解析.class文件 |4 不解析.js文件 |8 不越界解析) (--parse-java[=N])</span><br><span class="line">sN遵循robots.txt和meta robots标记 (0=never,1=sometimes,* 2=always, 3=always (even strict rules)) (--robots[=N])</span><br><span class="line">%h  强制HTTP/1请求 (仅针对旧服务器或代理减少更新特性) (--http-10)</span><br><span class="line">%k尽可能使用keep alive，大大减少小文件和测试请求的延迟 (%k0 不使用) (--keep-alive)</span><br><span class="line">%B  容忍请求 (在某些服务器上接受虚假响应，但不是标准的!) (--tolerant)</span><br><span class="line">%s  更新非法入侵：在更新时限制重新传输的各种非法入侵(相同大小，虚假响应…) (--updatehack)</span><br><span class="line">%u  url非法入侵：限制重复url的各种非法入侵 (strip //, www.foo.com==foo.com..) (--urlhack)</span><br><span class="line">%A  假设一个类型(cgi,asp..)总是与一个mime类型链接 (-%A php3,cgi=text/html;dat,bin=application/x-zip) (--assume &lt;param&gt;)</span><br><span class="line">     快捷方式：&#x27;--assume standard&#x27;相当于-%A php2 php3 php4 php cgi asp jsp pl cfm nsf=text/html</span><br><span class="line">     也可以用于强制特定的文件类型：-assume foo.cgi=text/html</span><br><span class="line">@iNinternet协议 (0=both ipv6+ipv4, 4=ipv4 only, 6=ipv6 only) (--protocol[=N])</span><br><span class="line">%w  禁用特定的外部mime模块 (-%w htsswf -%w htsjava) (--disable-module &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="浏览器-ID-3"><a href="#浏览器-ID-3" class="headerlink" title="浏览器 ID"></a>浏览器 ID</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F   在HTTP头中发送的用户代理字段 (-F &quot;user-agent name&quot;) (--user-agent &lt;param&gt;)</span><br><span class="line">%R  在HTTP头中发送的默认referer字段 (--referer &lt;param&gt;)</span><br><span class="line">%E  从以HTTP头发送的电子邮件地址 (--from &lt;param&gt;)</span><br><span class="line">%F  Html代码中的页脚字符串 (-%F &quot;Mirrored [from host %s [file %s [at %s]]]&quot; (--footer &lt;param&gt;)</span><br><span class="line">%l  首选语言 (-%l &quot;fr, en, jp, *&quot; (--language &lt;param&gt;)</span><br><span class="line">%a  接受格式 (-%a &quot;text/html,image/png;q=0.9,*/*;q=0.1&quot; (--accept &lt;param&gt;)</span><br><span class="line">%X  附加的HTTP标题行 (-%X &quot;X-Magic: 42&quot; (--headers &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="日志、索引、缓存-3"><a href="#日志、索引、缓存-3" class="headerlink" title="日志、索引、缓存"></a>日志、索引、缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C   创建/使用缓存进行更新和重试 (C0 无缓存,C1 缓存优先,* C2 测试更新前) (--cache[=N])</span><br><span class="line">k   将所有文件存储在缓存中 (如果文件在磁盘上，则此功能不可用) (--store-all-in-cache)</span><br><span class="line">%n  不能重新下载本地删除的文件 (--do-not-recatch)</span><br><span class="line">%v  在屏幕上显示下载的文件名(实时) - * %v1 缩写版 - %v2 完整 (--display)</span><br><span class="line">Q   无日志-安静模式  (--do-not-log)</span><br><span class="line">q   无问题-安静模式 (--quiet)</span><br><span class="line">z   日志-附加信息 (--extra-log)</span><br><span class="line">Z   日志-debug (--debug-log)</span><br><span class="line">v   登录屏幕 (--verbose)</span><br><span class="line">f  *登录文件 (--file-log)</span><br><span class="line">f2  一个单一日志文件(--single-log)</span><br><span class="line">I  *编制索引 (I0 不编制索引) (--index)</span><br><span class="line">%i  为项目文件夹创建顶级索引 (* %i0 不创建) (--build-top-index)</span><br><span class="line">%I  为此镜像创建可搜索索引 (* %I0 不创建) (--search-index)</span><br></pre></td></tr></table></figure><h2 id="专家选项-3"><a href="#专家选项-3" class="headerlink" title="专家选项"></a>专家选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pN  优先模式: (* p3) (--priority[=N])</span><br><span class="line">     p0 只扫描，不保存任何内容 (用于检查链接)</span><br><span class="line">     p1 只保存html文件</span><br><span class="line">     p2 只保存非html文件</span><br><span class="line">    *p3 保存所有文件</span><br><span class="line">     p7 先获取html文件，然后处理其他文件</span><br><span class="line">S   保持在同一个目录 (--stay-on-same-dir)</span><br><span class="line">D  *只能进入子目录 (--can-go-down)</span><br><span class="line">U   只能进入父目录 (--can-go-up)</span><br><span class="line">B   可以上下进入目录结构 (--can-go-up-and-down)</span><br><span class="line">a  *保持在同一地址 (--stay-on-same-address)</span><br><span class="line">d   保持在同一主域 (--stay-on-same-domain)</span><br><span class="line">l   保持相同的TLD (eg: .com) (--stay-on-same-tld)</span><br><span class="line">e   go everywhere on the web (--go-everywhere)</span><br><span class="line">%H  在日志文件中调试HTTP头 (--debug-headers)</span><br></pre></td></tr></table></figure><h2 id="权威选项-3"><a href="#权威选项-3" class="headerlink" title="权威选项"></a>权威选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#X  *使用优化引擎 (有限内存边界检查) (--fast-engine)</span><br><span class="line">#0   过滤测试 (-#0 &#x27;*.gif&#x27; &#x27;www.bar.com/foo.gif&#x27;) (--debug-testfilters &lt;param&gt;)</span><br><span class="line">#1   简化测试 (-#1 ./foo/bar/../foobar)</span><br><span class="line">#2   类型测试 (-#2 /foo/bar.php)</span><br><span class="line">#C   换成列表 (-#C &#x27;*.com/spider*.gif&#x27; (--debug-cache &lt;param&gt;)</span><br><span class="line">#R   缓存修复 (损坏缓存) (--repair-cache)</span><br><span class="line">#d   调试分析器 (--debug-parsing)</span><br><span class="line">#E   在meta.zip中提取new.zip缓存元数据</span><br><span class="line">#f   总是刷新日志文件 (--advanced-flushlogs)</span><br><span class="line">#FN  过滤器的最大过滤数目 (--advanced-maxfilters[=N])</span><br><span class="line">#h   版本信息 (--version)</span><br><span class="line">#K   扫描标准输入 (debug) (--debug-scanstdin)</span><br><span class="line">#L   最大链接数 (-#L1000000) (--advanced-maxlinks[=N])</span><br><span class="line">#p   显示进度信息 (--advanced-progressinfo)</span><br><span class="line">#P   抓取URL (--catch-url)</span><br><span class="line">#R   旧的FTP例程 (debug) (--repair-cache)</span><br><span class="line">#T   每分钟生成一次传输操作日志 (--debug-xfrstats)</span><br><span class="line">#u   等待时间 (--advanced-wait)</span><br><span class="line">#Z   每分钟生成传输速率的静态数据 (--debug-ratestats)</span><br></pre></td></tr></table></figure><h2 id="危险选项-3"><a href="#危险选项-3" class="headerlink" title="危险选项"></a>危险选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%!  绕过旨在避免带宽滥用的内置安全限制 (带宽，并发连接) (--disable-security-limits)</span><br></pre></td></tr></table></figure><p>危险选项，仅适用于专家；</p><p>谨慎使用；</p><h2 id="命令行特定选项-3"><a href="#命令行特定选项-3" class="headerlink" title="命令行特定选项"></a>命令行特定选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V   执行每个文件后的系统命令 ($0 is the filename: -V &quot;rm \$0&quot;) (--userdef-cmd &lt;param&gt;)</span><br><span class="line">%W  使用外部库函数作为包装器 (-%W myfoo.so[,myparameters]) (--callback &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="选项-N-详情-3"><a href="#选项-N-详情-3" class="headerlink" title="选项 N 详情"></a>选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N0 站点结构 (默认)</span><br><span class="line">N1 HTML in web/, images/other files in web/images/</span><br><span class="line">N2 HTML in web/HTML, images/other in web/images</span><br><span class="line">N3 HTML in web/,  images/other in web/</span><br><span class="line">N4 HTML in web/, images/other in web/xxx, where xxx is the file extension (all gif will be placed onto web/gif, for example)</span><br><span class="line">N5 Images/other in web/xxx and HTML in web/HTML</span><br><span class="line">N99 All files in web/, with random names (gadget !)</span><br><span class="line">N100 站点结构，不包括www.domain.xxx/</span><br><span class="line">N101 Identical to N1 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N102 Identical to N2 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N103 Identical to N3 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N104 Identical to N4 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N105 Identical to N5 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N199 Identical to N99 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N1001 Identical to N1 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1002 Identical to N2 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1003 Identical to N3 exept that there is no &quot;web&quot; directory (option set for g option)</span><br><span class="line">N1004 Identical to N4 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1005 Identical to N5 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1099 Identical to N99 exept that there is no &quot;web&quot; directory</span><br></pre></td></tr></table></figure><h2 id="用户定义选项-N-详情-3"><a href="#用户定义选项-N-详情-3" class="headerlink" title="用户定义选项 N 详情"></a>用户定义选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;%n&#x27; 没有文件类型的文件名 (ex: image)</span><br><span class="line">&#x27;%N&#x27; 文件名，包括文件类型 (ex: image.gif)</span><br><span class="line">&#x27;%t&#x27; 文件类型 (ex: gif)</span><br><span class="line">&#x27;%p&#x27; 路径 [无结尾 /] (ex: /someimages)</span><br><span class="line">&#x27;%h&#x27; 主机名 (ex: www.someweb.com)</span><br><span class="line">&#x27;%M&#x27; URL MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%Q&#x27; 查询字符串MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%k&#x27; 完整查询字符串</span><br><span class="line">&#x27;%r&#x27; 协议名 (ex: http)</span><br><span class="line">&#x27;%q&#x27; 短查询字符串 (16位，4个ascii字节)</span><br><span class="line"> &#x27;%s?&#x27; 短名称版本 (ex: %sN)</span><br><span class="line">&#x27;%[param]&#x27; 查询字符串中的param变量</span><br><span class="line">&#x27;%[param:before:after:empty:notfound]&#x27; 高级变量提取</span><br></pre></td></tr></table></figure><h2 id="用户定义的选项-N-和高级变量提取详情-3"><a href="#用户定义的选项-N-和高级变量提取详情-3" class="headerlink" title="用户定义的选项 N 和高级变量提取详情"></a>用户定义的选项 N 和高级变量提取详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%[param:before:after:empty:notfound]</span><br><span class="line">param    参数名称</span><br><span class="line">before   如果找到参数，则在其前面加上字符串</span><br><span class="line">after    找到参数后要追加的字符串</span><br><span class="line">notfound 如果找不到参数，则替换字符串</span><br><span class="line">empty    如果参数为空，则替换字符串</span><br></pre></td></tr></table></figure><p>除第一个字段（参数名）外，所有字段都可以为空</p><h2 id="选项-K-详情-3"><a href="#选项-K-详情-3" class="headerlink" title="选项 K 详情"></a>选项 K 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K0  foo.cgi?q=45  -&gt;  foo4B54.html?q=45 (relative URI, default)</span><br><span class="line">K                 -&gt;  http://www.foobar.com/folder/foo.cgi?q=45 (absolute URL) (--keep-links[=N])</span><br><span class="line">K3                -&gt;  /folder/foo.cgi?q=45 (absolute URI)</span><br><span class="line">K4                -&gt;  foo.cgi?q=45 (original URL)</span><br><span class="line">K5                -&gt;  http://www.foobar.com/folder/foo4B54.html?q=45 (transparent proxy URL)</span><br></pre></td></tr></table></figure><h2 id="快捷操作-3"><a href="#快捷操作-3" class="headerlink" title="快捷操作"></a>快捷操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--mirror      &lt;URLs&gt; *制作站点的镜像 (default)</span><br><span class="line">--get         &lt;URLs&gt;  获取指定的文件，不要查找其他URL (-qg)</span><br><span class="line">--list   &lt;text file&gt;  添加此文本文件中的所有URL (-%L)</span><br><span class="line">--mirrorlinks &lt;URLs&gt;  镜像一级页面中的所有链接 (-Y)</span><br><span class="line">--testlinks   &lt;URLs&gt;  测试页面中的链接 (-r1p0C0I0t)</span><br><span class="line">--spider      &lt;URLs&gt;  爬取站点，用于测试链接:报告错误和警告 (-p0C0I0t)</span><br><span class="line">--testsite    &lt;URLs&gt;  与--spider相同</span><br><span class="line">--skeleton    &lt;URLs&gt;  创建镜像，但只获取html文件 (-p1)</span><br><span class="line">--update              更新镜像，无需确认 (-iC2)</span><br><span class="line">--continue            继续镜像，无需确认 (-iC1)</span><br><span class="line"></span><br><span class="line">--catchurl            创建一个临时代理来捕获一个URL或一个表单post URL</span><br><span class="line">--clean               删除缓存和日志文件</span><br><span class="line"></span><br><span class="line">--http10              强制http/1.0请求 (-%h)</span><br></pre></td></tr></table></figure><h1 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h1><ol><li><p>只镜像站点 <code>www.someweb.com/bob/</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/</span><br></pre></td></tr></table></figure></li><li><p>将两个站点镜像在一起（带有共享链接），并接受.com 站点上的任何.jpg 文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/ www.anothertest.com/mike/ +*.com/*.jpg -mime:application/*</span><br></pre></td></tr></table></figure></li><li><p>从 bobby.html 开始获取所有文件，具有 6 个链接深度，并且可以在 web 上到处访问；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html +* -r6</span><br></pre></td></tr></table></figure></li><li><p>使用代理在 <code>www.someweb.com/bob/bobby.html</code> 上运行爬虫；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html --spider -P proxy.myhost.com:8080</span><br></pre></td></tr></table></figure></li><li><p>更新当前文件夹中的镜像 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --update</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹中继续镜像；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --continue</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.httrack.com/html/fcguide.html">Httrack Users Guide</a></p><ol start="5"><li><p>输入网站的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter URLs (separated by commas or blank spaces) :www.baidu.com</span><br></pre></td></tr></table></figure><p>[# HTTrack 简单使用</p></li></ol><ul><li><strong>本文作者：</strong> 李钰璕</li><li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack 简单使用.html</a></li></ul><h1 id="前言-5"><a href="#前言-5" class="headerlink" title="前言"></a>前言</h1><p><code>HTTrack</code> 是一个免费的（GPL，自由软件）和易于使用的离线浏览器工具。它可以爬取整站的网页，用于离线浏览，减少与目标系统交互。它可从 <code>Internet</code> 上下载万维网站点到本地目录，递归地构建所有目录，从服务器获取 <code>HTML</code>、图像和其他文件到本地。<code>HTTrack</code> 安排原始网站的相关链接结构。只需在浏览器中打开 “镜像” 网站的页面，即可从链接到链接浏览网站，就像在线查看网站一样。<code>HTTrack</code> 也可以更新现有的镜像站点，并恢复中断的下载。<code>HTTrack</code> 完全可配置，并具有集成的帮助系统。</p><h1 id="HTTrack-安装-5"><a href="#HTTrack-安装-5" class="headerlink" title="HTTrack 安装"></a><code>HTTrack</code> 安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# apt-get install httrack</span><br></pre></td></tr></table></figure><h1 id="HTTrack-交互模式使用步骤-5"><a href="#HTTrack-交互模式使用步骤-5" class="headerlink" title="HTTrack 交互模式使用步骤"></a><code>HTTrack</code> 交互模式使用步骤</h1><ol><li><p>创建目录存储复制网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# mkdir mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png" alt="img"></a></p></li><li><p>启动 <code>HTTrack</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# httrack</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png" alt="img"></a></p></li><li><p>输入项目名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter project name : blog//blog为项目名称</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png" alt="img"></a></p></li><li><p>选择存储网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base path (return=/root/websites/) :/root/mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png" alt="img"></a></p></li><li><p>输入网站的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter URLs (separated by commas or blank spaces) :www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png" alt="img"></a></p></li><li><p>选择操作 (此处选择 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action:</span><br><span class="line">(enter) 1Mirror Web Site(s)//直接镜像站点</span><br><span class="line">        2Mirror Web Site(s) with Wizard//用向导完成镜像</span><br><span class="line">        3Just Get Files Indicated//只get某种特定的文件</span><br><span class="line">        4Mirror ALL links in URLs (Multiple Mirror)//镜像在这个url下所有的链接</span><br><span class="line">        5Test Links In URLs (Bookmark Test)//测试在这个url下的链接</span><br><span class="line">        0Quit//退出</span><br><span class="line">: </span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png" alt="img"></a></p></li><li><p>指定是否在实施攻击时使用代理 (此处默认输入 none，不使用代理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png" alt="img"></a></p></li><li><p>定义字符，爬取特定类型的数据 (此处输入 <code>*</code> 表示爬取全部类型数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip</span><br><span class="line">Wildcards (return=none) :*</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png" alt="img"></a></p></li><li><p>设置更多选项，可以使用 <code>help</code> 查看 (此处选择默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png" alt="img"></a></p></li><li><p>开始克隆网站</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png" alt="img"></a></p></li><li><p>查看克隆的文件</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png" alt="img"></a></p></li></ol><p>备注：<code>httrack</code> 只能用于克隆静态内容，并且无法完全复制网站上的动态内容、中间部分 (数据库) 等内容。</p><h1 id="HTTrack-一般模式使用步骤-4"><a href="#HTTrack-一般模式使用步骤-4" class="headerlink" title="HTTrack 一般模式使用步骤"></a><code>HTTrack</code> 一般模式使用步骤</h1><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack &lt;URLs&gt; [-option] [+&lt;URL_FILTER&gt;] [-&lt;URL_FILTER&gt;] [+&lt;mime:MIME_FILTER&gt;] [-&lt;mime:MIME_FILTER&gt;]</span><br></pre></td></tr></table></figure><p>选项如下：（* 为默认值）</p><h2 id="一般选项-4"><a href="#一般选项-4" class="headerlink" title="一般选项"></a>一般选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O  镜像路径/缓存和日志文件路径</span><br><span class="line">-O 镜像路径[,缓存和日志文件路径] (--path &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="行为选项-4"><a href="#行为选项-4" class="headerlink" title="行为选项"></a>行为选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w  *镜像网站 (--mirror)</span><br><span class="line">W镜像网站，半自动 (asks questions) (--mirror-wizard)</span><br><span class="line">g只获取文件（保存在当前目录中） (--get-files)</span><br><span class="line">i使用缓存继续中断的镜像 (--continue)</span><br><span class="line">Y镜像所有位于第一级页面的链接 (镜像链接) (--mirrorlinks)</span><br></pre></td></tr></table></figure><h2 id="代理选项-4"><a href="#代理选项-4" class="headerlink" title="代理选项"></a>代理选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   代理使用 (-P proxy:port or -P user:pass@proxy:port) (--proxy &lt;param&gt;)</span><br><span class="line">%f *使用ftp代理 (f0 don&#x27;t use) (--httpproxy-ftp[=N])</span><br><span class="line">%b  使用此本地主机名发出/发送请求 (-%b 主机名) (--bind &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="限制选项-4"><a href="#限制选项-4" class="headerlink" title="限制选项"></a>限制选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rN  将“镜像深度”设置为N (* r9999) (--depth[=N])</span><br><span class="line">%eN   将“外部链接深度”设置为N (* %e0) (--ext-depth[=N])</span><br><span class="line">mN    将非HTML文件的最大文件长度设置为N (--max-files[=N])</span><br><span class="line">mN,N2 将非HTML文件的最大文件长度设置为N、将HTML文件的最大文件长度设置为N2</span><br><span class="line">MN    将可上传/扫描的最大总长度设置为N (--max-size[=N])</span><br><span class="line">EN    将最大镜像传输时间设置为N秒 (60=1 minute, 3600=1 hour) (--max-time[=N])</span><br><span class="line">AN    将最大传输速率设置为N字节/秒 (1000=1KB/s max) (--max-rate[=N])</span><br><span class="line">%cN   将最大连接数设置为N个/秒 (*%c10) (--connection-per-second[=N])</span><br><span class="line">GN    设置如果达到N个字节，则暂停传输，并等待锁定文件被删除 (--max-pause[=N])</span><br></pre></td></tr></table></figure><h2 id="流量控制-4"><a href="#流量控制-4" class="headerlink" title="流量控制"></a>流量控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cN  设置连接数为N (*c8) (--sockets[=N])</span><br><span class="line">TN  设置关闭无响应链接N秒后超时 (--timeout)</span><br><span class="line">RN  设置超时或非致命错误情况下的重试次数为N (*R1) (--retries[=N])</span><br><span class="line">JN  流量阻塞控制，设置链路允许的最小传输速率为N字节/秒 (--min-rate[=N])</span><br><span class="line">HN  如果：0=从不、1=超时、2=慢、3=超时或慢，则放弃主机 (--host-control[=N])</span><br></pre></td></tr></table></figure><h2 id="链接选项-4"><a href="#链接选项-4" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%P        *扩展解析，尝试解析所有链接，即使是未知标记或Javascript标记 (%P0 don&#x27;t use) (--extended-parsing[=N])</span><br><span class="line">n          在html文件附近获取非html文件 (例如：位于外部的图像) (--near)</span><br><span class="line">t          测试所有url（即使url被禁止） (--test)</span><br><span class="line">%L &lt;file&gt;  添加位于此文本文件中的所有URL（每行一个URL）  (--list &lt;param&gt;)</span><br><span class="line">%S &lt;file&gt;  添加位于此文本文件中的所有扫描规则（每行一个扫描规则） (--urllist &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="构建选项-4"><a href="#构建选项-4" class="headerlink" title="构建选项"></a>构建选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NN结构类型 (0 *原始结构, 1+: 详见下文) (--structure[=N])</span><br><span class="line">    或用户定义的结构 (-N &quot;%h%p/%n%q.%t&quot;)</span><br><span class="line">%N  延迟类型检查，不进行任何链接测试，而是等待文件下载开始（实验性的）(N0 不使用，%N1 用于未知扩展名，*%N2 始终使用)</span><br><span class="line">%D  缓存的延迟类型检查，不要在更新期间等待远程类型，以加快更新速度 (%D0 等待, * %D1 不等待) (--cached-delayed-type-check)</span><br><span class="line">%M  生成RFC MIME封装的完整存档 (.mht) (--mime-html)</span><br><span class="line">LN长名称 (L1 *长名称 / L0 8-3 转换 / L2 ISO9660 兼容) (--long-names[=N])</span><br><span class="line">KN保留原始链接 (e.g. http://www.adr/link) (K0 *相对链接, K 绝对链接, K4 原始链接, K3 绝对URI链接, K5 透明代理链接) (--keep-links[=N])</span><br><span class="line">x用错误页替换外部html链接 (--replace-external)</span><br><span class="line">%x不包括受外部密码保护的网站的任何密码 (%x0 包括) (--disable-passwords)</span><br><span class="line">%q *包含本地文件的查询字符串 (无用,仅供参考) (%q0 不包含) (--include-query-string)</span><br><span class="line">o  *出错时生成输出html文件 (404..) (o0 不生成) (--generate-errors)</span><br><span class="line">X  *更新后清除旧文件 (X0 保持删除) (--purge-old[=N])</span><br><span class="line">%p保留html文件“原样” (与&#x27;-K4 -%F &quot;&quot;&#x27;相同) (--preserve)</span><br><span class="line">%T链接转换为UTF-8 (--utf8-conversion)</span><br></pre></td></tr></table></figure><h2 id="蜘蛛选项-4"><a href="#蜘蛛选项-4" class="headerlink" title="蜘蛛选项"></a>蜘蛛选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bN接受cookies.txt中的cookies (0=不接受,* 1=接受) (--cookies[=N])</span><br><span class="line">u检查未知文档类型 (cgi,asp..) (u0 不检查, * u1 检查除了 /, u2 始终检查) (--check-type[=N])</span><br><span class="line">j  *解析JAVA类 (j0 不解析, 位掩码: |1 解析默认值, |2 不解析.class文件 |4 不解析.js文件 |8 不越界解析) (--parse-java[=N])</span><br><span class="line">sN遵循robots.txt和meta robots标记 (0=never,1=sometimes,* 2=always, 3=always (even strict rules)) (--robots[=N])</span><br><span class="line">%h  强制HTTP/1请求 (仅针对旧服务器或代理减少更新特性) (--http-10)</span><br><span class="line">%k尽可能使用keep alive，大大减少小文件和测试请求的延迟 (%k0 不使用) (--keep-alive)</span><br><span class="line">%B  容忍请求 (在某些服务器上接受虚假响应，但不是标准的!) (--tolerant)</span><br><span class="line">%s  更新非法入侵：在更新时限制重新传输的各种非法入侵(相同大小，虚假响应…) (--updatehack)</span><br><span class="line">%u  url非法入侵：限制重复url的各种非法入侵 (strip //, www.foo.com==foo.com..) (--urlhack)</span><br><span class="line">%A  假设一个类型(cgi,asp..)总是与一个mime类型链接 (-%A php3,cgi=text/html;dat,bin=application/x-zip) (--assume &lt;param&gt;)</span><br><span class="line">     快捷方式：&#x27;--assume standard&#x27;相当于-%A php2 php3 php4 php cgi asp jsp pl cfm nsf=text/html</span><br><span class="line">     也可以用于强制特定的文件类型：-assume foo.cgi=text/html</span><br><span class="line">@iNinternet协议 (0=both ipv6+ipv4, 4=ipv4 only, 6=ipv6 only) (--protocol[=N])</span><br><span class="line">%w  禁用特定的外部mime模块 (-%w htsswf -%w htsjava) (--disable-module &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="浏览器-ID-4"><a href="#浏览器-ID-4" class="headerlink" title="浏览器 ID"></a>浏览器 ID</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F   在HTTP头中发送的用户代理字段 (-F &quot;user-agent name&quot;) (--user-agent &lt;param&gt;)</span><br><span class="line">%R  在HTTP头中发送的默认referer字段 (--referer &lt;param&gt;)</span><br><span class="line">%E  从以HTTP头发送的电子邮件地址 (--from &lt;param&gt;)</span><br><span class="line">%F  Html代码中的页脚字符串 (-%F &quot;Mirrored [from host %s [file %s [at %s]]]&quot; (--footer &lt;param&gt;)</span><br><span class="line">%l  首选语言 (-%l &quot;fr, en, jp, *&quot; (--language &lt;param&gt;)</span><br><span class="line">%a  接受格式 (-%a &quot;text/html,image/png;q=0.9,*/*;q=0.1&quot; (--accept &lt;param&gt;)</span><br><span class="line">%X  附加的HTTP标题行 (-%X &quot;X-Magic: 42&quot; (--headers &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="日志、索引、缓存-4"><a href="#日志、索引、缓存-4" class="headerlink" title="日志、索引、缓存"></a>日志、索引、缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C   创建/使用缓存进行更新和重试 (C0 无缓存,C1 缓存优先,* C2 测试更新前) (--cache[=N])</span><br><span class="line">k   将所有文件存储在缓存中 (如果文件在磁盘上，则此功能不可用) (--store-all-in-cache)</span><br><span class="line">%n  不能重新下载本地删除的文件 (--do-not-recatch)</span><br><span class="line">%v  在屏幕上显示下载的文件名(实时) - * %v1 缩写版 - %v2 完整 (--display)</span><br><span class="line">Q   无日志-安静模式  (--do-not-log)</span><br><span class="line">q   无问题-安静模式 (--quiet)</span><br><span class="line">z   日志-附加信息 (--extra-log)</span><br><span class="line">Z   日志-debug (--debug-log)</span><br><span class="line">v   登录屏幕 (--verbose)</span><br><span class="line">f  *登录文件 (--file-log)</span><br><span class="line">f2  一个单一日志文件(--single-log)</span><br><span class="line">I  *编制索引 (I0 不编制索引) (--index)</span><br><span class="line">%i  为项目文件夹创建顶级索引 (* %i0 不创建) (--build-top-index)</span><br><span class="line">%I  为此镜像创建可搜索索引 (* %I0 不创建) (--search-index)</span><br></pre></td></tr></table></figure><h2 id="专家选项-4"><a href="#专家选项-4" class="headerlink" title="专家选项"></a>专家选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pN  优先模式: (* p3) (--priority[=N])</span><br><span class="line">     p0 只扫描，不保存任何内容 (用于检查链接)</span><br><span class="line">     p1 只保存html文件</span><br><span class="line">     p2 只保存非html文件</span><br><span class="line">    *p3 保存所有文件</span><br><span class="line">     p7 先获取html文件，然后处理其他文件</span><br><span class="line">S   保持在同一个目录 (--stay-on-same-dir)</span><br><span class="line">D  *只能进入子目录 (--can-go-down)</span><br><span class="line">U   只能进入父目录 (--can-go-up)</span><br><span class="line">B   可以上下进入目录结构 (--can-go-up-and-down)</span><br><span class="line">a  *保持在同一地址 (--stay-on-same-address)</span><br><span class="line">d   保持在同一主域 (--stay-on-same-domain)</span><br><span class="line">l   保持相同的TLD (eg: .com) (--stay-on-same-tld)</span><br><span class="line">e   go everywhere on the web (--go-everywhere)</span><br><span class="line">%H  在日志文件中调试HTTP头 (--debug-headers)</span><br></pre></td></tr></table></figure><h2 id="权威选项-4"><a href="#权威选项-4" class="headerlink" title="权威选项"></a>权威选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#X  *使用优化引擎 (有限内存边界检查) (--fast-engine)</span><br><span class="line">#0   过滤测试 (-#0 &#x27;*.gif&#x27; &#x27;www.bar.com/foo.gif&#x27;) (--debug-testfilters &lt;param&gt;)</span><br><span class="line">#1   简化测试 (-#1 ./foo/bar/../foobar)</span><br><span class="line">#2   类型测试 (-#2 /foo/bar.php)</span><br><span class="line">#C   换成列表 (-#C &#x27;*.com/spider*.gif&#x27; (--debug-cache &lt;param&gt;)</span><br><span class="line">#R   缓存修复 (损坏缓存) (--repair-cache)</span><br><span class="line">#d   调试分析器 (--debug-parsing)</span><br><span class="line">#E   在meta.zip中提取new.zip缓存元数据</span><br><span class="line">#f   总是刷新日志文件 (--advanced-flushlogs)</span><br><span class="line">#FN  过滤器的最大过滤数目 (--advanced-maxfilters[=N])</span><br><span class="line">#h   版本信息 (--version)</span><br><span class="line">#K   扫描标准输入 (debug) (--debug-scanstdin)</span><br><span class="line">#L   最大链接数 (-#L1000000) (--advanced-maxlinks[=N])</span><br><span class="line">#p   显示进度信息 (--advanced-progressinfo)</span><br><span class="line">#P   抓取URL (--catch-url)</span><br><span class="line">#R   旧的FTP例程 (debug) (--repair-cache)</span><br><span class="line">#T   每分钟生成一次传输操作日志 (--debug-xfrstats)</span><br><span class="line">#u   等待时间 (--advanced-wait)</span><br><span class="line">#Z   每分钟生成传输速率的静态数据 (--debug-ratestats)</span><br></pre></td></tr></table></figure><h2 id="危险选项-4"><a href="#危险选项-4" class="headerlink" title="危险选项"></a>危险选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%!  绕过旨在避免带宽滥用的内置安全限制 (带宽，并发连接) (--disable-security-limits)</span><br></pre></td></tr></table></figure><p>危险选项，仅适用于专家；</p><p>谨慎使用；</p><h2 id="命令行特定选项-4"><a href="#命令行特定选项-4" class="headerlink" title="命令行特定选项"></a>命令行特定选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V   执行每个文件后的系统命令 ($0 is the filename: -V &quot;rm \$0&quot;) (--userdef-cmd &lt;param&gt;)</span><br><span class="line">%W  使用外部库函数作为包装器 (-%W myfoo.so[,myparameters]) (--callback &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="选项-N-详情-4"><a href="#选项-N-详情-4" class="headerlink" title="选项 N 详情"></a>选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N0 站点结构 (默认)</span><br><span class="line">N1 HTML in web/, images/other files in web/images/</span><br><span class="line">N2 HTML in web/HTML, images/other in web/images</span><br><span class="line">N3 HTML in web/,  images/other in web/</span><br><span class="line">N4 HTML in web/, images/other in web/xxx, where xxx is the file extension (all gif will be placed onto web/gif, for example)</span><br><span class="line">N5 Images/other in web/xxx and HTML in web/HTML</span><br><span class="line">N99 All files in web/, with random names (gadget !)</span><br><span class="line">N100 站点结构，不包括www.domain.xxx/</span><br><span class="line">N101 Identical to N1 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N102 Identical to N2 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N103 Identical to N3 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N104 Identical to N4 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N105 Identical to N5 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N199 Identical to N99 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N1001 Identical to N1 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1002 Identical to N2 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1003 Identical to N3 exept that there is no &quot;web&quot; directory (option set for g option)</span><br><span class="line">N1004 Identical to N4 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1005 Identical to N5 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1099 Identical to N99 exept that there is no &quot;web&quot; directory</span><br></pre></td></tr></table></figure><h2 id="用户定义选项-N-详情-4"><a href="#用户定义选项-N-详情-4" class="headerlink" title="用户定义选项 N 详情"></a>用户定义选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;%n&#x27; 没有文件类型的文件名 (ex: image)</span><br><span class="line">&#x27;%N&#x27; 文件名，包括文件类型 (ex: image.gif)</span><br><span class="line">&#x27;%t&#x27; 文件类型 (ex: gif)</span><br><span class="line">&#x27;%p&#x27; 路径 [无结尾 /] (ex: /someimages)</span><br><span class="line">&#x27;%h&#x27; 主机名 (ex: www.someweb.com)</span><br><span class="line">&#x27;%M&#x27; URL MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%Q&#x27; 查询字符串MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%k&#x27; 完整查询字符串</span><br><span class="line">&#x27;%r&#x27; 协议名 (ex: http)</span><br><span class="line">&#x27;%q&#x27; 短查询字符串 (16位，4个ascii字节)</span><br><span class="line"> &#x27;%s?&#x27; 短名称版本 (ex: %sN)</span><br><span class="line">&#x27;%[param]&#x27; 查询字符串中的param变量</span><br><span class="line">&#x27;%[param:before:after:empty:notfound]&#x27; 高级变量提取</span><br></pre></td></tr></table></figure><h2 id="用户定义的选项-N-和高级变量提取详情-4"><a href="#用户定义的选项-N-和高级变量提取详情-4" class="headerlink" title="用户定义的选项 N 和高级变量提取详情"></a>用户定义的选项 N 和高级变量提取详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%[param:before:after:empty:notfound]</span><br><span class="line">param    参数名称</span><br><span class="line">before   如果找到参数，则在其前面加上字符串</span><br><span class="line">after    找到参数后要追加的字符串</span><br><span class="line">notfound 如果找不到参数，则替换字符串</span><br><span class="line">empty    如果参数为空，则替换字符串</span><br></pre></td></tr></table></figure><p>除第一个字段（参数名）外，所有字段都可以为空</p><h2 id="选项-K-详情-4"><a href="#选项-K-详情-4" class="headerlink" title="选项 K 详情"></a>选项 K 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K0  foo.cgi?q=45  -&gt;  foo4B54.html?q=45 (relative URI, default)</span><br><span class="line">K                 -&gt;  http://www.foobar.com/folder/foo.cgi?q=45 (absolute URL) (--keep-links[=N])</span><br><span class="line">K3                -&gt;  /folder/foo.cgi?q=45 (absolute URI)</span><br><span class="line">K4                -&gt;  foo.cgi?q=45 (original URL)</span><br><span class="line">K5                -&gt;  http://www.foobar.com/folder/foo4B54.html?q=45 (transparent proxy URL)</span><br></pre></td></tr></table></figure><h2 id="快捷操作-4"><a href="#快捷操作-4" class="headerlink" title="快捷操作"></a>快捷操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--mirror      &lt;URLs&gt; *制作站点的镜像 (default)</span><br><span class="line">--get         &lt;URLs&gt;  获取指定的文件，不要查找其他URL (-qg)</span><br><span class="line">--list   &lt;text file&gt;  添加此文本文件中的所有URL (-%L)</span><br><span class="line">--mirrorlinks &lt;URLs&gt;  镜像一级页面中的所有链接 (-Y)</span><br><span class="line">--testlinks   &lt;URLs&gt;  测试页面中的链接 (-r1p0C0I0t)</span><br><span class="line">--spider      &lt;URLs&gt;  爬取站点，用于测试链接:报告错误和警告 (-p0C0I0t)</span><br><span class="line">--testsite    &lt;URLs&gt;  与--spider相同</span><br><span class="line">--skeleton    &lt;URLs&gt;  创建镜像，但只获取html文件 (-p1)</span><br><span class="line">--update              更新镜像，无需确认 (-iC2)</span><br><span class="line">--continue            继续镜像，无需确认 (-iC1)</span><br><span class="line"></span><br><span class="line">--catchurl            创建一个临时代理来捕获一个URL或一个表单post URL</span><br><span class="line">--clean               删除缓存和日志文件</span><br><span class="line"></span><br><span class="line">--http10              强制http/1.0请求 (-%h)</span><br></pre></td></tr></table></figure><h1 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h1><ol><li><p>只镜像站点 <code>www.someweb.com/bob/</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/</span><br></pre></td></tr></table></figure></li><li><p>将两个站点镜像在一起（带有共享链接），并接受.com 站点上的任何.jpg 文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/ www.anothertest.com/mike/ +*.com/*.jpg -mime:application/*</span><br></pre></td></tr></table></figure></li><li><p>从 bobby.html 开始获取所有文件，具有 6 个链接深度，并且可以在 web 上到处访问；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html +* -r6</span><br></pre></td></tr></table></figure></li><li><p>使用代理在 <code>www.someweb.com/bob/bobby.html</code> 上运行爬虫；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html --spider -P proxy.myhost.com:8080</span><br></pre></td></tr></table></figure></li><li><p>更新当前文件夹中的镜像 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --update</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹中继续镜像；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --continue</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.httrack.com/html/fcguide.html">Httrack Users Guide</a></p><ol start="6"><li><p>选择操作 (此处选择 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action:</span><br><span class="line">(enter) 1Mirror Web Site(s)//直接镜像站点</span><br><span class="line">        2Mirror Web Site(s) with Wizard//用向导完成镜像</span><br><span class="line">        3Just Get Files Indicated//只get某种特定的文件</span><br><span class="line">        4Mirror ALL links in URLs (Multiple Mirror)//镜像在这个url下所有的链接</span><br><span class="line">        5Test Links In URLs (Bookmark Test)//测试在这个url下的链接</span><br><span class="line">        0Quit//退出</span><br><span class="line">: </span><br></pre></td></tr></table></figure><p>[# HTTrack 简单使用</p></li></ol><ul><li><strong>本文作者：</strong> 李钰璕</li><li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack 简单使用.html</a></li></ul><h1 id="前言-6"><a href="#前言-6" class="headerlink" title="前言"></a>前言</h1><p><code>HTTrack</code> 是一个免费的（GPL，自由软件）和易于使用的离线浏览器工具。它可以爬取整站的网页，用于离线浏览，减少与目标系统交互。它可从 <code>Internet</code> 上下载万维网站点到本地目录，递归地构建所有目录，从服务器获取 <code>HTML</code>、图像和其他文件到本地。<code>HTTrack</code> 安排原始网站的相关链接结构。只需在浏览器中打开 “镜像” 网站的页面，即可从链接到链接浏览网站，就像在线查看网站一样。<code>HTTrack</code> 也可以更新现有的镜像站点，并恢复中断的下载。<code>HTTrack</code> 完全可配置，并具有集成的帮助系统。</p><h1 id="HTTrack-安装-6"><a href="#HTTrack-安装-6" class="headerlink" title="HTTrack 安装"></a><code>HTTrack</code> 安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# apt-get install httrack</span><br></pre></td></tr></table></figure><h1 id="HTTrack-交互模式使用步骤-6"><a href="#HTTrack-交互模式使用步骤-6" class="headerlink" title="HTTrack 交互模式使用步骤"></a><code>HTTrack</code> 交互模式使用步骤</h1><ol><li><p>创建目录存储复制网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# mkdir mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png" alt="img"></a></p></li><li><p>启动 <code>HTTrack</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# httrack</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png" alt="img"></a></p></li><li><p>输入项目名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter project name : blog//blog为项目名称</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png" alt="img"></a></p></li><li><p>选择存储网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base path (return=/root/websites/) :/root/mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png" alt="img"></a></p></li><li><p>输入网站的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter URLs (separated by commas or blank spaces) :www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png" alt="img"></a></p></li><li><p>选择操作 (此处选择 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action:</span><br><span class="line">(enter) 1Mirror Web Site(s)//直接镜像站点</span><br><span class="line">        2Mirror Web Site(s) with Wizard//用向导完成镜像</span><br><span class="line">        3Just Get Files Indicated//只get某种特定的文件</span><br><span class="line">        4Mirror ALL links in URLs (Multiple Mirror)//镜像在这个url下所有的链接</span><br><span class="line">        5Test Links In URLs (Bookmark Test)//测试在这个url下的链接</span><br><span class="line">        0Quit//退出</span><br><span class="line">: </span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png" alt="img"></a></p></li><li><p>指定是否在实施攻击时使用代理 (此处默认输入 none，不使用代理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png" alt="img"></a></p></li><li><p>定义字符，爬取特定类型的数据 (此处输入 <code>*</code> 表示爬取全部类型数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip</span><br><span class="line">Wildcards (return=none) :*</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png" alt="img"></a></p></li><li><p>设置更多选项，可以使用 <code>help</code> 查看 (此处选择默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png" alt="img"></a></p></li><li><p>开始克隆网站</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png" alt="img"></a></p></li><li><p>查看克隆的文件</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png" alt="img"></a></p></li></ol><p>备注：<code>httrack</code> 只能用于克隆静态内容，并且无法完全复制网站上的动态内容、中间部分 (数据库) 等内容。</p><h1 id="HTTrack-一般模式使用步骤-5"><a href="#HTTrack-一般模式使用步骤-5" class="headerlink" title="HTTrack 一般模式使用步骤"></a><code>HTTrack</code> 一般模式使用步骤</h1><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack &lt;URLs&gt; [-option] [+&lt;URL_FILTER&gt;] [-&lt;URL_FILTER&gt;] [+&lt;mime:MIME_FILTER&gt;] [-&lt;mime:MIME_FILTER&gt;]</span><br></pre></td></tr></table></figure><p>选项如下：（* 为默认值）</p><h2 id="一般选项-5"><a href="#一般选项-5" class="headerlink" title="一般选项"></a>一般选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O  镜像路径/缓存和日志文件路径</span><br><span class="line">-O 镜像路径[,缓存和日志文件路径] (--path &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="行为选项-5"><a href="#行为选项-5" class="headerlink" title="行为选项"></a>行为选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w  *镜像网站 (--mirror)</span><br><span class="line">W镜像网站，半自动 (asks questions) (--mirror-wizard)</span><br><span class="line">g只获取文件（保存在当前目录中） (--get-files)</span><br><span class="line">i使用缓存继续中断的镜像 (--continue)</span><br><span class="line">Y镜像所有位于第一级页面的链接 (镜像链接) (--mirrorlinks)</span><br></pre></td></tr></table></figure><h2 id="代理选项-5"><a href="#代理选项-5" class="headerlink" title="代理选项"></a>代理选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   代理使用 (-P proxy:port or -P user:pass@proxy:port) (--proxy &lt;param&gt;)</span><br><span class="line">%f *使用ftp代理 (f0 don&#x27;t use) (--httpproxy-ftp[=N])</span><br><span class="line">%b  使用此本地主机名发出/发送请求 (-%b 主机名) (--bind &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="限制选项-5"><a href="#限制选项-5" class="headerlink" title="限制选项"></a>限制选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rN  将“镜像深度”设置为N (* r9999) (--depth[=N])</span><br><span class="line">%eN   将“外部链接深度”设置为N (* %e0) (--ext-depth[=N])</span><br><span class="line">mN    将非HTML文件的最大文件长度设置为N (--max-files[=N])</span><br><span class="line">mN,N2 将非HTML文件的最大文件长度设置为N、将HTML文件的最大文件长度设置为N2</span><br><span class="line">MN    将可上传/扫描的最大总长度设置为N (--max-size[=N])</span><br><span class="line">EN    将最大镜像传输时间设置为N秒 (60=1 minute, 3600=1 hour) (--max-time[=N])</span><br><span class="line">AN    将最大传输速率设置为N字节/秒 (1000=1KB/s max) (--max-rate[=N])</span><br><span class="line">%cN   将最大连接数设置为N个/秒 (*%c10) (--connection-per-second[=N])</span><br><span class="line">GN    设置如果达到N个字节，则暂停传输，并等待锁定文件被删除 (--max-pause[=N])</span><br></pre></td></tr></table></figure><h2 id="流量控制-5"><a href="#流量控制-5" class="headerlink" title="流量控制"></a>流量控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cN  设置连接数为N (*c8) (--sockets[=N])</span><br><span class="line">TN  设置关闭无响应链接N秒后超时 (--timeout)</span><br><span class="line">RN  设置超时或非致命错误情况下的重试次数为N (*R1) (--retries[=N])</span><br><span class="line">JN  流量阻塞控制，设置链路允许的最小传输速率为N字节/秒 (--min-rate[=N])</span><br><span class="line">HN  如果：0=从不、1=超时、2=慢、3=超时或慢，则放弃主机 (--host-control[=N])</span><br></pre></td></tr></table></figure><h2 id="链接选项-5"><a href="#链接选项-5" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%P        *扩展解析，尝试解析所有链接，即使是未知标记或Javascript标记 (%P0 don&#x27;t use) (--extended-parsing[=N])</span><br><span class="line">n          在html文件附近获取非html文件 (例如：位于外部的图像) (--near)</span><br><span class="line">t          测试所有url（即使url被禁止） (--test)</span><br><span class="line">%L &lt;file&gt;  添加位于此文本文件中的所有URL（每行一个URL）  (--list &lt;param&gt;)</span><br><span class="line">%S &lt;file&gt;  添加位于此文本文件中的所有扫描规则（每行一个扫描规则） (--urllist &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="构建选项-5"><a href="#构建选项-5" class="headerlink" title="构建选项"></a>构建选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NN结构类型 (0 *原始结构, 1+: 详见下文) (--structure[=N])</span><br><span class="line">    或用户定义的结构 (-N &quot;%h%p/%n%q.%t&quot;)</span><br><span class="line">%N  延迟类型检查，不进行任何链接测试，而是等待文件下载开始（实验性的）(N0 不使用，%N1 用于未知扩展名，*%N2 始终使用)</span><br><span class="line">%D  缓存的延迟类型检查，不要在更新期间等待远程类型，以加快更新速度 (%D0 等待, * %D1 不等待) (--cached-delayed-type-check)</span><br><span class="line">%M  生成RFC MIME封装的完整存档 (.mht) (--mime-html)</span><br><span class="line">LN长名称 (L1 *长名称 / L0 8-3 转换 / L2 ISO9660 兼容) (--long-names[=N])</span><br><span class="line">KN保留原始链接 (e.g. http://www.adr/link) (K0 *相对链接, K 绝对链接, K4 原始链接, K3 绝对URI链接, K5 透明代理链接) (--keep-links[=N])</span><br><span class="line">x用错误页替换外部html链接 (--replace-external)</span><br><span class="line">%x不包括受外部密码保护的网站的任何密码 (%x0 包括) (--disable-passwords)</span><br><span class="line">%q *包含本地文件的查询字符串 (无用,仅供参考) (%q0 不包含) (--include-query-string)</span><br><span class="line">o  *出错时生成输出html文件 (404..) (o0 不生成) (--generate-errors)</span><br><span class="line">X  *更新后清除旧文件 (X0 保持删除) (--purge-old[=N])</span><br><span class="line">%p保留html文件“原样” (与&#x27;-K4 -%F &quot;&quot;&#x27;相同) (--preserve)</span><br><span class="line">%T链接转换为UTF-8 (--utf8-conversion)</span><br></pre></td></tr></table></figure><h2 id="蜘蛛选项-5"><a href="#蜘蛛选项-5" class="headerlink" title="蜘蛛选项"></a>蜘蛛选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bN接受cookies.txt中的cookies (0=不接受,* 1=接受) (--cookies[=N])</span><br><span class="line">u检查未知文档类型 (cgi,asp..) (u0 不检查, * u1 检查除了 /, u2 始终检查) (--check-type[=N])</span><br><span class="line">j  *解析JAVA类 (j0 不解析, 位掩码: |1 解析默认值, |2 不解析.class文件 |4 不解析.js文件 |8 不越界解析) (--parse-java[=N])</span><br><span class="line">sN遵循robots.txt和meta robots标记 (0=never,1=sometimes,* 2=always, 3=always (even strict rules)) (--robots[=N])</span><br><span class="line">%h  强制HTTP/1请求 (仅针对旧服务器或代理减少更新特性) (--http-10)</span><br><span class="line">%k尽可能使用keep alive，大大减少小文件和测试请求的延迟 (%k0 不使用) (--keep-alive)</span><br><span class="line">%B  容忍请求 (在某些服务器上接受虚假响应，但不是标准的!) (--tolerant)</span><br><span class="line">%s  更新非法入侵：在更新时限制重新传输的各种非法入侵(相同大小，虚假响应…) (--updatehack)</span><br><span class="line">%u  url非法入侵：限制重复url的各种非法入侵 (strip //, www.foo.com==foo.com..) (--urlhack)</span><br><span class="line">%A  假设一个类型(cgi,asp..)总是与一个mime类型链接 (-%A php3,cgi=text/html;dat,bin=application/x-zip) (--assume &lt;param&gt;)</span><br><span class="line">     快捷方式：&#x27;--assume standard&#x27;相当于-%A php2 php3 php4 php cgi asp jsp pl cfm nsf=text/html</span><br><span class="line">     也可以用于强制特定的文件类型：-assume foo.cgi=text/html</span><br><span class="line">@iNinternet协议 (0=both ipv6+ipv4, 4=ipv4 only, 6=ipv6 only) (--protocol[=N])</span><br><span class="line">%w  禁用特定的外部mime模块 (-%w htsswf -%w htsjava) (--disable-module &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="浏览器-ID-5"><a href="#浏览器-ID-5" class="headerlink" title="浏览器 ID"></a>浏览器 ID</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F   在HTTP头中发送的用户代理字段 (-F &quot;user-agent name&quot;) (--user-agent &lt;param&gt;)</span><br><span class="line">%R  在HTTP头中发送的默认referer字段 (--referer &lt;param&gt;)</span><br><span class="line">%E  从以HTTP头发送的电子邮件地址 (--from &lt;param&gt;)</span><br><span class="line">%F  Html代码中的页脚字符串 (-%F &quot;Mirrored [from host %s [file %s [at %s]]]&quot; (--footer &lt;param&gt;)</span><br><span class="line">%l  首选语言 (-%l &quot;fr, en, jp, *&quot; (--language &lt;param&gt;)</span><br><span class="line">%a  接受格式 (-%a &quot;text/html,image/png;q=0.9,*/*;q=0.1&quot; (--accept &lt;param&gt;)</span><br><span class="line">%X  附加的HTTP标题行 (-%X &quot;X-Magic: 42&quot; (--headers &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="日志、索引、缓存-5"><a href="#日志、索引、缓存-5" class="headerlink" title="日志、索引、缓存"></a>日志、索引、缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C   创建/使用缓存进行更新和重试 (C0 无缓存,C1 缓存优先,* C2 测试更新前) (--cache[=N])</span><br><span class="line">k   将所有文件存储在缓存中 (如果文件在磁盘上，则此功能不可用) (--store-all-in-cache)</span><br><span class="line">%n  不能重新下载本地删除的文件 (--do-not-recatch)</span><br><span class="line">%v  在屏幕上显示下载的文件名(实时) - * %v1 缩写版 - %v2 完整 (--display)</span><br><span class="line">Q   无日志-安静模式  (--do-not-log)</span><br><span class="line">q   无问题-安静模式 (--quiet)</span><br><span class="line">z   日志-附加信息 (--extra-log)</span><br><span class="line">Z   日志-debug (--debug-log)</span><br><span class="line">v   登录屏幕 (--verbose)</span><br><span class="line">f  *登录文件 (--file-log)</span><br><span class="line">f2  一个单一日志文件(--single-log)</span><br><span class="line">I  *编制索引 (I0 不编制索引) (--index)</span><br><span class="line">%i  为项目文件夹创建顶级索引 (* %i0 不创建) (--build-top-index)</span><br><span class="line">%I  为此镜像创建可搜索索引 (* %I0 不创建) (--search-index)</span><br></pre></td></tr></table></figure><h2 id="专家选项-5"><a href="#专家选项-5" class="headerlink" title="专家选项"></a>专家选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pN  优先模式: (* p3) (--priority[=N])</span><br><span class="line">     p0 只扫描，不保存任何内容 (用于检查链接)</span><br><span class="line">     p1 只保存html文件</span><br><span class="line">     p2 只保存非html文件</span><br><span class="line">    *p3 保存所有文件</span><br><span class="line">     p7 先获取html文件，然后处理其他文件</span><br><span class="line">S   保持在同一个目录 (--stay-on-same-dir)</span><br><span class="line">D  *只能进入子目录 (--can-go-down)</span><br><span class="line">U   只能进入父目录 (--can-go-up)</span><br><span class="line">B   可以上下进入目录结构 (--can-go-up-and-down)</span><br><span class="line">a  *保持在同一地址 (--stay-on-same-address)</span><br><span class="line">d   保持在同一主域 (--stay-on-same-domain)</span><br><span class="line">l   保持相同的TLD (eg: .com) (--stay-on-same-tld)</span><br><span class="line">e   go everywhere on the web (--go-everywhere)</span><br><span class="line">%H  在日志文件中调试HTTP头 (--debug-headers)</span><br></pre></td></tr></table></figure><h2 id="权威选项-5"><a href="#权威选项-5" class="headerlink" title="权威选项"></a>权威选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#X  *使用优化引擎 (有限内存边界检查) (--fast-engine)</span><br><span class="line">#0   过滤测试 (-#0 &#x27;*.gif&#x27; &#x27;www.bar.com/foo.gif&#x27;) (--debug-testfilters &lt;param&gt;)</span><br><span class="line">#1   简化测试 (-#1 ./foo/bar/../foobar)</span><br><span class="line">#2   类型测试 (-#2 /foo/bar.php)</span><br><span class="line">#C   换成列表 (-#C &#x27;*.com/spider*.gif&#x27; (--debug-cache &lt;param&gt;)</span><br><span class="line">#R   缓存修复 (损坏缓存) (--repair-cache)</span><br><span class="line">#d   调试分析器 (--debug-parsing)</span><br><span class="line">#E   在meta.zip中提取new.zip缓存元数据</span><br><span class="line">#f   总是刷新日志文件 (--advanced-flushlogs)</span><br><span class="line">#FN  过滤器的最大过滤数目 (--advanced-maxfilters[=N])</span><br><span class="line">#h   版本信息 (--version)</span><br><span class="line">#K   扫描标准输入 (debug) (--debug-scanstdin)</span><br><span class="line">#L   最大链接数 (-#L1000000) (--advanced-maxlinks[=N])</span><br><span class="line">#p   显示进度信息 (--advanced-progressinfo)</span><br><span class="line">#P   抓取URL (--catch-url)</span><br><span class="line">#R   旧的FTP例程 (debug) (--repair-cache)</span><br><span class="line">#T   每分钟生成一次传输操作日志 (--debug-xfrstats)</span><br><span class="line">#u   等待时间 (--advanced-wait)</span><br><span class="line">#Z   每分钟生成传输速率的静态数据 (--debug-ratestats)</span><br></pre></td></tr></table></figure><h2 id="危险选项-5"><a href="#危险选项-5" class="headerlink" title="危险选项"></a>危险选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%!  绕过旨在避免带宽滥用的内置安全限制 (带宽，并发连接) (--disable-security-limits)</span><br></pre></td></tr></table></figure><p>危险选项，仅适用于专家；</p><p>谨慎使用；</p><h2 id="命令行特定选项-5"><a href="#命令行特定选项-5" class="headerlink" title="命令行特定选项"></a>命令行特定选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V   执行每个文件后的系统命令 ($0 is the filename: -V &quot;rm \$0&quot;) (--userdef-cmd &lt;param&gt;)</span><br><span class="line">%W  使用外部库函数作为包装器 (-%W myfoo.so[,myparameters]) (--callback &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="选项-N-详情-5"><a href="#选项-N-详情-5" class="headerlink" title="选项 N 详情"></a>选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N0 站点结构 (默认)</span><br><span class="line">N1 HTML in web/, images/other files in web/images/</span><br><span class="line">N2 HTML in web/HTML, images/other in web/images</span><br><span class="line">N3 HTML in web/,  images/other in web/</span><br><span class="line">N4 HTML in web/, images/other in web/xxx, where xxx is the file extension (all gif will be placed onto web/gif, for example)</span><br><span class="line">N5 Images/other in web/xxx and HTML in web/HTML</span><br><span class="line">N99 All files in web/, with random names (gadget !)</span><br><span class="line">N100 站点结构，不包括www.domain.xxx/</span><br><span class="line">N101 Identical to N1 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N102 Identical to N2 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N103 Identical to N3 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N104 Identical to N4 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N105 Identical to N5 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N199 Identical to N99 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N1001 Identical to N1 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1002 Identical to N2 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1003 Identical to N3 exept that there is no &quot;web&quot; directory (option set for g option)</span><br><span class="line">N1004 Identical to N4 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1005 Identical to N5 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1099 Identical to N99 exept that there is no &quot;web&quot; directory</span><br></pre></td></tr></table></figure><h2 id="用户定义选项-N-详情-5"><a href="#用户定义选项-N-详情-5" class="headerlink" title="用户定义选项 N 详情"></a>用户定义选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;%n&#x27; 没有文件类型的文件名 (ex: image)</span><br><span class="line">&#x27;%N&#x27; 文件名，包括文件类型 (ex: image.gif)</span><br><span class="line">&#x27;%t&#x27; 文件类型 (ex: gif)</span><br><span class="line">&#x27;%p&#x27; 路径 [无结尾 /] (ex: /someimages)</span><br><span class="line">&#x27;%h&#x27; 主机名 (ex: www.someweb.com)</span><br><span class="line">&#x27;%M&#x27; URL MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%Q&#x27; 查询字符串MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%k&#x27; 完整查询字符串</span><br><span class="line">&#x27;%r&#x27; 协议名 (ex: http)</span><br><span class="line">&#x27;%q&#x27; 短查询字符串 (16位，4个ascii字节)</span><br><span class="line"> &#x27;%s?&#x27; 短名称版本 (ex: %sN)</span><br><span class="line">&#x27;%[param]&#x27; 查询字符串中的param变量</span><br><span class="line">&#x27;%[param:before:after:empty:notfound]&#x27; 高级变量提取</span><br></pre></td></tr></table></figure><h2 id="用户定义的选项-N-和高级变量提取详情-5"><a href="#用户定义的选项-N-和高级变量提取详情-5" class="headerlink" title="用户定义的选项 N 和高级变量提取详情"></a>用户定义的选项 N 和高级变量提取详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%[param:before:after:empty:notfound]</span><br><span class="line">param    参数名称</span><br><span class="line">before   如果找到参数，则在其前面加上字符串</span><br><span class="line">after    找到参数后要追加的字符串</span><br><span class="line">notfound 如果找不到参数，则替换字符串</span><br><span class="line">empty    如果参数为空，则替换字符串</span><br></pre></td></tr></table></figure><p>除第一个字段（参数名）外，所有字段都可以为空</p><h2 id="选项-K-详情-5"><a href="#选项-K-详情-5" class="headerlink" title="选项 K 详情"></a>选项 K 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K0  foo.cgi?q=45  -&gt;  foo4B54.html?q=45 (relative URI, default)</span><br><span class="line">K                 -&gt;  http://www.foobar.com/folder/foo.cgi?q=45 (absolute URL) (--keep-links[=N])</span><br><span class="line">K3                -&gt;  /folder/foo.cgi?q=45 (absolute URI)</span><br><span class="line">K4                -&gt;  foo.cgi?q=45 (original URL)</span><br><span class="line">K5                -&gt;  http://www.foobar.com/folder/foo4B54.html?q=45 (transparent proxy URL)</span><br></pre></td></tr></table></figure><h2 id="快捷操作-5"><a href="#快捷操作-5" class="headerlink" title="快捷操作"></a>快捷操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--mirror      &lt;URLs&gt; *制作站点的镜像 (default)</span><br><span class="line">--get         &lt;URLs&gt;  获取指定的文件，不要查找其他URL (-qg)</span><br><span class="line">--list   &lt;text file&gt;  添加此文本文件中的所有URL (-%L)</span><br><span class="line">--mirrorlinks &lt;URLs&gt;  镜像一级页面中的所有链接 (-Y)</span><br><span class="line">--testlinks   &lt;URLs&gt;  测试页面中的链接 (-r1p0C0I0t)</span><br><span class="line">--spider      &lt;URLs&gt;  爬取站点，用于测试链接:报告错误和警告 (-p0C0I0t)</span><br><span class="line">--testsite    &lt;URLs&gt;  与--spider相同</span><br><span class="line">--skeleton    &lt;URLs&gt;  创建镜像，但只获取html文件 (-p1)</span><br><span class="line">--update              更新镜像，无需确认 (-iC2)</span><br><span class="line">--continue            继续镜像，无需确认 (-iC1)</span><br><span class="line"></span><br><span class="line">--catchurl            创建一个临时代理来捕获一个URL或一个表单post URL</span><br><span class="line">--clean               删除缓存和日志文件</span><br><span class="line"></span><br><span class="line">--http10              强制http/1.0请求 (-%h)</span><br></pre></td></tr></table></figure><h1 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h1><ol><li><p>只镜像站点 <code>www.someweb.com/bob/</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/</span><br></pre></td></tr></table></figure></li><li><p>将两个站点镜像在一起（带有共享链接），并接受.com 站点上的任何.jpg 文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/ www.anothertest.com/mike/ +*.com/*.jpg -mime:application/*</span><br></pre></td></tr></table></figure></li><li><p>从 bobby.html 开始获取所有文件，具有 6 个链接深度，并且可以在 web 上到处访问；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html +* -r6</span><br></pre></td></tr></table></figure></li><li><p>使用代理在 <code>www.someweb.com/bob/bobby.html</code> 上运行爬虫；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html --spider -P proxy.myhost.com:8080</span><br></pre></td></tr></table></figure></li><li><p>更新当前文件夹中的镜像 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --update</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹中继续镜像；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --continue</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.httrack.com/html/fcguide.html">Httrack Users Guide</a></p><ol start="7"><li><p>指定是否在实施攻击时使用代理 (此处默认输入 none，不使用代理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy (return=none) :</span><br></pre></td></tr></table></figure><p>[# HTTrack 简单使用</p></li></ol><ul><li><strong>本文作者：</strong> 李钰璕</li><li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack 简单使用.html</a></li></ul><h1 id="前言-7"><a href="#前言-7" class="headerlink" title="前言"></a>前言</h1><p><code>HTTrack</code> 是一个免费的（GPL，自由软件）和易于使用的离线浏览器工具。它可以爬取整站的网页，用于离线浏览，减少与目标系统交互。它可从 <code>Internet</code> 上下载万维网站点到本地目录，递归地构建所有目录，从服务器获取 <code>HTML</code>、图像和其他文件到本地。<code>HTTrack</code> 安排原始网站的相关链接结构。只需在浏览器中打开 “镜像” 网站的页面，即可从链接到链接浏览网站，就像在线查看网站一样。<code>HTTrack</code> 也可以更新现有的镜像站点，并恢复中断的下载。<code>HTTrack</code> 完全可配置，并具有集成的帮助系统。</p><h1 id="HTTrack-安装-7"><a href="#HTTrack-安装-7" class="headerlink" title="HTTrack 安装"></a><code>HTTrack</code> 安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# apt-get install httrack</span><br></pre></td></tr></table></figure><h1 id="HTTrack-交互模式使用步骤-7"><a href="#HTTrack-交互模式使用步骤-7" class="headerlink" title="HTTrack 交互模式使用步骤"></a><code>HTTrack</code> 交互模式使用步骤</h1><ol><li><p>创建目录存储复制网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# mkdir mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png" alt="img"></a></p></li><li><p>启动 <code>HTTrack</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# httrack</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png" alt="img"></a></p></li><li><p>输入项目名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter project name : blog//blog为项目名称</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png" alt="img"></a></p></li><li><p>选择存储网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base path (return=/root/websites/) :/root/mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png" alt="img"></a></p></li><li><p>输入网站的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter URLs (separated by commas or blank spaces) :www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png" alt="img"></a></p></li><li><p>选择操作 (此处选择 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action:</span><br><span class="line">(enter) 1Mirror Web Site(s)//直接镜像站点</span><br><span class="line">        2Mirror Web Site(s) with Wizard//用向导完成镜像</span><br><span class="line">        3Just Get Files Indicated//只get某种特定的文件</span><br><span class="line">        4Mirror ALL links in URLs (Multiple Mirror)//镜像在这个url下所有的链接</span><br><span class="line">        5Test Links In URLs (Bookmark Test)//测试在这个url下的链接</span><br><span class="line">        0Quit//退出</span><br><span class="line">: </span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png" alt="img"></a></p></li><li><p>指定是否在实施攻击时使用代理 (此处默认输入 none，不使用代理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png" alt="img"></a></p></li><li><p>定义字符，爬取特定类型的数据 (此处输入 <code>*</code> 表示爬取全部类型数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip</span><br><span class="line">Wildcards (return=none) :*</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png" alt="img"></a></p></li><li><p>设置更多选项，可以使用 <code>help</code> 查看 (此处选择默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png" alt="img"></a></p></li><li><p>开始克隆网站</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png" alt="img"></a></p></li><li><p>查看克隆的文件</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png" alt="img"></a></p></li></ol><p>备注：<code>httrack</code> 只能用于克隆静态内容，并且无法完全复制网站上的动态内容、中间部分 (数据库) 等内容。</p><h1 id="HTTrack-一般模式使用步骤-6"><a href="#HTTrack-一般模式使用步骤-6" class="headerlink" title="HTTrack 一般模式使用步骤"></a><code>HTTrack</code> 一般模式使用步骤</h1><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack &lt;URLs&gt; [-option] [+&lt;URL_FILTER&gt;] [-&lt;URL_FILTER&gt;] [+&lt;mime:MIME_FILTER&gt;] [-&lt;mime:MIME_FILTER&gt;]</span><br></pre></td></tr></table></figure><p>选项如下：（* 为默认值）</p><h2 id="一般选项-6"><a href="#一般选项-6" class="headerlink" title="一般选项"></a>一般选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O  镜像路径/缓存和日志文件路径</span><br><span class="line">-O 镜像路径[,缓存和日志文件路径] (--path &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="行为选项-6"><a href="#行为选项-6" class="headerlink" title="行为选项"></a>行为选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w  *镜像网站 (--mirror)</span><br><span class="line">W镜像网站，半自动 (asks questions) (--mirror-wizard)</span><br><span class="line">g只获取文件（保存在当前目录中） (--get-files)</span><br><span class="line">i使用缓存继续中断的镜像 (--continue)</span><br><span class="line">Y镜像所有位于第一级页面的链接 (镜像链接) (--mirrorlinks)</span><br></pre></td></tr></table></figure><h2 id="代理选项-6"><a href="#代理选项-6" class="headerlink" title="代理选项"></a>代理选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   代理使用 (-P proxy:port or -P user:pass@proxy:port) (--proxy &lt;param&gt;)</span><br><span class="line">%f *使用ftp代理 (f0 don&#x27;t use) (--httpproxy-ftp[=N])</span><br><span class="line">%b  使用此本地主机名发出/发送请求 (-%b 主机名) (--bind &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="限制选项-6"><a href="#限制选项-6" class="headerlink" title="限制选项"></a>限制选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rN  将“镜像深度”设置为N (* r9999) (--depth[=N])</span><br><span class="line">%eN   将“外部链接深度”设置为N (* %e0) (--ext-depth[=N])</span><br><span class="line">mN    将非HTML文件的最大文件长度设置为N (--max-files[=N])</span><br><span class="line">mN,N2 将非HTML文件的最大文件长度设置为N、将HTML文件的最大文件长度设置为N2</span><br><span class="line">MN    将可上传/扫描的最大总长度设置为N (--max-size[=N])</span><br><span class="line">EN    将最大镜像传输时间设置为N秒 (60=1 minute, 3600=1 hour) (--max-time[=N])</span><br><span class="line">AN    将最大传输速率设置为N字节/秒 (1000=1KB/s max) (--max-rate[=N])</span><br><span class="line">%cN   将最大连接数设置为N个/秒 (*%c10) (--connection-per-second[=N])</span><br><span class="line">GN    设置如果达到N个字节，则暂停传输，并等待锁定文件被删除 (--max-pause[=N])</span><br></pre></td></tr></table></figure><h2 id="流量控制-6"><a href="#流量控制-6" class="headerlink" title="流量控制"></a>流量控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cN  设置连接数为N (*c8) (--sockets[=N])</span><br><span class="line">TN  设置关闭无响应链接N秒后超时 (--timeout)</span><br><span class="line">RN  设置超时或非致命错误情况下的重试次数为N (*R1) (--retries[=N])</span><br><span class="line">JN  流量阻塞控制，设置链路允许的最小传输速率为N字节/秒 (--min-rate[=N])</span><br><span class="line">HN  如果：0=从不、1=超时、2=慢、3=超时或慢，则放弃主机 (--host-control[=N])</span><br></pre></td></tr></table></figure><h2 id="链接选项-6"><a href="#链接选项-6" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%P        *扩展解析，尝试解析所有链接，即使是未知标记或Javascript标记 (%P0 don&#x27;t use) (--extended-parsing[=N])</span><br><span class="line">n          在html文件附近获取非html文件 (例如：位于外部的图像) (--near)</span><br><span class="line">t          测试所有url（即使url被禁止） (--test)</span><br><span class="line">%L &lt;file&gt;  添加位于此文本文件中的所有URL（每行一个URL）  (--list &lt;param&gt;)</span><br><span class="line">%S &lt;file&gt;  添加位于此文本文件中的所有扫描规则（每行一个扫描规则） (--urllist &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="构建选项-6"><a href="#构建选项-6" class="headerlink" title="构建选项"></a>构建选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NN结构类型 (0 *原始结构, 1+: 详见下文) (--structure[=N])</span><br><span class="line">    或用户定义的结构 (-N &quot;%h%p/%n%q.%t&quot;)</span><br><span class="line">%N  延迟类型检查，不进行任何链接测试，而是等待文件下载开始（实验性的）(N0 不使用，%N1 用于未知扩展名，*%N2 始终使用)</span><br><span class="line">%D  缓存的延迟类型检查，不要在更新期间等待远程类型，以加快更新速度 (%D0 等待, * %D1 不等待) (--cached-delayed-type-check)</span><br><span class="line">%M  生成RFC MIME封装的完整存档 (.mht) (--mime-html)</span><br><span class="line">LN长名称 (L1 *长名称 / L0 8-3 转换 / L2 ISO9660 兼容) (--long-names[=N])</span><br><span class="line">KN保留原始链接 (e.g. http://www.adr/link) (K0 *相对链接, K 绝对链接, K4 原始链接, K3 绝对URI链接, K5 透明代理链接) (--keep-links[=N])</span><br><span class="line">x用错误页替换外部html链接 (--replace-external)</span><br><span class="line">%x不包括受外部密码保护的网站的任何密码 (%x0 包括) (--disable-passwords)</span><br><span class="line">%q *包含本地文件的查询字符串 (无用,仅供参考) (%q0 不包含) (--include-query-string)</span><br><span class="line">o  *出错时生成输出html文件 (404..) (o0 不生成) (--generate-errors)</span><br><span class="line">X  *更新后清除旧文件 (X0 保持删除) (--purge-old[=N])</span><br><span class="line">%p保留html文件“原样” (与&#x27;-K4 -%F &quot;&quot;&#x27;相同) (--preserve)</span><br><span class="line">%T链接转换为UTF-8 (--utf8-conversion)</span><br></pre></td></tr></table></figure><h2 id="蜘蛛选项-6"><a href="#蜘蛛选项-6" class="headerlink" title="蜘蛛选项"></a>蜘蛛选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bN接受cookies.txt中的cookies (0=不接受,* 1=接受) (--cookies[=N])</span><br><span class="line">u检查未知文档类型 (cgi,asp..) (u0 不检查, * u1 检查除了 /, u2 始终检查) (--check-type[=N])</span><br><span class="line">j  *解析JAVA类 (j0 不解析, 位掩码: |1 解析默认值, |2 不解析.class文件 |4 不解析.js文件 |8 不越界解析) (--parse-java[=N])</span><br><span class="line">sN遵循robots.txt和meta robots标记 (0=never,1=sometimes,* 2=always, 3=always (even strict rules)) (--robots[=N])</span><br><span class="line">%h  强制HTTP/1请求 (仅针对旧服务器或代理减少更新特性) (--http-10)</span><br><span class="line">%k尽可能使用keep alive，大大减少小文件和测试请求的延迟 (%k0 不使用) (--keep-alive)</span><br><span class="line">%B  容忍请求 (在某些服务器上接受虚假响应，但不是标准的!) (--tolerant)</span><br><span class="line">%s  更新非法入侵：在更新时限制重新传输的各种非法入侵(相同大小，虚假响应…) (--updatehack)</span><br><span class="line">%u  url非法入侵：限制重复url的各种非法入侵 (strip //, www.foo.com==foo.com..) (--urlhack)</span><br><span class="line">%A  假设一个类型(cgi,asp..)总是与一个mime类型链接 (-%A php3,cgi=text/html;dat,bin=application/x-zip) (--assume &lt;param&gt;)</span><br><span class="line">     快捷方式：&#x27;--assume standard&#x27;相当于-%A php2 php3 php4 php cgi asp jsp pl cfm nsf=text/html</span><br><span class="line">     也可以用于强制特定的文件类型：-assume foo.cgi=text/html</span><br><span class="line">@iNinternet协议 (0=both ipv6+ipv4, 4=ipv4 only, 6=ipv6 only) (--protocol[=N])</span><br><span class="line">%w  禁用特定的外部mime模块 (-%w htsswf -%w htsjava) (--disable-module &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="浏览器-ID-6"><a href="#浏览器-ID-6" class="headerlink" title="浏览器 ID"></a>浏览器 ID</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F   在HTTP头中发送的用户代理字段 (-F &quot;user-agent name&quot;) (--user-agent &lt;param&gt;)</span><br><span class="line">%R  在HTTP头中发送的默认referer字段 (--referer &lt;param&gt;)</span><br><span class="line">%E  从以HTTP头发送的电子邮件地址 (--from &lt;param&gt;)</span><br><span class="line">%F  Html代码中的页脚字符串 (-%F &quot;Mirrored [from host %s [file %s [at %s]]]&quot; (--footer &lt;param&gt;)</span><br><span class="line">%l  首选语言 (-%l &quot;fr, en, jp, *&quot; (--language &lt;param&gt;)</span><br><span class="line">%a  接受格式 (-%a &quot;text/html,image/png;q=0.9,*/*;q=0.1&quot; (--accept &lt;param&gt;)</span><br><span class="line">%X  附加的HTTP标题行 (-%X &quot;X-Magic: 42&quot; (--headers &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="日志、索引、缓存-6"><a href="#日志、索引、缓存-6" class="headerlink" title="日志、索引、缓存"></a>日志、索引、缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C   创建/使用缓存进行更新和重试 (C0 无缓存,C1 缓存优先,* C2 测试更新前) (--cache[=N])</span><br><span class="line">k   将所有文件存储在缓存中 (如果文件在磁盘上，则此功能不可用) (--store-all-in-cache)</span><br><span class="line">%n  不能重新下载本地删除的文件 (--do-not-recatch)</span><br><span class="line">%v  在屏幕上显示下载的文件名(实时) - * %v1 缩写版 - %v2 完整 (--display)</span><br><span class="line">Q   无日志-安静模式  (--do-not-log)</span><br><span class="line">q   无问题-安静模式 (--quiet)</span><br><span class="line">z   日志-附加信息 (--extra-log)</span><br><span class="line">Z   日志-debug (--debug-log)</span><br><span class="line">v   登录屏幕 (--verbose)</span><br><span class="line">f  *登录文件 (--file-log)</span><br><span class="line">f2  一个单一日志文件(--single-log)</span><br><span class="line">I  *编制索引 (I0 不编制索引) (--index)</span><br><span class="line">%i  为项目文件夹创建顶级索引 (* %i0 不创建) (--build-top-index)</span><br><span class="line">%I  为此镜像创建可搜索索引 (* %I0 不创建) (--search-index)</span><br></pre></td></tr></table></figure><h2 id="专家选项-6"><a href="#专家选项-6" class="headerlink" title="专家选项"></a>专家选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pN  优先模式: (* p3) (--priority[=N])</span><br><span class="line">     p0 只扫描，不保存任何内容 (用于检查链接)</span><br><span class="line">     p1 只保存html文件</span><br><span class="line">     p2 只保存非html文件</span><br><span class="line">    *p3 保存所有文件</span><br><span class="line">     p7 先获取html文件，然后处理其他文件</span><br><span class="line">S   保持在同一个目录 (--stay-on-same-dir)</span><br><span class="line">D  *只能进入子目录 (--can-go-down)</span><br><span class="line">U   只能进入父目录 (--can-go-up)</span><br><span class="line">B   可以上下进入目录结构 (--can-go-up-and-down)</span><br><span class="line">a  *保持在同一地址 (--stay-on-same-address)</span><br><span class="line">d   保持在同一主域 (--stay-on-same-domain)</span><br><span class="line">l   保持相同的TLD (eg: .com) (--stay-on-same-tld)</span><br><span class="line">e   go everywhere on the web (--go-everywhere)</span><br><span class="line">%H  在日志文件中调试HTTP头 (--debug-headers)</span><br></pre></td></tr></table></figure><h2 id="权威选项-6"><a href="#权威选项-6" class="headerlink" title="权威选项"></a>权威选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#X  *使用优化引擎 (有限内存边界检查) (--fast-engine)</span><br><span class="line">#0   过滤测试 (-#0 &#x27;*.gif&#x27; &#x27;www.bar.com/foo.gif&#x27;) (--debug-testfilters &lt;param&gt;)</span><br><span class="line">#1   简化测试 (-#1 ./foo/bar/../foobar)</span><br><span class="line">#2   类型测试 (-#2 /foo/bar.php)</span><br><span class="line">#C   换成列表 (-#C &#x27;*.com/spider*.gif&#x27; (--debug-cache &lt;param&gt;)</span><br><span class="line">#R   缓存修复 (损坏缓存) (--repair-cache)</span><br><span class="line">#d   调试分析器 (--debug-parsing)</span><br><span class="line">#E   在meta.zip中提取new.zip缓存元数据</span><br><span class="line">#f   总是刷新日志文件 (--advanced-flushlogs)</span><br><span class="line">#FN  过滤器的最大过滤数目 (--advanced-maxfilters[=N])</span><br><span class="line">#h   版本信息 (--version)</span><br><span class="line">#K   扫描标准输入 (debug) (--debug-scanstdin)</span><br><span class="line">#L   最大链接数 (-#L1000000) (--advanced-maxlinks[=N])</span><br><span class="line">#p   显示进度信息 (--advanced-progressinfo)</span><br><span class="line">#P   抓取URL (--catch-url)</span><br><span class="line">#R   旧的FTP例程 (debug) (--repair-cache)</span><br><span class="line">#T   每分钟生成一次传输操作日志 (--debug-xfrstats)</span><br><span class="line">#u   等待时间 (--advanced-wait)</span><br><span class="line">#Z   每分钟生成传输速率的静态数据 (--debug-ratestats)</span><br></pre></td></tr></table></figure><h2 id="危险选项-6"><a href="#危险选项-6" class="headerlink" title="危险选项"></a>危险选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%!  绕过旨在避免带宽滥用的内置安全限制 (带宽，并发连接) (--disable-security-limits)</span><br></pre></td></tr></table></figure><p>危险选项，仅适用于专家；</p><p>谨慎使用；</p><h2 id="命令行特定选项-6"><a href="#命令行特定选项-6" class="headerlink" title="命令行特定选项"></a>命令行特定选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V   执行每个文件后的系统命令 ($0 is the filename: -V &quot;rm \$0&quot;) (--userdef-cmd &lt;param&gt;)</span><br><span class="line">%W  使用外部库函数作为包装器 (-%W myfoo.so[,myparameters]) (--callback &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="选项-N-详情-6"><a href="#选项-N-详情-6" class="headerlink" title="选项 N 详情"></a>选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N0 站点结构 (默认)</span><br><span class="line">N1 HTML in web/, images/other files in web/images/</span><br><span class="line">N2 HTML in web/HTML, images/other in web/images</span><br><span class="line">N3 HTML in web/,  images/other in web/</span><br><span class="line">N4 HTML in web/, images/other in web/xxx, where xxx is the file extension (all gif will be placed onto web/gif, for example)</span><br><span class="line">N5 Images/other in web/xxx and HTML in web/HTML</span><br><span class="line">N99 All files in web/, with random names (gadget !)</span><br><span class="line">N100 站点结构，不包括www.domain.xxx/</span><br><span class="line">N101 Identical to N1 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N102 Identical to N2 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N103 Identical to N3 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N104 Identical to N4 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N105 Identical to N5 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N199 Identical to N99 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N1001 Identical to N1 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1002 Identical to N2 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1003 Identical to N3 exept that there is no &quot;web&quot; directory (option set for g option)</span><br><span class="line">N1004 Identical to N4 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1005 Identical to N5 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1099 Identical to N99 exept that there is no &quot;web&quot; directory</span><br></pre></td></tr></table></figure><h2 id="用户定义选项-N-详情-6"><a href="#用户定义选项-N-详情-6" class="headerlink" title="用户定义选项 N 详情"></a>用户定义选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;%n&#x27; 没有文件类型的文件名 (ex: image)</span><br><span class="line">&#x27;%N&#x27; 文件名，包括文件类型 (ex: image.gif)</span><br><span class="line">&#x27;%t&#x27; 文件类型 (ex: gif)</span><br><span class="line">&#x27;%p&#x27; 路径 [无结尾 /] (ex: /someimages)</span><br><span class="line">&#x27;%h&#x27; 主机名 (ex: www.someweb.com)</span><br><span class="line">&#x27;%M&#x27; URL MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%Q&#x27; 查询字符串MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%k&#x27; 完整查询字符串</span><br><span class="line">&#x27;%r&#x27; 协议名 (ex: http)</span><br><span class="line">&#x27;%q&#x27; 短查询字符串 (16位，4个ascii字节)</span><br><span class="line"> &#x27;%s?&#x27; 短名称版本 (ex: %sN)</span><br><span class="line">&#x27;%[param]&#x27; 查询字符串中的param变量</span><br><span class="line">&#x27;%[param:before:after:empty:notfound]&#x27; 高级变量提取</span><br></pre></td></tr></table></figure><h2 id="用户定义的选项-N-和高级变量提取详情-6"><a href="#用户定义的选项-N-和高级变量提取详情-6" class="headerlink" title="用户定义的选项 N 和高级变量提取详情"></a>用户定义的选项 N 和高级变量提取详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%[param:before:after:empty:notfound]</span><br><span class="line">param    参数名称</span><br><span class="line">before   如果找到参数，则在其前面加上字符串</span><br><span class="line">after    找到参数后要追加的字符串</span><br><span class="line">notfound 如果找不到参数，则替换字符串</span><br><span class="line">empty    如果参数为空，则替换字符串</span><br></pre></td></tr></table></figure><p>除第一个字段（参数名）外，所有字段都可以为空</p><h2 id="选项-K-详情-6"><a href="#选项-K-详情-6" class="headerlink" title="选项 K 详情"></a>选项 K 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K0  foo.cgi?q=45  -&gt;  foo4B54.html?q=45 (relative URI, default)</span><br><span class="line">K                 -&gt;  http://www.foobar.com/folder/foo.cgi?q=45 (absolute URL) (--keep-links[=N])</span><br><span class="line">K3                -&gt;  /folder/foo.cgi?q=45 (absolute URI)</span><br><span class="line">K4                -&gt;  foo.cgi?q=45 (original URL)</span><br><span class="line">K5                -&gt;  http://www.foobar.com/folder/foo4B54.html?q=45 (transparent proxy URL)</span><br></pre></td></tr></table></figure><h2 id="快捷操作-6"><a href="#快捷操作-6" class="headerlink" title="快捷操作"></a>快捷操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--mirror      &lt;URLs&gt; *制作站点的镜像 (default)</span><br><span class="line">--get         &lt;URLs&gt;  获取指定的文件，不要查找其他URL (-qg)</span><br><span class="line">--list   &lt;text file&gt;  添加此文本文件中的所有URL (-%L)</span><br><span class="line">--mirrorlinks &lt;URLs&gt;  镜像一级页面中的所有链接 (-Y)</span><br><span class="line">--testlinks   &lt;URLs&gt;  测试页面中的链接 (-r1p0C0I0t)</span><br><span class="line">--spider      &lt;URLs&gt;  爬取站点，用于测试链接:报告错误和警告 (-p0C0I0t)</span><br><span class="line">--testsite    &lt;URLs&gt;  与--spider相同</span><br><span class="line">--skeleton    &lt;URLs&gt;  创建镜像，但只获取html文件 (-p1)</span><br><span class="line">--update              更新镜像，无需确认 (-iC2)</span><br><span class="line">--continue            继续镜像，无需确认 (-iC1)</span><br><span class="line"></span><br><span class="line">--catchurl            创建一个临时代理来捕获一个URL或一个表单post URL</span><br><span class="line">--clean               删除缓存和日志文件</span><br><span class="line"></span><br><span class="line">--http10              强制http/1.0请求 (-%h)</span><br></pre></td></tr></table></figure><h1 id="举例-6"><a href="#举例-6" class="headerlink" title="举例"></a>举例</h1><ol><li><p>只镜像站点 <code>www.someweb.com/bob/</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/</span><br></pre></td></tr></table></figure></li><li><p>将两个站点镜像在一起（带有共享链接），并接受.com 站点上的任何.jpg 文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/ www.anothertest.com/mike/ +*.com/*.jpg -mime:application/*</span><br></pre></td></tr></table></figure></li><li><p>从 bobby.html 开始获取所有文件，具有 6 个链接深度，并且可以在 web 上到处访问；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html +* -r6</span><br></pre></td></tr></table></figure></li><li><p>使用代理在 <code>www.someweb.com/bob/bobby.html</code> 上运行爬虫；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html --spider -P proxy.myhost.com:8080</span><br></pre></td></tr></table></figure></li><li><p>更新当前文件夹中的镜像 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --update</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹中继续镜像；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --continue</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-6"><a href="#参考-6" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.httrack.com/html/fcguide.html">Httrack Users Guide</a></p><ol start="8"><li><p>定义字符，爬取特定类型的数据 (此处输入 <code>*</code> 表示爬取全部类型数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip</span><br><span class="line">Wildcards (return=none) :*</span><br></pre></td></tr></table></figure><p>[# HTTrack 简单使用</p></li></ol><ul><li><strong>本文作者：</strong> 李钰璕</li><li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack 简单使用.html</a></li></ul><h1 id="前言-8"><a href="#前言-8" class="headerlink" title="前言"></a>前言</h1><p><code>HTTrack</code> 是一个免费的（GPL，自由软件）和易于使用的离线浏览器工具。它可以爬取整站的网页，用于离线浏览，减少与目标系统交互。它可从 <code>Internet</code> 上下载万维网站点到本地目录，递归地构建所有目录，从服务器获取 <code>HTML</code>、图像和其他文件到本地。<code>HTTrack</code> 安排原始网站的相关链接结构。只需在浏览器中打开 “镜像” 网站的页面，即可从链接到链接浏览网站，就像在线查看网站一样。<code>HTTrack</code> 也可以更新现有的镜像站点，并恢复中断的下载。<code>HTTrack</code> 完全可配置，并具有集成的帮助系统。</p><h1 id="HTTrack-安装-8"><a href="#HTTrack-安装-8" class="headerlink" title="HTTrack 安装"></a><code>HTTrack</code> 安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# apt-get install httrack</span><br></pre></td></tr></table></figure><h1 id="HTTrack-交互模式使用步骤-8"><a href="#HTTrack-交互模式使用步骤-8" class="headerlink" title="HTTrack 交互模式使用步骤"></a><code>HTTrack</code> 交互模式使用步骤</h1><ol><li><p>创建目录存储复制网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# mkdir mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png" alt="img"></a></p></li><li><p>启动 <code>HTTrack</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# httrack</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png" alt="img"></a></p></li><li><p>输入项目名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter project name : blog//blog为项目名称</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png" alt="img"></a></p></li><li><p>选择存储网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base path (return=/root/websites/) :/root/mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png" alt="img"></a></p></li><li><p>输入网站的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter URLs (separated by commas or blank spaces) :www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png" alt="img"></a></p></li><li><p>选择操作 (此处选择 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action:</span><br><span class="line">(enter) 1Mirror Web Site(s)//直接镜像站点</span><br><span class="line">        2Mirror Web Site(s) with Wizard//用向导完成镜像</span><br><span class="line">        3Just Get Files Indicated//只get某种特定的文件</span><br><span class="line">        4Mirror ALL links in URLs (Multiple Mirror)//镜像在这个url下所有的链接</span><br><span class="line">        5Test Links In URLs (Bookmark Test)//测试在这个url下的链接</span><br><span class="line">        0Quit//退出</span><br><span class="line">: </span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png" alt="img"></a></p></li><li><p>指定是否在实施攻击时使用代理 (此处默认输入 none，不使用代理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png" alt="img"></a></p></li><li><p>定义字符，爬取特定类型的数据 (此处输入 <code>*</code> 表示爬取全部类型数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip</span><br><span class="line">Wildcards (return=none) :*</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png" alt="img"></a></p></li><li><p>设置更多选项，可以使用 <code>help</code> 查看 (此处选择默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png" alt="img"></a></p></li><li><p>开始克隆网站</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png" alt="img"></a></p></li><li><p>查看克隆的文件</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png" alt="img"></a></p></li></ol><p>备注：<code>httrack</code> 只能用于克隆静态内容，并且无法完全复制网站上的动态内容、中间部分 (数据库) 等内容。</p><h1 id="HTTrack-一般模式使用步骤-7"><a href="#HTTrack-一般模式使用步骤-7" class="headerlink" title="HTTrack 一般模式使用步骤"></a><code>HTTrack</code> 一般模式使用步骤</h1><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack &lt;URLs&gt; [-option] [+&lt;URL_FILTER&gt;] [-&lt;URL_FILTER&gt;] [+&lt;mime:MIME_FILTER&gt;] [-&lt;mime:MIME_FILTER&gt;]</span><br></pre></td></tr></table></figure><p>选项如下：（* 为默认值）</p><h2 id="一般选项-7"><a href="#一般选项-7" class="headerlink" title="一般选项"></a>一般选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O  镜像路径/缓存和日志文件路径</span><br><span class="line">-O 镜像路径[,缓存和日志文件路径] (--path &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="行为选项-7"><a href="#行为选项-7" class="headerlink" title="行为选项"></a>行为选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w  *镜像网站 (--mirror)</span><br><span class="line">W镜像网站，半自动 (asks questions) (--mirror-wizard)</span><br><span class="line">g只获取文件（保存在当前目录中） (--get-files)</span><br><span class="line">i使用缓存继续中断的镜像 (--continue)</span><br><span class="line">Y镜像所有位于第一级页面的链接 (镜像链接) (--mirrorlinks)</span><br></pre></td></tr></table></figure><h2 id="代理选项-7"><a href="#代理选项-7" class="headerlink" title="代理选项"></a>代理选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   代理使用 (-P proxy:port or -P user:pass@proxy:port) (--proxy &lt;param&gt;)</span><br><span class="line">%f *使用ftp代理 (f0 don&#x27;t use) (--httpproxy-ftp[=N])</span><br><span class="line">%b  使用此本地主机名发出/发送请求 (-%b 主机名) (--bind &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="限制选项-7"><a href="#限制选项-7" class="headerlink" title="限制选项"></a>限制选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rN  将“镜像深度”设置为N (* r9999) (--depth[=N])</span><br><span class="line">%eN   将“外部链接深度”设置为N (* %e0) (--ext-depth[=N])</span><br><span class="line">mN    将非HTML文件的最大文件长度设置为N (--max-files[=N])</span><br><span class="line">mN,N2 将非HTML文件的最大文件长度设置为N、将HTML文件的最大文件长度设置为N2</span><br><span class="line">MN    将可上传/扫描的最大总长度设置为N (--max-size[=N])</span><br><span class="line">EN    将最大镜像传输时间设置为N秒 (60=1 minute, 3600=1 hour) (--max-time[=N])</span><br><span class="line">AN    将最大传输速率设置为N字节/秒 (1000=1KB/s max) (--max-rate[=N])</span><br><span class="line">%cN   将最大连接数设置为N个/秒 (*%c10) (--connection-per-second[=N])</span><br><span class="line">GN    设置如果达到N个字节，则暂停传输，并等待锁定文件被删除 (--max-pause[=N])</span><br></pre></td></tr></table></figure><h2 id="流量控制-7"><a href="#流量控制-7" class="headerlink" title="流量控制"></a>流量控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cN  设置连接数为N (*c8) (--sockets[=N])</span><br><span class="line">TN  设置关闭无响应链接N秒后超时 (--timeout)</span><br><span class="line">RN  设置超时或非致命错误情况下的重试次数为N (*R1) (--retries[=N])</span><br><span class="line">JN  流量阻塞控制，设置链路允许的最小传输速率为N字节/秒 (--min-rate[=N])</span><br><span class="line">HN  如果：0=从不、1=超时、2=慢、3=超时或慢，则放弃主机 (--host-control[=N])</span><br></pre></td></tr></table></figure><h2 id="链接选项-7"><a href="#链接选项-7" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%P        *扩展解析，尝试解析所有链接，即使是未知标记或Javascript标记 (%P0 don&#x27;t use) (--extended-parsing[=N])</span><br><span class="line">n          在html文件附近获取非html文件 (例如：位于外部的图像) (--near)</span><br><span class="line">t          测试所有url（即使url被禁止） (--test)</span><br><span class="line">%L &lt;file&gt;  添加位于此文本文件中的所有URL（每行一个URL）  (--list &lt;param&gt;)</span><br><span class="line">%S &lt;file&gt;  添加位于此文本文件中的所有扫描规则（每行一个扫描规则） (--urllist &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="构建选项-7"><a href="#构建选项-7" class="headerlink" title="构建选项"></a>构建选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NN结构类型 (0 *原始结构, 1+: 详见下文) (--structure[=N])</span><br><span class="line">    或用户定义的结构 (-N &quot;%h%p/%n%q.%t&quot;)</span><br><span class="line">%N  延迟类型检查，不进行任何链接测试，而是等待文件下载开始（实验性的）(N0 不使用，%N1 用于未知扩展名，*%N2 始终使用)</span><br><span class="line">%D  缓存的延迟类型检查，不要在更新期间等待远程类型，以加快更新速度 (%D0 等待, * %D1 不等待) (--cached-delayed-type-check)</span><br><span class="line">%M  生成RFC MIME封装的完整存档 (.mht) (--mime-html)</span><br><span class="line">LN长名称 (L1 *长名称 / L0 8-3 转换 / L2 ISO9660 兼容) (--long-names[=N])</span><br><span class="line">KN保留原始链接 (e.g. http://www.adr/link) (K0 *相对链接, K 绝对链接, K4 原始链接, K3 绝对URI链接, K5 透明代理链接) (--keep-links[=N])</span><br><span class="line">x用错误页替换外部html链接 (--replace-external)</span><br><span class="line">%x不包括受外部密码保护的网站的任何密码 (%x0 包括) (--disable-passwords)</span><br><span class="line">%q *包含本地文件的查询字符串 (无用,仅供参考) (%q0 不包含) (--include-query-string)</span><br><span class="line">o  *出错时生成输出html文件 (404..) (o0 不生成) (--generate-errors)</span><br><span class="line">X  *更新后清除旧文件 (X0 保持删除) (--purge-old[=N])</span><br><span class="line">%p保留html文件“原样” (与&#x27;-K4 -%F &quot;&quot;&#x27;相同) (--preserve)</span><br><span class="line">%T链接转换为UTF-8 (--utf8-conversion)</span><br></pre></td></tr></table></figure><h2 id="蜘蛛选项-7"><a href="#蜘蛛选项-7" class="headerlink" title="蜘蛛选项"></a>蜘蛛选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bN接受cookies.txt中的cookies (0=不接受,* 1=接受) (--cookies[=N])</span><br><span class="line">u检查未知文档类型 (cgi,asp..) (u0 不检查, * u1 检查除了 /, u2 始终检查) (--check-type[=N])</span><br><span class="line">j  *解析JAVA类 (j0 不解析, 位掩码: |1 解析默认值, |2 不解析.class文件 |4 不解析.js文件 |8 不越界解析) (--parse-java[=N])</span><br><span class="line">sN遵循robots.txt和meta robots标记 (0=never,1=sometimes,* 2=always, 3=always (even strict rules)) (--robots[=N])</span><br><span class="line">%h  强制HTTP/1请求 (仅针对旧服务器或代理减少更新特性) (--http-10)</span><br><span class="line">%k尽可能使用keep alive，大大减少小文件和测试请求的延迟 (%k0 不使用) (--keep-alive)</span><br><span class="line">%B  容忍请求 (在某些服务器上接受虚假响应，但不是标准的!) (--tolerant)</span><br><span class="line">%s  更新非法入侵：在更新时限制重新传输的各种非法入侵(相同大小，虚假响应…) (--updatehack)</span><br><span class="line">%u  url非法入侵：限制重复url的各种非法入侵 (strip //, www.foo.com==foo.com..) (--urlhack)</span><br><span class="line">%A  假设一个类型(cgi,asp..)总是与一个mime类型链接 (-%A php3,cgi=text/html;dat,bin=application/x-zip) (--assume &lt;param&gt;)</span><br><span class="line">     快捷方式：&#x27;--assume standard&#x27;相当于-%A php2 php3 php4 php cgi asp jsp pl cfm nsf=text/html</span><br><span class="line">     也可以用于强制特定的文件类型：-assume foo.cgi=text/html</span><br><span class="line">@iNinternet协议 (0=both ipv6+ipv4, 4=ipv4 only, 6=ipv6 only) (--protocol[=N])</span><br><span class="line">%w  禁用特定的外部mime模块 (-%w htsswf -%w htsjava) (--disable-module &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="浏览器-ID-7"><a href="#浏览器-ID-7" class="headerlink" title="浏览器 ID"></a>浏览器 ID</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F   在HTTP头中发送的用户代理字段 (-F &quot;user-agent name&quot;) (--user-agent &lt;param&gt;)</span><br><span class="line">%R  在HTTP头中发送的默认referer字段 (--referer &lt;param&gt;)</span><br><span class="line">%E  从以HTTP头发送的电子邮件地址 (--from &lt;param&gt;)</span><br><span class="line">%F  Html代码中的页脚字符串 (-%F &quot;Mirrored [from host %s [file %s [at %s]]]&quot; (--footer &lt;param&gt;)</span><br><span class="line">%l  首选语言 (-%l &quot;fr, en, jp, *&quot; (--language &lt;param&gt;)</span><br><span class="line">%a  接受格式 (-%a &quot;text/html,image/png;q=0.9,*/*;q=0.1&quot; (--accept &lt;param&gt;)</span><br><span class="line">%X  附加的HTTP标题行 (-%X &quot;X-Magic: 42&quot; (--headers &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="日志、索引、缓存-7"><a href="#日志、索引、缓存-7" class="headerlink" title="日志、索引、缓存"></a>日志、索引、缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C   创建/使用缓存进行更新和重试 (C0 无缓存,C1 缓存优先,* C2 测试更新前) (--cache[=N])</span><br><span class="line">k   将所有文件存储在缓存中 (如果文件在磁盘上，则此功能不可用) (--store-all-in-cache)</span><br><span class="line">%n  不能重新下载本地删除的文件 (--do-not-recatch)</span><br><span class="line">%v  在屏幕上显示下载的文件名(实时) - * %v1 缩写版 - %v2 完整 (--display)</span><br><span class="line">Q   无日志-安静模式  (--do-not-log)</span><br><span class="line">q   无问题-安静模式 (--quiet)</span><br><span class="line">z   日志-附加信息 (--extra-log)</span><br><span class="line">Z   日志-debug (--debug-log)</span><br><span class="line">v   登录屏幕 (--verbose)</span><br><span class="line">f  *登录文件 (--file-log)</span><br><span class="line">f2  一个单一日志文件(--single-log)</span><br><span class="line">I  *编制索引 (I0 不编制索引) (--index)</span><br><span class="line">%i  为项目文件夹创建顶级索引 (* %i0 不创建) (--build-top-index)</span><br><span class="line">%I  为此镜像创建可搜索索引 (* %I0 不创建) (--search-index)</span><br></pre></td></tr></table></figure><h2 id="专家选项-7"><a href="#专家选项-7" class="headerlink" title="专家选项"></a>专家选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pN  优先模式: (* p3) (--priority[=N])</span><br><span class="line">     p0 只扫描，不保存任何内容 (用于检查链接)</span><br><span class="line">     p1 只保存html文件</span><br><span class="line">     p2 只保存非html文件</span><br><span class="line">    *p3 保存所有文件</span><br><span class="line">     p7 先获取html文件，然后处理其他文件</span><br><span class="line">S   保持在同一个目录 (--stay-on-same-dir)</span><br><span class="line">D  *只能进入子目录 (--can-go-down)</span><br><span class="line">U   只能进入父目录 (--can-go-up)</span><br><span class="line">B   可以上下进入目录结构 (--can-go-up-and-down)</span><br><span class="line">a  *保持在同一地址 (--stay-on-same-address)</span><br><span class="line">d   保持在同一主域 (--stay-on-same-domain)</span><br><span class="line">l   保持相同的TLD (eg: .com) (--stay-on-same-tld)</span><br><span class="line">e   go everywhere on the web (--go-everywhere)</span><br><span class="line">%H  在日志文件中调试HTTP头 (--debug-headers)</span><br></pre></td></tr></table></figure><h2 id="权威选项-7"><a href="#权威选项-7" class="headerlink" title="权威选项"></a>权威选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#X  *使用优化引擎 (有限内存边界检查) (--fast-engine)</span><br><span class="line">#0   过滤测试 (-#0 &#x27;*.gif&#x27; &#x27;www.bar.com/foo.gif&#x27;) (--debug-testfilters &lt;param&gt;)</span><br><span class="line">#1   简化测试 (-#1 ./foo/bar/../foobar)</span><br><span class="line">#2   类型测试 (-#2 /foo/bar.php)</span><br><span class="line">#C   换成列表 (-#C &#x27;*.com/spider*.gif&#x27; (--debug-cache &lt;param&gt;)</span><br><span class="line">#R   缓存修复 (损坏缓存) (--repair-cache)</span><br><span class="line">#d   调试分析器 (--debug-parsing)</span><br><span class="line">#E   在meta.zip中提取new.zip缓存元数据</span><br><span class="line">#f   总是刷新日志文件 (--advanced-flushlogs)</span><br><span class="line">#FN  过滤器的最大过滤数目 (--advanced-maxfilters[=N])</span><br><span class="line">#h   版本信息 (--version)</span><br><span class="line">#K   扫描标准输入 (debug) (--debug-scanstdin)</span><br><span class="line">#L   最大链接数 (-#L1000000) (--advanced-maxlinks[=N])</span><br><span class="line">#p   显示进度信息 (--advanced-progressinfo)</span><br><span class="line">#P   抓取URL (--catch-url)</span><br><span class="line">#R   旧的FTP例程 (debug) (--repair-cache)</span><br><span class="line">#T   每分钟生成一次传输操作日志 (--debug-xfrstats)</span><br><span class="line">#u   等待时间 (--advanced-wait)</span><br><span class="line">#Z   每分钟生成传输速率的静态数据 (--debug-ratestats)</span><br></pre></td></tr></table></figure><h2 id="危险选项-7"><a href="#危险选项-7" class="headerlink" title="危险选项"></a>危险选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%!  绕过旨在避免带宽滥用的内置安全限制 (带宽，并发连接) (--disable-security-limits)</span><br></pre></td></tr></table></figure><p>危险选项，仅适用于专家；</p><p>谨慎使用；</p><h2 id="命令行特定选项-7"><a href="#命令行特定选项-7" class="headerlink" title="命令行特定选项"></a>命令行特定选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V   执行每个文件后的系统命令 ($0 is the filename: -V &quot;rm \$0&quot;) (--userdef-cmd &lt;param&gt;)</span><br><span class="line">%W  使用外部库函数作为包装器 (-%W myfoo.so[,myparameters]) (--callback &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="选项-N-详情-7"><a href="#选项-N-详情-7" class="headerlink" title="选项 N 详情"></a>选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N0 站点结构 (默认)</span><br><span class="line">N1 HTML in web/, images/other files in web/images/</span><br><span class="line">N2 HTML in web/HTML, images/other in web/images</span><br><span class="line">N3 HTML in web/,  images/other in web/</span><br><span class="line">N4 HTML in web/, images/other in web/xxx, where xxx is the file extension (all gif will be placed onto web/gif, for example)</span><br><span class="line">N5 Images/other in web/xxx and HTML in web/HTML</span><br><span class="line">N99 All files in web/, with random names (gadget !)</span><br><span class="line">N100 站点结构，不包括www.domain.xxx/</span><br><span class="line">N101 Identical to N1 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N102 Identical to N2 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N103 Identical to N3 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N104 Identical to N4 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N105 Identical to N5 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N199 Identical to N99 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N1001 Identical to N1 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1002 Identical to N2 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1003 Identical to N3 exept that there is no &quot;web&quot; directory (option set for g option)</span><br><span class="line">N1004 Identical to N4 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1005 Identical to N5 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1099 Identical to N99 exept that there is no &quot;web&quot; directory</span><br></pre></td></tr></table></figure><h2 id="用户定义选项-N-详情-7"><a href="#用户定义选项-N-详情-7" class="headerlink" title="用户定义选项 N 详情"></a>用户定义选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;%n&#x27; 没有文件类型的文件名 (ex: image)</span><br><span class="line">&#x27;%N&#x27; 文件名，包括文件类型 (ex: image.gif)</span><br><span class="line">&#x27;%t&#x27; 文件类型 (ex: gif)</span><br><span class="line">&#x27;%p&#x27; 路径 [无结尾 /] (ex: /someimages)</span><br><span class="line">&#x27;%h&#x27; 主机名 (ex: www.someweb.com)</span><br><span class="line">&#x27;%M&#x27; URL MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%Q&#x27; 查询字符串MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%k&#x27; 完整查询字符串</span><br><span class="line">&#x27;%r&#x27; 协议名 (ex: http)</span><br><span class="line">&#x27;%q&#x27; 短查询字符串 (16位，4个ascii字节)</span><br><span class="line"> &#x27;%s?&#x27; 短名称版本 (ex: %sN)</span><br><span class="line">&#x27;%[param]&#x27; 查询字符串中的param变量</span><br><span class="line">&#x27;%[param:before:after:empty:notfound]&#x27; 高级变量提取</span><br></pre></td></tr></table></figure><h2 id="用户定义的选项-N-和高级变量提取详情-7"><a href="#用户定义的选项-N-和高级变量提取详情-7" class="headerlink" title="用户定义的选项 N 和高级变量提取详情"></a>用户定义的选项 N 和高级变量提取详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%[param:before:after:empty:notfound]</span><br><span class="line">param    参数名称</span><br><span class="line">before   如果找到参数，则在其前面加上字符串</span><br><span class="line">after    找到参数后要追加的字符串</span><br><span class="line">notfound 如果找不到参数，则替换字符串</span><br><span class="line">empty    如果参数为空，则替换字符串</span><br></pre></td></tr></table></figure><p>除第一个字段（参数名）外，所有字段都可以为空</p><h2 id="选项-K-详情-7"><a href="#选项-K-详情-7" class="headerlink" title="选项 K 详情"></a>选项 K 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K0  foo.cgi?q=45  -&gt;  foo4B54.html?q=45 (relative URI, default)</span><br><span class="line">K                 -&gt;  http://www.foobar.com/folder/foo.cgi?q=45 (absolute URL) (--keep-links[=N])</span><br><span class="line">K3                -&gt;  /folder/foo.cgi?q=45 (absolute URI)</span><br><span class="line">K4                -&gt;  foo.cgi?q=45 (original URL)</span><br><span class="line">K5                -&gt;  http://www.foobar.com/folder/foo4B54.html?q=45 (transparent proxy URL)</span><br></pre></td></tr></table></figure><h2 id="快捷操作-7"><a href="#快捷操作-7" class="headerlink" title="快捷操作"></a>快捷操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--mirror      &lt;URLs&gt; *制作站点的镜像 (default)</span><br><span class="line">--get         &lt;URLs&gt;  获取指定的文件，不要查找其他URL (-qg)</span><br><span class="line">--list   &lt;text file&gt;  添加此文本文件中的所有URL (-%L)</span><br><span class="line">--mirrorlinks &lt;URLs&gt;  镜像一级页面中的所有链接 (-Y)</span><br><span class="line">--testlinks   &lt;URLs&gt;  测试页面中的链接 (-r1p0C0I0t)</span><br><span class="line">--spider      &lt;URLs&gt;  爬取站点，用于测试链接:报告错误和警告 (-p0C0I0t)</span><br><span class="line">--testsite    &lt;URLs&gt;  与--spider相同</span><br><span class="line">--skeleton    &lt;URLs&gt;  创建镜像，但只获取html文件 (-p1)</span><br><span class="line">--update              更新镜像，无需确认 (-iC2)</span><br><span class="line">--continue            继续镜像，无需确认 (-iC1)</span><br><span class="line"></span><br><span class="line">--catchurl            创建一个临时代理来捕获一个URL或一个表单post URL</span><br><span class="line">--clean               删除缓存和日志文件</span><br><span class="line"></span><br><span class="line">--http10              强制http/1.0请求 (-%h)</span><br></pre></td></tr></table></figure><h1 id="举例-7"><a href="#举例-7" class="headerlink" title="举例"></a>举例</h1><ol><li><p>只镜像站点 <code>www.someweb.com/bob/</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/</span><br></pre></td></tr></table></figure></li><li><p>将两个站点镜像在一起（带有共享链接），并接受.com 站点上的任何.jpg 文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/ www.anothertest.com/mike/ +*.com/*.jpg -mime:application/*</span><br></pre></td></tr></table></figure></li><li><p>从 bobby.html 开始获取所有文件，具有 6 个链接深度，并且可以在 web 上到处访问；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html +* -r6</span><br></pre></td></tr></table></figure></li><li><p>使用代理在 <code>www.someweb.com/bob/bobby.html</code> 上运行爬虫；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html --spider -P proxy.myhost.com:8080</span><br></pre></td></tr></table></figure></li><li><p>更新当前文件夹中的镜像 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --update</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹中继续镜像；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --continue</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-7"><a href="#参考-7" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.httrack.com/html/fcguide.html">Httrack Users Guide</a></p><ol start="9"><li><p>设置更多选项，可以使用 <code>help</code> 查看 (此处选择默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return=none) :</span><br></pre></td></tr></table></figure><p>[# HTTrack 简单使用</p></li></ol><ul><li><strong>本文作者：</strong> 李钰璕</li><li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack 简单使用.html</a></li></ul><h1 id="前言-9"><a href="#前言-9" class="headerlink" title="前言"></a>前言</h1><p><code>HTTrack</code> 是一个免费的（GPL，自由软件）和易于使用的离线浏览器工具。它可以爬取整站的网页，用于离线浏览，减少与目标系统交互。它可从 <code>Internet</code> 上下载万维网站点到本地目录，递归地构建所有目录，从服务器获取 <code>HTML</code>、图像和其他文件到本地。<code>HTTrack</code> 安排原始网站的相关链接结构。只需在浏览器中打开 “镜像” 网站的页面，即可从链接到链接浏览网站，就像在线查看网站一样。<code>HTTrack</code> 也可以更新现有的镜像站点，并恢复中断的下载。<code>HTTrack</code> 完全可配置，并具有集成的帮助系统。</p><h1 id="HTTrack-安装-9"><a href="#HTTrack-安装-9" class="headerlink" title="HTTrack 安装"></a><code>HTTrack</code> 安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# apt-get install httrack</span><br></pre></td></tr></table></figure><h1 id="HTTrack-交互模式使用步骤-9"><a href="#HTTrack-交互模式使用步骤-9" class="headerlink" title="HTTrack 交互模式使用步骤"></a><code>HTTrack</code> 交互模式使用步骤</h1><ol><li><p>创建目录存储复制网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# mkdir mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png" alt="img"></a></p></li><li><p>启动 <code>HTTrack</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# httrack</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png" alt="img"></a></p></li><li><p>输入项目名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter project name : blog//blog为项目名称</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png" alt="img"></a></p></li><li><p>选择存储网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base path (return=/root/websites/) :/root/mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png" alt="img"></a></p></li><li><p>输入网站的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter URLs (separated by commas or blank spaces) :www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png" alt="img"></a></p></li><li><p>选择操作 (此处选择 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action:</span><br><span class="line">(enter) 1Mirror Web Site(s)//直接镜像站点</span><br><span class="line">        2Mirror Web Site(s) with Wizard//用向导完成镜像</span><br><span class="line">        3Just Get Files Indicated//只get某种特定的文件</span><br><span class="line">        4Mirror ALL links in URLs (Multiple Mirror)//镜像在这个url下所有的链接</span><br><span class="line">        5Test Links In URLs (Bookmark Test)//测试在这个url下的链接</span><br><span class="line">        0Quit//退出</span><br><span class="line">: </span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png" alt="img"></a></p></li><li><p>指定是否在实施攻击时使用代理 (此处默认输入 none，不使用代理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png" alt="img"></a></p></li><li><p>定义字符，爬取特定类型的数据 (此处输入 <code>*</code> 表示爬取全部类型数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip</span><br><span class="line">Wildcards (return=none) :*</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png" alt="img"></a></p></li><li><p>设置更多选项，可以使用 <code>help</code> 查看 (此处选择默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png" alt="img"></a></p></li><li><p>开始克隆网站</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png" alt="img"></a></p></li><li><p>查看克隆的文件</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png" alt="img"></a></p></li></ol><p>备注：<code>httrack</code> 只能用于克隆静态内容，并且无法完全复制网站上的动态内容、中间部分 (数据库) 等内容。</p><h1 id="HTTrack-一般模式使用步骤-8"><a href="#HTTrack-一般模式使用步骤-8" class="headerlink" title="HTTrack 一般模式使用步骤"></a><code>HTTrack</code> 一般模式使用步骤</h1><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack &lt;URLs&gt; [-option] [+&lt;URL_FILTER&gt;] [-&lt;URL_FILTER&gt;] [+&lt;mime:MIME_FILTER&gt;] [-&lt;mime:MIME_FILTER&gt;]</span><br></pre></td></tr></table></figure><p>选项如下：（* 为默认值）</p><h2 id="一般选项-8"><a href="#一般选项-8" class="headerlink" title="一般选项"></a>一般选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O  镜像路径/缓存和日志文件路径</span><br><span class="line">-O 镜像路径[,缓存和日志文件路径] (--path &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="行为选项-8"><a href="#行为选项-8" class="headerlink" title="行为选项"></a>行为选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w  *镜像网站 (--mirror)</span><br><span class="line">W镜像网站，半自动 (asks questions) (--mirror-wizard)</span><br><span class="line">g只获取文件（保存在当前目录中） (--get-files)</span><br><span class="line">i使用缓存继续中断的镜像 (--continue)</span><br><span class="line">Y镜像所有位于第一级页面的链接 (镜像链接) (--mirrorlinks)</span><br></pre></td></tr></table></figure><h2 id="代理选项-8"><a href="#代理选项-8" class="headerlink" title="代理选项"></a>代理选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   代理使用 (-P proxy:port or -P user:pass@proxy:port) (--proxy &lt;param&gt;)</span><br><span class="line">%f *使用ftp代理 (f0 don&#x27;t use) (--httpproxy-ftp[=N])</span><br><span class="line">%b  使用此本地主机名发出/发送请求 (-%b 主机名) (--bind &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="限制选项-8"><a href="#限制选项-8" class="headerlink" title="限制选项"></a>限制选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rN  将“镜像深度”设置为N (* r9999) (--depth[=N])</span><br><span class="line">%eN   将“外部链接深度”设置为N (* %e0) (--ext-depth[=N])</span><br><span class="line">mN    将非HTML文件的最大文件长度设置为N (--max-files[=N])</span><br><span class="line">mN,N2 将非HTML文件的最大文件长度设置为N、将HTML文件的最大文件长度设置为N2</span><br><span class="line">MN    将可上传/扫描的最大总长度设置为N (--max-size[=N])</span><br><span class="line">EN    将最大镜像传输时间设置为N秒 (60=1 minute, 3600=1 hour) (--max-time[=N])</span><br><span class="line">AN    将最大传输速率设置为N字节/秒 (1000=1KB/s max) (--max-rate[=N])</span><br><span class="line">%cN   将最大连接数设置为N个/秒 (*%c10) (--connection-per-second[=N])</span><br><span class="line">GN    设置如果达到N个字节，则暂停传输，并等待锁定文件被删除 (--max-pause[=N])</span><br></pre></td></tr></table></figure><h2 id="流量控制-8"><a href="#流量控制-8" class="headerlink" title="流量控制"></a>流量控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cN  设置连接数为N (*c8) (--sockets[=N])</span><br><span class="line">TN  设置关闭无响应链接N秒后超时 (--timeout)</span><br><span class="line">RN  设置超时或非致命错误情况下的重试次数为N (*R1) (--retries[=N])</span><br><span class="line">JN  流量阻塞控制，设置链路允许的最小传输速率为N字节/秒 (--min-rate[=N])</span><br><span class="line">HN  如果：0=从不、1=超时、2=慢、3=超时或慢，则放弃主机 (--host-control[=N])</span><br></pre></td></tr></table></figure><h2 id="链接选项-8"><a href="#链接选项-8" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%P        *扩展解析，尝试解析所有链接，即使是未知标记或Javascript标记 (%P0 don&#x27;t use) (--extended-parsing[=N])</span><br><span class="line">n          在html文件附近获取非html文件 (例如：位于外部的图像) (--near)</span><br><span class="line">t          测试所有url（即使url被禁止） (--test)</span><br><span class="line">%L &lt;file&gt;  添加位于此文本文件中的所有URL（每行一个URL）  (--list &lt;param&gt;)</span><br><span class="line">%S &lt;file&gt;  添加位于此文本文件中的所有扫描规则（每行一个扫描规则） (--urllist &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="构建选项-8"><a href="#构建选项-8" class="headerlink" title="构建选项"></a>构建选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NN结构类型 (0 *原始结构, 1+: 详见下文) (--structure[=N])</span><br><span class="line">    或用户定义的结构 (-N &quot;%h%p/%n%q.%t&quot;)</span><br><span class="line">%N  延迟类型检查，不进行任何链接测试，而是等待文件下载开始（实验性的）(N0 不使用，%N1 用于未知扩展名，*%N2 始终使用)</span><br><span class="line">%D  缓存的延迟类型检查，不要在更新期间等待远程类型，以加快更新速度 (%D0 等待, * %D1 不等待) (--cached-delayed-type-check)</span><br><span class="line">%M  生成RFC MIME封装的完整存档 (.mht) (--mime-html)</span><br><span class="line">LN长名称 (L1 *长名称 / L0 8-3 转换 / L2 ISO9660 兼容) (--long-names[=N])</span><br><span class="line">KN保留原始链接 (e.g. http://www.adr/link) (K0 *相对链接, K 绝对链接, K4 原始链接, K3 绝对URI链接, K5 透明代理链接) (--keep-links[=N])</span><br><span class="line">x用错误页替换外部html链接 (--replace-external)</span><br><span class="line">%x不包括受外部密码保护的网站的任何密码 (%x0 包括) (--disable-passwords)</span><br><span class="line">%q *包含本地文件的查询字符串 (无用,仅供参考) (%q0 不包含) (--include-query-string)</span><br><span class="line">o  *出错时生成输出html文件 (404..) (o0 不生成) (--generate-errors)</span><br><span class="line">X  *更新后清除旧文件 (X0 保持删除) (--purge-old[=N])</span><br><span class="line">%p保留html文件“原样” (与&#x27;-K4 -%F &quot;&quot;&#x27;相同) (--preserve)</span><br><span class="line">%T链接转换为UTF-8 (--utf8-conversion)</span><br></pre></td></tr></table></figure><h2 id="蜘蛛选项-8"><a href="#蜘蛛选项-8" class="headerlink" title="蜘蛛选项"></a>蜘蛛选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bN接受cookies.txt中的cookies (0=不接受,* 1=接受) (--cookies[=N])</span><br><span class="line">u检查未知文档类型 (cgi,asp..) (u0 不检查, * u1 检查除了 /, u2 始终检查) (--check-type[=N])</span><br><span class="line">j  *解析JAVA类 (j0 不解析, 位掩码: |1 解析默认值, |2 不解析.class文件 |4 不解析.js文件 |8 不越界解析) (--parse-java[=N])</span><br><span class="line">sN遵循robots.txt和meta robots标记 (0=never,1=sometimes,* 2=always, 3=always (even strict rules)) (--robots[=N])</span><br><span class="line">%h  强制HTTP/1请求 (仅针对旧服务器或代理减少更新特性) (--http-10)</span><br><span class="line">%k尽可能使用keep alive，大大减少小文件和测试请求的延迟 (%k0 不使用) (--keep-alive)</span><br><span class="line">%B  容忍请求 (在某些服务器上接受虚假响应，但不是标准的!) (--tolerant)</span><br><span class="line">%s  更新非法入侵：在更新时限制重新传输的各种非法入侵(相同大小，虚假响应…) (--updatehack)</span><br><span class="line">%u  url非法入侵：限制重复url的各种非法入侵 (strip //, www.foo.com==foo.com..) (--urlhack)</span><br><span class="line">%A  假设一个类型(cgi,asp..)总是与一个mime类型链接 (-%A php3,cgi=text/html;dat,bin=application/x-zip) (--assume &lt;param&gt;)</span><br><span class="line">     快捷方式：&#x27;--assume standard&#x27;相当于-%A php2 php3 php4 php cgi asp jsp pl cfm nsf=text/html</span><br><span class="line">     也可以用于强制特定的文件类型：-assume foo.cgi=text/html</span><br><span class="line">@iNinternet协议 (0=both ipv6+ipv4, 4=ipv4 only, 6=ipv6 only) (--protocol[=N])</span><br><span class="line">%w  禁用特定的外部mime模块 (-%w htsswf -%w htsjava) (--disable-module &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="浏览器-ID-8"><a href="#浏览器-ID-8" class="headerlink" title="浏览器 ID"></a>浏览器 ID</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F   在HTTP头中发送的用户代理字段 (-F &quot;user-agent name&quot;) (--user-agent &lt;param&gt;)</span><br><span class="line">%R  在HTTP头中发送的默认referer字段 (--referer &lt;param&gt;)</span><br><span class="line">%E  从以HTTP头发送的电子邮件地址 (--from &lt;param&gt;)</span><br><span class="line">%F  Html代码中的页脚字符串 (-%F &quot;Mirrored [from host %s [file %s [at %s]]]&quot; (--footer &lt;param&gt;)</span><br><span class="line">%l  首选语言 (-%l &quot;fr, en, jp, *&quot; (--language &lt;param&gt;)</span><br><span class="line">%a  接受格式 (-%a &quot;text/html,image/png;q=0.9,*/*;q=0.1&quot; (--accept &lt;param&gt;)</span><br><span class="line">%X  附加的HTTP标题行 (-%X &quot;X-Magic: 42&quot; (--headers &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="日志、索引、缓存-8"><a href="#日志、索引、缓存-8" class="headerlink" title="日志、索引、缓存"></a>日志、索引、缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C   创建/使用缓存进行更新和重试 (C0 无缓存,C1 缓存优先,* C2 测试更新前) (--cache[=N])</span><br><span class="line">k   将所有文件存储在缓存中 (如果文件在磁盘上，则此功能不可用) (--store-all-in-cache)</span><br><span class="line">%n  不能重新下载本地删除的文件 (--do-not-recatch)</span><br><span class="line">%v  在屏幕上显示下载的文件名(实时) - * %v1 缩写版 - %v2 完整 (--display)</span><br><span class="line">Q   无日志-安静模式  (--do-not-log)</span><br><span class="line">q   无问题-安静模式 (--quiet)</span><br><span class="line">z   日志-附加信息 (--extra-log)</span><br><span class="line">Z   日志-debug (--debug-log)</span><br><span class="line">v   登录屏幕 (--verbose)</span><br><span class="line">f  *登录文件 (--file-log)</span><br><span class="line">f2  一个单一日志文件(--single-log)</span><br><span class="line">I  *编制索引 (I0 不编制索引) (--index)</span><br><span class="line">%i  为项目文件夹创建顶级索引 (* %i0 不创建) (--build-top-index)</span><br><span class="line">%I  为此镜像创建可搜索索引 (* %I0 不创建) (--search-index)</span><br></pre></td></tr></table></figure><h2 id="专家选项-8"><a href="#专家选项-8" class="headerlink" title="专家选项"></a>专家选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pN  优先模式: (* p3) (--priority[=N])</span><br><span class="line">     p0 只扫描，不保存任何内容 (用于检查链接)</span><br><span class="line">     p1 只保存html文件</span><br><span class="line">     p2 只保存非html文件</span><br><span class="line">    *p3 保存所有文件</span><br><span class="line">     p7 先获取html文件，然后处理其他文件</span><br><span class="line">S   保持在同一个目录 (--stay-on-same-dir)</span><br><span class="line">D  *只能进入子目录 (--can-go-down)</span><br><span class="line">U   只能进入父目录 (--can-go-up)</span><br><span class="line">B   可以上下进入目录结构 (--can-go-up-and-down)</span><br><span class="line">a  *保持在同一地址 (--stay-on-same-address)</span><br><span class="line">d   保持在同一主域 (--stay-on-same-domain)</span><br><span class="line">l   保持相同的TLD (eg: .com) (--stay-on-same-tld)</span><br><span class="line">e   go everywhere on the web (--go-everywhere)</span><br><span class="line">%H  在日志文件中调试HTTP头 (--debug-headers)</span><br></pre></td></tr></table></figure><h2 id="权威选项-8"><a href="#权威选项-8" class="headerlink" title="权威选项"></a>权威选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#X  *使用优化引擎 (有限内存边界检查) (--fast-engine)</span><br><span class="line">#0   过滤测试 (-#0 &#x27;*.gif&#x27; &#x27;www.bar.com/foo.gif&#x27;) (--debug-testfilters &lt;param&gt;)</span><br><span class="line">#1   简化测试 (-#1 ./foo/bar/../foobar)</span><br><span class="line">#2   类型测试 (-#2 /foo/bar.php)</span><br><span class="line">#C   换成列表 (-#C &#x27;*.com/spider*.gif&#x27; (--debug-cache &lt;param&gt;)</span><br><span class="line">#R   缓存修复 (损坏缓存) (--repair-cache)</span><br><span class="line">#d   调试分析器 (--debug-parsing)</span><br><span class="line">#E   在meta.zip中提取new.zip缓存元数据</span><br><span class="line">#f   总是刷新日志文件 (--advanced-flushlogs)</span><br><span class="line">#FN  过滤器的最大过滤数目 (--advanced-maxfilters[=N])</span><br><span class="line">#h   版本信息 (--version)</span><br><span class="line">#K   扫描标准输入 (debug) (--debug-scanstdin)</span><br><span class="line">#L   最大链接数 (-#L1000000) (--advanced-maxlinks[=N])</span><br><span class="line">#p   显示进度信息 (--advanced-progressinfo)</span><br><span class="line">#P   抓取URL (--catch-url)</span><br><span class="line">#R   旧的FTP例程 (debug) (--repair-cache)</span><br><span class="line">#T   每分钟生成一次传输操作日志 (--debug-xfrstats)</span><br><span class="line">#u   等待时间 (--advanced-wait)</span><br><span class="line">#Z   每分钟生成传输速率的静态数据 (--debug-ratestats)</span><br></pre></td></tr></table></figure><h2 id="危险选项-8"><a href="#危险选项-8" class="headerlink" title="危险选项"></a>危险选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%!  绕过旨在避免带宽滥用的内置安全限制 (带宽，并发连接) (--disable-security-limits)</span><br></pre></td></tr></table></figure><p>危险选项，仅适用于专家；</p><p>谨慎使用；</p><h2 id="命令行特定选项-8"><a href="#命令行特定选项-8" class="headerlink" title="命令行特定选项"></a>命令行特定选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V   执行每个文件后的系统命令 ($0 is the filename: -V &quot;rm \$0&quot;) (--userdef-cmd &lt;param&gt;)</span><br><span class="line">%W  使用外部库函数作为包装器 (-%W myfoo.so[,myparameters]) (--callback &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="选项-N-详情-8"><a href="#选项-N-详情-8" class="headerlink" title="选项 N 详情"></a>选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N0 站点结构 (默认)</span><br><span class="line">N1 HTML in web/, images/other files in web/images/</span><br><span class="line">N2 HTML in web/HTML, images/other in web/images</span><br><span class="line">N3 HTML in web/,  images/other in web/</span><br><span class="line">N4 HTML in web/, images/other in web/xxx, where xxx is the file extension (all gif will be placed onto web/gif, for example)</span><br><span class="line">N5 Images/other in web/xxx and HTML in web/HTML</span><br><span class="line">N99 All files in web/, with random names (gadget !)</span><br><span class="line">N100 站点结构，不包括www.domain.xxx/</span><br><span class="line">N101 Identical to N1 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N102 Identical to N2 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N103 Identical to N3 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N104 Identical to N4 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N105 Identical to N5 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N199 Identical to N99 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N1001 Identical to N1 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1002 Identical to N2 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1003 Identical to N3 exept that there is no &quot;web&quot; directory (option set for g option)</span><br><span class="line">N1004 Identical to N4 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1005 Identical to N5 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1099 Identical to N99 exept that there is no &quot;web&quot; directory</span><br></pre></td></tr></table></figure><h2 id="用户定义选项-N-详情-8"><a href="#用户定义选项-N-详情-8" class="headerlink" title="用户定义选项 N 详情"></a>用户定义选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;%n&#x27; 没有文件类型的文件名 (ex: image)</span><br><span class="line">&#x27;%N&#x27; 文件名，包括文件类型 (ex: image.gif)</span><br><span class="line">&#x27;%t&#x27; 文件类型 (ex: gif)</span><br><span class="line">&#x27;%p&#x27; 路径 [无结尾 /] (ex: /someimages)</span><br><span class="line">&#x27;%h&#x27; 主机名 (ex: www.someweb.com)</span><br><span class="line">&#x27;%M&#x27; URL MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%Q&#x27; 查询字符串MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%k&#x27; 完整查询字符串</span><br><span class="line">&#x27;%r&#x27; 协议名 (ex: http)</span><br><span class="line">&#x27;%q&#x27; 短查询字符串 (16位，4个ascii字节)</span><br><span class="line"> &#x27;%s?&#x27; 短名称版本 (ex: %sN)</span><br><span class="line">&#x27;%[param]&#x27; 查询字符串中的param变量</span><br><span class="line">&#x27;%[param:before:after:empty:notfound]&#x27; 高级变量提取</span><br></pre></td></tr></table></figure><h2 id="用户定义的选项-N-和高级变量提取详情-8"><a href="#用户定义的选项-N-和高级变量提取详情-8" class="headerlink" title="用户定义的选项 N 和高级变量提取详情"></a>用户定义的选项 N 和高级变量提取详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%[param:before:after:empty:notfound]</span><br><span class="line">param    参数名称</span><br><span class="line">before   如果找到参数，则在其前面加上字符串</span><br><span class="line">after    找到参数后要追加的字符串</span><br><span class="line">notfound 如果找不到参数，则替换字符串</span><br><span class="line">empty    如果参数为空，则替换字符串</span><br></pre></td></tr></table></figure><p>除第一个字段（参数名）外，所有字段都可以为空</p><h2 id="选项-K-详情-8"><a href="#选项-K-详情-8" class="headerlink" title="选项 K 详情"></a>选项 K 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K0  foo.cgi?q=45  -&gt;  foo4B54.html?q=45 (relative URI, default)</span><br><span class="line">K                 -&gt;  http://www.foobar.com/folder/foo.cgi?q=45 (absolute URL) (--keep-links[=N])</span><br><span class="line">K3                -&gt;  /folder/foo.cgi?q=45 (absolute URI)</span><br><span class="line">K4                -&gt;  foo.cgi?q=45 (original URL)</span><br><span class="line">K5                -&gt;  http://www.foobar.com/folder/foo4B54.html?q=45 (transparent proxy URL)</span><br></pre></td></tr></table></figure><h2 id="快捷操作-8"><a href="#快捷操作-8" class="headerlink" title="快捷操作"></a>快捷操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--mirror      &lt;URLs&gt; *制作站点的镜像 (default)</span><br><span class="line">--get         &lt;URLs&gt;  获取指定的文件，不要查找其他URL (-qg)</span><br><span class="line">--list   &lt;text file&gt;  添加此文本文件中的所有URL (-%L)</span><br><span class="line">--mirrorlinks &lt;URLs&gt;  镜像一级页面中的所有链接 (-Y)</span><br><span class="line">--testlinks   &lt;URLs&gt;  测试页面中的链接 (-r1p0C0I0t)</span><br><span class="line">--spider      &lt;URLs&gt;  爬取站点，用于测试链接:报告错误和警告 (-p0C0I0t)</span><br><span class="line">--testsite    &lt;URLs&gt;  与--spider相同</span><br><span class="line">--skeleton    &lt;URLs&gt;  创建镜像，但只获取html文件 (-p1)</span><br><span class="line">--update              更新镜像，无需确认 (-iC2)</span><br><span class="line">--continue            继续镜像，无需确认 (-iC1)</span><br><span class="line"></span><br><span class="line">--catchurl            创建一个临时代理来捕获一个URL或一个表单post URL</span><br><span class="line">--clean               删除缓存和日志文件</span><br><span class="line"></span><br><span class="line">--http10              强制http/1.0请求 (-%h)</span><br></pre></td></tr></table></figure><h1 id="举例-8"><a href="#举例-8" class="headerlink" title="举例"></a>举例</h1><ol><li><p>只镜像站点 <code>www.someweb.com/bob/</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/</span><br></pre></td></tr></table></figure></li><li><p>将两个站点镜像在一起（带有共享链接），并接受.com 站点上的任何.jpg 文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/ www.anothertest.com/mike/ +*.com/*.jpg -mime:application/*</span><br></pre></td></tr></table></figure></li><li><p>从 bobby.html 开始获取所有文件，具有 6 个链接深度，并且可以在 web 上到处访问；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html +* -r6</span><br></pre></td></tr></table></figure></li><li><p>使用代理在 <code>www.someweb.com/bob/bobby.html</code> 上运行爬虫；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html --spider -P proxy.myhost.com:8080</span><br></pre></td></tr></table></figure></li><li><p>更新当前文件夹中的镜像 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --update</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹中继续镜像；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --continue</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-8"><a href="#参考-8" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.httrack.com/html/fcguide.html">Httrack Users Guide</a></p><ol start="10"><li><p>开始克隆网站</p><p>[# HTTrack 简单使用</p></li></ol><ul><li><strong>本文作者：</strong> 李钰璕</li><li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack 简单使用.html</a></li></ul><h1 id="前言-10"><a href="#前言-10" class="headerlink" title="前言"></a>前言</h1><p><code>HTTrack</code> 是一个免费的（GPL，自由软件）和易于使用的离线浏览器工具。它可以爬取整站的网页，用于离线浏览，减少与目标系统交互。它可从 <code>Internet</code> 上下载万维网站点到本地目录，递归地构建所有目录，从服务器获取 <code>HTML</code>、图像和其他文件到本地。<code>HTTrack</code> 安排原始网站的相关链接结构。只需在浏览器中打开 “镜像” 网站的页面，即可从链接到链接浏览网站，就像在线查看网站一样。<code>HTTrack</code> 也可以更新现有的镜像站点，并恢复中断的下载。<code>HTTrack</code> 完全可配置，并具有集成的帮助系统。</p><h1 id="HTTrack-安装-10"><a href="#HTTrack-安装-10" class="headerlink" title="HTTrack 安装"></a><code>HTTrack</code> 安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# apt-get install httrack</span><br></pre></td></tr></table></figure><h1 id="HTTrack-交互模式使用步骤-10"><a href="#HTTrack-交互模式使用步骤-10" class="headerlink" title="HTTrack 交互模式使用步骤"></a><code>HTTrack</code> 交互模式使用步骤</h1><ol><li><p>创建目录存储复制网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# mkdir mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png" alt="img"></a></p></li><li><p>启动 <code>HTTrack</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# httrack</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png" alt="img"></a></p></li><li><p>输入项目名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter project name : blog//blog为项目名称</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png" alt="img"></a></p></li><li><p>选择存储网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base path (return=/root/websites/) :/root/mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png" alt="img"></a></p></li><li><p>输入网站的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter URLs (separated by commas or blank spaces) :www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png" alt="img"></a></p></li><li><p>选择操作 (此处选择 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action:</span><br><span class="line">(enter) 1Mirror Web Site(s)//直接镜像站点</span><br><span class="line">        2Mirror Web Site(s) with Wizard//用向导完成镜像</span><br><span class="line">        3Just Get Files Indicated//只get某种特定的文件</span><br><span class="line">        4Mirror ALL links in URLs (Multiple Mirror)//镜像在这个url下所有的链接</span><br><span class="line">        5Test Links In URLs (Bookmark Test)//测试在这个url下的链接</span><br><span class="line">        0Quit//退出</span><br><span class="line">: </span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png" alt="img"></a></p></li><li><p>指定是否在实施攻击时使用代理 (此处默认输入 none，不使用代理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png" alt="img"></a></p></li><li><p>定义字符，爬取特定类型的数据 (此处输入 <code>*</code> 表示爬取全部类型数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip</span><br><span class="line">Wildcards (return=none) :*</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png" alt="img"></a></p></li><li><p>设置更多选项，可以使用 <code>help</code> 查看 (此处选择默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png" alt="img"></a></p></li><li><p>开始克隆网站</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png" alt="img"></a></p></li><li><p>查看克隆的文件</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png" alt="img"></a></p></li></ol><p>备注：<code>httrack</code> 只能用于克隆静态内容，并且无法完全复制网站上的动态内容、中间部分 (数据库) 等内容。</p><h1 id="HTTrack-一般模式使用步骤-9"><a href="#HTTrack-一般模式使用步骤-9" class="headerlink" title="HTTrack 一般模式使用步骤"></a><code>HTTrack</code> 一般模式使用步骤</h1><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack &lt;URLs&gt; [-option] [+&lt;URL_FILTER&gt;] [-&lt;URL_FILTER&gt;] [+&lt;mime:MIME_FILTER&gt;] [-&lt;mime:MIME_FILTER&gt;]</span><br></pre></td></tr></table></figure><p>选项如下：（* 为默认值）</p><h2 id="一般选项-9"><a href="#一般选项-9" class="headerlink" title="一般选项"></a>一般选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O  镜像路径/缓存和日志文件路径</span><br><span class="line">-O 镜像路径[,缓存和日志文件路径] (--path &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="行为选项-9"><a href="#行为选项-9" class="headerlink" title="行为选项"></a>行为选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w  *镜像网站 (--mirror)</span><br><span class="line">W镜像网站，半自动 (asks questions) (--mirror-wizard)</span><br><span class="line">g只获取文件（保存在当前目录中） (--get-files)</span><br><span class="line">i使用缓存继续中断的镜像 (--continue)</span><br><span class="line">Y镜像所有位于第一级页面的链接 (镜像链接) (--mirrorlinks)</span><br></pre></td></tr></table></figure><h2 id="代理选项-9"><a href="#代理选项-9" class="headerlink" title="代理选项"></a>代理选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   代理使用 (-P proxy:port or -P user:pass@proxy:port) (--proxy &lt;param&gt;)</span><br><span class="line">%f *使用ftp代理 (f0 don&#x27;t use) (--httpproxy-ftp[=N])</span><br><span class="line">%b  使用此本地主机名发出/发送请求 (-%b 主机名) (--bind &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="限制选项-9"><a href="#限制选项-9" class="headerlink" title="限制选项"></a>限制选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rN  将“镜像深度”设置为N (* r9999) (--depth[=N])</span><br><span class="line">%eN   将“外部链接深度”设置为N (* %e0) (--ext-depth[=N])</span><br><span class="line">mN    将非HTML文件的最大文件长度设置为N (--max-files[=N])</span><br><span class="line">mN,N2 将非HTML文件的最大文件长度设置为N、将HTML文件的最大文件长度设置为N2</span><br><span class="line">MN    将可上传/扫描的最大总长度设置为N (--max-size[=N])</span><br><span class="line">EN    将最大镜像传输时间设置为N秒 (60=1 minute, 3600=1 hour) (--max-time[=N])</span><br><span class="line">AN    将最大传输速率设置为N字节/秒 (1000=1KB/s max) (--max-rate[=N])</span><br><span class="line">%cN   将最大连接数设置为N个/秒 (*%c10) (--connection-per-second[=N])</span><br><span class="line">GN    设置如果达到N个字节，则暂停传输，并等待锁定文件被删除 (--max-pause[=N])</span><br></pre></td></tr></table></figure><h2 id="流量控制-9"><a href="#流量控制-9" class="headerlink" title="流量控制"></a>流量控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cN  设置连接数为N (*c8) (--sockets[=N])</span><br><span class="line">TN  设置关闭无响应链接N秒后超时 (--timeout)</span><br><span class="line">RN  设置超时或非致命错误情况下的重试次数为N (*R1) (--retries[=N])</span><br><span class="line">JN  流量阻塞控制，设置链路允许的最小传输速率为N字节/秒 (--min-rate[=N])</span><br><span class="line">HN  如果：0=从不、1=超时、2=慢、3=超时或慢，则放弃主机 (--host-control[=N])</span><br></pre></td></tr></table></figure><h2 id="链接选项-9"><a href="#链接选项-9" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%P        *扩展解析，尝试解析所有链接，即使是未知标记或Javascript标记 (%P0 don&#x27;t use) (--extended-parsing[=N])</span><br><span class="line">n          在html文件附近获取非html文件 (例如：位于外部的图像) (--near)</span><br><span class="line">t          测试所有url（即使url被禁止） (--test)</span><br><span class="line">%L &lt;file&gt;  添加位于此文本文件中的所有URL（每行一个URL）  (--list &lt;param&gt;)</span><br><span class="line">%S &lt;file&gt;  添加位于此文本文件中的所有扫描规则（每行一个扫描规则） (--urllist &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="构建选项-9"><a href="#构建选项-9" class="headerlink" title="构建选项"></a>构建选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NN结构类型 (0 *原始结构, 1+: 详见下文) (--structure[=N])</span><br><span class="line">    或用户定义的结构 (-N &quot;%h%p/%n%q.%t&quot;)</span><br><span class="line">%N  延迟类型检查，不进行任何链接测试，而是等待文件下载开始（实验性的）(N0 不使用，%N1 用于未知扩展名，*%N2 始终使用)</span><br><span class="line">%D  缓存的延迟类型检查，不要在更新期间等待远程类型，以加快更新速度 (%D0 等待, * %D1 不等待) (--cached-delayed-type-check)</span><br><span class="line">%M  生成RFC MIME封装的完整存档 (.mht) (--mime-html)</span><br><span class="line">LN长名称 (L1 *长名称 / L0 8-3 转换 / L2 ISO9660 兼容) (--long-names[=N])</span><br><span class="line">KN保留原始链接 (e.g. http://www.adr/link) (K0 *相对链接, K 绝对链接, K4 原始链接, K3 绝对URI链接, K5 透明代理链接) (--keep-links[=N])</span><br><span class="line">x用错误页替换外部html链接 (--replace-external)</span><br><span class="line">%x不包括受外部密码保护的网站的任何密码 (%x0 包括) (--disable-passwords)</span><br><span class="line">%q *包含本地文件的查询字符串 (无用,仅供参考) (%q0 不包含) (--include-query-string)</span><br><span class="line">o  *出错时生成输出html文件 (404..) (o0 不生成) (--generate-errors)</span><br><span class="line">X  *更新后清除旧文件 (X0 保持删除) (--purge-old[=N])</span><br><span class="line">%p保留html文件“原样” (与&#x27;-K4 -%F &quot;&quot;&#x27;相同) (--preserve)</span><br><span class="line">%T链接转换为UTF-8 (--utf8-conversion)</span><br></pre></td></tr></table></figure><h2 id="蜘蛛选项-9"><a href="#蜘蛛选项-9" class="headerlink" title="蜘蛛选项"></a>蜘蛛选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bN接受cookies.txt中的cookies (0=不接受,* 1=接受) (--cookies[=N])</span><br><span class="line">u检查未知文档类型 (cgi,asp..) (u0 不检查, * u1 检查除了 /, u2 始终检查) (--check-type[=N])</span><br><span class="line">j  *解析JAVA类 (j0 不解析, 位掩码: |1 解析默认值, |2 不解析.class文件 |4 不解析.js文件 |8 不越界解析) (--parse-java[=N])</span><br><span class="line">sN遵循robots.txt和meta robots标记 (0=never,1=sometimes,* 2=always, 3=always (even strict rules)) (--robots[=N])</span><br><span class="line">%h  强制HTTP/1请求 (仅针对旧服务器或代理减少更新特性) (--http-10)</span><br><span class="line">%k尽可能使用keep alive，大大减少小文件和测试请求的延迟 (%k0 不使用) (--keep-alive)</span><br><span class="line">%B  容忍请求 (在某些服务器上接受虚假响应，但不是标准的!) (--tolerant)</span><br><span class="line">%s  更新非法入侵：在更新时限制重新传输的各种非法入侵(相同大小，虚假响应…) (--updatehack)</span><br><span class="line">%u  url非法入侵：限制重复url的各种非法入侵 (strip //, www.foo.com==foo.com..) (--urlhack)</span><br><span class="line">%A  假设一个类型(cgi,asp..)总是与一个mime类型链接 (-%A php3,cgi=text/html;dat,bin=application/x-zip) (--assume &lt;param&gt;)</span><br><span class="line">     快捷方式：&#x27;--assume standard&#x27;相当于-%A php2 php3 php4 php cgi asp jsp pl cfm nsf=text/html</span><br><span class="line">     也可以用于强制特定的文件类型：-assume foo.cgi=text/html</span><br><span class="line">@iNinternet协议 (0=both ipv6+ipv4, 4=ipv4 only, 6=ipv6 only) (--protocol[=N])</span><br><span class="line">%w  禁用特定的外部mime模块 (-%w htsswf -%w htsjava) (--disable-module &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="浏览器-ID-9"><a href="#浏览器-ID-9" class="headerlink" title="浏览器 ID"></a>浏览器 ID</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F   在HTTP头中发送的用户代理字段 (-F &quot;user-agent name&quot;) (--user-agent &lt;param&gt;)</span><br><span class="line">%R  在HTTP头中发送的默认referer字段 (--referer &lt;param&gt;)</span><br><span class="line">%E  从以HTTP头发送的电子邮件地址 (--from &lt;param&gt;)</span><br><span class="line">%F  Html代码中的页脚字符串 (-%F &quot;Mirrored [from host %s [file %s [at %s]]]&quot; (--footer &lt;param&gt;)</span><br><span class="line">%l  首选语言 (-%l &quot;fr, en, jp, *&quot; (--language &lt;param&gt;)</span><br><span class="line">%a  接受格式 (-%a &quot;text/html,image/png;q=0.9,*/*;q=0.1&quot; (--accept &lt;param&gt;)</span><br><span class="line">%X  附加的HTTP标题行 (-%X &quot;X-Magic: 42&quot; (--headers &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="日志、索引、缓存-9"><a href="#日志、索引、缓存-9" class="headerlink" title="日志、索引、缓存"></a>日志、索引、缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C   创建/使用缓存进行更新和重试 (C0 无缓存,C1 缓存优先,* C2 测试更新前) (--cache[=N])</span><br><span class="line">k   将所有文件存储在缓存中 (如果文件在磁盘上，则此功能不可用) (--store-all-in-cache)</span><br><span class="line">%n  不能重新下载本地删除的文件 (--do-not-recatch)</span><br><span class="line">%v  在屏幕上显示下载的文件名(实时) - * %v1 缩写版 - %v2 完整 (--display)</span><br><span class="line">Q   无日志-安静模式  (--do-not-log)</span><br><span class="line">q   无问题-安静模式 (--quiet)</span><br><span class="line">z   日志-附加信息 (--extra-log)</span><br><span class="line">Z   日志-debug (--debug-log)</span><br><span class="line">v   登录屏幕 (--verbose)</span><br><span class="line">f  *登录文件 (--file-log)</span><br><span class="line">f2  一个单一日志文件(--single-log)</span><br><span class="line">I  *编制索引 (I0 不编制索引) (--index)</span><br><span class="line">%i  为项目文件夹创建顶级索引 (* %i0 不创建) (--build-top-index)</span><br><span class="line">%I  为此镜像创建可搜索索引 (* %I0 不创建) (--search-index)</span><br></pre></td></tr></table></figure><h2 id="专家选项-9"><a href="#专家选项-9" class="headerlink" title="专家选项"></a>专家选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pN  优先模式: (* p3) (--priority[=N])</span><br><span class="line">     p0 只扫描，不保存任何内容 (用于检查链接)</span><br><span class="line">     p1 只保存html文件</span><br><span class="line">     p2 只保存非html文件</span><br><span class="line">    *p3 保存所有文件</span><br><span class="line">     p7 先获取html文件，然后处理其他文件</span><br><span class="line">S   保持在同一个目录 (--stay-on-same-dir)</span><br><span class="line">D  *只能进入子目录 (--can-go-down)</span><br><span class="line">U   只能进入父目录 (--can-go-up)</span><br><span class="line">B   可以上下进入目录结构 (--can-go-up-and-down)</span><br><span class="line">a  *保持在同一地址 (--stay-on-same-address)</span><br><span class="line">d   保持在同一主域 (--stay-on-same-domain)</span><br><span class="line">l   保持相同的TLD (eg: .com) (--stay-on-same-tld)</span><br><span class="line">e   go everywhere on the web (--go-everywhere)</span><br><span class="line">%H  在日志文件中调试HTTP头 (--debug-headers)</span><br></pre></td></tr></table></figure><h2 id="权威选项-9"><a href="#权威选项-9" class="headerlink" title="权威选项"></a>权威选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#X  *使用优化引擎 (有限内存边界检查) (--fast-engine)</span><br><span class="line">#0   过滤测试 (-#0 &#x27;*.gif&#x27; &#x27;www.bar.com/foo.gif&#x27;) (--debug-testfilters &lt;param&gt;)</span><br><span class="line">#1   简化测试 (-#1 ./foo/bar/../foobar)</span><br><span class="line">#2   类型测试 (-#2 /foo/bar.php)</span><br><span class="line">#C   换成列表 (-#C &#x27;*.com/spider*.gif&#x27; (--debug-cache &lt;param&gt;)</span><br><span class="line">#R   缓存修复 (损坏缓存) (--repair-cache)</span><br><span class="line">#d   调试分析器 (--debug-parsing)</span><br><span class="line">#E   在meta.zip中提取new.zip缓存元数据</span><br><span class="line">#f   总是刷新日志文件 (--advanced-flushlogs)</span><br><span class="line">#FN  过滤器的最大过滤数目 (--advanced-maxfilters[=N])</span><br><span class="line">#h   版本信息 (--version)</span><br><span class="line">#K   扫描标准输入 (debug) (--debug-scanstdin)</span><br><span class="line">#L   最大链接数 (-#L1000000) (--advanced-maxlinks[=N])</span><br><span class="line">#p   显示进度信息 (--advanced-progressinfo)</span><br><span class="line">#P   抓取URL (--catch-url)</span><br><span class="line">#R   旧的FTP例程 (debug) (--repair-cache)</span><br><span class="line">#T   每分钟生成一次传输操作日志 (--debug-xfrstats)</span><br><span class="line">#u   等待时间 (--advanced-wait)</span><br><span class="line">#Z   每分钟生成传输速率的静态数据 (--debug-ratestats)</span><br></pre></td></tr></table></figure><h2 id="危险选项-9"><a href="#危险选项-9" class="headerlink" title="危险选项"></a>危险选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%!  绕过旨在避免带宽滥用的内置安全限制 (带宽，并发连接) (--disable-security-limits)</span><br></pre></td></tr></table></figure><p>危险选项，仅适用于专家；</p><p>谨慎使用；</p><h2 id="命令行特定选项-9"><a href="#命令行特定选项-9" class="headerlink" title="命令行特定选项"></a>命令行特定选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V   执行每个文件后的系统命令 ($0 is the filename: -V &quot;rm \$0&quot;) (--userdef-cmd &lt;param&gt;)</span><br><span class="line">%W  使用外部库函数作为包装器 (-%W myfoo.so[,myparameters]) (--callback &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="选项-N-详情-9"><a href="#选项-N-详情-9" class="headerlink" title="选项 N 详情"></a>选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N0 站点结构 (默认)</span><br><span class="line">N1 HTML in web/, images/other files in web/images/</span><br><span class="line">N2 HTML in web/HTML, images/other in web/images</span><br><span class="line">N3 HTML in web/,  images/other in web/</span><br><span class="line">N4 HTML in web/, images/other in web/xxx, where xxx is the file extension (all gif will be placed onto web/gif, for example)</span><br><span class="line">N5 Images/other in web/xxx and HTML in web/HTML</span><br><span class="line">N99 All files in web/, with random names (gadget !)</span><br><span class="line">N100 站点结构，不包括www.domain.xxx/</span><br><span class="line">N101 Identical to N1 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N102 Identical to N2 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N103 Identical to N3 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N104 Identical to N4 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N105 Identical to N5 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N199 Identical to N99 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N1001 Identical to N1 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1002 Identical to N2 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1003 Identical to N3 exept that there is no &quot;web&quot; directory (option set for g option)</span><br><span class="line">N1004 Identical to N4 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1005 Identical to N5 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1099 Identical to N99 exept that there is no &quot;web&quot; directory</span><br></pre></td></tr></table></figure><h2 id="用户定义选项-N-详情-9"><a href="#用户定义选项-N-详情-9" class="headerlink" title="用户定义选项 N 详情"></a>用户定义选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;%n&#x27; 没有文件类型的文件名 (ex: image)</span><br><span class="line">&#x27;%N&#x27; 文件名，包括文件类型 (ex: image.gif)</span><br><span class="line">&#x27;%t&#x27; 文件类型 (ex: gif)</span><br><span class="line">&#x27;%p&#x27; 路径 [无结尾 /] (ex: /someimages)</span><br><span class="line">&#x27;%h&#x27; 主机名 (ex: www.someweb.com)</span><br><span class="line">&#x27;%M&#x27; URL MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%Q&#x27; 查询字符串MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%k&#x27; 完整查询字符串</span><br><span class="line">&#x27;%r&#x27; 协议名 (ex: http)</span><br><span class="line">&#x27;%q&#x27; 短查询字符串 (16位，4个ascii字节)</span><br><span class="line"> &#x27;%s?&#x27; 短名称版本 (ex: %sN)</span><br><span class="line">&#x27;%[param]&#x27; 查询字符串中的param变量</span><br><span class="line">&#x27;%[param:before:after:empty:notfound]&#x27; 高级变量提取</span><br></pre></td></tr></table></figure><h2 id="用户定义的选项-N-和高级变量提取详情-9"><a href="#用户定义的选项-N-和高级变量提取详情-9" class="headerlink" title="用户定义的选项 N 和高级变量提取详情"></a>用户定义的选项 N 和高级变量提取详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%[param:before:after:empty:notfound]</span><br><span class="line">param    参数名称</span><br><span class="line">before   如果找到参数，则在其前面加上字符串</span><br><span class="line">after    找到参数后要追加的字符串</span><br><span class="line">notfound 如果找不到参数，则替换字符串</span><br><span class="line">empty    如果参数为空，则替换字符串</span><br></pre></td></tr></table></figure><p>除第一个字段（参数名）外，所有字段都可以为空</p><h2 id="选项-K-详情-9"><a href="#选项-K-详情-9" class="headerlink" title="选项 K 详情"></a>选项 K 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K0  foo.cgi?q=45  -&gt;  foo4B54.html?q=45 (relative URI, default)</span><br><span class="line">K                 -&gt;  http://www.foobar.com/folder/foo.cgi?q=45 (absolute URL) (--keep-links[=N])</span><br><span class="line">K3                -&gt;  /folder/foo.cgi?q=45 (absolute URI)</span><br><span class="line">K4                -&gt;  foo.cgi?q=45 (original URL)</span><br><span class="line">K5                -&gt;  http://www.foobar.com/folder/foo4B54.html?q=45 (transparent proxy URL)</span><br></pre></td></tr></table></figure><h2 id="快捷操作-9"><a href="#快捷操作-9" class="headerlink" title="快捷操作"></a>快捷操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--mirror      &lt;URLs&gt; *制作站点的镜像 (default)</span><br><span class="line">--get         &lt;URLs&gt;  获取指定的文件，不要查找其他URL (-qg)</span><br><span class="line">--list   &lt;text file&gt;  添加此文本文件中的所有URL (-%L)</span><br><span class="line">--mirrorlinks &lt;URLs&gt;  镜像一级页面中的所有链接 (-Y)</span><br><span class="line">--testlinks   &lt;URLs&gt;  测试页面中的链接 (-r1p0C0I0t)</span><br><span class="line">--spider      &lt;URLs&gt;  爬取站点，用于测试链接:报告错误和警告 (-p0C0I0t)</span><br><span class="line">--testsite    &lt;URLs&gt;  与--spider相同</span><br><span class="line">--skeleton    &lt;URLs&gt;  创建镜像，但只获取html文件 (-p1)</span><br><span class="line">--update              更新镜像，无需确认 (-iC2)</span><br><span class="line">--continue            继续镜像，无需确认 (-iC1)</span><br><span class="line"></span><br><span class="line">--catchurl            创建一个临时代理来捕获一个URL或一个表单post URL</span><br><span class="line">--clean               删除缓存和日志文件</span><br><span class="line"></span><br><span class="line">--http10              强制http/1.0请求 (-%h)</span><br></pre></td></tr></table></figure><h1 id="举例-9"><a href="#举例-9" class="headerlink" title="举例"></a>举例</h1><ol><li><p>只镜像站点 <code>www.someweb.com/bob/</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/</span><br></pre></td></tr></table></figure></li><li><p>将两个站点镜像在一起（带有共享链接），并接受.com 站点上的任何.jpg 文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/ www.anothertest.com/mike/ +*.com/*.jpg -mime:application/*</span><br></pre></td></tr></table></figure></li><li><p>从 bobby.html 开始获取所有文件，具有 6 个链接深度，并且可以在 web 上到处访问；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html +* -r6</span><br></pre></td></tr></table></figure></li><li><p>使用代理在 <code>www.someweb.com/bob/bobby.html</code> 上运行爬虫；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html --spider -P proxy.myhost.com:8080</span><br></pre></td></tr></table></figure></li><li><p>更新当前文件夹中的镜像 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --update</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹中继续镜像；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --continue</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-9"><a href="#参考-9" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.httrack.com/html/fcguide.html">Httrack Users Guide</a></p><ol start="11"><li><p>查看克隆的文件</p><p>[# HTTrack 简单使用</p></li></ol><ul><li><strong>本文作者：</strong> 李钰璕</li><li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack 简单使用.html</a></li></ul><h1 id="前言-11"><a href="#前言-11" class="headerlink" title="前言"></a>前言</h1><p><code>HTTrack</code> 是一个免费的（GPL，自由软件）和易于使用的离线浏览器工具。它可以爬取整站的网页，用于离线浏览，减少与目标系统交互。它可从 <code>Internet</code> 上下载万维网站点到本地目录，递归地构建所有目录，从服务器获取 <code>HTML</code>、图像和其他文件到本地。<code>HTTrack</code> 安排原始网站的相关链接结构。只需在浏览器中打开 “镜像” 网站的页面，即可从链接到链接浏览网站，就像在线查看网站一样。<code>HTTrack</code> 也可以更新现有的镜像站点，并恢复中断的下载。<code>HTTrack</code> 完全可配置，并具有集成的帮助系统。</p><h1 id="HTTrack-安装-11"><a href="#HTTrack-安装-11" class="headerlink" title="HTTrack 安装"></a><code>HTTrack</code> 安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# apt-get install httrack</span><br></pre></td></tr></table></figure><h1 id="HTTrack-交互模式使用步骤-11"><a href="#HTTrack-交互模式使用步骤-11" class="headerlink" title="HTTrack 交互模式使用步骤"></a><code>HTTrack</code> 交互模式使用步骤</h1><ol><li><p>创建目录存储复制网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# mkdir mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117195447.png" alt="img"></a></p></li><li><p>启动 <code>HTTrack</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# httrack</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117172009.png" alt="img"></a></p></li><li><p>输入项目名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter project name : blog//blog为项目名称</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171943.png" alt="img"></a></p></li><li><p>选择存储网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base path (return=/root/websites/) :/root/mywebsite</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117171926.png" alt="img"></a></p></li><li><p>输入网站的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter URLs (separated by commas or blank spaces) :www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200710.png" alt="img"></a></p></li><li><p>选择操作 (此处选择 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action:</span><br><span class="line">(enter) 1Mirror Web Site(s)//直接镜像站点</span><br><span class="line">        2Mirror Web Site(s) with Wizard//用向导完成镜像</span><br><span class="line">        3Just Get Files Indicated//只get某种特定的文件</span><br><span class="line">        4Mirror ALL links in URLs (Multiple Mirror)//镜像在这个url下所有的链接</span><br><span class="line">        5Test Links In URLs (Bookmark Test)//测试在这个url下的链接</span><br><span class="line">        0Quit//退出</span><br><span class="line">: </span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200731.png" alt="img"></a></p></li><li><p>指定是否在实施攻击时使用代理 (此处默认输入 none，不使用代理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200756.png" alt="img"></a></p></li><li><p>定义字符，爬取特定类型的数据 (此处输入 <code>*</code> 表示爬取全部类型数据)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip</span><br><span class="line">Wildcards (return=none) :*</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200814.png" alt="img"></a></p></li><li><p>设置更多选项，可以使用 <code>help</code> 查看 (此处选择默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return=none) :</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200836.png" alt="img"></a></p></li><li><p>开始克隆网站</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117200903.png" alt="img"></a></p></li><li><p>查看克隆的文件</p><p><a href="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png"><img src="https://raw.githubusercontent.com/Leeyuxun/pic-storage/main/img/20200117201137.png" alt="img"></a></p></li></ol><p>备注：<code>httrack</code> 只能用于克隆静态内容，并且无法完全复制网站上的动态内容、中间部分 (数据库) 等内容。</p><h1 id="HTTrack-一般模式使用步骤-10"><a href="#HTTrack-一般模式使用步骤-10" class="headerlink" title="HTTrack 一般模式使用步骤"></a><code>HTTrack</code> 一般模式使用步骤</h1><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack &lt;URLs&gt; [-option] [+&lt;URL_FILTER&gt;] [-&lt;URL_FILTER&gt;] [+&lt;mime:MIME_FILTER&gt;] [-&lt;mime:MIME_FILTER&gt;]</span><br></pre></td></tr></table></figure><p>选项如下：（* 为默认值）</p><h2 id="一般选项-10"><a href="#一般选项-10" class="headerlink" title="一般选项"></a>一般选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O  镜像路径/缓存和日志文件路径</span><br><span class="line">-O 镜像路径[,缓存和日志文件路径] (--path &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="行为选项-10"><a href="#行为选项-10" class="headerlink" title="行为选项"></a>行为选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w  *镜像网站 (--mirror)</span><br><span class="line">W镜像网站，半自动 (asks questions) (--mirror-wizard)</span><br><span class="line">g只获取文件（保存在当前目录中） (--get-files)</span><br><span class="line">i使用缓存继续中断的镜像 (--continue)</span><br><span class="line">Y镜像所有位于第一级页面的链接 (镜像链接) (--mirrorlinks)</span><br></pre></td></tr></table></figure><h2 id="代理选项-10"><a href="#代理选项-10" class="headerlink" title="代理选项"></a>代理选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   代理使用 (-P proxy:port or -P user:pass@proxy:port) (--proxy &lt;param&gt;)</span><br><span class="line">%f *使用ftp代理 (f0 don&#x27;t use) (--httpproxy-ftp[=N])</span><br><span class="line">%b  使用此本地主机名发出/发送请求 (-%b 主机名) (--bind &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="限制选项-10"><a href="#限制选项-10" class="headerlink" title="限制选项"></a>限制选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rN  将“镜像深度”设置为N (* r9999) (--depth[=N])</span><br><span class="line">%eN   将“外部链接深度”设置为N (* %e0) (--ext-depth[=N])</span><br><span class="line">mN    将非HTML文件的最大文件长度设置为N (--max-files[=N])</span><br><span class="line">mN,N2 将非HTML文件的最大文件长度设置为N、将HTML文件的最大文件长度设置为N2</span><br><span class="line">MN    将可上传/扫描的最大总长度设置为N (--max-size[=N])</span><br><span class="line">EN    将最大镜像传输时间设置为N秒 (60=1 minute, 3600=1 hour) (--max-time[=N])</span><br><span class="line">AN    将最大传输速率设置为N字节/秒 (1000=1KB/s max) (--max-rate[=N])</span><br><span class="line">%cN   将最大连接数设置为N个/秒 (*%c10) (--connection-per-second[=N])</span><br><span class="line">GN    设置如果达到N个字节，则暂停传输，并等待锁定文件被删除 (--max-pause[=N])</span><br></pre></td></tr></table></figure><h2 id="流量控制-10"><a href="#流量控制-10" class="headerlink" title="流量控制"></a>流量控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cN  设置连接数为N (*c8) (--sockets[=N])</span><br><span class="line">TN  设置关闭无响应链接N秒后超时 (--timeout)</span><br><span class="line">RN  设置超时或非致命错误情况下的重试次数为N (*R1) (--retries[=N])</span><br><span class="line">JN  流量阻塞控制，设置链路允许的最小传输速率为N字节/秒 (--min-rate[=N])</span><br><span class="line">HN  如果：0=从不、1=超时、2=慢、3=超时或慢，则放弃主机 (--host-control[=N])</span><br></pre></td></tr></table></figure><h2 id="链接选项-10"><a href="#链接选项-10" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%P        *扩展解析，尝试解析所有链接，即使是未知标记或Javascript标记 (%P0 don&#x27;t use) (--extended-parsing[=N])</span><br><span class="line">n          在html文件附近获取非html文件 (例如：位于外部的图像) (--near)</span><br><span class="line">t          测试所有url（即使url被禁止） (--test)</span><br><span class="line">%L &lt;file&gt;  添加位于此文本文件中的所有URL（每行一个URL）  (--list &lt;param&gt;)</span><br><span class="line">%S &lt;file&gt;  添加位于此文本文件中的所有扫描规则（每行一个扫描规则） (--urllist &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="构建选项-10"><a href="#构建选项-10" class="headerlink" title="构建选项"></a>构建选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NN结构类型 (0 *原始结构, 1+: 详见下文) (--structure[=N])</span><br><span class="line">    或用户定义的结构 (-N &quot;%h%p/%n%q.%t&quot;)</span><br><span class="line">%N  延迟类型检查，不进行任何链接测试，而是等待文件下载开始（实验性的）(N0 不使用，%N1 用于未知扩展名，*%N2 始终使用)</span><br><span class="line">%D  缓存的延迟类型检查，不要在更新期间等待远程类型，以加快更新速度 (%D0 等待, * %D1 不等待) (--cached-delayed-type-check)</span><br><span class="line">%M  生成RFC MIME封装的完整存档 (.mht) (--mime-html)</span><br><span class="line">LN长名称 (L1 *长名称 / L0 8-3 转换 / L2 ISO9660 兼容) (--long-names[=N])</span><br><span class="line">KN保留原始链接 (e.g. http://www.adr/link) (K0 *相对链接, K 绝对链接, K4 原始链接, K3 绝对URI链接, K5 透明代理链接) (--keep-links[=N])</span><br><span class="line">x用错误页替换外部html链接 (--replace-external)</span><br><span class="line">%x不包括受外部密码保护的网站的任何密码 (%x0 包括) (--disable-passwords)</span><br><span class="line">%q *包含本地文件的查询字符串 (无用,仅供参考) (%q0 不包含) (--include-query-string)</span><br><span class="line">o  *出错时生成输出html文件 (404..) (o0 不生成) (--generate-errors)</span><br><span class="line">X  *更新后清除旧文件 (X0 保持删除) (--purge-old[=N])</span><br><span class="line">%p保留html文件“原样” (与&#x27;-K4 -%F &quot;&quot;&#x27;相同) (--preserve)</span><br><span class="line">%T链接转换为UTF-8 (--utf8-conversion)</span><br></pre></td></tr></table></figure><h2 id="蜘蛛选项-10"><a href="#蜘蛛选项-10" class="headerlink" title="蜘蛛选项"></a>蜘蛛选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bN接受cookies.txt中的cookies (0=不接受,* 1=接受) (--cookies[=N])</span><br><span class="line">u检查未知文档类型 (cgi,asp..) (u0 不检查, * u1 检查除了 /, u2 始终检查) (--check-type[=N])</span><br><span class="line">j  *解析JAVA类 (j0 不解析, 位掩码: |1 解析默认值, |2 不解析.class文件 |4 不解析.js文件 |8 不越界解析) (--parse-java[=N])</span><br><span class="line">sN遵循robots.txt和meta robots标记 (0=never,1=sometimes,* 2=always, 3=always (even strict rules)) (--robots[=N])</span><br><span class="line">%h  强制HTTP/1请求 (仅针对旧服务器或代理减少更新特性) (--http-10)</span><br><span class="line">%k尽可能使用keep alive，大大减少小文件和测试请求的延迟 (%k0 不使用) (--keep-alive)</span><br><span class="line">%B  容忍请求 (在某些服务器上接受虚假响应，但不是标准的!) (--tolerant)</span><br><span class="line">%s  更新非法入侵：在更新时限制重新传输的各种非法入侵(相同大小，虚假响应…) (--updatehack)</span><br><span class="line">%u  url非法入侵：限制重复url的各种非法入侵 (strip //, www.foo.com==foo.com..) (--urlhack)</span><br><span class="line">%A  假设一个类型(cgi,asp..)总是与一个mime类型链接 (-%A php3,cgi=text/html;dat,bin=application/x-zip) (--assume &lt;param&gt;)</span><br><span class="line">     快捷方式：&#x27;--assume standard&#x27;相当于-%A php2 php3 php4 php cgi asp jsp pl cfm nsf=text/html</span><br><span class="line">     也可以用于强制特定的文件类型：-assume foo.cgi=text/html</span><br><span class="line">@iNinternet协议 (0=both ipv6+ipv4, 4=ipv4 only, 6=ipv6 only) (--protocol[=N])</span><br><span class="line">%w  禁用特定的外部mime模块 (-%w htsswf -%w htsjava) (--disable-module &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="浏览器-ID-10"><a href="#浏览器-ID-10" class="headerlink" title="浏览器 ID"></a>浏览器 ID</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F   在HTTP头中发送的用户代理字段 (-F &quot;user-agent name&quot;) (--user-agent &lt;param&gt;)</span><br><span class="line">%R  在HTTP头中发送的默认referer字段 (--referer &lt;param&gt;)</span><br><span class="line">%E  从以HTTP头发送的电子邮件地址 (--from &lt;param&gt;)</span><br><span class="line">%F  Html代码中的页脚字符串 (-%F &quot;Mirrored [from host %s [file %s [at %s]]]&quot; (--footer &lt;param&gt;)</span><br><span class="line">%l  首选语言 (-%l &quot;fr, en, jp, *&quot; (--language &lt;param&gt;)</span><br><span class="line">%a  接受格式 (-%a &quot;text/html,image/png;q=0.9,*/*;q=0.1&quot; (--accept &lt;param&gt;)</span><br><span class="line">%X  附加的HTTP标题行 (-%X &quot;X-Magic: 42&quot; (--headers &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="日志、索引、缓存-10"><a href="#日志、索引、缓存-10" class="headerlink" title="日志、索引、缓存"></a>日志、索引、缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C   创建/使用缓存进行更新和重试 (C0 无缓存,C1 缓存优先,* C2 测试更新前) (--cache[=N])</span><br><span class="line">k   将所有文件存储在缓存中 (如果文件在磁盘上，则此功能不可用) (--store-all-in-cache)</span><br><span class="line">%n  不能重新下载本地删除的文件 (--do-not-recatch)</span><br><span class="line">%v  在屏幕上显示下载的文件名(实时) - * %v1 缩写版 - %v2 完整 (--display)</span><br><span class="line">Q   无日志-安静模式  (--do-not-log)</span><br><span class="line">q   无问题-安静模式 (--quiet)</span><br><span class="line">z   日志-附加信息 (--extra-log)</span><br><span class="line">Z   日志-debug (--debug-log)</span><br><span class="line">v   登录屏幕 (--verbose)</span><br><span class="line">f  *登录文件 (--file-log)</span><br><span class="line">f2  一个单一日志文件(--single-log)</span><br><span class="line">I  *编制索引 (I0 不编制索引) (--index)</span><br><span class="line">%i  为项目文件夹创建顶级索引 (* %i0 不创建) (--build-top-index)</span><br><span class="line">%I  为此镜像创建可搜索索引 (* %I0 不创建) (--search-index)</span><br></pre></td></tr></table></figure><h2 id="专家选项-10"><a href="#专家选项-10" class="headerlink" title="专家选项"></a>专家选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pN  优先模式: (* p3) (--priority[=N])</span><br><span class="line">     p0 只扫描，不保存任何内容 (用于检查链接)</span><br><span class="line">     p1 只保存html文件</span><br><span class="line">     p2 只保存非html文件</span><br><span class="line">    *p3 保存所有文件</span><br><span class="line">     p7 先获取html文件，然后处理其他文件</span><br><span class="line">S   保持在同一个目录 (--stay-on-same-dir)</span><br><span class="line">D  *只能进入子目录 (--can-go-down)</span><br><span class="line">U   只能进入父目录 (--can-go-up)</span><br><span class="line">B   可以上下进入目录结构 (--can-go-up-and-down)</span><br><span class="line">a  *保持在同一地址 (--stay-on-same-address)</span><br><span class="line">d   保持在同一主域 (--stay-on-same-domain)</span><br><span class="line">l   保持相同的TLD (eg: .com) (--stay-on-same-tld)</span><br><span class="line">e   go everywhere on the web (--go-everywhere)</span><br><span class="line">%H  在日志文件中调试HTTP头 (--debug-headers)</span><br></pre></td></tr></table></figure><h2 id="权威选项-10"><a href="#权威选项-10" class="headerlink" title="权威选项"></a>权威选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#X  *使用优化引擎 (有限内存边界检查) (--fast-engine)</span><br><span class="line">#0   过滤测试 (-#0 &#x27;*.gif&#x27; &#x27;www.bar.com/foo.gif&#x27;) (--debug-testfilters &lt;param&gt;)</span><br><span class="line">#1   简化测试 (-#1 ./foo/bar/../foobar)</span><br><span class="line">#2   类型测试 (-#2 /foo/bar.php)</span><br><span class="line">#C   换成列表 (-#C &#x27;*.com/spider*.gif&#x27; (--debug-cache &lt;param&gt;)</span><br><span class="line">#R   缓存修复 (损坏缓存) (--repair-cache)</span><br><span class="line">#d   调试分析器 (--debug-parsing)</span><br><span class="line">#E   在meta.zip中提取new.zip缓存元数据</span><br><span class="line">#f   总是刷新日志文件 (--advanced-flushlogs)</span><br><span class="line">#FN  过滤器的最大过滤数目 (--advanced-maxfilters[=N])</span><br><span class="line">#h   版本信息 (--version)</span><br><span class="line">#K   扫描标准输入 (debug) (--debug-scanstdin)</span><br><span class="line">#L   最大链接数 (-#L1000000) (--advanced-maxlinks[=N])</span><br><span class="line">#p   显示进度信息 (--advanced-progressinfo)</span><br><span class="line">#P   抓取URL (--catch-url)</span><br><span class="line">#R   旧的FTP例程 (debug) (--repair-cache)</span><br><span class="line">#T   每分钟生成一次传输操作日志 (--debug-xfrstats)</span><br><span class="line">#u   等待时间 (--advanced-wait)</span><br><span class="line">#Z   每分钟生成传输速率的静态数据 (--debug-ratestats)</span><br></pre></td></tr></table></figure><h2 id="危险选项-10"><a href="#危险选项-10" class="headerlink" title="危险选项"></a>危险选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%!  绕过旨在避免带宽滥用的内置安全限制 (带宽，并发连接) (--disable-security-limits)</span><br></pre></td></tr></table></figure><p>危险选项，仅适用于专家；</p><p>谨慎使用；</p><h2 id="命令行特定选项-10"><a href="#命令行特定选项-10" class="headerlink" title="命令行特定选项"></a>命令行特定选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V   执行每个文件后的系统命令 ($0 is the filename: -V &quot;rm \$0&quot;) (--userdef-cmd &lt;param&gt;)</span><br><span class="line">%W  使用外部库函数作为包装器 (-%W myfoo.so[,myparameters]) (--callback &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="选项-N-详情-10"><a href="#选项-N-详情-10" class="headerlink" title="选项 N 详情"></a>选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N0 站点结构 (默认)</span><br><span class="line">N1 HTML in web/, images/other files in web/images/</span><br><span class="line">N2 HTML in web/HTML, images/other in web/images</span><br><span class="line">N3 HTML in web/,  images/other in web/</span><br><span class="line">N4 HTML in web/, images/other in web/xxx, where xxx is the file extension (all gif will be placed onto web/gif, for example)</span><br><span class="line">N5 Images/other in web/xxx and HTML in web/HTML</span><br><span class="line">N99 All files in web/, with random names (gadget !)</span><br><span class="line">N100 站点结构，不包括www.domain.xxx/</span><br><span class="line">N101 Identical to N1 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N102 Identical to N2 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N103 Identical to N3 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N104 Identical to N4 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N105 Identical to N5 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N199 Identical to N99 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N1001 Identical to N1 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1002 Identical to N2 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1003 Identical to N3 exept that there is no &quot;web&quot; directory (option set for g option)</span><br><span class="line">N1004 Identical to N4 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1005 Identical to N5 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1099 Identical to N99 exept that there is no &quot;web&quot; directory</span><br></pre></td></tr></table></figure><h2 id="用户定义选项-N-详情-10"><a href="#用户定义选项-N-详情-10" class="headerlink" title="用户定义选项 N 详情"></a>用户定义选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;%n&#x27; 没有文件类型的文件名 (ex: image)</span><br><span class="line">&#x27;%N&#x27; 文件名，包括文件类型 (ex: image.gif)</span><br><span class="line">&#x27;%t&#x27; 文件类型 (ex: gif)</span><br><span class="line">&#x27;%p&#x27; 路径 [无结尾 /] (ex: /someimages)</span><br><span class="line">&#x27;%h&#x27; 主机名 (ex: www.someweb.com)</span><br><span class="line">&#x27;%M&#x27; URL MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%Q&#x27; 查询字符串MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%k&#x27; 完整查询字符串</span><br><span class="line">&#x27;%r&#x27; 协议名 (ex: http)</span><br><span class="line">&#x27;%q&#x27; 短查询字符串 (16位，4个ascii字节)</span><br><span class="line"> &#x27;%s?&#x27; 短名称版本 (ex: %sN)</span><br><span class="line">&#x27;%[param]&#x27; 查询字符串中的param变量</span><br><span class="line">&#x27;%[param:before:after:empty:notfound]&#x27; 高级变量提取</span><br></pre></td></tr></table></figure><h2 id="用户定义的选项-N-和高级变量提取详情-10"><a href="#用户定义的选项-N-和高级变量提取详情-10" class="headerlink" title="用户定义的选项 N 和高级变量提取详情"></a>用户定义的选项 N 和高级变量提取详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%[param:before:after:empty:notfound]</span><br><span class="line">param    参数名称</span><br><span class="line">before   如果找到参数，则在其前面加上字符串</span><br><span class="line">after    找到参数后要追加的字符串</span><br><span class="line">notfound 如果找不到参数，则替换字符串</span><br><span class="line">empty    如果参数为空，则替换字符串</span><br></pre></td></tr></table></figure><p>除第一个字段（参数名）外，所有字段都可以为空</p><h2 id="选项-K-详情-10"><a href="#选项-K-详情-10" class="headerlink" title="选项 K 详情"></a>选项 K 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K0  foo.cgi?q=45  -&gt;  foo4B54.html?q=45 (relative URI, default)</span><br><span class="line">K                 -&gt;  http://www.foobar.com/folder/foo.cgi?q=45 (absolute URL) (--keep-links[=N])</span><br><span class="line">K3                -&gt;  /folder/foo.cgi?q=45 (absolute URI)</span><br><span class="line">K4                -&gt;  foo.cgi?q=45 (original URL)</span><br><span class="line">K5                -&gt;  http://www.foobar.com/folder/foo4B54.html?q=45 (transparent proxy URL)</span><br></pre></td></tr></table></figure><h2 id="快捷操作-10"><a href="#快捷操作-10" class="headerlink" title="快捷操作"></a>快捷操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--mirror      &lt;URLs&gt; *制作站点的镜像 (default)</span><br><span class="line">--get         &lt;URLs&gt;  获取指定的文件，不要查找其他URL (-qg)</span><br><span class="line">--list   &lt;text file&gt;  添加此文本文件中的所有URL (-%L)</span><br><span class="line">--mirrorlinks &lt;URLs&gt;  镜像一级页面中的所有链接 (-Y)</span><br><span class="line">--testlinks   &lt;URLs&gt;  测试页面中的链接 (-r1p0C0I0t)</span><br><span class="line">--spider      &lt;URLs&gt;  爬取站点，用于测试链接:报告错误和警告 (-p0C0I0t)</span><br><span class="line">--testsite    &lt;URLs&gt;  与--spider相同</span><br><span class="line">--skeleton    &lt;URLs&gt;  创建镜像，但只获取html文件 (-p1)</span><br><span class="line">--update              更新镜像，无需确认 (-iC2)</span><br><span class="line">--continue            继续镜像，无需确认 (-iC1)</span><br><span class="line"></span><br><span class="line">--catchurl            创建一个临时代理来捕获一个URL或一个表单post URL</span><br><span class="line">--clean               删除缓存和日志文件</span><br><span class="line"></span><br><span class="line">--http10              强制http/1.0请求 (-%h)</span><br></pre></td></tr></table></figure><h1 id="举例-10"><a href="#举例-10" class="headerlink" title="举例"></a>举例</h1><ol><li><p>只镜像站点 <code>www.someweb.com/bob/</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/</span><br></pre></td></tr></table></figure></li><li><p>将两个站点镜像在一起（带有共享链接），并接受.com 站点上的任何.jpg 文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/ www.anothertest.com/mike/ +*.com/*.jpg -mime:application/*</span><br></pre></td></tr></table></figure></li><li><p>从 bobby.html 开始获取所有文件，具有 6 个链接深度，并且可以在 web 上到处访问；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html +* -r6</span><br></pre></td></tr></table></figure></li><li><p>使用代理在 <code>www.someweb.com/bob/bobby.html</code> 上运行爬虫；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html --spider -P proxy.myhost.com:8080</span><br></pre></td></tr></table></figure></li><li><p>更新当前文件夹中的镜像 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --update</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹中继续镜像；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --continue</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-10"><a href="#参考-10" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.httrack.com/html/fcguide.html">Httrack Users Guide</a></p><p>备注：<code>httrack</code> 只能用于克隆静态内容，并且无法完全复制网站上的动态内容、中间部分 (数据库) 等内容。</p><h1 id="HTTrack-一般模式使用步骤-11"><a href="#HTTrack-一般模式使用步骤-11" class="headerlink" title="HTTrack 一般模式使用步骤"></a><code>HTTrack</code> 一般模式使用步骤</h1><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack &lt;URLs&gt; [-option] [+&lt;URL_FILTER&gt;] [-&lt;URL_FILTER&gt;] [+&lt;mime:MIME_FILTER&gt;] [-&lt;mime:MIME_FILTER&gt;]</span><br></pre></td></tr></table></figure><p>选项如下：（* 为默认值）</p><h2 id="一般选项-11"><a href="#一般选项-11" class="headerlink" title="一般选项"></a>一般选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O  镜像路径/缓存和日志文件路径</span><br><span class="line">-O 镜像路径[,缓存和日志文件路径] (--path &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="行为选项-11"><a href="#行为选项-11" class="headerlink" title="行为选项"></a>行为选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w  *镜像网站 (--mirror)</span><br><span class="line">W镜像网站，半自动 (asks questions) (--mirror-wizard)</span><br><span class="line">g只获取文件（保存在当前目录中） (--get-files)</span><br><span class="line">i使用缓存继续中断的镜像 (--continue)</span><br><span class="line">Y镜像所有位于第一级页面的链接 (镜像链接) (--mirrorlinks)</span><br></pre></td></tr></table></figure><h2 id="代理选项-11"><a href="#代理选项-11" class="headerlink" title="代理选项"></a>代理选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   代理使用 (-P proxy:port or -P user:pass@proxy:port) (--proxy &lt;param&gt;)</span><br><span class="line">%f *使用ftp代理 (f0 don&#x27;t use) (--httpproxy-ftp[=N])</span><br><span class="line">%b  使用此本地主机名发出/发送请求 (-%b 主机名) (--bind &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="限制选项-11"><a href="#限制选项-11" class="headerlink" title="限制选项"></a>限制选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rN  将“镜像深度”设置为N (* r9999) (--depth[=N])</span><br><span class="line">%eN   将“外部链接深度”设置为N (* %e0) (--ext-depth[=N])</span><br><span class="line">mN    将非HTML文件的最大文件长度设置为N (--max-files[=N])</span><br><span class="line">mN,N2 将非HTML文件的最大文件长度设置为N、将HTML文件的最大文件长度设置为N2</span><br><span class="line">MN    将可上传/扫描的最大总长度设置为N (--max-size[=N])</span><br><span class="line">EN    将最大镜像传输时间设置为N秒 (60=1 minute, 3600=1 hour) (--max-time[=N])</span><br><span class="line">AN    将最大传输速率设置为N字节/秒 (1000=1KB/s max) (--max-rate[=N])</span><br><span class="line">%cN   将最大连接数设置为N个/秒 (*%c10) (--connection-per-second[=N])</span><br><span class="line">GN    设置如果达到N个字节，则暂停传输，并等待锁定文件被删除 (--max-pause[=N])</span><br></pre></td></tr></table></figure><h2 id="流量控制-11"><a href="#流量控制-11" class="headerlink" title="流量控制"></a>流量控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cN  设置连接数为N (*c8) (--sockets[=N])</span><br><span class="line">TN  设置关闭无响应链接N秒后超时 (--timeout)</span><br><span class="line">RN  设置超时或非致命错误情况下的重试次数为N (*R1) (--retries[=N])</span><br><span class="line">JN  流量阻塞控制，设置链路允许的最小传输速率为N字节/秒 (--min-rate[=N])</span><br><span class="line">HN  如果：0=从不、1=超时、2=慢、3=超时或慢，则放弃主机 (--host-control[=N])</span><br></pre></td></tr></table></figure><h2 id="链接选项-11"><a href="#链接选项-11" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%P        *扩展解析，尝试解析所有链接，即使是未知标记或Javascript标记 (%P0 don&#x27;t use) (--extended-parsing[=N])</span><br><span class="line">n          在html文件附近获取非html文件 (例如：位于外部的图像) (--near)</span><br><span class="line">t          测试所有url（即使url被禁止） (--test)</span><br><span class="line">%L &lt;file&gt;  添加位于此文本文件中的所有URL（每行一个URL）  (--list &lt;param&gt;)</span><br><span class="line">%S &lt;file&gt;  添加位于此文本文件中的所有扫描规则（每行一个扫描规则） (--urllist &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="构建选项-11"><a href="#构建选项-11" class="headerlink" title="构建选项"></a>构建选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NN结构类型 (0 *原始结构, 1+: 详见下文) (--structure[=N])</span><br><span class="line">    或用户定义的结构 (-N &quot;%h%p/%n%q.%t&quot;)</span><br><span class="line">%N  延迟类型检查，不进行任何链接测试，而是等待文件下载开始（实验性的）(N0 不使用，%N1 用于未知扩展名，*%N2 始终使用)</span><br><span class="line">%D  缓存的延迟类型检查，不要在更新期间等待远程类型，以加快更新速度 (%D0 等待, * %D1 不等待) (--cached-delayed-type-check)</span><br><span class="line">%M  生成RFC MIME封装的完整存档 (.mht) (--mime-html)</span><br><span class="line">LN长名称 (L1 *长名称 / L0 8-3 转换 / L2 ISO9660 兼容) (--long-names[=N])</span><br><span class="line">KN保留原始链接 (e.g. http://www.adr/link) (K0 *相对链接, K 绝对链接, K4 原始链接, K3 绝对URI链接, K5 透明代理链接) (--keep-links[=N])</span><br><span class="line">x用错误页替换外部html链接 (--replace-external)</span><br><span class="line">%x不包括受外部密码保护的网站的任何密码 (%x0 包括) (--disable-passwords)</span><br><span class="line">%q *包含本地文件的查询字符串 (无用,仅供参考) (%q0 不包含) (--include-query-string)</span><br><span class="line">o  *出错时生成输出html文件 (404..) (o0 不生成) (--generate-errors)</span><br><span class="line">X  *更新后清除旧文件 (X0 保持删除) (--purge-old[=N])</span><br><span class="line">%p保留html文件“原样” (与&#x27;-K4 -%F &quot;&quot;&#x27;相同) (--preserve)</span><br><span class="line">%T链接转换为UTF-8 (--utf8-conversion)</span><br></pre></td></tr></table></figure><h2 id="蜘蛛选项-11"><a href="#蜘蛛选项-11" class="headerlink" title="蜘蛛选项"></a>蜘蛛选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bN接受cookies.txt中的cookies (0=不接受,* 1=接受) (--cookies[=N])</span><br><span class="line">u检查未知文档类型 (cgi,asp..) (u0 不检查, * u1 检查除了 /, u2 始终检查) (--check-type[=N])</span><br><span class="line">j  *解析JAVA类 (j0 不解析, 位掩码: |1 解析默认值, |2 不解析.class文件 |4 不解析.js文件 |8 不越界解析) (--parse-java[=N])</span><br><span class="line">sN遵循robots.txt和meta robots标记 (0=never,1=sometimes,* 2=always, 3=always (even strict rules)) (--robots[=N])</span><br><span class="line">%h  强制HTTP/1请求 (仅针对旧服务器或代理减少更新特性) (--http-10)</span><br><span class="line">%k尽可能使用keep alive，大大减少小文件和测试请求的延迟 (%k0 不使用) (--keep-alive)</span><br><span class="line">%B  容忍请求 (在某些服务器上接受虚假响应，但不是标准的!) (--tolerant)</span><br><span class="line">%s  更新非法入侵：在更新时限制重新传输的各种非法入侵(相同大小，虚假响应…) (--updatehack)</span><br><span class="line">%u  url非法入侵：限制重复url的各种非法入侵 (strip //, www.foo.com==foo.com..) (--urlhack)</span><br><span class="line">%A  假设一个类型(cgi,asp..)总是与一个mime类型链接 (-%A php3,cgi=text/html;dat,bin=application/x-zip) (--assume &lt;param&gt;)</span><br><span class="line">     快捷方式：&#x27;--assume standard&#x27;相当于-%A php2 php3 php4 php cgi asp jsp pl cfm nsf=text/html</span><br><span class="line">     也可以用于强制特定的文件类型：-assume foo.cgi=text/html</span><br><span class="line">@iNinternet协议 (0=both ipv6+ipv4, 4=ipv4 only, 6=ipv6 only) (--protocol[=N])</span><br><span class="line">%w  禁用特定的外部mime模块 (-%w htsswf -%w htsjava) (--disable-module &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="浏览器-ID-11"><a href="#浏览器-ID-11" class="headerlink" title="浏览器 ID"></a>浏览器 ID</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F   在HTTP头中发送的用户代理字段 (-F &quot;user-agent name&quot;) (--user-agent &lt;param&gt;)</span><br><span class="line">%R  在HTTP头中发送的默认referer字段 (--referer &lt;param&gt;)</span><br><span class="line">%E  从以HTTP头发送的电子邮件地址 (--from &lt;param&gt;)</span><br><span class="line">%F  Html代码中的页脚字符串 (-%F &quot;Mirrored [from host %s [file %s [at %s]]]&quot; (--footer &lt;param&gt;)</span><br><span class="line">%l  首选语言 (-%l &quot;fr, en, jp, *&quot; (--language &lt;param&gt;)</span><br><span class="line">%a  接受格式 (-%a &quot;text/html,image/png;q=0.9,*/*;q=0.1&quot; (--accept &lt;param&gt;)</span><br><span class="line">%X  附加的HTTP标题行 (-%X &quot;X-Magic: 42&quot; (--headers &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="日志、索引、缓存-11"><a href="#日志、索引、缓存-11" class="headerlink" title="日志、索引、缓存"></a>日志、索引、缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C   创建/使用缓存进行更新和重试 (C0 无缓存,C1 缓存优先,* C2 测试更新前) (--cache[=N])</span><br><span class="line">k   将所有文件存储在缓存中 (如果文件在磁盘上，则此功能不可用) (--store-all-in-cache)</span><br><span class="line">%n  不能重新下载本地删除的文件 (--do-not-recatch)</span><br><span class="line">%v  在屏幕上显示下载的文件名(实时) - * %v1 缩写版 - %v2 完整 (--display)</span><br><span class="line">Q   无日志-安静模式  (--do-not-log)</span><br><span class="line">q   无问题-安静模式 (--quiet)</span><br><span class="line">z   日志-附加信息 (--extra-log)</span><br><span class="line">Z   日志-debug (--debug-log)</span><br><span class="line">v   登录屏幕 (--verbose)</span><br><span class="line">f  *登录文件 (--file-log)</span><br><span class="line">f2  一个单一日志文件(--single-log)</span><br><span class="line">I  *编制索引 (I0 不编制索引) (--index)</span><br><span class="line">%i  为项目文件夹创建顶级索引 (* %i0 不创建) (--build-top-index)</span><br><span class="line">%I  为此镜像创建可搜索索引 (* %I0 不创建) (--search-index)</span><br></pre></td></tr></table></figure><h2 id="专家选项-11"><a href="#专家选项-11" class="headerlink" title="专家选项"></a>专家选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pN  优先模式: (* p3) (--priority[=N])</span><br><span class="line">     p0 只扫描，不保存任何内容 (用于检查链接)</span><br><span class="line">     p1 只保存html文件</span><br><span class="line">     p2 只保存非html文件</span><br><span class="line">    *p3 保存所有文件</span><br><span class="line">     p7 先获取html文件，然后处理其他文件</span><br><span class="line">S   保持在同一个目录 (--stay-on-same-dir)</span><br><span class="line">D  *只能进入子目录 (--can-go-down)</span><br><span class="line">U   只能进入父目录 (--can-go-up)</span><br><span class="line">B   可以上下进入目录结构 (--can-go-up-and-down)</span><br><span class="line">a  *保持在同一地址 (--stay-on-same-address)</span><br><span class="line">d   保持在同一主域 (--stay-on-same-domain)</span><br><span class="line">l   保持相同的TLD (eg: .com) (--stay-on-same-tld)</span><br><span class="line">e   go everywhere on the web (--go-everywhere)</span><br><span class="line">%H  在日志文件中调试HTTP头 (--debug-headers)</span><br></pre></td></tr></table></figure><h2 id="权威选项-11"><a href="#权威选项-11" class="headerlink" title="权威选项"></a>权威选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#X  *使用优化引擎 (有限内存边界检查) (--fast-engine)</span><br><span class="line">#0   过滤测试 (-#0 &#x27;*.gif&#x27; &#x27;www.bar.com/foo.gif&#x27;) (--debug-testfilters &lt;param&gt;)</span><br><span class="line">#1   简化测试 (-#1 ./foo/bar/../foobar)</span><br><span class="line">#2   类型测试 (-#2 /foo/bar.php)</span><br><span class="line">#C   换成列表 (-#C &#x27;*.com/spider*.gif&#x27; (--debug-cache &lt;param&gt;)</span><br><span class="line">#R   缓存修复 (损坏缓存) (--repair-cache)</span><br><span class="line">#d   调试分析器 (--debug-parsing)</span><br><span class="line">#E   在meta.zip中提取new.zip缓存元数据</span><br><span class="line">#f   总是刷新日志文件 (--advanced-flushlogs)</span><br><span class="line">#FN  过滤器的最大过滤数目 (--advanced-maxfilters[=N])</span><br><span class="line">#h   版本信息 (--version)</span><br><span class="line">#K   扫描标准输入 (debug) (--debug-scanstdin)</span><br><span class="line">#L   最大链接数 (-#L1000000) (--advanced-maxlinks[=N])</span><br><span class="line">#p   显示进度信息 (--advanced-progressinfo)</span><br><span class="line">#P   抓取URL (--catch-url)</span><br><span class="line">#R   旧的FTP例程 (debug) (--repair-cache)</span><br><span class="line">#T   每分钟生成一次传输操作日志 (--debug-xfrstats)</span><br><span class="line">#u   等待时间 (--advanced-wait)</span><br><span class="line">#Z   每分钟生成传输速率的静态数据 (--debug-ratestats)</span><br></pre></td></tr></table></figure><h2 id="危险选项-11"><a href="#危险选项-11" class="headerlink" title="危险选项"></a>危险选项</h2><p>（尽量避免使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%!  绕过旨在避免带宽滥用的内置安全限制 (带宽，并发连接) (--disable-security-limits)</span><br></pre></td></tr></table></figure><p>危险选项，仅适用于专家；</p><p>谨慎使用；</p><h2 id="命令行特定选项-11"><a href="#命令行特定选项-11" class="headerlink" title="命令行特定选项"></a>命令行特定选项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V   执行每个文件后的系统命令 ($0 is the filename: -V &quot;rm \$0&quot;) (--userdef-cmd &lt;param&gt;)</span><br><span class="line">%W  使用外部库函数作为包装器 (-%W myfoo.so[,myparameters]) (--callback &lt;param&gt;)</span><br></pre></td></tr></table></figure><h2 id="选项-N-详情-11"><a href="#选项-N-详情-11" class="headerlink" title="选项 N 详情"></a>选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N0 站点结构 (默认)</span><br><span class="line">N1 HTML in web/, images/other files in web/images/</span><br><span class="line">N2 HTML in web/HTML, images/other in web/images</span><br><span class="line">N3 HTML in web/,  images/other in web/</span><br><span class="line">N4 HTML in web/, images/other in web/xxx, where xxx is the file extension (all gif will be placed onto web/gif, for example)</span><br><span class="line">N5 Images/other in web/xxx and HTML in web/HTML</span><br><span class="line">N99 All files in web/, with random names (gadget !)</span><br><span class="line">N100 站点结构，不包括www.domain.xxx/</span><br><span class="line">N101 Identical to N1 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N102 Identical to N2 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N103 Identical to N3 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N104 Identical to N4 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N105 Identical to N5 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N199 Identical to N99 exept that &quot;web&quot; is replaced by the site&#x27;s name</span><br><span class="line">N1001 Identical to N1 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1002 Identical to N2 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1003 Identical to N3 exept that there is no &quot;web&quot; directory (option set for g option)</span><br><span class="line">N1004 Identical to N4 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1005 Identical to N5 exept that there is no &quot;web&quot; directory</span><br><span class="line">N1099 Identical to N99 exept that there is no &quot;web&quot; directory</span><br></pre></td></tr></table></figure><h2 id="用户定义选项-N-详情-11"><a href="#用户定义选项-N-详情-11" class="headerlink" title="用户定义选项 N 详情"></a>用户定义选项 N 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;%n&#x27; 没有文件类型的文件名 (ex: image)</span><br><span class="line">&#x27;%N&#x27; 文件名，包括文件类型 (ex: image.gif)</span><br><span class="line">&#x27;%t&#x27; 文件类型 (ex: gif)</span><br><span class="line">&#x27;%p&#x27; 路径 [无结尾 /] (ex: /someimages)</span><br><span class="line">&#x27;%h&#x27; 主机名 (ex: www.someweb.com)</span><br><span class="line">&#x27;%M&#x27; URL MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%Q&#x27; 查询字符串MD5 (128位，32个ascii字节)</span><br><span class="line">&#x27;%k&#x27; 完整查询字符串</span><br><span class="line">&#x27;%r&#x27; 协议名 (ex: http)</span><br><span class="line">&#x27;%q&#x27; 短查询字符串 (16位，4个ascii字节)</span><br><span class="line"> &#x27;%s?&#x27; 短名称版本 (ex: %sN)</span><br><span class="line">&#x27;%[param]&#x27; 查询字符串中的param变量</span><br><span class="line">&#x27;%[param:before:after:empty:notfound]&#x27; 高级变量提取</span><br></pre></td></tr></table></figure><h2 id="用户定义的选项-N-和高级变量提取详情-11"><a href="#用户定义的选项-N-和高级变量提取详情-11" class="headerlink" title="用户定义的选项 N 和高级变量提取详情"></a>用户定义的选项 N 和高级变量提取详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%[param:before:after:empty:notfound]</span><br><span class="line">param    参数名称</span><br><span class="line">before   如果找到参数，则在其前面加上字符串</span><br><span class="line">after    找到参数后要追加的字符串</span><br><span class="line">notfound 如果找不到参数，则替换字符串</span><br><span class="line">empty    如果参数为空，则替换字符串</span><br></pre></td></tr></table></figure><p>除第一个字段（参数名）外，所有字段都可以为空</p><h2 id="选项-K-详情-11"><a href="#选项-K-详情-11" class="headerlink" title="选项 K 详情"></a>选项 K 详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K0  foo.cgi?q=45  -&gt;  foo4B54.html?q=45 (relative URI, default)</span><br><span class="line">K                 -&gt;  http://www.foobar.com/folder/foo.cgi?q=45 (absolute URL) (--keep-links[=N])</span><br><span class="line">K3                -&gt;  /folder/foo.cgi?q=45 (absolute URI)</span><br><span class="line">K4                -&gt;  foo.cgi?q=45 (original URL)</span><br><span class="line">K5                -&gt;  http://www.foobar.com/folder/foo4B54.html?q=45 (transparent proxy URL)</span><br></pre></td></tr></table></figure><h2 id="快捷操作-11"><a href="#快捷操作-11" class="headerlink" title="快捷操作"></a>快捷操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--mirror      &lt;URLs&gt; *制作站点的镜像 (default)</span><br><span class="line">--get         &lt;URLs&gt;  获取指定的文件，不要查找其他URL (-qg)</span><br><span class="line">--list   &lt;text file&gt;  添加此文本文件中的所有URL (-%L)</span><br><span class="line">--mirrorlinks &lt;URLs&gt;  镜像一级页面中的所有链接 (-Y)</span><br><span class="line">--testlinks   &lt;URLs&gt;  测试页面中的链接 (-r1p0C0I0t)</span><br><span class="line">--spider      &lt;URLs&gt;  爬取站点，用于测试链接:报告错误和警告 (-p0C0I0t)</span><br><span class="line">--testsite    &lt;URLs&gt;  与--spider相同</span><br><span class="line">--skeleton    &lt;URLs&gt;  创建镜像，但只获取html文件 (-p1)</span><br><span class="line">--update              更新镜像，无需确认 (-iC2)</span><br><span class="line">--continue            继续镜像，无需确认 (-iC1)</span><br><span class="line"></span><br><span class="line">--catchurl            创建一个临时代理来捕获一个URL或一个表单post URL</span><br><span class="line">--clean               删除缓存和日志文件</span><br><span class="line"></span><br><span class="line">--http10              强制http/1.0请求 (-%h)</span><br></pre></td></tr></table></figure><h1 id="举例-11"><a href="#举例-11" class="headerlink" title="举例"></a>举例</h1><ol><li><p>只镜像站点 <code>www.someweb.com/bob/</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/</span><br></pre></td></tr></table></figure></li><li><p>将两个站点镜像在一起（带有共享链接），并接受.com 站点上的任何.jpg 文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/ www.anothertest.com/mike/ +*.com/*.jpg -mime:application/*</span><br></pre></td></tr></table></figure></li><li><p>从 bobby.html 开始获取所有文件，具有 6 个链接深度，并且可以在 web 上到处访问；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html +* -r6</span><br></pre></td></tr></table></figure></li><li><p>使用代理在 <code>www.someweb.com/bob/bobby.html</code> 上运行爬虫；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack www.someweb.com/bob/bobby.html --spider -P proxy.myhost.com:8080</span><br></pre></td></tr></table></figure></li><li><p>更新当前文件夹中的镜像 ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --update</span><br></pre></td></tr></table></figure></li><li><p>进入交互模式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack</span><br></pre></td></tr></table></figure></li><li><p>在当前文件夹中继续镜像；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httrack --continue</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-11"><a href="#参考-11" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.httrack.com/html/fcguide.html">Httrack Users Guide</a></p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/HTTrack-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/HTTrack-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h1 id="HTTrack-简单使用"><a href="#HTTrack-简单使用" class="headerlink" title="HTTrack 简单使用"></a>HTTrack 简单使用</h1><ul>
<li><strong>本文作者：</strong> 李钰璕</li>
<li><strong>本文链接：</strong> <a href="https://leeyuxun.github.io/HTTrack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">https://leeyuxun.github.io/HTTrack]]>
    </summary>
    <title>HTTrack 简单使用</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<p>原文链接：<a href="https://www.tisi.org/5029">欧盟首个数据保护条例GDPR明日生效，你可能需要这份中文版的全文 (tisi.org)</a></p><p> 经过欧盟议会长达四年的讨论，欧盟《一般数据保护条例》（General Data Protection Regulation，简称GDPR）终于将在2018年5月25日生效。</p><p>   在一些媒体的报道中，这一保护条例被称为“史上最严数据保护条例”。尽管这是现代社会保护个人数据与安全迈出的重要一步，但在国内外的许多媒体报道中，GDPR中的一些条款被误读或是错误理解引起了一些用户、公司、学者的恐慌。<br>   在GDPR即将正式实施之际，严谨的阅读并理解GDPR的原文显得尤为重要。</p><p> <strong>一般数据保护条例</strong></p><p><strong>第一章 一般条款</strong></p><p><strong>第二章 原则</strong></p><p><strong>第三章 数据主体的权利</strong></p><p><strong>第四章 控制者和处理者</strong></p><p><strong>第五章 将个人数据转移到第三国或国际组织</strong></p><p><strong>第六章 独立监管机构</strong></p><p><strong>第七章 合作与一致性</strong></p><p><strong>第八章 救济、责任与惩罚</strong></p><p><strong>第九章 和特定处理情形相关的条款</strong></p><p><strong>第十章 授权法案与实施性法案</strong></p><p><strong>第一章 一般条款</strong></p><p><strong>第1条 主要事项与目标</strong><br>1．本条例制定关于处理个人数据中对自然人进行保护的规则，以及个人 数据自由流动的规则。<br>2．本条例保护自然人的基本权利与自由，特别是自然人享有的个人数据 保护的权利。<br>3．不能以保护处理个人数据中的相关自然人为由，对欧盟内部个人数据 的自由流动进行限制或禁止。<br><strong>第2条 适用范围</strong><br>1．本条例适用于全自动个人数据处理、半自动个人数据处理，以及形成 或旨在形成用户画像的非自动个人数据处理。<br>2．本条例不适用以下情形：<br>(a)欧盟法管辖之外的活动中所进行的个人数据处理；<br>(b)欧盟成员国为履行《欧盟基本条约》（TEU）第2章第5款所规定的活动而进行的个人数据处理；<br>(c)自然人在纯粹个人或家庭活动中所进行的个人数据处理；<br>(d) ）有关主管部门为预防、调查、侦查、起诉刑事犯罪、执行刑事处罚、防范及预防公共安全威胁而进行的个人数据处理。<br>3．欧盟机构、实体、办事处和规制机构所进行的个人数据处理，适用(EC)第 45&#x2F;2001条例。根据本条例第98条，(EC)第45&#x2F;2001条例和其他适用于此类个人数据处理的欧盟法案应当进行调整，以符合本条例的原则和规则。<br>4．本条例不影响2000&#x2F;31&#x2F;EC指令的适用，特别是2000&#x2F;31&#x2F;EC指令第12至15条所规定的中间服务商的责任规则的适用。<br><strong>第3条 地域范围</strong><br>1．本例适用于在欧盟内部设立的数据控制者或处理者对个人数据的处理，不论其实际数据处理行为是否在欧盟内进行。<br>2．本条例适用于如下相关活动中的个人数据处理，即使数据控制者或处理者不在欧盟设立：<br>(a)为欧盟内的数据主体提供商品或服务——不论此项商品或服务是否要求数据主体支付对价；或<br>(b)对发生在欧洲范围内的数据主体的活动进行监控。<br>3．本条例适用于在欧盟之外设立，但基于国际公法成员国的法律对其有管辖权的数据控制者的个人数据处理。<br><strong>第4条 定义</strong><br>就本条例而言：<br>(1)“个人数据”指的是任何已识别或可识别的自然人（“数据主体”）相关的信息；一个可识别的自然人是一个能够被直接或间接识别的个体，特别是通过诸如姓名、身份编号、地址数据、网上标识或者自然人所特有的一项或多项的身体性、生理性、遗传性、精神性、经济性、文化性或社会性身份而识别个体。<br>(2)“处理”是指任何一项或多项针对单一个人数据或系列个人数据所进行的操作行为，不论该操作行为是否采取收集、记录、组织、构造、存储、调整、更改、检索、咨询、使用、通过传输而公开、散布或其他方式对他人公开、排列或组合、限制、删除或销毁而公开等自动化方式。<br>(3)“限制处理”是指对存储的个人数据进行标记，以限制此后对该数据的处理行为。<br>(4)“用户画像”指的是为了评估自然人的某些条件而对个人数据进行的任何自动化处理，特别是为了评估自然人的工作表现、经济状况、健康、个人偏好、兴趣、可靠性、行为方式、位置或行踪而进行的处理。<br>(5)“匿名化”指的是在采取某种方式对个人数据进行处理后，如果没有额外的信息就不能识别数据主体的处理方式。此类额外信息应当单独保存，并且已有技术与组织方式确保个人数据不能关联到某个已识别或可识别的自然人。<br>(6)“档案系统”指的是根据某种特定标准——不论这种标准是去中心化的、分散的、功能性的或是基于地理而设置的——而可以访问的个人数据的结构化集合。<br>(7)“控制者”指的是那些决定——不论是单独决定还是共同决定——个人数据处理目的与方式的自然人或法人、公共机构、规制机构或其他实体；如果此类处理的方式是由欧盟或成员国的法律决定的，那么对控制者的定义或确定控制者的标准应当由欧盟或成员国的法律来规定。<br>(8)“处理者”指的是为数据控制者而处理个人数据的自然人或法人、公共机构、规制机构或其他实体。<br>(9)“接收者”指的是接收数据的自然人、法人、公共机构、规制机构或另一实体，不论其是否为第三方。然而，公共机构基于欧盟或成员国法律的某项特定调查框架而接收个人数据，则不应当被视为接收者；公共机构对此类数据的处理，应当根据处理目的遵循可适用的数据保护规则。<br>(10)“第三方”指的是除了数据主体、控制者、处理者、控制者或处理者直接授权其处理个人数据之外的自然人或法人、公共机构、规制机构或组织。<br>(11)数据主体的“同意”指的是数据主体通过一个声明，或者通过某项清晰的确信行动而自由作出的、充分知悉的、不含混的、表明同意对其相关个人数据进行处理的意愿。<br>(12) “个人数据泄露”是指由于违反安全政策而导致传输、储存、处理中的个人数据被意外或非法损毁、丢失、更改或未经同意而被公开或访问。<br>(13)“基因数据”指的是和自然人的遗传性或获得性基因特征相关的个人数据，这些数据可以提供自然人生理或健康的独特信息，尤其是通过对自然人生物性样本进行分析而可以得出的独特信息。<br>(14)“生物性识别数据”指的是基于特别技术处理自然人的相关身体、生理或行为特征而得出的个人数据，这种个人数据能够识别或确定自然人的独特标识，例如脸部形象或指纹数据。<br>(15)“和健康相关的数据”指的是那些和自然人的身体或精神健康相关的、显示其个人健康状况信息的个人数据，包括和卫生保健服务相关的服务。<br>(16)“主要营业机构”指的是：<br>(a)如果控制者在不止一个成员国内有多处营业机构，那么其在欧盟的管理中心所在地是主要营业机构，除非个人数据处理的目的与方式是由控制者的另一个机构决定的，并且这一机构有权实施此决定，在这种情况下，做出此类决定的机构应当被认为是主要营业机构；<br>(b)如果处理者在不止一个成员国内具有多处机构，那么其在欧盟的管理中心所在地是主要营业机构。如果处理者在欧盟没有管理中心，那么在处理者需要遵守本条例所规定的特殊责任的前提下，其在欧盟的主要处理活动发生地的机构应当被视为主要营业机构。<br>(17)“代表”指的是控制者或处理者根据第27条在欧盟书面委任，代表控制者或处理者承担本条例所规定的相应责任的自然人或法人。<br>(18)“经济主体”的含义是采用任意法律形式的进行经济活动的自然人或法人，包括经常进行经济活动的合伙企业或协会；<br>(19)“企业集团”的含义是控股企业和被控股企业；<br>(20)“有约束力的公司规则”指的是在某成员国内设立的控制者或处理者，为了在企业集团内部或进行联合经济活动的经济主体内部将个人数据转移或多次转移给位于第三国或多个第三国的控制者或处理者，所遵循的个人数据保护政策。<br>(21)“监管机构”指的是成员国根据第51条而设立的独立性公共机构。<br>(22)“相关监管机构”指的是基于如下原因而和个人数据处理相关的监管机构：<br>(a)控制者或处理者是在某监管机构所在的成员国的境内所设立的；<br>(b)数据处理对居住在某监管机构所在地成员国的数据主体具有实质性影响；或者<br>(c)该监管机构已经收到一项申诉；<br>(23)“跨境处理”指的是：<br>(a)个人数据处理发生在一个控制者或处理者在多个成员国所设立的多个营业机构内；或者<br>(b)个人数据处理是在欧盟内的控制者或处理者的单一营业机构内进行的，但其对不止一国的数据主体具有实质性影响。<br>(24)“相关和合理的异议”指的是对是否存在违反本条例的情形，或者某项和控制者或处理者相关的初步设想是否符合本条例的异议——已有证据表明，这种初步设想的决定会对数据主体的基本权利和自由，以及在某些情形下对欧盟的个人数据的自由流通会带来风险。<br>(25)“信息社会服务”指的是欧洲议会和欧盟理事会的(EU) 2015&#x2F;1535指令在第1（1）条（b）点所定义的服务。<br>(26)“国际组织”指的是依照国际公法、或根据两个或多个国家协议所设立的组织及其下属机构。<br>1．本例适用于在欧盟内部设立的数据控制者或处理者对个人数据的处理，不论其实际数据处理行为是否在欧盟内进行。<br>2．本条例适用于如下相关活动中的个人数据处理，即使数据控制者或处理者不在欧盟设立：<br>(a)为欧盟内的数据主体提供商品或服务——不论此项商品或服务是否要求数据主体支付对价；或<br>(b)对发生在欧洲范围内的数据主体的活动进行监控。<br>3．本条例适用于在欧盟之外设立，但基于国际公法成员国的法律对其有管辖权的数据控制者的个人数据处理。<br><strong>第二章 原则</strong><br><strong>第5条 个人数据处理原则</strong><br>1．对于个人数据，应遵循下列规定：<br>(a)对涉及到数据主体的个人数据，应当以合法的、合理的和透明的方式来进行处理（“合法性、合理性和透明性”）；<br>(b)个人数据的收集应当具有具体的、清晰的和正当的目的，对个人数据的处理不应当违反初始目的。根据第89（1）条，因为公共利益、科学或历史研究或统计目的而进一步处理数据，不视为违反初始目的（“目的限制”）；<br>(c)个人数据的处理应当是为了实现数据处理目的而适当的、相关的和必要的（“数据最小化”）；<br>(d)个人数据应当是准确的，如有必要，必须及时更新；必须采取合理措施确保不准确的个人数据，即违反初始目的的个人数据，及时得到擦除或更正（“准确性”）；<br>(e)对于能够识别数据主体的个人数据，其储存时间不得超过实现其处理目的所必需的时间；超过此期限的数据处理只有在如下情况下才能被允许：为了实现公共利益、科学或历史研究目的或统计目的，为了保障数据主体的权利和自由，并采取了本条例第89（1）条所规定的合理技术与组织措施。（“限期储存”）；<br>(f) 处理过程中应确保个人数据的安全，采取合理的技术手段、组织措施，避免数据未经授权即被处理或遭到非法处理，避免数据发生意外毁损或灭失（“数据的完整性与保密性”）。<br>2．控制者有责任遵守以上第1段，并且有责任对此提供证明。（“可问责性”）。<br><strong>第6条 处理的合法性</strong><br>1．只有满足至少如下一项条件时，处理才是合法的，且处理的合法性只限于满足条件内的处理：<br>(a)数据主体已经同意基于一项或多项目的而对其个人数据进行处理；<br>(b)处理对于完成某项数据主体所参与的契约是必要的，或者在签订契约前基于数据主体的请求而进行的处理；<br>(c) 处理是控制商履行其法定义务所必需的；<br>(d)处理对于保护数据主体或另一个自然人的核心利益所必要的；<br>(e)处理是数据控制者为了公共利益或基于官方权威而履行某项任务而进行的；<br>(f)处理对于控制者或第三方所追求的正当利益是必要的，这不包括需要通过个人数据保护以实现数据主体的优先性利益或基本权利与自由，特别是儿童的优先性利益或基本权利与自由。<br>第1段（f）点不适用公共机构在履行其任务时的处理。<br>2．对于第1段（c）和（e）所规定的处理，成员国可以维持或新制定更多具体条款，以适应本条例规则的适用，成员国为了确保合法与合理处理，可以制定更为明确的规定，包括第9章所规定的其他特定的处理情形。<br>3．第1段（c）和（e）所规定的处理的基准应当通过如下法律进行规定：<br>(a)欧盟法；或者<br>(b)控制者所属的成员国的法律。<br>处理的目的应当在此法律基准上进行确定，而对于第1段（e）所规定的处理，处理的目的应当是控制者为了公共利益或基于官方权威而履行某项任务。此法律基准可以包含如下特定条款，以适应对本条例规则的适用：对控制者处理的合法性进行监控的一般条件；可以被处理的数据类型；相关数据主体；个人数据公开的目的，以及其可能被公开给的对象；目的限定；储存期限；包括第9章所规定的其他特定的处理情形在内的处理操作和处理程序。欧盟或成员国的法律应当满足公共利益的目标，且应当与实现正当目的成比例。<br>4．若处理是出于收集个人数据以外的其他目的，如果该目的未经数据主体同意或并非是基于联盟或成员国的法律（在一个民主社会中，若要实现第23（1）条中的目的，法律是必要且合适的），那么为确保该目的与初始目相容，控制商应当考虑以下因素，但不限于以下因素：<br>(a)个人数据收集时的目的与计划进一步处理的目的之间的所有关联性；<br>(b)个人数据收集时的语境，特别是数据主体与控制者之间的关系；<br>(c)个人数据的性质，特别是某些特定类型的个人数据是否符合第9条的规定，或者与刑事定罪和刑事违法相关的个人数据是否符合第10条的规定；<br>(d) 数据主体计划进一步处理可能造成的结果；<br>(e)是否具有加密与匿名化措施等恰当保护措施；<br><strong>第7条 同意的条件</strong><br>1．当处理是建立在同意基础上的，控制者需要能证明，数据主体已经同意对其个人数据进行处理。<br>2．如果数据主体的同意是在涉及到其他事项的书面声明的情形下作出的，请求获得同意应当完全区别于其他事项，并且应当以一种容易理解的形式，使用清晰和平白的语言。任何违反本条例的声明都不具有约束力。<br>3．数据主体应当有权随时撤回其同意。在撤回之前，对于基于同意的处理，其合法性不受影响。在数据主体表达同意之前，数据主体应当被告知这点。撤回同意应当和表达同意一样简单。<br>4．分析同意是否是自由做出的，应当最大限度地考虑一点是：对契约的履行——包括履行条款所规定的服务——是否要求同意履行契约所不必要的个人数据处理。<br><strong>第8条 信息社会服务中适用儿童同意的条件</strong><br>1．在第6（1）条（a）适用的情形下，对于为儿童直接提供信息社会服务的请求，当儿童年满16周岁，对儿童个人数据的处理是合法的。当儿童不满16周岁，只有当对儿童具有父母监护责任的主体同意或授权，此类处理才是合法的。<br>2．对于年满13周岁的情形，成员国的法律可以降低年龄要求。<br>3．控制者应当采取合理的努力，结合技术可行性，确保此类情形中对儿童具有父母监护责任的主体已经授权或同意。<br>第1段不应影响成员国的一般合同法，例如关于儿童的合同有效性、形成与效力的规则。<br><strong>第9条 对特殊类型个人数据的处理</strong><br>1．对于那些显示种族或民族背景、政治观念、宗教或哲学信仰或工会成员的个人数据、基因数据、为了特定识别自然人的生物性识别数据、以及和自然人健康、个人性生活或性取向相关的数据，应当禁止处理。<br>2．如果具有如下条件之一，第1段将不适用：<br>(a)数据主体明确同意基于一个或多个特定目的而授权处理其个人数据，但依照欧盟或成员国的法律规定，数据主体无权解除第1段中所规定的禁令的除外；<br>(b)处理对于控制者履行责任以及行使其特定权利是必要的，或者对于在雇佣、社会安全与社会保障法领域采取符合欧盟或成员国法律或集体协议的措施以保护数据主体的根本权利和利益是必要的；<br>(c)数据主体因为身体原因或法律原因而无法表达同意，但处理对于保护数据主体或另一自然人的核心利益却是必要的；<br>(d)基金、协会或其它具有政治、哲学、宗教或工会目的的非盈利机构的正当性活动中所进行的处理，并且已经采取了恰当的保护措施；或者处理目的仅仅和机构成员、之前成员或具有经常联系的人相关，并且个人数据在未经数据主体同意前不对实体外的人公开；<br>(e)对数据主体已经明显公开的相关个人数据的处理；<br>(f)当处理对于提起、行使或辩护法律性主张必要时，或者法院在其所有的司法活动中所进行的处理；<br>(g)处理对实现实质性的公共利益必要的，建立在欧盟或成员国的法律基准之上、对实现目标是相称的，尊重数据保护权的核心要素，并且为数据主体的基本权利和利益提供合适和特定的保护措施；<br>(h)处理对于预防性医学或临床医学目的是必要的，或者对于评估雇员的工作能力、医疗诊断、提供——基于欧盟或成员国法律，或遵循和健康职业机构签订的契约并遵循第3段所规定的情形与保障措施——健康或社会保健或治疗或管理健康或社会保健体系是必要的；<br>(i)在公共健康领域，处理是为了实现公共利益所必要的，例如，在欧盟或成员国内已经为保障数据主体的权利与自由而采取合适与特定措施的法律基础上，处理对于预防严重的跨境健康威胁是必要的，或者为了保障医疗质量和安全、医疗产品或医疗设备的高质量和安全是必要的；或者<br>(j)处理对于实现符合第89(1)条公共利益、科学或历史研究目的或统计目的是必要的，处理采取了与其期望目的所相称的处理，尊重数据保护权的核心要素，并且对数据主体的基本权利与利益采取了合适与特定的措施。<br>3．根据欧盟或成员国的有权机构所制定的法律或规则而具有保守职业性秘密责任的职业主体，或者根据欧盟或成员国的有权机构所制定的法律或规则而具有保守秘密责任的自然人，可以为了第2段（h）点所规定的目的而处理第1段所规定的个人数据。<br>4．对于基因数据、生物性识别数据或健康相关数据的处理，成员国可以维持原有规定，或者作出新的规定，包括对处理基因数据、生物性识别数据或健康相关数据进行限定。<br><strong>第10条 处理涉及犯罪定罪与违法的个人数据</strong><br>处理和犯罪定罪与违法相关的个人数据，或处理第6（1）条规定的与安全措施相关的个人数据，只有如下情形才能被允许：当个人数据处理为官方机构控制，或者当欧盟或成员国的法律授权进行处理，并且采取了恰当的措施保障数据主体的权利与自由。任何犯罪定罪的全面性登记只能由官方机构进行。<br><strong>第11条 不需要识别的处理</strong><br>1．如果控制者处理个人数据的目的不需要或不再需要控制者对数据主体进行识别，控制者就不再具有为了遵循本条例而维持、获取或处理额外信息以识别数据主体的责任。<br>2．对于第1段所规定的情形，如果控制者能够证明其不适合识别数据主体，如有可能，数据控制者应当告知数据主体。在此类情形下，除非数据主体为了行使第15至20条所规定的权利，需要提供额外信息而使得对其识别变得可能，第15至20条将不应适用。<br><strong>第三章 数据主体的权利</strong><br><strong>第一部分 透明性与模式</strong><br><strong>第12条 信息、交流与模式的透明性——保证数据主体权利的行使</strong><br>1．对于和个人信息处理相关的第13和第14条规定的所有信息、或者第15条至22条以及34条所规定的所有交流，控制者应当以一种简洁、透明、易懂和容易获取的形式，以清晰和平白的语言来提供；对于针对儿童的所有信息，尤其应当如此。信息应当以书面形式或其他形式提供，包括在合适的情况下通过电子方式提供。若数据主体的身份可通过其他途径得到证实，那么控制者可依主体申请以口头方式提供相关信息。<br>2．控制者应当对数据主体行使第15至22条的权利而提供帮助。对于第11（2）条所规定的情形，当数据主体请求其行使第15至22条的权利，控制者不应拒绝，除非控制者能够证明其并不适宜识别数据主体。<br>3．在数据主体根据第15至22条的规定提出请求后，控制者应当提供信息，不应无故拖延，在任何情形下应当在收到请求后一个月内提供信息。在必要的情形下，考虑到请求的复杂性和多样性，这个期限可以再延长两个月。如果有此类延长，控制者应当在收到请求的一个月内将此类延长以及延长原因告知数据主体。当数据主体以电子形式做出请求，在可行的情况下，对信息的提供也应当以电子形式提供，除非数据主体有不同请求。<br>4．如果控制者没有采取相应的行动对数据主体的请求做出回应，那么应当及时告知该数据主体其在收到请求后一个月内未能采取行动的具体原因，同时可向监管机构提出申诉，寻求司法救济。<br>5．第13和第14条所规定的信息以及第15至22条和34条所规定的所有交流与行为都应当是免费的。当数据主体的请求明显不具备正当理由或超过必要限度，特别是当请求是重复性的时候，控制者可以：<br>(a)结合提供信息、交流或相应行动的行政花费，收取一定的合理费用；或者<br>(b)拒绝对请求作出行动。<br>控制者有责任证明数据主体的请求明显是毫无根据的或过分的。<br>6．在不影响第11条的前提下，控制者可以对第15至21条中提出要求的自然人的身份有合理怀疑，要求数据主体提供必要的额外信息以确认数据主体的身份。<br>7．根据第13条和14条提供给数据主体的信息可以和标准化的图标一起提供，以便于数据主体以一种一目了然的、易懂的和清晰的方式对计划的数据处理有全盘理解。当图标以电子化的方式提供，它们必须是机器可读的。<br>8．对于确定图标所提供的信息以及提供标准化图标的程序，欧盟理事会将有权根据第92条制定授权行动。<br><strong>第二部分 信息与对个人数据的访问</strong><br><strong>第13条 收集数据主体个人数据时应当提供的信息</strong><br>1．当收集和数据主体相关的个人数据时，控制者应当为数据主体提供如下信息：<br>(a)控制者的身份与详细联系方式，以及如果适用的话，控制者的代表；<br>(b)数据保护官的详细联系方式，如果适用的话；<br>(c)处理将要涉及到的个人数据的目的，以及处理的法律基础；<br>(d)当处理是基于（f）点或第6（1）条的时候，控制者或第三方的正当利益；<br>(e)个人数据的接收者或者接收者的类型，如果有的话；<br>(f)如果适用的话，控制者期望将数据转移到第三国或国际组织的事实、欧盟委员会作出或未作出充分决定的事实，或者，在第46或47条或者第49（1）条的第二小段所规定的转移情形中，所采取的适当保障措施的参考资料、获取它们备份的方式，或者在那里可以获取它们。<br>2．除了第1段所规定的信息，控制者应当在获取个人数据时为数据主体提供确保合理与透明处理所必要的进一步信息：<br>(a)个人数据将被储存的期限，以及确定此期限的标准；<br>(b)数据主体所拥有的权利：可以要求控制者提供对个人数据的访问、更正或擦除，或者限制或反对相关处理的权利；数据携带权；<br>(c)当处理是根据第6（1）条或第9（2）条的（a）点而进行的，数据主体拥有可以随时撤回——这种撤回不会影响撤回之前根据同意而进行处理的合法性——同意的权利；<br>(d)向监管机构进行申诉的权利；<br>(e)提供个人数据是一项制定法还是合同法的要求，是否对于缔结一项契约是必要的，数据主体是否有责任提供个人数据，以及没有提供此类数据会造成的可能后果。<br>(f)存在自动化的决策，包括第22（1）和（4）条所规定的用户画像，以及在此类情形下，对于相关逻辑、包括此类处理对于数据主体的预期后果的有效信息。<br>3．若控制者进一步处理个人信息的目的与收集个人信息的目的不一致，那么，控制者应当在进一步处理之前向数据主体提供此类目的的信息，以及提供第2段所规定的相关进一步信息。<br>4．在数据主体已经拥有信息的情况下，第1，2，3段不应当适用。<br><strong>第14条 未获得数据主体个人数据的情形下，应当提供的信息</strong><br>1．当个人数据还没有从数据主体那里收集，控制者应当向数据主体提供如下信息：<br>(a)控制者的身份与详细联系方式，以及如果适用的话，控制者的代表；<br>(b)如果适用的话，数据保护官的详细联系方式；<br>(c)处理将要涉及到的个人数据的目的，以及处理的法律基础；<br>(d)相关个人数据的类型；<br>(e)个人数据的接收者或者接收者的类型，如果有的话；<br>(f)如果适用的话，控制者期望将数据转移到第三国或国际组织、欧盟委员会作出或未作出的充足保护的认定，或者，在第46或47条或者第49（1）条的第二小段所规定的转移情形中，所采取的适当保障措施的参考资料、获取它们备份的方式，或者在那里可以获取它们。<br>2．除了第1段所规定的信息，控制者应当向数据主体提供如下确保涉及到数据主体的处理是合理与透明的必要信息：<br>(a)个人数据将被储存的期限，或者如果不可能的话，用来确定此期限的标准；<br>(b)当处理是根据第6（1）条（f）点而进行的，控制者或第三方所追求的正当利益；<br>(c)数据主体存在如下权利，可以要求控制者提供对个人数据的访问、更正或擦除，或者限制或反对相关处理，数据携带权；<br>(d)当处理是根据第6（1）条或第9（2）条的（a）点而进行的，数据主体拥有可以随时撤回——这种撤回不会影响撤回之前根据同意而进行处理的合法性——同意的权利；<br>(e)向监管机构进行申诉的权利；<br>(f)个人数据的来源，以及如果适用的话，其来源是否可以是公开性的资源；<br>(g)存在自动化的决策，包括第22（1）和（4）条所规定的用户画像，以及在此类情形下，对于相关逻辑、包括此类处理对于数据主体的预期后果的有效信息。<br>3．控制者应当按如下方式提供第1段和第2段所规定的信息：<br>(a)应当在获得个人数据后的一段合理期限内提供信息，如果考虑到个人数据处理的特定情形，应当至少在一个月以内；<br>(b)如果个人数据是被用来和数据主体进行沟通的，最晚应当在其和数据主体进行第一次沟通时提供信息；<br>(c)如果个人数据将被计划披露给另一个接收者，那么最晚应当在个人数据被第一次披露时提供信息。<br>4．当控制者因为与收集个人信息时不一致的目的进一步处理个人信息，控制者应当在进一步处理之前向数据主体提供此类目的的信息，以及提供第2段所规定的相关进一步信息。<br>5．在如下情形中，第1至4段不适用：<br>(a)数据主体已经拥有信息；<br>(b)此类信息的提供是不可能的，或者说需要付出某种不相称的工作，在如下情形中尤其不适用：为了实现公共利益、科学或历史研究目的或统计目的，为了保障数据主体的权利和自由，并采取了本条例第89（1）条所规定的合理技术与组织措施；或者本条第1段所规定的责任会严重妨碍实现处理的目标。在此类情形中，控制者应当采取恰当的措施保护数据主体的权利与自由与正当利益，包括使得信息可以公开获取；<br>(c)欧盟或成员国为控制者特别制定了获取或公开信息的法律，并且已经对保护数据主体的正当利益制定了恰当的措施；<br>(d)当个人数据必须保密，必须遵守欧盟或成员国法律所规定的职业秘密责任，包括制定法上的保守秘密责任。<br><strong>第15条 数据主体的访问权</strong><br>1．数据主体应当有权从控制者那里得知，关于其的个人数据是否正在被处理，如果正在被处理的话，其应当有权访问个人数据和获知如下信息：<br>(a)处理的目的；<br>(b)相关个人数据的类型；<br>(c)个人数据已经被或将被披露给接收者或接收者的类型，特别是当接收者属于第三国或国际组织时；<br>(d)在可能的情形下，个人数据将被储存的预期期限，或者如果不可能的话，确定此期限的标准；<br>(e)数据主体要求控制者纠正或擦除个人数据、限制或反对对数据主体相关的个人数据进行处理的权利；<br>(f)向监管机构进行申诉的权利；<br>(g)当个人数据不是从数据主体那里收集的，关于来源的任何信息；<br>(h)存在自动化的决策，包括第22（1）和（4）条所规定的数据分析，以及在此类情形下，对于相关逻辑、包括此类处理对于数据主体的预期后果的有效信息。<br>2．当个人数据被转移到第三国或一个国际组织，数据主体应当有权获知和转移相关的符合第46条的恰当的保障措施。<br>3．控制者应当对进行处理的个人数据提供一份备份。对于任何数据主体所要求的额外备份，控制者可以根据管理花费而收取合理的费用。当数据主体通过电子方式而请求，且除非数据主体有其他请求，信息应当以通常使用的电子形式提供。<br>4．获取第三段中所规定的备份的权利不应当对他人的权利与自由产生负面影响。<br><strong>第三部分 更正与擦除</strong><br><strong>第16条 更正权</strong><br>数据主体应当有权从控制者那里及时得知对与其相关的不正确信息的更正。在考虑处理目的的前提下，数据主体应当有权完善不充分的个人数据，包括通过提供额外声明的方式来进行完善。<br><strong>第17条 擦除权（“被遗忘权”）</strong><br>1．数据主体有权要求控制者擦除关于其个人数据的权利，当具有如下情形之一时，控制者有责任及时擦除个人数据：<br>(a)个人数据对于实现其被收集或处理的相关目的不再必要；<br>(b)处理是根据第6（1）条（a）点，或者第9（2）条（a）点而进行的，并且没有处理的其他法律根据，数据主体撤回在此类处理中的同意；<br>(c)数据主体反对根据第21（1）条进行的处理，并且没有压倒性的正当理由可以进行处理，或者数据主体反对根据第21（2）条进行的处理；<br>(d)已经存在非法的个人数据处理；<br>(e)为了履行欧盟或成员国法律为控制者所设定的法律责任，个人数据需要被擦除；<br>(f)已经收集了第8（1）条所规定的和提供信息社会服务相关的个人人数据。<br>2．当控制者已经公开个人数据，并且负有第1段所规定的擦除个人数据的责任，控制者应当考虑可行技术与执行成本，采取包括技术措施在内的合理措施告知正在处理个人数据的控制者们，数据主体已经要求他们擦除那些和个人数据相关的链接、备份或复制。<br>3．当处理对于如下目的是必要的，第1和第2段将不适用：<br>(a)为了行使表达自由和信息自由的权利；<br>(b)控制者执行或者为了执行基于公共利益的某项任务，或者基于被授予的官方权威而履行某项任务，欧盟或成员国的法律要求进行处理，以便履行其法律职责；<br>(c)为了实现公共健康领域符合第9（2）条（h）和（i）点以及第9（3）条的公共利益而进行的处理；<br>(d)如果第1段所提到权利会受严重影响，或者会彻底阻碍实现第89(1)条的公共利益目的、科学或历史研究目的或统计目的；或者<br>(e)为了提起、行使或辩护法律性主张。<br><strong>第18条 限制处理权</strong><br>1．当存在如下情形之一时，数据主体有权要求控制者对处理进行限制：<br>(a)数据主体对个人数据的准确性有争议，并给与控制者以一定的期限以核实个人数据的准确性；<br>(b)处理是非法的，并且数据主体反对擦除个人数据，要求对使用其个人数据进行限制；<br>(c)控制者不再需要个人数据以实现其处理的目的，但数据主体为了提起、行使或辩护法律性主张而需要该个人数据；<br>(d)数据主体根据第21（1）条的规定而反对处理，因其需要确定控制者的正当理由是否优先于数据主体的正当理由。<br>2．当处理受第1段的规定所限制，除了储存的情形，此类个人数据只有在如下情形中才能进行处理：获取了数据主体的同意，或者为了提起、行使或辩护法律性主张，或者为了保护另一个自然人或法人的权利，或者为了欧盟或某个成员国的重要公共利益。<br>3．那些根据第1段规定已经获取了对处理进行限制的数据主体，在限制被解除前，控制者应当告知数据主体。<br><strong>第19条 关于更正或擦除或限制处理中的通知责任</strong><br>对于所有根据第16、17（1）、18条而限制或擦除个人数据，或限制处理个人数据，控制者都应当将其告知个人数据已经被披露给的每个接收者——除非此类告知是不可能的，或者需要付出不相称的工作。如果数据主体提出要求，控制者应当将关于接收者的情形告知数据主体。<br><strong>第20条 数据携带权</strong><br>1．当存在如下情形时，数据主体有权获得其提供给控制者的相关个人数据，且其获得个人数据应当是经过整理的、普遍使用的和机器可读的，数据主体有权无障碍地将此类数据从其提供给的控制者那里传输给给另一个控制者：<br>(a)处理是建立在第6（1）条（a）点或9（2）条（a）点所规定的同意，或者6（1）条所规定的合同的基础上的；<br>(b)处理是通过自动化方式的。<br>2．在行使第1段所规定的携带权时，如果技术可行，数据主体应当有权将个人数据直接从一个控制者传输到另一个控制者。<br>3．行使第1段所规定的权利，不能影响第17条的规定。对于控制者为了公共利益，或者为了行使其被授权的官方权威而进行的必要处理，这种权利不适用。<br>4．第1段所规定的权利不能对他人的权利或自由产生负面影响。<br><strong>第四部分 反对的权利和自动化的个人决策</strong><br><strong>第21条 反对权</strong><br>1．对于根据第6（1）条（e）或（f）点而进行的关乎数据主体的数据处理，包括根据这些条款而进行的用户画像，数据主体应当有权随时反对。此时，控制者须立即停止针对这部分个人数据的处理行为，除非控制者证明，相比数据主体的利益、权利和自由，具有压倒性的正当理由需要进行处理，或者处理是为了提起、行使或辩护法律性主张。<br>2．当因为直接营销目的而处理个人数据，数据主体有权随时反对为了此类营销而处理相关个人数据，包括反对和此类直接营销相关的用户画像。<br>3．当数据主体反对为了直接营销目的而处理，将不能为了此类目的而处理个人数据。<br>4．至晚在和数据主体所进行的第一次沟通中，第1段和第2段所规定的权利应当让数据主体明确知晓，且应当与其他信息区分开来，清晰地告知数据主体。<br>5．在适用信息社会服务的语境中，尽管存在2002&#x2F;58&#x2F;EC指令的规定，数据主体仍可以使用技术性条件、通过自动化方式行使反对权。<br>6．当个人数据是为了第89（1）条所规定的科学目的或历史研究目的或统计目的，数据主体基于其特定情形应当有权反对对关乎其的个人数据进行处理，除非处理对于实现公共利益的某项任务是必要的。<br><strong>第22条 自动化的个人决策，包括用户画像</strong><br>1．数据主体有权反对此类决策：完全依靠自动化处理——包括用户画像——对对数据主体做出具有法律影响或类似严重影响的决策。<br>2．当决策存在如下情形时，第1段不适用：<br>(a)当决策对于数据主体与数据控制者的合同签订或合同履行是必要的；<br>(b)当决策是欧盟或成员国的法律所授权的，控制者是决策的主体，并且已经制定了恰当的措施保证数据主体的权利、自由与正当利益；或者<br>(c)当决策建立在数据主体的明确同意基础之上。<br>3．在第2段所规定的（a）和（c）点的情形中，数据控制者应当采取适当措施保障数据主体的权利、自由、正当利益，以及数据主体对控制者进行人工干涉，以便表达其观点和对决策进行异议的基本权利。<br>4．第2段所规定的决策的基础不适用于第9（1）条所规定的特定类型的个人数据，除非符合第9（2）条（a）点或（g）点的规定，并且已经采取了保护数据主体权利、自由与正当利益的措施。<br>第五部分限制<br><strong>第23条 限制</strong><br>1．若控制者或处理者受欧盟法律或某成员国法律的调整，那么欧盟法律或该成员国法律可以通过立法手段限制第12至22条、34条以及第5条所赋予的责任范围与权利范围，只要其法律条款和第12至22条所赋予的责任与权利相对应。如果此类限制尊重基本权利与自由的核心要素，并且此类限制是实现如下民主社会中的目的所必要和成比例的措施，那么此类限制应当被允许：<br>(a)国家安全；<br>(b)国防；<br>(c)公共安全；<br>(d)预防、调查、侦查、起诉刑事违法进行或者执行刑法，包括保障公共安全和预防对公共安全的威胁；<br>(e)其他些欧盟或某个成员国的重要一般公共利益，特别是欧盟或某个成员国的经济或金融利益，包括财政、预算、税收事项、公共健康和社会安全；<br>(f)司法独立和司法诉讼的保护；<br>(g)为了规制性职业而预防、调查、保护和起诉违反伦理的行为；<br>(h)和行使（a）（b）（c）（d）（e）（g）点中所规定的官方权威相联系的某项监控、调查或规制功能；<br>(i)保护数据主体或其他人的权利和自由；<br>(j)实施民事法律主张。<br>2．需要特别注意的是，至少在涉及到如下情形时，任何第1段所规定的立法措施都应当包含特定条款，规定：<br>(a)处理的目的或处理的类型；<br>(b)个人数据的类型；<br>(c)施加限制的范围；<br>(d)防止滥用或非法性访问或转移的措施；<br>(e)控制者的具体情况或控制者类型的具体情况；<br>(f)在考虑了处理的性质、范围和目的或处理类型之后所制定的储存期限和可适用的保障措施；<br>(g)数据主体的权利和自由所面临的风险；以及<br>(h)数据主体获知限制的权利，除非这种权利可能影响实现限制的目的。<br><strong>第四章 控制者和处理者</strong><br><strong>第一部分 一般性责任</strong><br><strong>第24条 控制者的责任</strong><br>1．在考虑了处理的性质、范围、语境与目的，以及考虑了处理对自然人权利与自由所带来的不同概率和程度的风险后，控制者应当采取恰当的技术与组织措施，保证处理符合本条例规定的，并且能够证明处理符合本条例规定。必要时，这些措施应当被审查。<br>2．第1段所规定的措施，当和处理活动成比例时，应当包括控制者所采用的合适的数据保护政策。<br>3．遵守第40条所规定的已生效的行为准则，或遵守第42条规定的已生效的认证机制，这可以被用以证明控制者责任的合规性。<br><strong>第25条 通过设计的数据保护和默认的数据保护</strong><br>1．在考虑了最新水平、实施成本、处理的性质、处理的范围、处理的语境与目的，以及处理给自然人权利与自由带来的伤害可能性与严重性之后，控制者应当在决定处理方式时和决定处理时，应当采取合适的技术与组织措施，并且在处理中整合必要的保障措施，以便符合本条例的要求和保护数据主体的权利。例如，控制者可以采取匿名化，一种设计用来实施数据保护原则——比如数据最小化原则——的措施。<br>2．控制者有责任采取适当的技术与组织措施，以保障在默认情况下，只有某个特定处理目的所必要的个人数据被处理。这种责任适用于收集的个人数据的数量、处理的限度，储存的期限以及可访问性。尤其需要注意的是，此类措施必须确保，在默认情况下，如果没有个体介入，个人数据不能为不特定数量的自然人所访问。<br>3．根据第42条的某种已生效的认证机制，可以被用来证明本条第1段和第2段所规定的合规要求。<br><strong>第26条 共同控制者</strong><br>1．当两个或更多控制者联合确定处理的目的与方法，它们就是共同控制者。它们应当以一种透明的方式确定遵守本条例责任的相应责任，尤其当其涉及到行使数据主体个人权利，以及涉及控制者为数据主体——根据他们的合约安排——提供第13条和第14条所规定的信息的相应责任，除非欧盟或成员国的法律已经对对控制者施加了相应责任。<br>2．第1段所规定的合约安排应当恰当地反映相对于数据主体的共同控制者的相应角色和相互关系。数据主体应当可以知晓安排的实质。<br>3．不论第1段所规定的合约安排的条款如何，数据主体都可以向任一控制者主张其本条例所赋予的权利。<br><strong>第27条 不在欧盟所设立的控制者或处理者的代表</strong><br>1．在第3（2）条适用的情形下，控制者或处理者应当以书面形式在欧盟委任一名代表。<br>2．此项责任不应当适用于：<br>(a)除了第9（1）条所规定的特定类型数据的大规模处理，或者第10条所规定的和刑事定罪或违法相关的个人数据处理之外的偶尔性处理，以及考虑到处理的性质、语境、范围和目的，不太可能对自然人的权利与自由带来风险的处理；或者<br>(b)公共机构或实体。<br>3．为数据主体提供相关商品或服务，或者监控数据主体的行为，数据主体的所在国之一应当设立代表。<br>4．为了确保对本条例的遵守，对于所有涉及到处理的事项，控制者或处理者应当做出强制性规定，确保其代表能在控制者或处理者之外收到信息，或者替代控制者或处理者收到信息，对于监管机构和数据主体所要求的事项尤其如此。<br>5．控制者或处理者委任代表，不能影响控制者或处理者进行的法律行动。<br><strong>第28条 处理者</strong><br>1．处理者代表控制者进行处理，控制者只能选用有充分保证的、可采取合适技术与组织措施的、其处理方式符合本条例要求并且保障数据主体权利的处理者。<br>2．如果没有控制者之前的特别授权或一般书面授权，处理者不应聘用另一个处理者。在具有一般书面授权的情形下，对于涉及到补充或替换其他处理者的变动，处理者都应当告知控制者，以便使控制者有机会反对此类变化。<br>3．处理者的处理应当受某类合同或其他欧盟法与成员国法的约束，这类合同或法律应当规定处理者相对于控制者的责任、主体事项、处理期限、处理性质与目的、个人数据的类型、数据主体的类型以及控制者的责任与权利的。此类合同或法律尤其应当对如下情形做出规定：<br>(a)只有在收到控制者的书面指示时才可以处理个人数据，在涉及到将个人数据转移到第三国或某个国际组织的事项中亦是如此，除非欧盟法或成员国法对处理者有要求；在这种情形下，处理者应当在处理之前将法律要求告知控制者，除非告知会影响重要的公共利益；<br>(b)对于被授权处理个人数据的人，确保其履行保密义务或法律上的适当保密责任；<br>(c)采取第32条所要求的所有措施；<br>(d)尊重第2段和第4段规定的聘用另一个处理者的条件；<br>(e)结合处理的性质，在可能的情形下，通过合适的技术与组织手段帮助控制者履行其责任，以便使得数据主体能够行使其第三章所规定的权利；<br>(f)结合处理的性质和处理者所能得到的信息，帮助控制者履行第32至36条所规定的责任；<br>(g)基于控制者的选择，在提供和处理相关的服务结束后，将个人数据删除或返还给控制者，并且删除已有备份，除非欧盟或成员国的法律要求储存个人数据；<br>(h)给控制者提供所有能够证明其已经遵循本条款规定责任的信息，以及有利于控制者或控制者委任的审计员进行审计和核查的信息。<br>关于第1段（h）点，如果处理者认为某项指示违反了本条例或其它欧盟或成员国的数据保护条款，其应当立即告知控制者。<br>4．当处理者代表控制者为了进行特定的处理活动而应聘另一处理者，第3段所规定的控制者和处理者之间的合同或其它法律条款所规定的数据保护责任应当通过合同或欧盟或成员国的法律条款而同等适用于另一处理者，尤其是应当采取充分的保障措施、恰当的技术与组织手段以满足本条例的要求。当另一个处理者无法完成其数据保护职责时，对其责任，处理者应当完全负担。<br>5．处理者遵守第40条所规定的已生效的行为准则，或者遵守第42条所规定的已生效的验证机制，这可以被作为证据之一，证明处理者已经采取了本条款第1段和第4段所规定的充分保障。<br>6．在不影响控制者和处理者之间的单独合同的前提下，第3段和第4段所规定的合同或法律条款可以全部或部分运用本条第7段和第8段所规定的格式合同条款，包括它们何时属于根据第42条和第43条规定的赋予给控制者或处理者的验证机制。<br>7．欧盟委员会可以对于本条第3段和第4段所规定的事项，根据第93（2）条所规定的检查程序而制定格式合同条款。<br>8．监管机构可以对本条第3段和第4段所规定的事项，根据第63条所规定的一致性机制而制定格式合同条款。<br>9．第3段和第4段所规定的合同或法律条款必须是书面的，包括以电子形式做出的书面记录。<br>10．在不影响第82、83、84条的情形下，如果某个处理者因为确定处理目的与方法方而违反了本条例，处理者应当在此次处理中被视为控制者。<br><strong>第29条 代表控制者或处理者进行的处理</strong><br>对个人数据有访问权的处理者或控制者、处理者的代表人，未经控制者允许，不得处理该个人数据。欧盟法律或成员国法律另有规定的除外。<br><strong>第30条 处理活动的记录</strong><br>1．每个控制者——以及如果有的话——每个控制者的代表，都应当保持其所负责的处理活动的记录。这种记录应当包含所有如下信息：<br>(a)控制者以及——如果有的话——共同控制者、控制者的代表、数据保护官的姓名、详细联系方式；<br>(b)处理的目的；<br>(c)对数据主体的类型以及个人数据的类型的描述；<br>(d)个人数据已经被披露或将被披露给的接收者——包括位于第三国或国际组织的接收者——的类型；<br>(e)如果适用的话，将个人数据转移到第三国或国际组织的记录，包括识别此第三国或国际组织的记录，以及在第49（1）条第二分段所提到转移的情形中，对适当保障措施的记录；<br>(f)如果适用的话，擦除不同种数据类型的预计期限；<br>(g)如果适用的话，对第32（1）条所规定的技术性与组织性安全措施的一般性描述。<br>2．每个处理者以及——如果适用的话——处理者的代表对于以控制者名义进行的处理都应当保持保存一份记录，包含如下信息：<br>(a)处理者或处理者们的名字和详细联系方式、处理者所代表的每个控制者以及——如果有的话——控制者或处理者的代表、数据保护官；<br>(b)代表每个控制者进行处理的类型；<br>(c)如果适用的话，将个人数据转移到第三国或国际组织的记录，包括识别此第三国或国际组织的记录，以及在第49（1）条第二分段所提到转移的情形中，对适当保障措施的记录；<br>(d)如果有的话，对第32（1）条所规定的技术性和组织性安全措施的一般性描述。<br>3．第1段和第2段所规定的记录应当是书面的，包括以电子形式作出的书面记录。<br>4．基于监管机构的要求，控制者或处理者以及——在有的情况下——控制者或处理者的代表，应当提供可获取的记录。<br>5．第1和第2段所规定的责任不适用于雇员少于250人的经济主体或组织，除非其进行的处理不是偶尔性的，而且可能会对数据主体的权利与自由带来风险，或者其处理包含了第9（1）条规定的特定种类的数据或第10条规定的和刑事犯罪和违法相关的个人数据。<br><strong>第31条 和监管机构的合作</strong><br>在监管机构的要求下，控制者和处理者以及——在适用的情况下——它们的代表应当配合监管机构的工作。<br><strong>第二部分 个人数据的安全</strong><br><strong>第32条 处理的安全</strong><br>1．在考虑了最新水平、实施成本、处理的性质、处理的范围、处理的语境与目的之后，以及处理给自然人权利与自由带来的伤害可能性与严重性之后，控制者和处理者应当采取包括但不限于如下的适当技术与组织措施，以便保证和风险相称的安全水平：<br>(a)个人数据的匿名化和加密；<br>(b)保持处理系统与服务的保密性、公正性、有效性以及重新恢复的能力；<br>(c)在遭受物理性或技术性事件的情形中，有能力恢复对个人数据的获取与访问；<br>(d)具有为保证处理安全而常规性地测试、评估与评价技术性与组织性手段有效性的流程。<br>2．在评估合适的安全级别的时候，应当特别考虑处理所带来的风险，特别是在个人数据传输、储存或处理过程中的的意外或非法销毁、丢失、篡改、未经授权的披露或访问。<br>3．遵守第40条所规定的已生效的行为准则，或者遵守第42条所规定的已生效的验证机制，这可以被作为证据之一，证明已经遵守了本条款第1段的要求。<br>4．控制者和处理者应当采取措施确保，除非接到控制者的指示，任何有权访问个人数据的处理者或任何代表控制者和处理者的自然人都不会进行处理，除非欧盟或成员国法律要求进行处理。<br><strong>第33条 向监管机构报告对个人数据的泄露</strong><br>1．在个人数据泄露的情形中，如果可行，控制者在知悉后应当及时——至迟在72小时内——将个人数据泄露告知第55条所规定的有权监管机构，除非个人数据泄露对于自然人的权利与自由不太可能会带来风险。对于不能在72小时以内告知监管机构的情形，应当提供延迟告知的原因。<br>2．处理者在获知个人数据泄露后，应当及时告知控制者。<br>3．第1段所规定的告知应当至少包括：<br>(a)描述个人数据泄露的性质，在可能的情形下，描述包括相关数据主体的类型和大致数量，以及涉及到个人数据的类型与大致数量；<br>(b)告知数据保护官的姓名与详细联系方式，或者可以获取更多信息的其他联系方式；<br>(c)描述个人数据泄露的可能后果；<br>(d)描述控制者应对个人数据泄露已经采用或计划采用的措施，包括——如果合适的话——减少负面影响的措施。<br>4．在不可能同时提供信息的情形下，可以分阶段地及时提供信息。<br>5．控制者应当记录所有对个人数据的泄露，包括泄露个人数据相关的事实、影响与已经采取的救济行动。参照该记录，监管机构得以核实控制者是否遵守本条例的有关规定。<br><strong>第34条 向数据主体传达个人数据泄露</strong><br>1．当个人数据泄露很可能给自然人的权利与自由带来高风险时，控制者应当及时向数据主体传达对个人数据泄露。<br>2．本条第1段所规定的向数据主体传达，应当以清晰和平白的语言传达个人数据泄露的性质，并且应当至少包括第33（3）条（b）（c）（d）点所提供的信息与建议。<br>3．当满足如下情形之一时，不要求控制者告知数据主体其个人数据被泄露的信息：<br>(a)控制者已经采取合适的技术与组织保证措施，并且那些措施已经应用于那些被个人数据泄露所影响的个人数据，特别是已经应用那些使得未被授权访问的个人无法辨识个人数据的措施，例如加密；<br>(b)控制者已经采取后续措施，保证第1段所规定的给数据主体的权利与自由带来的高风险不再有实现的可能；<br>(c)告知将需要付出不相称的努力。此时，应存在公告机制或类似措施来承担控制者的告知义务，并且与控制者告知相比，这种措施的告知效果应当至少有相同效果。<br>4．如果控制者仍然没有将个人数据泄露告知数据主体，监管机构在考虑了个人数据泄露所可能带来的高风险可能性后，可以要求其告知，或者可以认为符合第3段所规定的情形。<br><strong>第三部分 数据保护影响评估与提前咨询</strong><br><strong>第35条 数据保护影响评估</strong><br>1．当某种类型的处理——特别是适用新技术进行的处理——很可能会对自然人的权利与自由带来高风险时，在考虑了处理的性质、范围、语境与目的后，控制者应当在处理之前评估计划的处理进程对个人数据保护的影响。若多项高风险处理活动属于同一种类，那么此时仅对其中某一项活动进行评估即可。<br>2．如果控制者已经委任数据保护官，当其进行数据保护影响评估时，控制者应当向数据保护官进行咨询。<br>3．在如下情形中，第1段所规定的数据保护影响评估是尤其必须的：<br>(a)对与自然人相关的个人因素进行系统性与全面性的评价，此类评价建立在自动化处理——包括用户画像——基础上的，并且其决策对自然人产生法律影响或类似重大影响；<br>(b)以大规模处理的方式处理第9（1）条所规定的特定类型的数据，或者和第10条规定的定罪与违法相关的个人数据；或者<br>(c)以大规模的方式系统性地监控某个公众可以访问的空间。<br>4．监管机构应当建立并公开一个列表，列明符合第1段所要求的数据保护影响评估的处理操作的类型。监管机构应当将此类列表告知第68条所提到欧盟数据保护委员会。<br>5．监管机构还可以建立一个公开性的列表，列明符合不需要进行数据保护影响评估的处理操作的类型。监管机构应当将此类列表告知欧盟数据保护委员会。<br>6．在设置第4段与第5段所规定的列表之前，当此类列表涉及到为数据主体提供商品或服务，或者涉及到对多个成员国行为的监管，或者可能实质性地影响欧盟内部个人数据的自由流动，有职权的监管机构应当首先适用第63条所规定的一致性机制。<br>7．评估应当至少包括：<br>(a)对计划的处理操作和处理目的的系统性描述，以及——如果适用的话——对控制者所追求的正当利益的描述；<br>(b)对和目的相关的处理操作的必要性与相称性进行分析；<br>(c)对第1段所规定的给数据主体的权利与自由带来的风险的评估；<br>(d)结合数据主体和其他相关个人的权利与正当利益，采取的计划性风险应对措施，包括保障个人数据保护和证明遵循本条例的安全保障、安全措施和机制。<br>8．评估相关控制者或处理者的处理操作的影响时，特别是评估数据保护影响时，应当合理考虑其对第40条所规定的已生效的行为准则的遵守。<br>9．在合适的情形下，如果其不影响保护商业或公共利益或处理操作的安全性，控制者应当咨询数据主体或数据主体代表对于其预期处理的观点。<br>10．当基于第6（1）条（c）或（e）点而进行的处理符合欧盟或成员国为控制者制定涉及到处理操作的法律，并且在制定其法律基准时已经进行了作为一般性影响评估一部分的数据保护影响评估时，第1至7段不应当适用，除非成员国认为，有必要在处理活动前进行此类评估。<br>11．必要时，控制者应当进行核查，评估处理是否是符合数据保护影响评估，至少当处理操作所带来的风险存在变化时，应进行核查。<br><strong>第36条 提前咨询</strong><br>1．当第35条所规定的数据保护影响评估表明，如果控制者不采取措施，处理会带来高风险，那么控制者应当在处理之前咨询监管机构。<br>2．当监管机构认为，第1段所规定的预期的处理将违反本条例，特别是当控制者无法识别或减小风险，监管机构应当在收到咨询请求的八个星期以内向控制者以及——在适用的情况下——处理者提供书面建议，并且可以使用第58条所规定的权力。考虑到预期处理的复杂性，这种期限可以延长六个星期。监管机构应当在收到咨询请求的一个月内向控制者以及——在适用的情况下——处理者告知延期以及延期的原因。监管机构可以延长期限，直到其获取了咨询所要求的信息。<br>3．当咨询第1段所规定的监管机构时，控制者应当向监管机构提供如下信息：<br>(a)在适用的情形下，涉及到处理——特别是当处理是在一群企业内部进行的——的控制者、共同控制者和处理者的相应责任；<br>(b)预期处理的目的与方法；<br>(c)为了保障数据主体权利与自由所采取的符合本条例的方法与措施；<br>(d)在适用的情形下，数据保护官的详细联系方式；<br>(e)第35条所规定的数据保护影响评估；以及<br>(f)监管机构要求的所有其它信息。<br>4．成员国在起草相关立法草案以获得国会通过时，或者根据此类立法措施制定处理相关的规制措施时，应当咨询监管机构。<br>5．虽然有第1段的规定，但在和控制者履行实现公共利益任务相关的处理中，包括和社会保障与公共健康相关的处理中，成员国法律可以要求控制者在其处理相关的事项中咨询监管机构并且提前获取监管机构的授权。<br><strong>第四部分 数据保护官</strong><br><strong>第37条 数据保护官的委任</strong><br>1．在如下任一情形中，控制者和处理者应当委任数据保护官：<br>(a)处理是公共机构或公共实体进行操作的，法庭在履行其司法职能时除外；<br>(b)控制者或处理者的核心处理活动天然性地需要大规模性地对数据主体进行常规和系统性的监控；或者<br>(c)控制者或处理者的核心活动包含了第9条规定的对某种特殊类型数据的大规模处理和第10条规定的对定罪和违法相关的个人数据的处理。<br>2．如果一组企业的每一个机构都能很容易联系数据保护官，这一组企业可以任命一个单独的数据保护官。<br>3．当控制者或处理者是一个公共机构或公共实体，基于它们的组织结构和规模，多个此类公共机构或实体可以共同委任一个数据保护官。<br>4．除了第1段所规定的情形，在欧盟或成员国法律要求的情形下，控制者或处理者，或代表某类控制者或处理者的协会和其他实体可以委任一名数据保护官。对于此类协会，或代表控制者或处理者的其他实体的活动，数据保护官有权代表它们进行活动。<br>5．数据保护官的委任必须基于其专业性的素质，其需要具有数据保护法律与实践的专业知识，以及完成第39条所规定的任务的能力。<br>6．数据保护官应当是控制者或处理者或基于服务合同而完成任务的一名职员。<br>7．控制者或处理者应当发布数据保护官的详细联系方式，并向监管机构进行报告。<br><strong>第38条 数据保护官的职位</strong><br>1．控制者和处理者应当确保，在所有与个人数据保护相关的事项中，数据保护官都应当以一种恰当和及时的方式介入。<br>2．控制者和处理者应当支持数据保护官履行第39条所规定的责任，应当提供其履行此类责任、访问个人数据、进行处理操作，以及维持其专业性知识的必要资源。<br>3．控制者和处理者应当确保个人数据保护官不会收到任何关于履行此类责任的指示。个人数据保护官不能因为完成其任务而被控制者或处理者解雇。其可以直接向控制者或处理者的最高管理层进行报告。<br>4．数据主体可以在所有和处理其个人数据相关的事项中，以及和行使本条例所赋予的权利相关的事项中联系数据保护官。<br>5．数据保护官在完成其任务时，应当遵守欧盟或成员国的法律，负有保密义务。<br>6．数据保护官可以完成其他任务或责任。控制者或处理者应当保证任何此类任务和责任不会导致利益冲突。<br><strong>第39条 数据保护官的任务</strong><br>1．数据保护官应当至少具有如下任务：<br>(a)对控制者或处理者，以及那些履行本条例和欧盟其他成员国数据保护条款所规定的处理责任的雇员进行告知，提供建议；<br>(b)确保遵守本条例、其他欧盟或成员国数据保护条款、和个人数据保护相关的控制者或处理者的政策，包括分配处理操作中以及相关审计中的责任、增强意识以及培训职员；<br>(c)根据要求，应当对数据保护影响评估以及根据第35条对其实施进行监管的事项提供建议；<br>(d)和监管机构进行合作；<br>(e)在与处理相关的事项中，包括第36条所规定的提前咨询中，以及——在适用的情况下——在其他所有相关事项的咨询中，充当监管机构的联系人。<br>2．数据保护官在履行其任务时，应当结合处理的性质、范围、语境与目的，合理地考虑处理操作所伴随的风险。<br><strong>第五部分 行为准则与认证</strong><br><strong>第40条 行为准则</strong><br>1．成员国、监管机构以及欧盟数据保护委员会与欧盟委员会鼓励在考虑不同处理部门的特征以及微型、小型以及中型经济主体的特定需求的基础上起草促进本条例合理适用的行为准则。<br>2．协会以及其它代表某类控制者或处理者的实体为了对适用本规则进行细化，可以起草行为准则，或修正或延长此类准则，例如，它们可以起草涉及到如下事项的准则：<br>(a)合理与透明的处理；<br>(b)在特定情境下控制者所追求的正当利益；<br>(c)对个人数据的收集；<br>(d)对个人数据进行匿名化处置；<br>(e)提供给公众与数据主体的信息；<br>(f)数据主体权利的行使；<br>(g)提供给儿童和保护儿童的信息，以及为了获取儿童监护人同意所采取的形式；<br>(h)第24条和第25条所规定的措施与程序，以及为了保障第32条所规定的处理安全所采取的措施；<br>(i)向监管机构通报个人数据泄露，以及将此类个人数据泄露告知数据主体；<br>(j)将个人数据转移到第三国或国际组织；或者<br>(k)不影响第77条和第99条所规定的数据主体权利的庭外诉讼性活动，以及为了解决控制者与数据主体在处理相关事项中争议的纠纷解决程序。<br>3．控制者或处理者除了受本条例约束之外，对于根据第3条不受本条例约束的情形，为了保证在第46（2）条（e）点所规定的将个人数据转移到第三国或国际组织的框架中提供合适的安全措施，也可以受本条第5段所规定的已生效的行为准则约束，或者受本条第9段规定的具有一般性效力的行为准则所约束。为了提供此类合适的安全措施，包括和数据主体权利相关的安全措施，此类控制者或处理者应当通过合同或其他具有法律强制力的措施制定有约束力和可执行的承诺。<br>4．在不影响第55或56条所规定的有权监管机构的任务与权利的前提下，本条第2段所规定的行为准则应当包括使第41（1）条所规定的实体能履行其监管任务的有效措施，保证负责实施行为准则的控制者或处理者遵循其条款的规定。<br>5．本条第2段所规定的计划起草、修改行为准则或延长现有准则的协会或其他实体，应当将准则草案、修正案或延期提议提交给符合第55条的有权监管机构。监管机构应当提供一份意见书，表明草案、修正案或延期提议是否符合本条例的规定，如果监管机构认定已经采取了足够和适当的安全保障，其应当批准草案、修正案或延期提议。<br>6．当准则草案、或修正案或延期提议是根据第5段的规定而被批准的，并且行为准则不涉及多个成员国的处理活动，监管机构应当进行登记并发表准则。<br>7．当行为准则的草案涉及到多个国家的处理活动，第55条所规定的有权监管机构应当在批准准则草案、修订或延期之前将其按照第63条规定的程序提交给欧盟数据保护委员会，并应提供一份意见书，表明准则草案、修正案或延期是否遵循了本条例，或者——在第3段所规定的情形中——是否提供了恰当的安全措施。<br>8．当第7段中规定的意见书确认了准则草案、修正案或延期遵循了本条例，或者——在第3段所规定的情形中——提供了恰当的安全措施，欧盟数据保护委员会应当将意见书提交给欧盟委员会。<br>9．欧盟委员会应当通过制定实施法案确定，根据第8段规定而提交的已生效的行为准则、修正案或延期是否在欧盟具有一般效力。此类法案的制定应当符合第94（2）条所规定的核查程序。<br>10．对于已经被认定符合第9段中所规定的具有一般有效性的已生效准则，欧盟委员会应当保证其具有适当的公开性。<br>11．欧盟数据保护委员会应当核查所有登记的已生效行为准则、修正案以及延期，并且应当以恰当的方式使得公众能够获取。<br><strong>第41条 对已生效行为准则的监控</strong><br>1．在不影响第57和第58条规定的有权监管机构的任务与权利的前提下，对根据第40条制定的行为准则的合规性监管可以交给如下实体：在准则所规定事项方面具有适当的专业性，并且其合规性监管权力已经得到有权监管机构认证。<br>2．第1段所规定的实体，当存在如下条件时，可以被委任为有权监管是否遵守行为准则的机构：<br>(a)已经证明在准则所规定事项方面具有独立性与专业性，满足有权监管机构的要求；<br>(b)已经确立了相关程序，可以通过程序评估相关控制者和处理者适用准则的资质，监控其对准则条款的遵守，以及间歇性地评估其操作；<br>(c)已经设立程序和体系，解决关于违反准则，或关于控制者或处理者已经实施、或正在实施准则的方式的申诉，并且已使得此类程序与体系对数据主体和公众透明化；并且<br>(d)已经表明其符合有权监管机构的要求，其任务和职责不存在利益冲突的情形。<br>3．有权监管机构应当按照第63条所规定的一致性机制，将认证第1段中所规定的实体的标准草案提交给欧盟数据保护委员会。<br>4．当控制者或处理者违反准则，第1段所规定的实体在不影响有权监管机构的任务和权利、第八章条款的前提下，应当在适当安全措施的保障下采取合适的行动，包括准则中中止或剔除相关控制者或处理者。实体应当将此类行动以及行动的理由告知有权监管机构。<br>5．如果第1段所规定的实体不符合或不再符合认证的条件，或者其行为违反了本条例，有权监管机构应当撤回对其的认证。<br>6．本条不适用于公共机构和公共实体所进行的处理。<br><strong>第42条 认证</strong><br>1．成员国、监管机构、欧盟数据保护委员会和欧盟委员会应当鼓励——尤其是在欧盟层面——建立数据保护认证机制、数据保护印章和标记，以证明控制者和处理者的处理操作符合本条例。对此应当考虑微型、小型以及中型经济主体的特定需求。<br>2．控制者或处理者除了受本条例约束之外，也可以设立符合本条第5段的数据保护认证机制、印章或标记，以便证明，对于根据第3条不受本条例约束的情形，已经对第46（2）条（f）点所规定的将个人数据转移到第三国或国际组织的情形采取了合适的安全措施。为了提供此类合适的安全措施，包括和数据主体权利相关的安全措施，此类控制者或处理者应当通过合同或其他具有法律强制力的措施制定有约束力和可执行的承诺。<br>3．认证应当是自愿的，而且可以通过透明程序而获得。<br>4．根据本条而进行的认证，不能减轻控制者或处理者遵循本条例的责任，而且也不对第55条或56条所规定的有权监管机构的任务和权利产生影响。<br>5．符合本条的认证应当为第43条所规定的认证机构所批准，应当建立在第58（3）条的有权监管机构或第63条的欧盟数据保护委员会所批准的标准之上。当标准被欧盟数据保护委员会所批准，这可以产生一个通用性认证——欧盟数据保护印章。<br>6．那些将其处理提交认证机制的控制者或处理者，应当将进行认证程序所必需的所有信息与访问权提交给第43条规定的认证机构，在适用的情形下，还应当提交给有权监管机构。<br>7．颁发给控制者或处理者的认证的有效期最长是三年，如果相关条件满足，同样的情形下有效期可以延长。当认证的条件不满足或不再满足时，在适用的情形下，第43条规定的认证实体或有权监管机构可以撤回认证。<br>8．欧盟数据保护委员会应当核查所有已登记的验证机制、数据保护印章和标记，而且应当以恰当的方式使得公众能够获取。<br><strong>第43条 认证机构</strong><br>1．在不影响第57条和第58条规定的有权监管机构的任务与权利的前提下，具有相应专业性的认证机构可以在告知监管机构后——以便监管机构可以行使第58（2）点h点所规定的权利——颁发和更新认证。成员国应当确保这些认证机构是如下一个机构认可或两个机构同时认可的：<br>(a)第55或56条所规定的有权监管机构；<br>(b)按照欧洲议会和理事会的(EC)No 765&#x2F;2008条例、EN-ISO&#x2F;IEC 17065&#x2F;2012设定的，以及满足第55条或第56条的有权监管机构所规定的额外要求的全国性认证机构。<br>2．只有存在如下情形时，第1段所规定的认证机构才能根据第1段的规定被认证：<br>(a)已经证明在准则所规定事项方面具有独立性与专业性，满足有权监管机构的要求；<br>(b)采取措施遵从第42（5）条所规定的标准，并且已经为第55条所规定的有权监管机构或第63条规定的欧盟数据保护委员会所批准；<br>(c)建立了发行、定期审查和撤回数据保护认证、印章和标记的程序；<br>(d)已经设立了解决关于违反准则，或关于控制者或处理者已经实施、或正在实施准则的方式的申诉程序和体系，并且数据主体和公众已知悉此类程序和体系；且<br>(e)已经表明其符合有权监管机构的要求，其任务和职责不存在利益冲突的情形。<br>3．第1段和第2段所规定的委任认证机构应当建立在第55条或第66条所规定的有权监管机构所批准的基础性标准之上，或者第63条所规定的欧盟数据保护委员会所批准的基础性标准之上。对于本条第1段（b）点所规定的授权，此类要求应当补充(EC) No 765&#x2F;2008指令所设想的要求，以及描述认证机构方法与程序的技术性规则。<br>4．在不影响控制者或处理者对本条例的遵守的前提下，第1段所规定的认证机构应当负责颁发认证或撤销此类认证的有效评估。颁发给控制者或处理者的认证的有效期最长是五年，如果相关条件满足，同样的情形下有效期可以延长。<br>5．第1段所规定的验证机构应当向有权监管机构报告颁发或撤销所要求认证的理由。<br>6．监管机构应当以容易获取的方式公开本条第3段所规定的要求，以及第42（5）段所规定的标准。监管机构还应当将那些要求和标准传输给欧盟数据保护委员会。欧盟数据保护委员会应当核查所有登记的认证机制与数据保护印章，而且应当通过某种恰当的方式将它们公开。<br>7．在不影响第八章的前提下，当认证的条件不符合或不再符合，或者当认证机构所采取的行为侵犯了本条例，有权监管机构或全国性的认证机构应当取消根据本条第1段对认证机构的认证。<br>8．为了细化第42（1）条所规定的数据保护验证机制所需要考虑的条件，欧盟委员会有权制定符合第92条的授权法案。</p><p>9．欧盟委员会可以制定实施法案，为验证机制与数据保护印章、标记与机制设定技术标准，以便促进和认可那些验证机制、印章与标记。此类实施法条的制定应当符合第94（2）条所规定的验证程序。</p><p><strong>第五章 将个人数据转移到第三国或国际组织</strong><br><strong>第44条 转移的一般性原则</strong><br>对于正在处理或计划进行处理的个人数据，将其转移到第三国或国际组织，包括将个人数据从第三国或国际组织转移到另一第三国或另一国际组织，控制者和处理者只有满足本条例的其他条款，以及满足本章规定的条件才能进行转移。为了保证本条例对于自然人的保护程度不会被削弱，本章的所有条款都应当被遵守。<br><strong>第45条 基于认定具有充足保护的转移</strong><br>1．当欧盟委员会作出认定，认为相关的第三国、第三国中的某区域或一个或多个特定部门、或国际组织具有充足保护，可以将个人数据转移到第三国或国际组织。此类转移不需要特定的授权。<br>2．当评估保护程度的充足性时，欧盟委员会应当特别考虑如下因素：<br>(a)法治、对人权与基本自由的尊重、包括关于公共安全、国防、国家安全、刑法和公共机构访问个人数据的一般性与部门性立法，以及此类立法的实施、数据保护规则、职业规则和安全措施，包括将个人数据转移到另一第三国或国际组织所必须遵循的第三国或国际组织的规则、判例法以及有效可执行的数据主体权利、对其个人数据正在转移的数据主体的司法救济；<br>(b)在国际组织是主体的情形中，第三国内存在一个或多个有效运作的独立监管机构，保证数据保护规则的实施，包括具有充分的执行权力，在数据主体行使其权利时和与成员国的监管机构合作时提供帮助和建议；<br>(c)第三国或国际组织已经许下的国际性承诺，或者承诺愿意承担有法律约束力的条约或法律文件所引起的其它责任，以及参加多边或地区性的体系，特别是和数据保护相关的体系所引起的其它责任。<br>3．在评估了保护程度的充足性之后，欧盟委员会可以通过制定实施性法案，确定本条第2段含义内的第三国、第三国内的领地或一个或多个特定部门或一个国际组织是否具有充足的保护。实施性法案应当提供一种周期性审查，至少每四年对第三国或国际组织的所有相关发展进行审查。实施性法案应当细化其领域性与部门性的实施，以及在适用的情况下确定本条第2段（b）点所规定的一个或多个监管机构。实施性法案的制定应当遵循第93（2）条所规定的验证程序。<br>4．欧盟委员会应当持续性地监控第三国或国际组织的某些可能会影响根据本条第3款而作出的决定和建立在95&#x2F;46&#x2F;EC指令第25（6）条基础之上的决定发挥作用的某些发展。<br>5．当已有信息显示，第三国或第三国内的一个或多个特殊部门或国际组织不再提供本条第2段所规定的充足的保护，欧盟委员会应当——尤其是在经过第3段所规定的核查后——通过制定不具有溯及力的实施性法案，在必要限度内废止、修正或中止本条第3段所规定的决定。此类实施性法案的制定应当遵循第93（2）条所规定的验证程序。<br>在具有高度正当性的紧急状态情形中，欧盟委员会应当立即根据第93（3）条规定的程序而制定实施性法案。<br>6．为了补救导致第5条决定的情形，欧盟委员会应当与第三国或国际组织磋商。<br>7．符合本条第5段的决定不会影响到将个人数据转移到第三国、第三国内的领地或一个或多个部门、或者第46条至49条所规定的相关国际组织。<br>8．欧盟委员会应当在欧盟的官方杂志及其网站上发表名单，列明其确定已经具备充足保护或不再具有充足保护的第三国、第三国内的特定部门和国际组织。<br>9．欧盟委员会在95&#x2F;46&#x2F;EC指令第25（6）条基础上而做出的决定，在被欧盟委员会根据本条第3段或第5段而修改、替代或废止前应具有效力。<br><strong>第46条 转移所需要的适当安全保障</strong><br>1．如果没有根据第45（3）条而做出的决定，控制者或处理者只有提供适当的保障措施，以及为数据主体提供可执行的权利与有效的法律救济措施，才能将个人数据转移到第三国或一个国际组织。<br>2．在不要求监管机构提供任何具体授权的情形下，第1段所规定的适当保障措施可以如下方式提供：<br>(a)公共机构或实体之间之间签订的具有法律约束力和可执行性的文件；<br>(b)符合第47条的有约束力的公司规则；<br>(c)欧盟委员会根据第93（2）条规定的核查程序而制定的数据保护标准条款；<br>(d)监管机构根据第93（2）条规定的核查程序制定并且为欧盟委员会批准的数据保护标准条款；<br>(e)根据第40条制定的行为准则，以及第三国的控制者或处理者为了采取合适的安全保障而做出的具有约束力和执行力的承诺，包括数据主体的权利；或者<br>(f)根据第42条而被批准的验证机制，以及第三国的控制者或处理者为了采取合适的安全保障而做出的具有约束力和执行力的承诺，包括数据主体的权利。<br>3．在需要有权监管机构授权的情形下，第1段所规定的合适安全措施尤其可以通过如下方式进行规定：<br>(a)控制者或处理者与控制者、处理者或第三国或国际组织的个人数据接收者之间的合同条款；或者<br>(b)公共机构或公共实体之间在行政性安排中所插入的条款，包括可执行的与有效的数据主体权利。<br>4．在本条第3段所规定的情形中，监管机构应当适用第63段所规定的一致性机制。<br>5．成员国或监管机构根据95&#x2F;46&#x2F;EC指令的第26（2）条而做出的授权，在被监管机构修改、替代或废止之前应当一直有效。欧盟委员会根据95&#x2F;46&#x2F;EC指令第26（4）条而做出的决定，在欧盟委员会按照本条第2段做出必要性的修改、替换或废止决定前应当一直有效。<br><strong>第47条 有约束力的公司规则</strong><br>1．在满足如下条件时，对于符合第63条所规定的一致性机制的有约束力的公司规则，有权监管机关应当批准：<br>(a)具有法律约束力，适用于进行联合经济活动的企业集团或一系列经济主体的所有相关成员——包括其雇员，并且为他们所执行。<br>(b)在处理个人数据方面明确赋予数据主体以可执行的权利；以及<br>(c)满足第2段所规定的要求。<br>2．第1段所规定的有约束力的规则应当至少明确：<br>(a)进行联合经济活动的企业集团或一系列经济主体，及其每一个成员的架构和详细联系方式；<br>(b)数据转移或一系列的数据转移，包括个人数据的类型；处理类型及其目的；受影响的数据主体的类型；以及涉及到的对第三国或多个第三国的确定；<br>(c)规则的法律约束效力，既包括内部的约束力，也包括外部的约束力；<br>(d)对一般数据保护原则的适用，特别是目的限定、数据最小化、有限的储存期限、数据质量、通过设计的数据保护与默认的数据保护、处理的法律基础、对特定类型个人数据的处理；保障数据安全的措施；以及将数据转移到不受约束性公司规则所约束的实体所做的要求；<br>(e)和处理相关的数据主体的权利以及行使这些权利的方式，包括有权不被仅仅根据自动化处理——包括符合第22条的用户画像——而对数据主体做出决定，有权按照第79条向有权监管机构和成员国的有权管辖的法庭申诉，以及有权在违反有约束力的公司规则的情形下获取救济和——如果适用的话——赔偿；<br>(f)对于任何不在欧盟设立的控制者或处理者的相关成员违反约束性公司规则，在成员国的领域内设立的控制者或处理者愿意承担责任；只有当控制者或处理者证明，该成员对于导致损害的事件没有责任，控制者或处理者的此种责任才能被免除；<br>(g)关于约束性公司规则的信息如何提供给数据主体，特别是第13和14条之外关于本段所规定的(d)(e)(f)点的信息如何提供给数据主体；<br>(h)根据第37条所委任的所有数据保护官的任务，或者企业集团、或进行联合经济活动的一系列经济主体内部负责监控遵守约束性公司规则、监控培训和处置申诉的所有人或实体的任务；<br>(i)申诉程序；<br>(j)企业集团或进行联合经济活动的一系列经济主体，为了核实对约束性公司规则的遵守的而在内部所设立机制。此类机制应当包括数据保护核查以及能够确保采取矫正性活动保护数据主体权利的方法。此类核实结果应当告知（h）点所规定的个人或实体，企业集团或进行联合经济活动的一系列经济主体，而且在有权监管机构的要求下应当能够提供其核实结果；<br>(k)报告和记录规则变化的机制，以及将此类变化报告给监管机构的机制；<br>(l)为了保证企业集团或进行联合经济活动的一系列经济主体的合规性而和监管机构一起设立的合作机制，特别是向监管机构提供（j）点所规定的方法的核查结果；<br>(m)企业集团或进行联合经济活动的一系列经济主体的成员是第三国的主体，可能会对约束性企业规则所提供的保障产生实质性的负面影响，向有权监管机构报告对此类主体是否有法律要求的机制；以及<br>(n)对于可永久性或经常性访问个人数据的员工进行的适当数据保护培训。<br>3．欧盟委员会可以明确控制者、处理者和监管机构之间为了本条含义内的约束性公司规则而进行信息交换的形式和程序。此类实施性法案的制定应当遵循第93（2）条所规定的验证程序。<br><strong>第48条 未经欧盟法授权的转移或披露</strong><br>任何法庭判决、仲裁裁决或第三国行政机构的决定，若要求控制者或处理者对个人数据进行转移或披露，同时满足以下条件时方能得到认可或执行：一是该判决、裁决或决定必须基于提出请求的第三国与欧盟或其成员国之间订立的法律互助协议等国际条约，二是该判决、裁决或决定不会对本章规定的其他转移形式产生消极影响。<br><strong>第49条 特殊情形下的克减</strong><br>1．如果不存在根据第45（3）而做出的充足保护认定或根据第46条而制定的适当安全措施——包括约束性公司规则，将个人数据转移到第三国或国际机构，只有满足如下情形之一才能进行：<br>(a)数据主体被明确告知，不存在充足保护或适当的安全措施，预期的数据转移存在风险，但之后数据主体仍然明确表示同意预期的数据转移；<br>(b)转移对于履行数据主体与控制者之间的合同，或者履行数据主体在签订契约前所提出要求是必要的；<br>(c)控制者和另一自然人或法人之间签订或履行合同时，转移对于实现数据主体的利益是必要的；<br>(d)转移对于实现公共利益是必要的；<br>(e)转移对于确立、行使或辩护法律性主张是必要的；<br>(f)当数据主体基于身体性或法律性原因无法表达同意，为了保护数据主体或其他人的关键利益是必要的；<br>(g)转移是根据登记册而进行的——这种登记册是欧盟法或成员国法律为了向具有正当利益的一般性公众或个人提供咨询。但是，只有满足欧盟法或成员国法对咨询所规定必要条件，此类个案中的转移才能进行克减。<br>当转移无法基于第45或第46条，包括基于约束性公司规则的条款的规定而进行，且从（a）点到（g）的克减条件都不符合，将数据转移到第三国或国际组织，这只有在转移满足如下条件时才可以：转移是非重复性的；关乎很小一部分数据主体的权利；对于实现控制者压倒性的正当利益是必要的，并且不会违反数据主体的有限性的利益或权利与自由；控制者已经对围绕数据传输的情形进行评估，而且基于这种评估对个人数据保护采取了合适的安全保障。控制者除了提供第13条和第14条所规定的信息之外，应当将转移和追求的压倒性正当利益告知数据主体。<br>2．符合第1段（g）点的转移不应当包括登记册里的全部个人数据或所有类型的个人数据。当登记册是为了给具有正当利益的人提供咨询的，只有那些人提出要求，或者那些人是接收者的情形才能进行转移。<br>3．对于公共机构在行使其公共权力时的活动，第1段的（a）（b）（c）点以及第1段的第二分段不适用。<br>4．第1段（d）点规定的公共利益应当为欧盟或成员国为控制者所制定的法律所确认。<br>5．如果不存在充足保护的认定，欧盟或成员国的法律可以基于公共利益而明确做出限制，限制将个人数据转移到第三国或国际组织的特定类型。成员国应当将此类条款告知欧盟委员会。<br>6．控制者或处理者应当在第30条规定的档案中记录本条第1段第二分段所规定的评估以及合适的安全措施。<br><strong>第50条 为保护个人数据的国际合作</strong><br>在涉及到第三国或国际组织的情形中，欧盟委员会和监管机构应当采取合适的措施以：<br>(a)发展国际合作机制，以便促进对个人数据保护立法的有效实施；<br>(b)在采取合适安全措施保障个人数据保护和其它基本权利与自由的前提下，通过告知、申诉转介、调查帮助和信息互换为个人数据保护立法的实施提供国际性互助；<br>(c)在实施个人数据保护立法中，使相关利益方密切参与为了进一步国际合作而进行的讨论和活动；<br>(d)促进个人数据立法与实践——包括与第三国管辖权冲突——的交换与记录。<br><strong>第六章 独立监管机构</strong><br><strong>第一部分 独立性地位</strong><br><strong>第51条 监管机构</strong><br>1．为了保护自然人在处理过程中的基本权利与自由，以及促进欧盟内部的个人数据的自由流通，每个成员国应当建立一个或多个独立公共机构，负责监控本条例的实施。<br>2．每个监管机构都应当帮助本条例在欧盟的一致性适用。基于这种目的，监管机构应当按照第七章的规定彼此合作以及和欧盟委员会合作。<br>3．当一个成员国确立了不止一个监管机构，该成员国应当在欧盟数据保护委员会委任一个监管机构代表其他机构，而且应当建立一套机制，保证其他机构遵守第63条规定的一致性机制相关的规则。<br>4．每个成员国都应当将其根据本章所制定的法律条款告知欧盟委员会，[最迟应当在本条例生效的两年内]，而且应当及时将影响条款的修订告知欧盟委员会。<br><strong>第52条 独立性</strong><br>1．每个监管机构在行使其任务和行使符合本条例的权力时，应当保持完全的独立性。<br>2．每个监管机构的一个或多个成员在行使其任务和行使符合本条例的权力时，应当不受外部影响，不论是直接的还是间接性的，而且不应接收任何人的指示。<br>3．监管机构的成员不得从事违反其监管职责的活动，任职期间不得担任任何与其监管工作相冲突的有偿或无偿的职务。<br>4．每个成员国都必须确保，每个监管机构都具有为了有效履行其任务和行使其权利——包括在欧盟数据保护委员会中互助、合作和参与的履行任务和行使权利——所必需的人力性、技术性与资金资源，前提性与基础性要素。<br>5．每个成员国都应当确保，每个监管机构都具有选择和雇佣其成员的权力，这只受相关监管机构的一个或多个成员的专门指令的约束。<br>6．每个成员国都必须确保，在不影响其独立性以及其具有单独和公共性的年度预算的前提下，每个监管机构都受资金控制——此类资金控制可能是州预算或国家预算一部分的——的约束。<br><strong>第53条 监管机构成员的一般性要求</strong><br>1．成员国应当通过如下机构以透明化的方式委任其监管机构的每个成员：<br>-它们的议会；<br>-它们的政府；<br>-它们的国家元首；或者<br>-成员国法律指派的独立性实体。<br>2．每个成员都应当具有履行其职责和行使其权力所应当具有的资质、经验与技巧，特别是在个人数据保护领域的资质、经验与技巧。<br>3．成员根据成员国的相关法律结束其任期、辞职或强制性退休时，其职责也相应结束。<br>4．只有存在严重的不当行为，或者不再符合履行其职责的条件时，成员才可以被解职。<br><strong>第54条 设立监管机构的规则</strong><br>1．每个成员国都应当通过法律规定如下事项：<br>(a)每个监管机构的设立；<br>(b)被任命为每个监管机构的成员所需要的资质与合适的条件；<br>(c)任命每个监管机构的一个或多个成员的规则和程序；<br>(d)每个监管机构的一个或多个成员的不少于四年的任期，（在此条例生效之后的第一次任命例外），如果有必要通过间断性的任命程序来保护监管机构的独立性，一部分成员的任期可以更短；<br>(e)每个监管机构的一个或多个成员是否可以连任，如果可以的话，可以连任多少个任期；<br>(f)每个监管机构的成员和员工需要负责的情形，对于其任期内或任期结束后的具有冲突性的行为、任职和收益的禁止条款，以及中止雇佣的规则。<br>2．每个监管机构的成员和员工都应当遵循欧盟或成员国的法律，对于其履行任务或行使其权力期间所获取的秘密信息，在任职期间或任期结束后都具有保守职业秘密的职责。尤其在自然人报告具有违反本条例的情形下，成员或员工应当履行其保守职业秘密的职责。<br><strong>第二部分 职权、任务与权力</strong><br><strong>第55条 职权</strong><br>1．每个监管机构都有权在其所属的成员国境内根据本条例履行分配给其的任务，行使授予其的权力。<br>2．当公共机构或私人实体基于第6（1）条的（c）或（e）点而进行处理，成员国的相关监管机构应当拥有职权。在此类情形中，第56条不适用。<br>3．对于法庭在其司法活动中进行处理操作，监管机构不具有监管职权。<br><strong>第56条 领导性监管机构的职权</strong><br>1．在不影响第55条的前提下，控制者或处理者的主要营业机构或唯一营业机构所在地的监管机构应可以充当领导性监管机构，监管控制者或处理者根据第60条程序而进行的跨境处理。<br>2．第1段的规定可以进行减免，如果主要事项只和成员国内的一个机构相关，或者只在一个成员国内对数据主体产生实质性影响，每个监管机构应当都有权对向其进行的申诉或违反本条例的行为进行处置。<br>3．对于第2段所规定的情形，监管机构应当将此事项及时告知领导性监管机构。在被告知的三个星期以内，领导性的监管机构应当——结合控制者或处理者是否在通知其的监管机构所在的成员国内有拥有机构——决定，其是否要根据第60条的规定的程序而处置该案例。<br>4．当领导性监管机构决定处理案件，第60条所规定的程序应当适用。那个告知领导性监管机构的监管机构可以向领导性监管机构提交一份决定草案。当领导性监管机构起草第60（3）条所规定的决定时，其应当尽最大限度地考虑提交的决定草案。<br>5．当领导性监管机构决定不处置案子，通知领导性监管机构的监管机构应当根据第61条和第62条进行处置。<br>6．对于控制者或处理者所进行的跨境处理，领导性监管机构应当是该控制者或处理者的唯一面谈者。<br><strong>第57条 任务</strong><br>1．在不影响本条例规定的其他任务的前提下，在其管辖范围内，每个监管机构应当：<br>(a)监控和执行对本条例的实施；<br>(b)提高公众意识，对和处理相关的风险、规则、安全保障和权利的理解。对针对儿童的活动保持特别注意；<br>(c)根据成员国的法律、全国性议会、政府以及其他制度和实体对与处理相关的自然人的权利与自由提供建议；<br>(d)提高控制者与处理者对本条例所规定责任的意识；<br>(e) 基于要求为所有数据主体提供行使本条例所规定的权利，以及——如果适用的话——和其它成员国的监管机构为了实现这一目的而进行合作；<br>(f)处置数据主体或实体、组织或协会根据第80条的申诉，采用合适的手段调查申诉的主要事项，在合理期限内向申诉者告知进展和调查结论——特别是如果需要进一步的调查或和监管机构协调；<br>(g)为保证对本条例适用与执行的一致性和其他监管机构合作，包括分享信息和提供相互协助；<br>(h)为本条例的适用进行调查，包括基于另一监管机构或其它公共机构提供的信息而进行的调查；<br>(i)在相关发展——特别是信息和通讯技术、商业实践发展——对个人数据保护产生影响的情况下，对相关发展进行监控；<br>(j)采用第28（8）条和第46（2）条（d）点规定的标准格式合同；<br>(k)建立并维持和第35（4）条规定的个人数据保护影响评估相关的条目；<br>(l)对第36（2）条规定的处理操作给出建议；<br>(m)鼓励起草符合第40条的行为准则，对符合第40（5）条提供充分安全保障的此类行为准则提供意见并进行批准；<br>(n)鼓励设立数据保护认证机制以及符合第42（1）条的数据保护印章与标记，并批准符合第42（5）条的认证标准；<br>(o)在适用的情形下，对根据第42（7）条而颁发的认证进行阶段性审查；<br>(p)对符合第41条规定的监控行为准则的委派实体，以及符合第43条规定的认证实体，对其标准进行起草并发布；<br>(q)委任符合第41条规定的监控行为准则的实体，以及符合第43条规定的认证实体；<br>(r)授权合同条款与第46（3）条规定的条款；<br>(s)批准符合第47条的约束性合同规则；<br>(t)欧盟数据保护委员会的活动提供帮助；<br>(u)对违反本条例的情形以及根据第58（2）条而采取的措施保持内部纪录；并且<br>(v)完成和个人数据保护相关的其它任务。<br>2．每个监管机构都应当为第1段（f）点规定的提交申诉提供便利，例如在不排除其它通讯方式的前提下，提供可以通过电子方式填写和提交的申诉方式。<br>3．每个监管机构的任务履行对于数据主体都应当是免费的，如果适用的话，对于数据保护官也应当是免费的。<br>4．当请求是明显毫无根据的或过分的，特别是当请求是重复性的，监管可以基于行政花费而收取一定的合理费用，或拒绝对请求作出行动。监管机构有责任证明，请求是明显毫无根据的或过分的。<br><strong>第58条 权力</strong><br>1．每个监管机构都具有所有如下调查权力：<br>(a)要求控制者和处理者，以及——在适合的情形下——控制者或处理者的代表提供履行其任务所需要的所有信息；<br>(b)以数据保护核查的方式进行调查；<br>(c)对根据第42（7）所颁布的认证进行审查；<br>(d)将可能侵犯本条例的情况告知控制者或处理者；<br>(e)从控制者或处理者那里获取访问个人数据的权力，以及为了行使其任务而所需的所有信息；<br>(f)按照欧盟与成员国法律的程序法，获取对控制者和处理者的所有房屋建筑及场地，包括数据处理设施和方法的访问权。<br>2．每个监管机构都有所有如下矫正性权力：<br>(a)对控制者或处理者颁发警告，警告预期的处理操作可能会侵犯本条例的条款；<br>(b)当处理操作侵犯本条例条款的时候，对控制者或处理者进行申诫；<br>(c)命令控制者或处理者尊重数据主体行使符合本条例的权利；<br>(d)命令控制者或处理者的处理操作符合本条例条款，如果适合的话，应当在特定的期限内以特定的方式完成；<br>(e)命令控制者将个人数据泄露的情况告知数据主体；<br>(f)对处理施加暂时性或具有明确期限的禁令；<br>(g)要求对个人数据进行纠正或擦除，或根据第16条，17条和18条而对处理进行限制，以及将此类行动告知第17（2）条和第19条规定的个人数据披露给的接收者；<br>(h)撤回认证，或命令认证机构撤回根据第42条和第43条而颁发的认证，或者当认证的要求不满足或不再满足时，命令认证机构不要颁发认证；<br>(i)视每个案例的情形不同，在本段所规定的措施之外，或者替代本段所规定的措施而采取第83条规定的行政处罚；<br>(j)要求中止将数据传输到第三国或国际组织。<br>3．每个监管机构都有所有如下授权和建议的权力：<br>(a)根据第36条规定的提前咨询条款向控制者提出建议；<br>(b)主动或根据要求为全国性议会、成员国政府提供意见，或者根据成员国法为其他机构、实体与公众提供和个人数据保护相关的保护；<br>(c)如果成员国的法律要求此类提前咨询，根据第36（5）条而授权处理；<br>(d)根据第40（5）条而发布意见以及行为准则；<br>(e)根据第43条而委任认证机构；<br>(f)根据第42（5）条颁发认证和批准认证的标准；<br>(g)制定第28（8）条以及第46（2）条（d）点规定的数据保护标准条款；<br>(h)授权第46（3）条（a）点规定的合同条款；<br>(i)授权第46（3）条（b）点规定的行政性安排；<br>(j)批准符合第47条的约束性公司规则。<br>4．根据本条而行使赋予给监管机构的权力应当满足合适的安全保障，包括根据欧盟宪章而在欧盟和成员国法律中规定的有效司法救济和正当程序。<br>5．每个成员国应当通过法律规定，其监管机构为了执行本条例的条款，有权将违反本条例的情形诉诸司法机构，在合适的情形下可以提起或参与法律诉讼。<br>6．每个成员国都应当通过法律规定，其监管机构具有第1、2和3段规定的附加权力。对那些权利的行使不应当削弱第七章规定的有效运行。<br><strong>第59条 活动报告</strong><br>每个监管机构都应当起草一份关于其活动的年度报告，这可以包括其被告知的违法类型以及根据第58（2）条而采取的措施类型。此类报告应当传输给全国性议会、政府以及成员国法律所委任的其他机构。公众、欧盟委员会和欧盟数据保护委员会应当能够获取这些报告。<br><strong>第七章 合作与一致性</strong><br><strong>第一部分 合作</strong><br><strong>第60条 领导性监管机构和其他相关监管机构的合作</strong><br>1．领导性监管机构应当根据本条和其他相关监管机构进行合作，努力达成共识。领导性监管机构和相关监管机构应当彼此分享相关信息。<br>2．领导性监管机构可以随时要求其他相关监管机构提供第61条规定的互助合作，而且可以根据第62条而进行联合行动，这尤其适用于如下情形：为了进行调查，或者为了实施涉及到设立在另一成员国的控制者或处理者的措施。<br>3．领导性监管机构应当及时将事项相关信息告知给其他相关监管机构。对于其他相关监管机构的意见，其应当充分考虑，并及时向其他相关监管机构提交一份决定草案。<br>4．当其他任何相关监管机构收到第3段中所规定的咨询，并在四周内表达了对决定草案的相关与合理的反对，领导性监管机构如果不同意此相关与合理的反对，或者认为其意见是不相关或不合理的，应当将此事项提交给第63条规定的一致性机制。<br>5．如果领导性的监管机构同意相关与合理的反对意见，对于此反对意见，其应当将一份修订后的草案决定提交给其他监管机构。修订后的草案决定应当遵守第4段所规定的程序，并且应当在两个星期内做出。<br>6．如果在第4段和第5段所规定的期间内，其他相关监管机构都没有反对领导性监管机构所提交的决定草案，应当推定领导性的监管机构和相关监管机构对于决定草案具有一致意见，而且应当受其约束。<br>7．领导性监管机构应当做出决定，将决定的情况——包括相关事实和理由的总结——通知给控制者或处理者的主要营业机构或唯一营业机构，并视情况通过其他相关监管机构以及做出该决定的欧盟数据保护委员会。收到申诉的监管机构应当将决定的情况告知给申诉者。<br>8．在申诉被撤销或驳回的情形中，第7段的规定可以进行克减，收到申诉的监管机构应当采用决定并将其告知申诉者，由此也告知了控制者。<br>9．当领导性监管机构和相关监管机构同意撤销或驳回申诉的一部分，对申诉的其他部分采取行动，对于此类其他部分的事项，应当采取单独的决定。领导性监管机构应当采用和控制者行动相关的那部分决定，将其通告给控制者或处理者在成员国境内的主要营业机构或唯一营业机构，由此也告知了申诉者。另一方面，申诉者的监管机构应当采用和撤销或驳回申诉相关的那部分决定，将其告知申诉者，由此也告知了控制者或处理者。<br>10．当收到领导性监管机构根据第7段和第9段而进行的告知后，控制者或处理者应当采取必要措施，保证其在欧盟所有的所有机构的处理活动都符合决定。控制者或处理者应当向领导性监管机构告知为遵守决定而采取的措施，并通知其他相关监管机构。<br>11．在极端情形下，当某相关监管机构认为，有充分理由证明需要采取紧急行动以保护数据主体的利益，应当援引第66条有关紧急程序的规定。<br>12．领导性监管机构和其他相关监管机构应当通过电子方式，以标准化的格式为彼此提供本条所要求提供的信息。<br><strong>第61条 互相协助</strong><br>1．监管机构应当为彼此提供信息和互相协助，以便以一种一致性的方式执行和适用本条例，而且应当拥有有效信息以进行有效的相互合作。互相协助尤其应当包括信息请求和监管措施，例如在授权与咨询、检验与调查之前请求信息和采取监管措施。<br>2．对于另一监管机构的请求，每个监管机构都应当采取恰当的合适措施及时回应，而且至迟应当在收到请求内的一个月内进行。此类措施尤其可以包括传输和调查相关的信息。<br>3．请求协助应当包括所有必要信息，包括请求的目的与原因。被交换的信息只能被用于实现请求协助的目的。<br>4．除非存在如下情形，被请求的监管机构不应当拒绝请求：<br>(a)被请求的监管机构对被请求的主体事项或被请求执行的措施没有职权；或者<br>(b)被请求的监管机构对请求进行照办，这会侵犯本条例或欧盟或成员国的为被请求的监管机构所制定的法律。<br>5．被请求的监管机构应将结果告知发出请求的监管机构，而且应当视情况告知为了实现请求而采取的措施。被请求的监管机构如果拒绝按第4段而提出的请求，应当提供说明。<br>6．基于其他监管机构的请求，被请求的监管机构应当以电子形式，使用标准化的格式提供信息，这应当成为一项规则。<br>7．所有被请求的监管机构根据请求而进行的互相协作，都不应当收取费用。对于特定情形下因为提供互相协作而产生的特定花费，监管机构之间可以签订补偿规则。<br>8．当某监管机构在收到另一监管的请求后一个月内仍然不提供第5段所规定的信息，做出请求的监管机构可以根据第55（1）条在其成员国境内采取临时性措施。在这种情形中，可以推定为符合第66（1）条的紧急情况，欧盟数据保护委员会应根据第66（1）条而作出紧急约束性决定。<br>9．欧盟数据保护委员会可以通过制定实施性法案而细化本条规定的互相协助的形式与程序，在监管机构之间、监管机构和欧盟委员会之间以电子方式进行的信息交换，特别是本条第6段所规定的标准化格式。此类实施性法案的制定应当遵循第93（2）条规定的验证程序。<br><strong>第62条 监管机构的联合行动</strong><br>1．在合适的时候，监管机构应当进行联合行动，包括在涉及到其他成员国监管机构的成员或员工的情形下进行联合调查和采取联合执行措施。<br>2．当控制者或处理者在多个成员国设立机构，或者当两国或两国以上的数据主体可能会受处理操作的实质性影响，这些成员国的监管机构都有权参与联合行动。按照第56（1）或56（4）条规定而拥有职权的监管机构可以邀请这些成员国中的每个国家的监管机构参与联合行动，而且应当及时回应某监管机构的参与请求。<br>3．一个监管机构可以按照成员国的法律，以及临时调派的监管机构的授权，将调查权等权力授权给临时调查的监管机构的成员或员工。或者，如果监管机构的成员国的法律允许，应当允许临时调派的监管机构的成员或员工行使其符合成员国法律对其做出规定的调查权。只有在东道主监管机构的成员或员工的指导和见证之下，此类权力才能被行使。临时调派的监管机构的成员或员工应当遵守东道主监管机构所在的成员国国家的法律。<br>4．当根据第一段的规定临时调派的监管机构在另一成员国内活动，东道主监管机构所在的成员国应当对其行动承担责任，包括对活动期间所引起的损害，应当按照其活动地所属的成员国法律承担责任。<br>5．对于成员国境内所造成的损害，如果其可以适用其成员国的损害赔偿，成员国应当进行赔偿。临时调派的监管机构的某成员国的员工对另一成员国境内的人造成伤害，在另一成员国对个人进行补偿后，某成员国应当对另一成员国进行补偿。<br>6．除了第5段所规定的情形，在不影响行使相对于第三人权利的前提下，若出现第1段规定的情形，各成员国不得就第4段的损害向相关成员国提出损害赔偿的要求。<br>7．当存在联合行动的计划，而且当监管机构拒绝遵守本条第2段第二句所设定的责任，其他监管机构可以根据第55条在其境内采取临时性措施。在这种情形中，可以推定为符合第66（1）条的紧急情况，欧盟数据保护委员会应根据第66（2）条而作出紧急约束性决定。<br><strong>第二部分 一致性</strong><br><strong>第63条 一致性机制</strong><br>为了帮助本条例在欧盟的一致性适用，监管机构应当相互合作，以及在相关的情形下通过本部分规定的一致性机制而和欧盟委员会进行合作。<br><strong>第64条 欧盟数据保护委员会的意见</strong><br>1．当某个有权监管机构计划采取如下任何一项措施，欧盟数据保护委员会应当发布意见。为此，有权监管机构应当将决定草案告知欧盟数据保护委员会，如果：<br>(a)决定草案的目标是采取一系列符合第35（4）条所规定的数据保护影响评估要求的处理操作；<br>(b)决定草案涉及到第40（7）条规定的行为准则草案，或行为准则草案的修订案或延期是否符合本条例；<br>(c)决定草案的目标是批准符合第41（3）条规定的委派实体，以及符合第43（3）条规定的认证实体的标准；<br>(d)决定草案的目标是确定第46（2）条（d）点和第28（8）条规定的标准数据保护条款；<br>(e)决定草案的目标是批准第46（3）条（a）点规定的合同条款；或者<br>(f)决定草案的目标是批准第47条所指的有效性公司规则。<br>2．任何监管机构、欧盟数据保护委员会或欧盟委员会的主席都可以提出要求，为了给出意见——特别是当有权监管机构不遵守第61条规定的相互协助的责任或第62条规定的联合行动时——可以对任何关乎一般性使用的事项，或在不止一个成员国产生影响的事项进行核查。<br>3．对于第1段和第2段提到的情形，欧盟数据保护委员会如果此前没有对类似事项发表过意见，应当对提交给它的事项发布一份意见。这份意见应当在八周内根据欧盟数据保护委员会成员的简单多数来决定。考虑到主要事项的复杂性，八周的期限可以再延长六周。关于第1段规定的按照第5段而在欧盟数据保护委员会中流通的决议草案，如果某成员在欧盟数据保护委员会主席所表明的合理期限内不提出异议，就应当视为同意决议草案。<br>4．监管机构和欧盟数据保护委员会应当及时以电子化手段，使用标准化的格式将任何相关信息进行沟通。此类信息可以是事实的总结、决议草案、采取此类必要措施的理由，以及其他相关机构的观点。<br>5．欧盟数据保护委员会的主席应当及时通过电子手段：<br>(a)通过标准化格式将任何已经获知的相关信息告知欧盟数据保护委员会和欧盟委员会的成员。如有需要，欧盟数据保护委员会的秘书应当提供相关信息的翻译；并且<br>(b)将意见告知第1段和第2段规定的监管机构和欧盟委员会，并公开意见。<br>6．在第3段规定的期间内，有权监管机构不应当采用第1段所规定的决议草案。<br>7．第1段中所规定的监管机构应当最大限度地考虑欧盟数据保护委员会的意见，而且应在收到意见的两周内以电子方式告知欧盟数据保护委员会的主席，其是否会维持或修改其决议草案，以及修改后的决议草案——如果有的话。<br>8．当相关监管机构在本条第7段规定的期限内通知委员会主席，其并无意遵守委员会的所有意见或意见的一部分，并且提供了相关理由，此种情形下第65（1）条应当适用。<br><strong>第65条 欧盟数据保护委员会的纠纷解决</strong><br>1．为了确保在个案中对本条例的正确与融贯适用，欧盟数据保护委员会应当在如下情形中做出有约束力的决定：<br>(a)在第60（4）条规定的情形中，相关监管机构对领导性机构的草案决定提出了相关与合理的反对，或者领导性机构驳回了反对，认为其不相关或不合理。约束性决定应当涉及相关与合理反对所涉及的所有事项，特别是当其存在违反本条例的情形；<br>(b)对于哪个监管机构有权管辖主要营业机构存在不同意见；<br>(c)在第64（1）条规定的情形中，有权监管机构并不请求获得欧盟数据保护委员会的意见，或者并不遵守欧盟数据保护委员会按照第64条发布的意见。在这种情形下，任何相关监管机构或欧盟数据保护委员会都可以将此事项告知欧盟数据保护委员会。<br>2．三分之二多数的欧盟数据保护委员会成员在将主体事项转交后，应当在1个月以内做出第1段所规定的决定。考虑到主体事项的复杂性，这个期间可以再延长一个月。第1段所规定的决定应当是合理的，应当告知领导性监管机构和所有相关监管机构，并且对它们具有约束力。<br>3．当欧盟数据保护委员会无法在第2段所规定的期限内做出决定，其应当以欧盟数据保护委员会成员简单多数的方式在第2段所规定的第二个月的期限结束后的两星期内做出决定。如果欧盟数据保护委员会成员的投票刚好完全分裂，那么决定将根据主席的投票而做出。<br>4．在第2段和第3段所规定的期限内，相关监管机构不应当对根据第1段而提交给欧盟数据保护委员会的主体事项做出决定。<br>5．欧盟数据保护委员会的主席应当及时将第1段所规定的决定告知相关监管机构。这也就告知了欧盟委员会。在监管机构告知第6段规定的最终决定后，决定应当在欧盟数据保护委员会的网站上及时发表。<br>6．领导性监管机构或者收到申诉的监管机构应当根据本条第1段所规定的决定性基础及时做出最终决定，至迟应当在欧盟数据保护委员会告知其决定后的一个月以内做出。领导性的监管机构或收到申诉的监管机构应当向欧盟数据保护委员会报告其将该决定告知控制者或处理者以及数据主体的时间。相关监管机构的最终决定应当根据第60（7）（8）（9）条的条款而做出。最终决定应当涉及本条第1段所规定的决定，而且应当具体说明，本条第1段所规定的决定将会根据本条第5段而在欧盟数据保护委员会的网站上发表。最终决定应当附上本条第1段所规定的决定。<br><strong>第66条 紧急程序</strong><br>1．在例外情形中，当相关监管机构认为有必要对保护数据主体的权利与自由采取紧急行动，其可以通过第63、64和65条规定的一致性机制或第60条规定的程序来进行克减，立即采取在其境内一段时间内——不超过3个月——具有法律效力的临时性措施。监管机构应当及时将采取这些措施的手段与原因告知其他相关监管机构、欧盟数据保护委员会与欧盟委员会。<br>2．当监管机构采取符合第1段的措施，以及考虑亟需采用的最终措施，其可以请求欧盟数据保护委员会出具一份紧急意见或紧急约束性决定，并说明提出此请求的原因。<br>3．如果有必要对保护数据主体的权利与自由采取紧急行动，而有权监管机构却没有采取合适措施，任何监管机构都可以向欧盟数据保护委员会请求一份紧急意见或紧急约束性决定，说明提出此请求的原因，包括需要采取紧急行动的原因。<br>4．对于第64（3）条和第65（2）条规定的的克减，欧盟数据保护委员会成员的简单多数应当在两个星期内做出本条第2段和第3段规定的紧急意见或紧急约束性决定。<br><strong>第67条 信息交换</strong><br>对于监管机构之间、监管机构与欧盟数据保护委员会之间以电子方式进行的信息交换，特别是对于第64条规定的标准化格式，欧盟委员会可以进一步制定细化的实施性法案。<br>这些实施性法案应当根据第93（2）条规定的验证程序制定。<br><strong>第三部分 欧盟数据保护委员会</strong><br><strong>第68条 欧盟数据保护委员会</strong><br>1．欧盟数据保护委员会特此被设立为欧盟的一个机构，而且将具有法人身份。<br>2．欧盟数据保护委员会的代表是其主席。<br>3．欧盟数据保护委员会应当包括每个成员国的每个监管机构的首长、欧盟数据保护监管者的首长，或者他们的代表。<br>4．当一个成员国内不止一个监管机构负责监控对本条例条款的适用，应当按照成员国的法律任命一个联合代表。<br>5．欧盟委员会应当有权参与欧盟数据保护委员会的活动与会议，但没有投票权。欧盟委员会应当委任一名代表。欧盟数据保护委员会的主席应当将其活动告知欧盟委员会。<br>6．对于第65条规定的情形，只有当决议涉及到适用于和本条例规定有实质性对应的欧盟机构、实体、办公室、规制机构的原则和规则时，欧盟数据保护监管者才具有投票权。<br><strong>第69条 独立性</strong><br>1．当根据第70条和第71条履行其任务或行使其权力时，欧盟数据保护委员会应当保持其独立性。<br>2．在不影响第70（1）条（b）点和第70（2）条所规定的欧盟委员会的请求的前提下，欧盟数据保护委员会在履行其任务或行使其权力时，应当避免从任何人那里获取指示。<br><strong>第70条 欧盟数据保护委员会的任务</strong><br>1．欧盟数据保护委员会应当确保对本条例的一致性适用。为了实现这一目的，在相关情形中，欧盟数据保护委员应当主动或根据欧盟委员会的请求而采取如下行动：<br>(a)在不影响全国性监管机构的任务的前提下，确保在第64条和65条所规定的情形中正确适用本条例；<br>(b)对欧盟数据保护相关的所有事项，包括对本条例的修改动议，向欧盟委员会提供建议；<br>(c)对为制定约束性公司规则而在控制者、处理者和监管机构之间进行的信息交换的格式与程序向欧盟委员会提供建议；<br>(d)从第17（2）条规定的公众可以获取的通讯服务中擦除个人信息的链接、备份或复制品，对这种活动的程序发布指导方针、建议和最佳操作；<br>(e)主动或根据其成员的请求，或根据欧盟委员会的请求核查涉及本条例适用的任何问题，为了鼓励对本条例的适用，发布指导方针、建议和最佳操作；<br>(f)为了进一步细化第22（2）条规定的基于用户画像的决策的标准和条件，发布符合本段（e）点的指导方针、建议和最佳操作；<br>(g)为了认定个人数据泄露，确定是否存在第33（1）、（2）条所规定的无理拖延，以及控制者或处理者是否需要告知个人数据泄露，发布符合本段（e）点的指导方针、建议和最佳操作；<br>(h)对于个人数据违法可能会对第34（1）条规定的自然人的权利与自由带来高风险的情形，发布符合本段（e）点的纲领、建议和最佳操作；<br>(i)对于符合控制者所遵守的约束性公司规则、处理者所遵守的约束性公司规则的数据转移，以及符合为了保证第47条规定的对数据主体的个人数据保障而采取的必要措施的个人数据转移，为了细化此类转移的标准和要求，发布符合本段（e）点的指导方针、建议和最佳操作；<br>(j)为了进一步细化第49（1）条规定的个人数据转移所需要的标准和要求，发布符合本段（e）点的指导方针、建议和最佳操作；<br>(k)对于涉及第58（1）、（2）、（3）条规定的适用措施和确定第83条规定的行政处罚，为监管机构起草指导方针；<br>(l)对本段（e）点和（f）点规定的指导方针、建议和最佳操作的实际运用进行审查；<br>(m)对自然人设报告侵犯本条例的行为，为其设立符合第54（2）条的一般程序，，发布符合本段（e）点的指导方针、建议和最佳操作；<br>(n)鼓励起草行为准则，设立符合第40条和第42条的数据保护认证机制、数据保护印章和标记；<br>(o)对认证机构进行委任，根据第43条而进行阶段性审查，对符合第43（6）条的委任机构、符合第42（7）条而在第三国设立的被认证的控制者或处理者进行持续性的公共登记；<br>(p)为了委任第42条规定的认证机构而细化第43（3）条规定的要求；<br>(q)向欧盟委员会提供关于第43（8）条规定的验证要求的意见；<br>(r)向欧盟委员会提供关于第12（7）条规定的图标的意见；<br>(s)评估第三国或国际组织的保护程度，包括评估第三国、某个地区、或该第三国的一个或多个特定部门，或国际组织是否仍然提供足够程度的保护。为了实现这一目的，欧盟委员会应当向欧盟数据保护委员会提供所有必要的记录，包括和该第三国政府的进行的涉及到第三国、某个地区、或该第三国的一个或多个特定部门，或国际组织的通信。<br>(t)发布按照第64（1）条规定的一致性机制而做出的关于监管机构的决议草案，按第64（2）条提交的事项，以及发布根据第65条，包括第66条规定的约束性决定。<br>(u)促进监管机构之间的合作，有效的双边或多边信息交换，以及最好的实践；<br>(v)促进共同培训项目，协助监管机构之间以及——如果适用的话——监管机构与第三国监管机构或国际组织之间的人员交换；<br>(w)促进与全球数据保护监管机构的知识交流、数据保护立法的记录与实践。<br>(x)发布关于根据第40（9）条在欧盟层面起草的行为准则的意见；以及<br>(y)对于监管机构和法庭做出的决定以及根据一致性机制所处置的事项，保持一份公众可以访问的电子登记。<br>2．当欧盟委员会请求欧盟数据保护委员会提供意见，欧盟委员会可以在考虑事项的紧急程度后表明期限要求。<br>3．欧盟数据保护委员会应当将其意见、指导纲领、推荐以及最佳操作告知欧盟委员会和第93条规定的理事会，而且应当将它们公开。<br>4．如果适用的话，欧盟数据保护委员会应当咨询当事人，給与他们在一段合理期限内进行评论的机会。在不影响第76条的前提下，欧盟数据保护委员会应当将咨询程序的结果公之于众。<br><strong>第71条 报告</strong><br>1．对于欧盟内部、相关第三国以及国际组织中的数据处理活动，若涉及自然人的保护，欧盟数据保护委员会应当起草年度报告。报告应当公开，而且应当传输给欧洲议会、欧盟理事会和欧盟委员会。<br>2．年度报告应当包括第70（1）条（l）点规定的对指导方针、建议和最佳操作的实际运用进行审查，以及第65条规定的约束性决议。<br><strong>第72条 程序</strong><br>1．欧盟数据保护委员会应当通过其成员的简单多数做出决定，除非本条例有相反规定。<br>2．欧盟数据保护委员会应当以其成员的三分之二多数制定程序规则，组建其自身的操作机制。<br><strong>第73条 主席</strong><br>1．欧盟数据保护委员会应当通过简单多数的方式从其成员中选举一位主席、两位副主席。<br>2．主席以及副主席职位的任期应当是5年，可以连任一届。<br><strong>第74条 主席的任务</strong><br>1．主席具有如下任务：<br>(a)召集欧盟数据保护委员会的会议，准备会议议程；<br>(b)将委员会根据第65条而做出的决定告知第65条规定的领导性监管机构和相关监管机构；<br>(c)保证欧盟数据保护委员会任务的及时履行，特别是和第63规定的一致性机制相关的任务。<br>2．欧盟数据保护委员会应当在其程序规则中对主席与副主席的任务分工进行分配。<br><strong>第75条 秘书</strong><br>1．欧盟数据保护委员会应当有一名秘书，其应当由欧盟数据保护监督者来任命。<br>2．秘书应当严格按照欧盟数据保护委员会主席的指示履行其职责。<br>3．欧盟数据保护监管者的员工，如果涉及履行到本条例赋予给欧盟数据保护委员会的任务，应当与涉及履行赋予给欧盟数据保护监管者的任务的员工遵守不同的报告程序。<br>4．在适用的情况下，欧盟数据保护委员会和欧盟数据保护监管者应当撰写与发布一份实施本条的谅解备忘录，确定它们之间合作的条款，在涉及履行本条例赋予给欧盟数据保护委员会的任务时，谅解备忘录适用于欧盟数据保护监管者的员工。<br>5．秘书应当向欧盟数据保护委员会提供分析、管理与后期支持。<br>6．秘书应当对如下事项负责：<br>(a)欧盟数据保护委员会的日常事务；<br>(b)欧盟数据保护委员会、欧盟数据保护委员会主席与欧盟委员会之间的交流；<br>(c)与其他机构及公众的交流；<br>(d) 内部交流与外部交流中对电子手段的使用；<br>(e)对相关信息的翻译；<br>(f)对欧盟数据保护委员会会议的准备与跟踪；<br>(g)准备、起草与发布欧盟数据保护委员会对监管机构之间分歧的意见与决定，以及其他文本。<br><strong>第76条 机密性</strong><br>1．欧盟数据保护委员会若认为根据程序规则的要求，有必要秘密开展某项讨论活动，那么该讨论活动就应当严格保密。<br>2．访问提交给欧盟数据保护委员会的成员、专家与第三方代表的文件，应当遵守欧洲议会和欧盟理事会的 (EC) No 1049&#x2F;2001条例[1]。<br><strong>第八章 救济、责任与惩罚</strong><br><strong>第77条 向监管机构提起申诉的权利</strong><br>1．在不影响任何其他行政或司法救济的前提下，每个数据主体都有向监管机构进行申诉的权利，这尤其适用于以下地点的监管机构：数据主体所属的成员国或经常居住地、工作地、或数据主体认为处理其个人数据违反本条例的发生地。<br>2．收到申诉的监管机构应当告知申诉者申诉的进展和结果，包括符合第78条的司法救济的可能性。<br><strong>第78条 针对监管机构的有效司法救济权</strong><br>1．在不影响其他任何行政或司法救济的前提下，任何自然人或法人都有权对关乎他们的监管机构的有法律约束力的决定获得有效的司法救济。<br>2．在不影响其他任何行政或司法救济的前提下，如果根据第55条和第56条的有权监管机构不处置申诉，或者在三个月内没有向数据主体告知第77条规定的申诉的进展或结果，任何自然人或法人都有权获得有效的司法救济。<br>3．针对监管机构的法律诉讼应当在监管机构所在的成员国的法庭提起。<br>4．如果针对监管机构决定的法律诉讼发生在欧盟数据保护委员会根据一致性机制而做出意见或决定之前，监管机构应当将其意见或决定告知法院。<br><strong>第79条 针对控制者或处理者的有效司法救济权</strong><br>1．在不影响其他任何行政或司法救济的前提下，包括在不影响第77条规定的向监管机构提交申诉的前提下，任何数据主体认为，由于违反本条例而处理其个人数据，导致其被本条例所赋予的权利被侵犯，在这些情形下其都有获取司法救济的权利。<br>2．针对控制者或处理者的法律诉讼应当在它们拥有机构的成员国的法庭提起。在其他情形下，此类法律诉讼可以在数据主体的经常居住地的法庭提起，除非控制者或处理者是成员国行使其公共权力的公共机构。<br><strong>第80条 对数据主体的代表</strong><br>1．数据主体有权委托非盈利机构、实体或协会代表其行使第77、78、79条规定的权利，以及在成员国法律规定的情形下，代表其行使第82条规定的获得赔偿的权利。非盈利机构、实体或协会应具备如下条件：按照成员国法律设立，其章程目标是实现公共利益，在为了保护数据主体的权利与自由而代表个人提起申诉方面表现积极。<br>2．不论数据主体是否委托，成员国都可以规定，本条第1段所规定的任何机构、组织或协会如果认为本条例所规定的数据主体的权利已经因为处理而受到侵犯，都有权在成员国向第77条规定的有权监管机构提起申诉，行使第78条和第79条规定的权利。<br><strong>第81条 法律诉讼的中止</strong><br>1．当一个成员国的有管辖权的法院获知，另一成员国的法院准备对涉及同一个控制者或处理者处理的同一主要事项进行判决，该法院应当通知另一成员国的法院已经存在此类法律程序。<br>2．当另一成员国法院准备对涉及同一个控制者或处理者处理的同一主要事项进行判决，除了首先接收案件的法院，所有有权审理的法院都可以停止其法律程序。<br>3．在那些诉讼等待初审的情形中，如果首先接收案件的法院对涉及的活动具有管辖权而且其法律允许合并审理，所有除了首先接收案件的法院都可以基于相关一方的申请而拒绝管辖。<br><strong>第82条 获取赔偿的权利与责任</strong><br>1．任何因为违反本条例而受到物质或非物质性伤害的人都有权从控制者或数据者那里获得对损害的赔偿。<br>2．任何涉及到处理的控制者都应当对因为违反本条例的处理而受到的损害承担责任。对于处理者，当其没有遵守本条例明确规定的对处理者的要求，或者当其违反控制者的合法指示时，其应当对处理所造成的损失负责。<br>3．控制者或处理者如果证明自己对引起损失的事件没有任何责任，那么其第2段所规定的责任可以免除。<br>4．当不止一个控制者或处理者，或控制者与处理者同时涉及到同一处理，而且它们对第2段和第3段规定的处理所引起的所有损失承担责任，每个控制者或处理者都应当对损失负有连带责任，以便保证对数据主体的有效赔偿。<br>5．当控制者或处理者已经根据第4段的规定对所受损失进行全额赔偿，该控制者或处理者可以按照第2段所规定的条件，要求另一控制者或处理者返回其造成的那部分损失。<br>6．为了行使其获得赔偿的权利，根据第79（2）条的规定，应当在成员国认可的有管辖权的法院提起诉讼请求。<br><strong>第83条 行政罚款的一般条件</strong><br>1．.每个监管机构都应当保证，其根据本条而对第4、5、6条所规定的违反本条例的行为进行罚款，在每个案件中都应当是有效的、成比例的和劝诫性的。<br>2．根据每个案件的具体情形，行政处罚应当在第58（2）条的（a）至（h）点以及（j）点规定的措施基础上进行追加，或者应当代替这些措施。当在每个具体案件中决定是否应当进行行政处罚，以及决定行政处罚的金额，应当充分考虑如下因素：<br>(a)结合相关处理的性质、范围或目的，被影响的数据主体的数量以及损害程度而确定的违法的性质、严重性与持续时间；<br>(b)违法的性质是基于故意还是过失；<br>(c)控制者或处理者为了减轻数据主体损失而采取的所有行动；<br>(d)结合控制者或处理者采取的符合第25条和第32条的技术性与组织性措施而认定的控制者或处理者的责任程度；<br>(e)控制者或处理者之前的所有相关违法行为；<br>(f)为了纠正违法行为和减轻违法所造成的可能负面影响而和监管机构进行合作的程度；<br>(g)为违法行为所影响的个人数据类型；<br>(h)监管机构得知违法行为的方式，特别是控制者或处理者是否对违法行为进行了报告，以及在何种程度上进行了报告；<br>(i)如果对同一主题事项已经对控制者或处理者发布第58（2）条规定的措施，对这些措施是否遵守；<br>(j)遵守符合第40条的已生效的行为准则或符合第42条的已生效的认证机制；以及<br>(k)对于案件情形可以适用的所有加重或减轻因素，例如因为违法而直接或间接导致的经济收益、避免的损失。<br>3．如果控制者或处理者故意或过失性地因为同一或相关的处理操作而违反本条例的条款，行政罚款的总额不应当超过最严重违法所确定的额度。<br>4．违反如下条款，应当按第2段的规定施加最高10 000 000欧元的行政罚款，如果是企业的话，最高可处相当于其上一年全球总营业额2%的金额的罚款，两者取其高的一项进行罚款：<br>(a)第8，11，25，26，27，28，29，30，31，32，33，34，35，36，37，38，39，42和43条规定的控制者和处理者的责任；<br>(b)第42条和第43条规定的认证机构的责任；<br>(c)第41（4）条规定的监管机构的责任。<br>5．违反如下条款，应当按第2段的规定施加最高20 000 000欧元的行政罚款，如果是企业的话，最高可处相当于其上一年全球总营业额4%的金额的罚款，两者取其高的一项进行罚款：<br>(a)处理的基本原则，包括第5、6、7和9条规定的同意的条件；<br>(b)第12条至22条规定的数据主体的权利；<br>(c)第44条至第49条规定的将个人数据转移到第三国或一个国际组织的接收者；<br>(d)所有第九章规定的符合成员国法律的责任；<br>(e)违反监管机构根据第58（2）条对处理所发布的命令、或暂时性或确定性的限制，或对数据流动的中止，或违反第58（1）条拒绝提供访问。<br>6．违反第58（2）条规定的监管机构发布的命令，应当按第2段的规定施加最高20 000 000欧元的行政罚款，如果是集团的话，可以施加最高前一年全球总营业额4%的罚款，两者取其高的一项进行罚款。<br>7．在不影响符合第58（2）条的监管机构的矫正权力的前提下，每个成员国都可以制定规则，确定在什么情况下对在其境内设立的公共机构和实体进行行政处罚。<br>8．监管机构行使本条所规定的权力，应当采取符合欧盟和成员国法律所规定的合适的程序性保障，包括有效的司法救济和正当程序。<br>9．当成员国的法律体系并不提供行政处罚，本条可以以如下方式适用：可以通过有权监管机构提出行政处罚，然后有职权的全国性法院进行适用，同时，应保证那些法律救济是有效的，而且这些法律救济与监管机构所施加的行政处罚具有同等效力。不论在何种情形中，所施加的处罚必须是有效的、成比例的和劝诫性的。那些成员国应当[在本条例生效两年内]将根据本段所制定的法律条款、所有后续的修正性法律或影响它们的法律修订及时告知欧盟委员会。<br><strong>第84条 惩罚</strong><br>1．成员国应当制定可适用于违反本条例的其他惩罚的规则，特别是对于那些不受第83条规定的行政处罚约束的违法行为，成员国应当制定必要措施保证这些惩罚规则得到执行。此类惩罚应当是有效的、成比例的和劝诫性的。<br>2．对于符合第1段所制定的法律，每个成员国的应当[在本条例生效的两年内]将其法律条款告知欧盟委员会，而且应当及时告知影响条款的后续修订。<br><strong>第九章 和特定处理情形相关的条款</strong><br><strong>第85条 处理、表达自由与信息</strong><br>1．成员国应当通过制定法律调和符合本条例制定的个人数据保护权与表达自由权与信息权，包括调和为了新闻目的和学术、艺术或文学表达目的而进行的处理。<br>2．对于出于新闻目的和学术、艺术或文学表达目的而进行的处理，如果对于调和符合本条例制定的个人数据保护权与表达自由权与信息权有必要，成员国应当对第二章（原则）、第三章（数据主体的权利）、第四章（控制者和处理者）、第五章（个人数据转移到第三国或国际组织）、第六章（独立监管机构）、第七章（合作与一致性）和第九章（特定数据处理的情形）的规定进行豁免或克减。<br>3．每个成员国都应当将其按照第2段所制定的法律条款告知欧盟委员会，而且应当将所有后续的修正性法律或影响它们的法律修订及时告知欧盟委员会。<br><strong>第86条 处理与公众对官方文件的访问</strong><br>为了调和公众对官方文件的访问与本条例规定的个人数据保护权，对于公共机构或公共实体或为了实现公共利益而履行任务的私人实体所拥有的官方文件中的个人数据，机构或实体可以根据成员国为机构或实体而制定的法律而公开。<br><strong>第87条 对全国性身份识别号码的处理</strong><br>成员国可以对处理全国性身份识别号码或其他一般性识别标识的特定情形做出规定。在这种情形下，只有对本条例规定的数据主体的权利与自由采取适当安全保障，才能使用全国性身份识别号码或其他一般性识别标识。<br><strong>第88条 雇佣语境下的处理</strong><br>1．多个成员国可以通过法律或通过协定制定特定规则，以保证在雇佣语境下处理雇员个人数据保证其权利与自由。这在如下情形中尤其适用：为了招聘、履行雇佣合同，包括法律或集体合同规定的免除合同；对工作的管理、计划与组织；工作场所的合理性与多样性；工作中的健康与安全，对员工与顾客财产的保护；为了行使和享受雇佣相关的权利与收益；以及为了终止雇佣关系。<br>2．此类规则应当包括为保障数据主体人身尊严、正当利益与基本权利的合适与特定的措施。这在涉及到如下事项时尤其适用：处理的透明性；在一群企业中转移个人数据；或进行联合经济活动的一群企业和工作场所的监管系统。<br>3．每个成员国应当[在本条例生效的两年内]将其按照第1段所制定的那些法律条款告知欧盟委员会，而且应当及时告知影响条款的后续修订。<br><strong>第89条 为了实现公共利益、科学或历史研究或统计目的处理中的安全保障与克减</strong><br>1．为了实现公共利益、科学或历史研究或统计目而处理，应当采取符合本条例的恰当防护措施，保障数据主体的权利与自由。这些防护措施应当确保，为了保证数据最小化原则，已经采取技术与组织性的措施。这些措施可以包括匿名化，如果匿名化也能实现上诉目的。如果在进一步处理中实现对数据主体无法识别也可以实现上诉目的，那就应当采取这种方式处理。<br>2．对于为了实现公共利益、科学或历史研究或统计目的处理，成员国的法律可以按照本条第1段所规定的情形与防护措施对第15、16、18、21条所规定的权利进行克减——如果此类权利可能彻底阻碍或严重阻碍实现上述目的，而此类克减对于实现上诉目的是必要的。<br>3．当个人数据处理是为了实现公共利益，欧盟或成员国的法律可以按照本条第1段所规定的情形与防护措施对第15、16、18、19、20和21条规定的权利进行克减——如果此类权利可能彻底阻碍或严重阻碍实现上述目的，而此类克减对于实现上诉目的是必要的。<br>4．如果第2段和第3段所规定的处理还有其他目的，克减将只适用于为了实现第2段和第3段中所规定的目的的处理。<br><strong>第90条 保密责任</strong><br>1．成员国可以制定特定的规则，对第58（1）条（3）和（f）点所规定的、和作为主体的控制者或处理者相关的、全国性有权机构所设立的监管机构的权力进行规定，如果有必要对个人数据保护与保守秘密进行调和与比例性保护，此特定规则可以施加职业性秘密保守责任或其他同等责任。只有在那些保守秘密责任所涉及的活动中或因为此类活动而接收个人数据，此类规则才适用于控制者或处理者。<br>2．每个成员国的应当[在本条例生效的两年内] 将其按照第1段所制定的那些法律条款告知欧盟委员会，而且应当及时告知影响条款的后续修订。<br><strong>第91条 现有的的对教会和宗教协会的数据保护规则</strong><br>1．在本条例生效后，对于适用于某成员国境内教会、宗教协会或团体的保护自然人在处理相关中的综合性规则，如果它们和本条例保持一致，仍然应当适用。<br>2．对于那些适用符合第1段的综合性规则的教会和宗教协会，其应当接受一个独立监管机构的监管，如果其满足本条例第六章规定的条件，这种独立监管机构可以是特别指定的。<br><strong>第十章 授权法案与实施性法案</strong><br><strong>第92条 对授权的行使</strong><br>1．欧盟委员会享有授权法案的制定权，此权力受本条所规定的条件所约束。<br>2．第12（8）条和43（8）条所规定的授权应当[在本条例生效后]的一段不确定的时间内赋予给欧盟委员会。<br>3．第12（8）条和43（8）条所规定的授权可以随时被欧洲议会或欧盟理事会撤销。撤销决定应当终止决定所特别指明的授予性权力。撤销决定生效日是欧盟官方杂志发布后的第二天或决定所特别标明的日期。撤销决定不应影响任何已经生效的授权性法案。<br>4．欧盟委员会一旦制定授权性法案，其应当立刻同时告知欧洲议会和欧盟理事会。<br>5．根据第12（8）条和第43（8）条而指定的授权性法案，只有欧洲议会或欧盟理事会在其收到通知后三个月内都没有表达反对，或者在三个月内欧洲议会或欧盟理事会已经告知欧洲委员会它们不会反对，其才能生效。如果欧洲议会或欧盟理事会提出延期，这个期间可以再延长三个月。<br><strong>第93条 委员会程序</strong><br>1．欧盟委员会应当有一个小组对其进行协助。该小组应当是(EU) No 182&#x2F;2011条例所规定的小组。<br>2．涉及到此段时，(EU) No 182&#x2F;2011指令第5条应当适用。<br>3．涉及到此段时，与(EU) No 182&#x2F;2011指令第5条配合的(EU) No 182&#x2F;2011指令第8条应当适用。<br><strong>第十一章 最后条款</strong><br><strong>第94条 95&#x2F;46&#x2F;EC指令的废止</strong><br>1．在[本条例生效后的两年]后95&#x2F;46&#x2F;EC指令将被废止。<br>2．当参照废止指令时，应当通过参照本条例来进行解释。对于参照工作小组在95&#x2F;46&#x2F;EC指令第29条所规定的处理个人数据中个人保护，这应当以参照本条例所规定的欧盟数据保护委员会来进行解释。<br><strong>第95条 与2002&#x2F;58&#x2F;EC的关系</strong><br>在欧盟的公共通讯网络中提供公众可获取的电子通讯服务的情形中，对于2002&#x2F;58&#x2F;EC指令已经施加特殊责任的事项，本条例不应再对同一事项再向自然人或法人施加额外责任。<br><strong>第96条 和之前已经达成的协议的关系</strong><br>对于[在此条例生效]之前的，符合[在此条例生效]之前所制定的法律的，涉及到将个人数据传输到第三国或国际组织的成员国之间已经达成的国际性协议，在其被修改、替代或撤销之前，应当一直具有效力。<br><strong>第97条 委员会报告</strong><br>1．在[本条例生效后的四年后]，以及在这之后的每四年，欧盟委员会应当向欧洲议会和欧盟理事会提交一份对本条例的评价与审查。该报告应当公之于众。<br>2．在第1段所规定的评价与审查情形中，欧盟委员会应当尤其检查如下事项的适用与运作：<br>(a)第五章规定的将个人数据转移到第三国或国际组织，特别是按照本条例第45（3）条而做出的决定，以及根据95&#x2F;46&#x2F;EC第25（6）条而做出的决定；<br>(b)第七章规定的合作与一致性。<br>3．为了实现第1段的目的，欧盟委员会可以要求成员国和监管机构提供相关信息。<br>4．为了进行第1段和第2段规定的评价与审查，欧盟理事会应当考虑欧洲议会、欧盟理事会以及其他相关实体与生产商的立场与调查。<br>5．在必要的情形下，欧盟委员会应当提交修改本条例的合适动议，特别是如果考虑了信息科技的发展以及信息社会中的发展状态。<br><strong>第98条 对欧盟其他数据保护法案的审查</strong><br>如果合适的话，欧盟委员会应当提交立法性动议，以便对欧盟的其他个人数据保护法案进行保护，以便保证在处理中对自然人进行一致与一致性的保护。这尤其应当涉及到欧盟机构、实体、办公室和规制机构处理中和自然人保护相关的规则，以及此类数据的自由流动。<br><strong>第99条 生效与适用</strong><br>1．本条例的生效时间是其在欧盟官方杂志发布后的二十天后。<br>2．其适用时间是[本条例生效后的两年后]。<br>本条例的所有条款都具有约束力，而且应当直接适用于成员国。<br>[1]欧洲议会和欧盟理事会关于公众访问欧洲议会、欧盟理事会与欧盟委员会文件(OJ L 145, 31.5.2001, p. 43)的(EC) No 1049&#x2F;2001条例。</p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/GDPR-zh/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/GDPR-zh/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<p>原文链接：<a href="https://www.tisi.org/5029">欧盟首个数据保护条例GDPR明日生效，你可能需要这份中文版的全文 (tisi.org)</a></p>
<p> 经过欧盟议会长达四年的讨论，欧盟《一般数据保护条例》（General Data Protection Regulation，简称GDPR）终于将在2018年5月25日生效。</p>
<p>]]>
    </summary>
    <title>GDPR zh</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h2 id="快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1"><a href="#快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1" class="headerlink" title="快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1"></a>快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1</h2><p>在 Windows 上，<a href="https://sspai.com/post/58167">存储感知</a> 这个小功能可以自动地、按计划地清除无用的系统缓存文件和应用程序主动声明的缓存文件，<a href="https://sspai.com/item/92">CCleaner</a> 这类第三方清理工具则可以清理掉更多不同软件留下来的垃圾。</p><p>但上述方法一般用于自动化、周期化的自动清理，针对一些一时有用、有意存放的大文件或无意间散落在磁盘里的冗余数据，分析、定位然后根据实际需求决定去留是更加保险的方法。</p><p>针对大文件扫描和分析，Windows 上比较老牌的工具有 <a href="https://sspai.com/post/42425">SpaceSniffer</a>。2017 年 <a href="https://sspai.com/u/jfo2ptxo">@Jerry___</a> 在他的文章中介绍说：SpaceSniffer 是一款免费便携的绿色软件，整体安装包只有 1.58MB……但到了 2021 年，距离 2016 年 10 月 2 日的最后一次更新已经有四年多的时间了，这样的  SpaceSniffer 放在今天使用，最直观的感受就是<strong>慢、而且不够准确。</strong></p><p>例如，在 Windows 10 支持网盘的「<a href="https://sspai.com/post/58566">按需同步</a>」功能后，OneDrive 的文件夹采用了 <a href="https://sspai.com/link?target=https://unix.stackexchange.com/questions/404159/accessing-onedrive-folder-on-windows-partition">特殊 NTFS 挂载点</a> 的方法挂载在硬盘上，这就使得 SpaceSniffer 无法扫描到；除此之外，SpaceSniffer 的基本扫描原理其实就是在硬盘内实实在在地检索文件大小，在固态硬盘上的扫描速度尚且可以接受，但如果在有很多小文件的机械硬盘上，搜索速度就肉眼可见地慢了下来。</p><h2 id="快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1-1"><a href="#快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1-1" class="headerlink" title="快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1"></a>快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1</h2><p>在 Windows 上，<a href="https://sspai.com/post/58167">存储感知</a> 这个小功能可以自动地、按计划地清除无用的系统缓存文件和应用程序主动声明的缓存文件，<a href="https://sspai.com/item/92">CCleaner</a> 这类第三方清理工具则可以清理掉更多不同软件留下来的垃圾。</p><p>但上述方法一般用于自动化、周期化的自动清理，针对一些一时有用、有意存放的大文件或无意间散落在磁盘里的冗余数据，分析、定位然后根据实际需求决定去留是更加保险的方法。</p><p>针对大文件扫描和分析，Windows 上比较老牌的工具有 <a href="https://sspai.com/post/42425">SpaceSniffer</a>。2017 年 <a href="https://sspai.com/u/jfo2ptxo">@Jerry___</a> 在他的文章中介绍说：SpaceSniffer 是一款免费便携的绿色软件，整体安装包只有 1.58MB……但到了 2021 年，距离 2016 年 10 月 2 日的最后一次更新已经有四年多的时间了，这样的  SpaceSniffer 放在今天使用，最直观的感受就是<strong>慢、而且不够准确。</strong></p><p>例如，在 Windows 10 支持网盘的「<a href="https://sspai.com/post/58566">按需同步</a>」功能后，OneDrive 的文件夹采用了 <a href="https://sspai.com/link?target=https://unix.stackexchange.com/questions/404159/accessing-onedrive-folder-on-windows-partition">特殊 NTFS 挂载点</a> 的方法挂载在硬盘上，这就使得 SpaceSniffer 无法扫描到；除此之外，SpaceSniffer 的基本扫描原理其实就是在硬盘内实实在在地检索文件大小，在固态硬盘上的扫描速度尚且可以接受，但如果在有很多小文件的机械硬盘上，搜索速度就肉眼可见地慢了下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6f93e853d433fc5fe630b4ae270735bf" alt="img"></p><p>相比之下，今天要介绍的 WizTree 则在速度和新特性兼容上好了不少。</p><p>WizTree 在自家官网上号称最快的磁盘空间分析工具（The FASTEST Disk Space Analyser），虽然有点不太「广告法」，但实测下来它的快也是可以感知到的：WizTree 使用了与 Everything 相类似的技术，利用 NTFS 分区的特性直接读取 MFT 记录进行分析，达到了「秒排序」的效果。同时它也能够识别通过网络存储（Samba）挂载于 Windows 资源管理器中的驱动器。</p><p>具体的速度我录制了一个 GIF 来展示，注意 GIF 停止录制时右边的 SpaceSniffer 并未完成扫描：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/aa09508bb17a1563ef30ed0ca39144a1.gif" alt="img"></p><p>对于使用 NTFS 新特性的文件夹，WizTree 可以通过「大小」「分配」两个不同的属性来分辨文件是否已经被「释放空间」。这两个概念你可以这样理解：</p><ul><li>「大小」即文件的大小，在没有使用「按需同步」时，它与文件的占用空间理论上一致</li><li>「分配」即文件被分配的空间。如果一个文件在 OneDrive 云端存在，但没有被下载到本地，或文件被主动释放空间。这一类情况下文件被「分配」的空间将会是 0</li></ul><p>如下图，我的OneDrive 中存放着一些已经被「释放」的系统镜像，它们的大小可以正常显示，「分配」一栏也能正确显示分配（占用）空间为 0.</p><p><img src="https://cdn.sspai.com/2021/01/02/article/1aaf27c4326caeb1005f861b83f7b04d?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>当然，对于没有明显「捷径」可走的 FAT &#x2F; exFAT 分区，WizTree 的表现也不错。以下是一个综合的性能测试表格：</p><table><thead><tr><th></th><th>SpaceSniffer</th><th>WizTree</th></tr></thead><tbody><tr><td>机械，exFAT</td><td>11.15s</td><td>8.02s</td></tr><tr><td>机械，NTFS</td><td>24.23s</td><td>5.24s</td></tr><tr><td>固态，NTFS（NVMe，系统分区）</td><td>76.97s</td><td>2.53s</td></tr><tr><td>固态，exFAT（Portable）</td><td>1.75s</td><td>0.55s</td></tr></tbody></table><p>除了传统的树形大小比较、自动绘制的文件夹大小图之外，WizTree 还提供了分扩展名占用的空间统计，方便你搞懂这个盘究竟装了些什么，或是找出「影音收藏」在哪个硬盘。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/2d4d97716086944550afac9a794c8949" alt="img"></p><p>最后还是在这里提醒大家：此类扫描软件可以让你清晰、直观地看到硬盘内的空间占用，但在执行删除操作前，<strong>请确保你知道自己在删除的文件确实没有作用，否则可能会导致系统的崩溃</strong>。</p><p><img src="https://cdn.sspai.com/2021/01/02/article/1a9093d1de2f499929c4d7bb7498d7fb?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>你可以在官网下载 <a href="https://sspai.com/link?target=https://wiztreefree.com/download">WizTree</a>，个人使用完全免费、自带中文。由于开发商打包时的问题，中文安装界面存在乱码的情况。建议在安装时选择英文的安装界面，安装完后再将语言改成中文。</p><p>相比之下，今天要介绍的 WizTree 则在速度和新特性兼容上好了不少。</p><p>WizTree 在自家官网上号称最快的磁盘空间分析工具（The FASTEST Disk Space Analyser），虽然有点不太「广告法」，但实测下来它的快也是可以感知到的：WizTree 使用了与 Everything 相类似的技术，利用 NTFS 分区的特性直接读取 MFT 记录进行分析，达到了「秒排序」的效果。同时它也能够识别通过网络存储（Samba）挂载于 Windows 资源管理器中的驱动器。</p><p>具体的速度我录制了一个 GIF 来展示，注意 GIF 停止录制时右边的 SpaceSniffer 并未完成扫描：</p><h2 id="快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1-2"><a href="#快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1-2" class="headerlink" title="快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1"></a>快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1</h2><p>在 Windows 上，<a href="https://sspai.com/post/58167">存储感知</a> 这个小功能可以自动地、按计划地清除无用的系统缓存文件和应用程序主动声明的缓存文件，<a href="https://sspai.com/item/92">CCleaner</a> 这类第三方清理工具则可以清理掉更多不同软件留下来的垃圾。</p><p>但上述方法一般用于自动化、周期化的自动清理，针对一些一时有用、有意存放的大文件或无意间散落在磁盘里的冗余数据，分析、定位然后根据实际需求决定去留是更加保险的方法。</p><p>针对大文件扫描和分析，Windows 上比较老牌的工具有 <a href="https://sspai.com/post/42425">SpaceSniffer</a>。2017 年 <a href="https://sspai.com/u/jfo2ptxo">@Jerry___</a> 在他的文章中介绍说：SpaceSniffer 是一款免费便携的绿色软件，整体安装包只有 1.58MB……但到了 2021 年，距离 2016 年 10 月 2 日的最后一次更新已经有四年多的时间了，这样的  SpaceSniffer 放在今天使用，最直观的感受就是<strong>慢、而且不够准确。</strong></p><p>例如，在 Windows 10 支持网盘的「<a href="https://sspai.com/post/58566">按需同步</a>」功能后，OneDrive 的文件夹采用了 <a href="https://sspai.com/link?target=https://unix.stackexchange.com/questions/404159/accessing-onedrive-folder-on-windows-partition">特殊 NTFS 挂载点</a> 的方法挂载在硬盘上，这就使得 SpaceSniffer 无法扫描到；除此之外，SpaceSniffer 的基本扫描原理其实就是在硬盘内实实在在地检索文件大小，在固态硬盘上的扫描速度尚且可以接受，但如果在有很多小文件的机械硬盘上，搜索速度就肉眼可见地慢了下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6f93e853d433fc5fe630b4ae270735bf" alt="img"></p><p>相比之下，今天要介绍的 WizTree 则在速度和新特性兼容上好了不少。</p><p>WizTree 在自家官网上号称最快的磁盘空间分析工具（The FASTEST Disk Space Analyser），虽然有点不太「广告法」，但实测下来它的快也是可以感知到的：WizTree 使用了与 Everything 相类似的技术，利用 NTFS 分区的特性直接读取 MFT 记录进行分析，达到了「秒排序」的效果。同时它也能够识别通过网络存储（Samba）挂载于 Windows 资源管理器中的驱动器。</p><p>具体的速度我录制了一个 GIF 来展示，注意 GIF 停止录制时右边的 SpaceSniffer 并未完成扫描：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/aa09508bb17a1563ef30ed0ca39144a1.gif" alt="img"></p><p>对于使用 NTFS 新特性的文件夹，WizTree 可以通过「大小」「分配」两个不同的属性来分辨文件是否已经被「释放空间」。这两个概念你可以这样理解：</p><ul><li>「大小」即文件的大小，在没有使用「按需同步」时，它与文件的占用空间理论上一致</li><li>「分配」即文件被分配的空间。如果一个文件在 OneDrive 云端存在，但没有被下载到本地，或文件被主动释放空间。这一类情况下文件被「分配」的空间将会是 0</li></ul><p>如下图，我的OneDrive 中存放着一些已经被「释放」的系统镜像，它们的大小可以正常显示，「分配」一栏也能正确显示分配（占用）空间为 0.</p><p><img src="https://cdn.sspai.com/2021/01/02/article/1aaf27c4326caeb1005f861b83f7b04d?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>当然，对于没有明显「捷径」可走的 FAT &#x2F; exFAT 分区，WizTree 的表现也不错。以下是一个综合的性能测试表格：</p><table><thead><tr><th></th><th>SpaceSniffer</th><th>WizTree</th></tr></thead><tbody><tr><td>机械，exFAT</td><td>11.15s</td><td>8.02s</td></tr><tr><td>机械，NTFS</td><td>24.23s</td><td>5.24s</td></tr><tr><td>固态，NTFS（NVMe，系统分区）</td><td>76.97s</td><td>2.53s</td></tr><tr><td>固态，exFAT（Portable）</td><td>1.75s</td><td>0.55s</td></tr></tbody></table><p>除了传统的树形大小比较、自动绘制的文件夹大小图之外，WizTree 还提供了分扩展名占用的空间统计，方便你搞懂这个盘究竟装了些什么，或是找出「影音收藏」在哪个硬盘。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/2d4d97716086944550afac9a794c8949" alt="img"></p><p>最后还是在这里提醒大家：此类扫描软件可以让你清晰、直观地看到硬盘内的空间占用，但在执行删除操作前，<strong>请确保你知道自己在删除的文件确实没有作用，否则可能会导致系统的崩溃</strong>。</p><p><img src="https://cdn.sspai.com/2021/01/02/article/1a9093d1de2f499929c4d7bb7498d7fb?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>你可以在官网下载 <a href="https://sspai.com/link?target=https://wiztreefree.com/download">WizTree</a>，个人使用完全免费、自带中文。由于开发商打包时的问题，中文安装界面存在乱码的情况。建议在安装时选择英文的安装界面，安装完后再将语言改成中文。</p><p>对于使用 NTFS 新特性的文件夹，WizTree 可以通过「大小」「分配」两个不同的属性来分辨文件是否已经被「释放空间」。这两个概念你可以这样理解：</p><ul><li>「大小」即文件的大小，在没有使用「按需同步」时，它与文件的占用空间理论上一致</li><li>「分配」即文件被分配的空间。如果一个文件在 OneDrive 云端存在，但没有被下载到本地，或文件被主动释放空间。这一类情况下文件被「分配」的空间将会是 0</li></ul><p>如下图，我的OneDrive 中存放着一些已经被「释放」的系统镜像，它们的大小可以正常显示，「分配」一栏也能正确显示分配（占用）空间为 0.</p><h2 id="快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1-3"><a href="#快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1-3" class="headerlink" title="快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1"></a>快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1</h2><p>在 Windows 上，<a href="https://sspai.com/post/58167">存储感知</a> 这个小功能可以自动地、按计划地清除无用的系统缓存文件和应用程序主动声明的缓存文件，<a href="https://sspai.com/item/92">CCleaner</a> 这类第三方清理工具则可以清理掉更多不同软件留下来的垃圾。</p><p>但上述方法一般用于自动化、周期化的自动清理，针对一些一时有用、有意存放的大文件或无意间散落在磁盘里的冗余数据，分析、定位然后根据实际需求决定去留是更加保险的方法。</p><p>针对大文件扫描和分析，Windows 上比较老牌的工具有 <a href="https://sspai.com/post/42425">SpaceSniffer</a>。2017 年 <a href="https://sspai.com/u/jfo2ptxo">@Jerry___</a> 在他的文章中介绍说：SpaceSniffer 是一款免费便携的绿色软件，整体安装包只有 1.58MB……但到了 2021 年，距离 2016 年 10 月 2 日的最后一次更新已经有四年多的时间了，这样的  SpaceSniffer 放在今天使用，最直观的感受就是<strong>慢、而且不够准确。</strong></p><p>例如，在 Windows 10 支持网盘的「<a href="https://sspai.com/post/58566">按需同步</a>」功能后，OneDrive 的文件夹采用了 <a href="https://sspai.com/link?target=https://unix.stackexchange.com/questions/404159/accessing-onedrive-folder-on-windows-partition">特殊 NTFS 挂载点</a> 的方法挂载在硬盘上，这就使得 SpaceSniffer 无法扫描到；除此之外，SpaceSniffer 的基本扫描原理其实就是在硬盘内实实在在地检索文件大小，在固态硬盘上的扫描速度尚且可以接受，但如果在有很多小文件的机械硬盘上，搜索速度就肉眼可见地慢了下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6f93e853d433fc5fe630b4ae270735bf" alt="img"></p><p>相比之下，今天要介绍的 WizTree 则在速度和新特性兼容上好了不少。</p><p>WizTree 在自家官网上号称最快的磁盘空间分析工具（The FASTEST Disk Space Analyser），虽然有点不太「广告法」，但实测下来它的快也是可以感知到的：WizTree 使用了与 Everything 相类似的技术，利用 NTFS 分区的特性直接读取 MFT 记录进行分析，达到了「秒排序」的效果。同时它也能够识别通过网络存储（Samba）挂载于 Windows 资源管理器中的驱动器。</p><p>具体的速度我录制了一个 GIF 来展示，注意 GIF 停止录制时右边的 SpaceSniffer 并未完成扫描：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/aa09508bb17a1563ef30ed0ca39144a1.gif" alt="img"></p><p>对于使用 NTFS 新特性的文件夹，WizTree 可以通过「大小」「分配」两个不同的属性来分辨文件是否已经被「释放空间」。这两个概念你可以这样理解：</p><ul><li>「大小」即文件的大小，在没有使用「按需同步」时，它与文件的占用空间理论上一致</li><li>「分配」即文件被分配的空间。如果一个文件在 OneDrive 云端存在，但没有被下载到本地，或文件被主动释放空间。这一类情况下文件被「分配」的空间将会是 0</li></ul><p>如下图，我的OneDrive 中存放着一些已经被「释放」的系统镜像，它们的大小可以正常显示，「分配」一栏也能正确显示分配（占用）空间为 0.</p><p><img src="https://cdn.sspai.com/2021/01/02/article/1aaf27c4326caeb1005f861b83f7b04d?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>当然，对于没有明显「捷径」可走的 FAT &#x2F; exFAT 分区，WizTree 的表现也不错。以下是一个综合的性能测试表格：</p><table><thead><tr><th></th><th>SpaceSniffer</th><th>WizTree</th></tr></thead><tbody><tr><td>机械，exFAT</td><td>11.15s</td><td>8.02s</td></tr><tr><td>机械，NTFS</td><td>24.23s</td><td>5.24s</td></tr><tr><td>固态，NTFS（NVMe，系统分区）</td><td>76.97s</td><td>2.53s</td></tr><tr><td>固态，exFAT（Portable）</td><td>1.75s</td><td>0.55s</td></tr></tbody></table><p>除了传统的树形大小比较、自动绘制的文件夹大小图之外，WizTree 还提供了分扩展名占用的空间统计，方便你搞懂这个盘究竟装了些什么，或是找出「影音收藏」在哪个硬盘。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/2d4d97716086944550afac9a794c8949" alt="img"></p><p>最后还是在这里提醒大家：此类扫描软件可以让你清晰、直观地看到硬盘内的空间占用，但在执行删除操作前，<strong>请确保你知道自己在删除的文件确实没有作用，否则可能会导致系统的崩溃</strong>。</p><p><img src="https://cdn.sspai.com/2021/01/02/article/1a9093d1de2f499929c4d7bb7498d7fb?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>你可以在官网下载 <a href="https://sspai.com/link?target=https://wiztreefree.com/download">WizTree</a>，个人使用完全免费、自带中文。由于开发商打包时的问题，中文安装界面存在乱码的情况。建议在安装时选择英文的安装界面，安装完后再将语言改成中文。</p><p>当然，对于没有明显「捷径」可走的 FAT &#x2F; exFAT 分区，WizTree 的表现也不错。以下是一个综合的性能测试表格：</p><table><thead><tr><th></th><th>SpaceSniffer</th><th>WizTree</th></tr></thead><tbody><tr><td>机械，exFAT</td><td>11.15s</td><td>8.02s</td></tr><tr><td>机械，NTFS</td><td>24.23s</td><td>5.24s</td></tr><tr><td>固态，NTFS（NVMe，系统分区）</td><td>76.97s</td><td>2.53s</td></tr><tr><td>固态，exFAT（Portable）</td><td>1.75s</td><td>0.55s</td></tr></tbody></table><p>除了传统的树形大小比较、自动绘制的文件夹大小图之外，WizTree 还提供了分扩展名占用的空间统计，方便你搞懂这个盘究竟装了些什么，或是找出「影音收藏」在哪个硬盘。</p><h2 id="快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1-4"><a href="#快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1-4" class="headerlink" title="快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1"></a>快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1</h2><p>在 Windows 上，<a href="https://sspai.com/post/58167">存储感知</a> 这个小功能可以自动地、按计划地清除无用的系统缓存文件和应用程序主动声明的缓存文件，<a href="https://sspai.com/item/92">CCleaner</a> 这类第三方清理工具则可以清理掉更多不同软件留下来的垃圾。</p><p>但上述方法一般用于自动化、周期化的自动清理，针对一些一时有用、有意存放的大文件或无意间散落在磁盘里的冗余数据，分析、定位然后根据实际需求决定去留是更加保险的方法。</p><p>针对大文件扫描和分析，Windows 上比较老牌的工具有 <a href="https://sspai.com/post/42425">SpaceSniffer</a>。2017 年 <a href="https://sspai.com/u/jfo2ptxo">@Jerry___</a> 在他的文章中介绍说：SpaceSniffer 是一款免费便携的绿色软件，整体安装包只有 1.58MB……但到了 2021 年，距离 2016 年 10 月 2 日的最后一次更新已经有四年多的时间了，这样的  SpaceSniffer 放在今天使用，最直观的感受就是<strong>慢、而且不够准确。</strong></p><p>例如，在 Windows 10 支持网盘的「<a href="https://sspai.com/post/58566">按需同步</a>」功能后，OneDrive 的文件夹采用了 <a href="https://sspai.com/link?target=https://unix.stackexchange.com/questions/404159/accessing-onedrive-folder-on-windows-partition">特殊 NTFS 挂载点</a> 的方法挂载在硬盘上，这就使得 SpaceSniffer 无法扫描到；除此之外，SpaceSniffer 的基本扫描原理其实就是在硬盘内实实在在地检索文件大小，在固态硬盘上的扫描速度尚且可以接受，但如果在有很多小文件的机械硬盘上，搜索速度就肉眼可见地慢了下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6f93e853d433fc5fe630b4ae270735bf" alt="img"></p><p>相比之下，今天要介绍的 WizTree 则在速度和新特性兼容上好了不少。</p><p>WizTree 在自家官网上号称最快的磁盘空间分析工具（The FASTEST Disk Space Analyser），虽然有点不太「广告法」，但实测下来它的快也是可以感知到的：WizTree 使用了与 Everything 相类似的技术，利用 NTFS 分区的特性直接读取 MFT 记录进行分析，达到了「秒排序」的效果。同时它也能够识别通过网络存储（Samba）挂载于 Windows 资源管理器中的驱动器。</p><p>具体的速度我录制了一个 GIF 来展示，注意 GIF 停止录制时右边的 SpaceSniffer 并未完成扫描：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/aa09508bb17a1563ef30ed0ca39144a1.gif" alt="img"></p><p>对于使用 NTFS 新特性的文件夹，WizTree 可以通过「大小」「分配」两个不同的属性来分辨文件是否已经被「释放空间」。这两个概念你可以这样理解：</p><ul><li>「大小」即文件的大小，在没有使用「按需同步」时，它与文件的占用空间理论上一致</li><li>「分配」即文件被分配的空间。如果一个文件在 OneDrive 云端存在，但没有被下载到本地，或文件被主动释放空间。这一类情况下文件被「分配」的空间将会是 0</li></ul><p>如下图，我的OneDrive 中存放着一些已经被「释放」的系统镜像，它们的大小可以正常显示，「分配」一栏也能正确显示分配（占用）空间为 0.</p><p><img src="https://cdn.sspai.com/2021/01/02/article/1aaf27c4326caeb1005f861b83f7b04d?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>当然，对于没有明显「捷径」可走的 FAT &#x2F; exFAT 分区，WizTree 的表现也不错。以下是一个综合的性能测试表格：</p><table><thead><tr><th></th><th>SpaceSniffer</th><th>WizTree</th></tr></thead><tbody><tr><td>机械，exFAT</td><td>11.15s</td><td>8.02s</td></tr><tr><td>机械，NTFS</td><td>24.23s</td><td>5.24s</td></tr><tr><td>固态，NTFS（NVMe，系统分区）</td><td>76.97s</td><td>2.53s</td></tr><tr><td>固态，exFAT（Portable）</td><td>1.75s</td><td>0.55s</td></tr></tbody></table><p>除了传统的树形大小比较、自动绘制的文件夹大小图之外，WizTree 还提供了分扩展名占用的空间统计，方便你搞懂这个盘究竟装了些什么，或是找出「影音收藏」在哪个硬盘。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/2d4d97716086944550afac9a794c8949" alt="img"></p><p>最后还是在这里提醒大家：此类扫描软件可以让你清晰、直观地看到硬盘内的空间占用，但在执行删除操作前，<strong>请确保你知道自己在删除的文件确实没有作用，否则可能会导致系统的崩溃</strong>。</p><p><img src="https://cdn.sspai.com/2021/01/02/article/1a9093d1de2f499929c4d7bb7498d7fb?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>你可以在官网下载 <a href="https://sspai.com/link?target=https://wiztreefree.com/download">WizTree</a>，个人使用完全免费、自带中文。由于开发商打包时的问题，中文安装界面存在乱码的情况。建议在安装时选择英文的安装界面，安装完后再将语言改成中文。</p><p>最后还是在这里提醒大家：此类扫描软件可以让你清晰、直观地看到硬盘内的空间占用，但在执行删除操作前，<strong>请确保你知道自己在删除的文件确实没有作用，否则可能会导致系统的崩溃</strong>。</p><h2 id="快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1-5"><a href="#快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1-5" class="headerlink" title="快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1"></a>快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1</h2><p>在 Windows 上，<a href="https://sspai.com/post/58167">存储感知</a> 这个小功能可以自动地、按计划地清除无用的系统缓存文件和应用程序主动声明的缓存文件，<a href="https://sspai.com/item/92">CCleaner</a> 这类第三方清理工具则可以清理掉更多不同软件留下来的垃圾。</p><p>但上述方法一般用于自动化、周期化的自动清理，针对一些一时有用、有意存放的大文件或无意间散落在磁盘里的冗余数据，分析、定位然后根据实际需求决定去留是更加保险的方法。</p><p>针对大文件扫描和分析，Windows 上比较老牌的工具有 <a href="https://sspai.com/post/42425">SpaceSniffer</a>。2017 年 <a href="https://sspai.com/u/jfo2ptxo">@Jerry___</a> 在他的文章中介绍说：SpaceSniffer 是一款免费便携的绿色软件，整体安装包只有 1.58MB……但到了 2021 年，距离 2016 年 10 月 2 日的最后一次更新已经有四年多的时间了，这样的  SpaceSniffer 放在今天使用，最直观的感受就是<strong>慢、而且不够准确。</strong></p><p>例如，在 Windows 10 支持网盘的「<a href="https://sspai.com/post/58566">按需同步</a>」功能后，OneDrive 的文件夹采用了 <a href="https://sspai.com/link?target=https://unix.stackexchange.com/questions/404159/accessing-onedrive-folder-on-windows-partition">特殊 NTFS 挂载点</a> 的方法挂载在硬盘上，这就使得 SpaceSniffer 无法扫描到；除此之外，SpaceSniffer 的基本扫描原理其实就是在硬盘内实实在在地检索文件大小，在固态硬盘上的扫描速度尚且可以接受，但如果在有很多小文件的机械硬盘上，搜索速度就肉眼可见地慢了下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6f93e853d433fc5fe630b4ae270735bf" alt="img"></p><p>相比之下，今天要介绍的 WizTree 则在速度和新特性兼容上好了不少。</p><p>WizTree 在自家官网上号称最快的磁盘空间分析工具（The FASTEST Disk Space Analyser），虽然有点不太「广告法」，但实测下来它的快也是可以感知到的：WizTree 使用了与 Everything 相类似的技术，利用 NTFS 分区的特性直接读取 MFT 记录进行分析，达到了「秒排序」的效果。同时它也能够识别通过网络存储（Samba）挂载于 Windows 资源管理器中的驱动器。</p><p>具体的速度我录制了一个 GIF 来展示，注意 GIF 停止录制时右边的 SpaceSniffer 并未完成扫描：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/aa09508bb17a1563ef30ed0ca39144a1.gif" alt="img"></p><p>对于使用 NTFS 新特性的文件夹，WizTree 可以通过「大小」「分配」两个不同的属性来分辨文件是否已经被「释放空间」。这两个概念你可以这样理解：</p><ul><li>「大小」即文件的大小，在没有使用「按需同步」时，它与文件的占用空间理论上一致</li><li>「分配」即文件被分配的空间。如果一个文件在 OneDrive 云端存在，但没有被下载到本地，或文件被主动释放空间。这一类情况下文件被「分配」的空间将会是 0</li></ul><p>如下图，我的OneDrive 中存放着一些已经被「释放」的系统镜像，它们的大小可以正常显示，「分配」一栏也能正确显示分配（占用）空间为 0.</p><p><img src="https://cdn.sspai.com/2021/01/02/article/1aaf27c4326caeb1005f861b83f7b04d?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>当然，对于没有明显「捷径」可走的 FAT &#x2F; exFAT 分区，WizTree 的表现也不错。以下是一个综合的性能测试表格：</p><table><thead><tr><th></th><th>SpaceSniffer</th><th>WizTree</th></tr></thead><tbody><tr><td>机械，exFAT</td><td>11.15s</td><td>8.02s</td></tr><tr><td>机械，NTFS</td><td>24.23s</td><td>5.24s</td></tr><tr><td>固态，NTFS（NVMe，系统分区）</td><td>76.97s</td><td>2.53s</td></tr><tr><td>固态，exFAT（Portable）</td><td>1.75s</td><td>0.55s</td></tr></tbody></table><p>除了传统的树形大小比较、自动绘制的文件夹大小图之外，WizTree 还提供了分扩展名占用的空间统计，方便你搞懂这个盘究竟装了些什么，或是找出「影音收藏」在哪个硬盘。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/2d4d97716086944550afac9a794c8949" alt="img"></p><p>最后还是在这里提醒大家：此类扫描软件可以让你清晰、直观地看到硬盘内的空间占用，但在执行删除操作前，<strong>请确保你知道自己在删除的文件确实没有作用，否则可能会导致系统的崩溃</strong>。</p><p><img src="https://cdn.sspai.com/2021/01/02/article/1a9093d1de2f499929c4d7bb7498d7fb?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>你可以在官网下载 <a href="https://sspai.com/link?target=https://wiztreefree.com/download">WizTree</a>，个人使用完全免费、自带中文。由于开发商打包时的问题，中文安装界面存在乱码的情况。建议在安装时选择英文的安装界面，安装完后再将语言改成中文。</p><p>你可以在官网下载 <a href="https://sspai.com/link?target=https://wiztreefree.com/download">WizTree</a>，个人使用完全免费、自带中文。由于开发商打包时的问题，中文安装界面存在乱码的情况。建议在安装时选择英文的安装界面，安装完后再将语言改成中文。</p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/WizTree/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/WizTree/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h2 id="快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1"><a href="#快速清理-Windows-大文件，它比「老牌」更好用：WizTree-App-1" class="headerlink" title="快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1"></a>快速清理 Windows 大文件，它比「老牌」更好用：WizTree | App +1</h2><p>在 Windows 上，<a href="https://sspai.com/post/58167">存储感知</a>]]>
    </summary>
    <title>WizTree</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h3 id="1、Kali-Linux中的文件系统"><a href="#1、Kali-Linux中的文件系统" class="headerlink" title="1、Kali Linux中的文件系统"></a>1、Kali Linux中的文件系统</h3><p>通过系统界面可以看到一个“file system”，这个就是文件系统，双击点开，会看到如下界面：</p><p>右侧就是该文件下的文件系统目录</p><h3 id="1、Kali-Linux中的文件系统-1"><a href="#1、Kali-Linux中的文件系统-1" class="headerlink" title="1、Kali Linux中的文件系统"></a>1、Kali Linux中的文件系统</h3><p>通过系统界面可以看到一个“file system”，这个就是文件系统，双击点开，会看到如下界面：</p><p>右侧就是该文件下的文件系统目录</p><p><img src="https://pic4.zhimg.com/v2-55331ca8b332d67f44278abbfef2c337_b.webp?consumer=ZHI_MENG" alt="img"></p><p>重点文件的说明，从上到下，从左到右：</p><p>bin：二进制可执行文件的目录</p><p>boot：用来存放Linux操作系统的内核和在引导过程中使用的文件</p><p>dev：dev是设备（device）的英文缩写，在这个目录中包含Linux操作系统中使用的所有外部设备。</p><p>etc：配置文件存放的目录，如人员的用户名&#x2F;密码文件、各种服务的起始文件等。</p><p>home：系统默认的用户home目录，当新增账户时，用户的home目录都存放在该目录下</p><p>lib：系统使用函数库的目录，程序在执行过程中，调用的一些额外参数时就需要函数库的协助，后面32或者64是根据不同系统调用来区分的</p><p>media：挂载的媒体设备目录，一般讲外部设备挂载到这里，例如插入的U盘</p><p>mnt：用于存放挂载存储设备的挂载目录，如磁盘等</p><p>opt：该目录用来安装附加软件包，是用户级的程序目录</p><p>proc：这是一种特殊的、由软件创建的文件系统，内核使用它向外界导出信息，只存在内存中，而不占用外存空间。</p><p>root：root用户的目录</p><p>run：是临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件被删掉或清除</p><p>sbin：该目录用于存放root用户使用的可执行命令</p><p>srv：服务启动之后需要访问的数据目录</p><p>sys：该目录下是系统及内核重要的操作内容</p><p>tmp：一般用户或正在执行的程序临时存放文件的目录，任何用户都可以访问，重要数据不可存放在该目录下</p><p>usr：应用程序存放的目录，usr&#x2F;bin用于存放应用程序；usr&#x2F;share用于存放共享数据；usr&#x2F;lib用于存放不能直接运行的，却是许多应用程序运行所必需的一些函数库文件。</p><p>var：该目录用于存放系统执行过程中经常变化的文件。</p><h3 id="2、Kali-Linux-常用命令"><a href="#2、Kali-Linux-常用命令" class="headerlink" title="2、Kali Linux 常用命令"></a>2、Kali Linux 常用命令</h3><h4 id="2-1-与文件目录相关的命令（pwd、cd、ls）"><a href="#2-1-与文件目录相关的命令（pwd、cd、ls）" class="headerlink" title="2.1 与文件目录相关的命令（pwd、cd、ls）"></a>2.1 与文件目录相关的命令（pwd、cd、ls）</h4><p>•PWD命令是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><p>•cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><p>•ls命令用于显示指定工作目录下之内容（列出当前工作目录所含之文件及子目录)。</p><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h4 id="2-2-文件查看命令（cat、head、tail、nl、grep）"><a href="#2-2-文件查看命令（cat、head、tail、nl、grep）" class="headerlink" title="2.2 文件查看命令（cat、head、tail、nl、grep）"></a>2.2 文件查看命令（cat、head、tail、nl、grep）</h4><p>cat命令用来显示文件内容，语法为“cat 目录项”，cat命令可以在屏幕上显示文件，可以合并文件，还可以建立文本文件。</p><p>另外head、tail、nl、more和less命令也可以用来浏览文件。</p><p>grep 命令用于查找文件里符合条件的字符串。</p><p>more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，使用者在阅读时可以按空格键（space）来显示下一页，按 b 键来返回（back）一页显示。</p><p>less 与 more 类似，但使用 less 可以随意浏览文件，下面是使用less参数显示文件内容之后，使用者可以进行的一些操作。</p><h4 id="2-3-网络相关命令（ifconfig、ip-addr-show等）"><a href="#2-3-网络相关命令（ifconfig、ip-addr-show等）" class="headerlink" title="2.3 网络相关命令（ifconfig、ip addr show等）"></a>2.3 网络相关命令（ifconfig、ip addr show等）</h4><p>Kali Linux 2同时支持net-tools和iproute2，所以可以使用这两种命令来完成对网络的配置和查看。如果要查看设备的网络连接信息，可以使用“ip addr”和“sudo ifconifg”</p><p>ip命令中常用的方法有：</p><p>•ip addr show：显示网络信息；</p><p>•ip route show：显示路由，如果直接用route命令，也可以查看到路由信息</p><p>•ip neigh show：显示arp表，地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</p><p><strong>ifconfig：可以查看整个网络信息，例如IP地址，子网掩码等等</strong></p><h4 id="2-4-进程控制命令（ps）"><a href="#2-4-进程控制命令（ps）" class="headerlink" title="2.4 进程控制命令（ps）"></a>2.4 进程控制命令（ps）</h4><p>进程指的是程序正在运行的一个实例。Kali Linux 2中提供了对进程控制的命令。ps命令用于显示当前进程 (process) 的状态ps 的参数非常多, 在此仅列出几个常用的参数并介绍含义。</p><p> -A 列出所有的进程</p><p> -w 显示加宽可以显示较多的信息</p><p> -au 显示较详细的信息</p><p> -aux 显示所有（包含其他使用者）的进程</p><h4 id="2-5-Kali中的服务管理（service）"><a href="#2-5-Kali中的服务管理（service）" class="headerlink" title="2.5 Kali中的服务管理（service）"></a>2.5 Kali中的服务管理（service）</h4><p>在Linux术语中，服务指的是在运行在后台等待使用的应用程序。Service命令用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、查看状态（status）等。在Kali linux2中预装了很多服务。在Kali Linux中的有些服务可以通过GUI停止和启动，就像在Windows或Mac里一样。但是，也有些服务需要使用命令行管理。我们在这里介绍管理基本服务的语法：</p><p>service servicename start|stop|restart</p><h4 id="2-6-Kali中的shell脚本"><a href="#2-6-Kali中的shell脚本" class="headerlink" title="2.6 Kali中的shell脚本"></a>2.6 Kali中的shell脚本</h4><p>Shell脚本与Windows&#x2F;Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，主要是方便进行设置或者管理用的。Shell 脚本的编写跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>那么打开一个编辑器，输入以下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\#! /bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;Hello, Kali!&quot;</span><br></pre></td></tr></table></figure><p>将该文件保存为HelloKali，不需要后缀名。</p><p>当前我们还不能执行这个脚本，这是因为该脚本的权限导致的。这里可以使用ls -l命令来查看这个文件的权限。当前这个文件只有w和r权限，是不能执行的，这里需要为它添加一个可执行的权限。</p><p>chmod 755 HelloKali</p><p>再次使用ls -l查看，可以看到它具有了可执行权限。</p><p>kali &gt; .&#x2F;HelloKali</p><p>这里的.&#x2F; 可以理解为在当前目录下查找文件。</p><p>按下回车可以看到屏幕上输出：</p><p>Hello, Kali!</p><p>这表明当前程序已经成功执行。</p><p>Nmap脚本：找出子网 192.168.1.0&#x2F;24 内所有开放了445端口的主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\#! /bin/bash</span><br><span class="line"></span><br><span class="line">nmap -sT 192.168.1.0/24 -p 445 &gt;/dev/null -oG EternalBluescan</span><br><span class="line">cat EternalBluescan | grep open &gt; EternalBluescan2</span><br><span class="line">cat EternalBluescan2</span><br></pre></td></tr></table></figure><p>将该文件保存为EternalBluescanner.sh，然后执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kali &gt; ./EternalBluescanner.sh</span><br></pre></td></tr></table></figure><h3 id="Linux命令：查看服务器IP地址"><a href="#Linux命令：查看服务器IP地址" class="headerlink" title="Linux命令：查看服务器IP地址"></a>Linux命令：查看服务器IP地址</h3><p>1.查看当前登录的服务器的ip地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主机的 ip</span></span><br><span class="line">hostname -i</span><br><span class="line"></span><br><span class="line">hostname -I</span><br></pre></td></tr></table></figure><p>2.ifconfig</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前系统中所有网络接口的配置信息，包括IP地址、子网掩码和网关等。</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>3.ip addr</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 列出当前系统中所有网络接口的详细信息，包括IP地址、子网掩码和网关等。</span><br><span class="line">ip addr</span><br><span class="line"></span><br><span class="line">ip a</span><br><span class="line"># 或者</span><br><span class="line">ip a | more</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.nmcli命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 显示网络管理器中所有网络设备的信息，包括IP地址、子网掩码和网关等</span><br><span class="line">nmcli device show</span><br></pre></td></tr></table></figure><p>重点文件的说明，从上到下，从左到右：</p><p>bin：二进制可执行文件的目录</p><p>boot：用来存放Linux操作系统的内核和在引导过程中使用的文件</p><p>dev：dev是设备（device）的英文缩写，在这个目录中包含Linux操作系统中使用的所有外部设备。</p><p>etc：配置文件存放的目录，如人员的用户名&#x2F;密码文件、各种服务的起始文件等。</p><p>home：系统默认的用户home目录，当新增账户时，用户的home目录都存放在该目录下</p><p>lib：系统使用函数库的目录，程序在执行过程中，调用的一些额外参数时就需要函数库的协助，后面32或者64是根据不同系统调用来区分的</p><p>media：挂载的媒体设备目录，一般讲外部设备挂载到这里，例如插入的U盘</p><p>mnt：用于存放挂载存储设备的挂载目录，如磁盘等</p><p>opt：该目录用来安装附加软件包，是用户级的程序目录</p><p>proc：这是一种特殊的、由软件创建的文件系统，内核使用它向外界导出信息，只存在内存中，而不占用外存空间。</p><p>root：root用户的目录</p><p>run：是临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件被删掉或清除</p><p>sbin：该目录用于存放root用户使用的可执行命令</p><p>srv：服务启动之后需要访问的数据目录</p><p>sys：该目录下是系统及内核重要的操作内容</p><p>tmp：一般用户或正在执行的程序临时存放文件的目录，任何用户都可以访问，重要数据不可存放在该目录下</p><p>usr：应用程序存放的目录，usr&#x2F;bin用于存放应用程序；usr&#x2F;share用于存放共享数据；usr&#x2F;lib用于存放不能直接运行的，却是许多应用程序运行所必需的一些函数库文件。</p><p>var：该目录用于存放系统执行过程中经常变化的文件。</p><h3 id="2、Kali-Linux-常用命令-1"><a href="#2、Kali-Linux-常用命令-1" class="headerlink" title="2、Kali Linux 常用命令"></a>2、Kali Linux 常用命令</h3><h4 id="2-1-与文件目录相关的命令（pwd、cd、ls）-1"><a href="#2-1-与文件目录相关的命令（pwd、cd、ls）-1" class="headerlink" title="2.1 与文件目录相关的命令（pwd、cd、ls）"></a>2.1 与文件目录相关的命令（pwd、cd、ls）</h4><p>•PWD命令是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><p>•cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><p>•ls命令用于显示指定工作目录下之内容（列出当前工作目录所含之文件及子目录)。</p><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h4 id="2-2-文件查看命令（cat、head、tail、nl、grep）-1"><a href="#2-2-文件查看命令（cat、head、tail、nl、grep）-1" class="headerlink" title="2.2 文件查看命令（cat、head、tail、nl、grep）"></a>2.2 文件查看命令（cat、head、tail、nl、grep）</h4><p>cat命令用来显示文件内容，语法为“cat 目录项”，cat命令可以在屏幕上显示文件，可以合并文件，还可以建立文本文件。</p><p>另外head、tail、nl、more和less命令也可以用来浏览文件。</p><p>grep 命令用于查找文件里符合条件的字符串。</p><p>more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，使用者在阅读时可以按空格键（space）来显示下一页，按 b 键来返回（back）一页显示。</p><p>less 与 more 类似，但使用 less 可以随意浏览文件，下面是使用less参数显示文件内容之后，使用者可以进行的一些操作。</p><h4 id="2-3-网络相关命令（ifconfig、ip-addr-show等）-1"><a href="#2-3-网络相关命令（ifconfig、ip-addr-show等）-1" class="headerlink" title="2.3 网络相关命令（ifconfig、ip addr show等）"></a>2.3 网络相关命令（ifconfig、ip addr show等）</h4><p>Kali Linux 2同时支持net-tools和iproute2，所以可以使用这两种命令来完成对网络的配置和查看。如果要查看设备的网络连接信息，可以使用“ip addr”和“sudo ifconifg”</p><p>ip命令中常用的方法有：</p><p>•ip addr show：显示网络信息；</p><p>•ip route show：显示路由，如果直接用route命令，也可以查看到路由信息</p><p>•ip neigh show：显示arp表，地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</p><p><strong>ifconfig：可以查看整个网络信息，例如IP地址，子网掩码等等</strong></p><h4 id="2-4-进程控制命令（ps）-1"><a href="#2-4-进程控制命令（ps）-1" class="headerlink" title="2.4 进程控制命令（ps）"></a>2.4 进程控制命令（ps）</h4><p>进程指的是程序正在运行的一个实例。Kali Linux 2中提供了对进程控制的命令。ps命令用于显示当前进程 (process) 的状态ps 的参数非常多, 在此仅列出几个常用的参数并介绍含义。</p><p> -A 列出所有的进程</p><p> -w 显示加宽可以显示较多的信息</p><p> -au 显示较详细的信息</p><p> -aux 显示所有（包含其他使用者）的进程</p><h4 id="2-5-Kali中的服务管理（service）-1"><a href="#2-5-Kali中的服务管理（service）-1" class="headerlink" title="2.5 Kali中的服务管理（service）"></a>2.5 Kali中的服务管理（service）</h4><p>在Linux术语中，服务指的是在运行在后台等待使用的应用程序。Service命令用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、查看状态（status）等。在Kali linux2中预装了很多服务。在Kali Linux中的有些服务可以通过GUI停止和启动，就像在Windows或Mac里一样。但是，也有些服务需要使用命令行管理。我们在这里介绍管理基本服务的语法：</p><p>service servicename start|stop|restart</p><h4 id="2-6-Kali中的shell脚本-1"><a href="#2-6-Kali中的shell脚本-1" class="headerlink" title="2.6 Kali中的shell脚本"></a>2.6 Kali中的shell脚本</h4><p>Shell脚本与Windows&#x2F;Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，主要是方便进行设置或者管理用的。Shell 脚本的编写跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>那么打开一个编辑器，输入以下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\#! /bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;Hello, Kali!&quot;</span><br></pre></td></tr></table></figure><p>将该文件保存为HelloKali，不需要后缀名。</p><p>当前我们还不能执行这个脚本，这是因为该脚本的权限导致的。这里可以使用ls -l命令来查看这个文件的权限。当前这个文件只有w和r权限，是不能执行的，这里需要为它添加一个可执行的权限。</p><p>chmod 755 HelloKali</p><p>再次使用ls -l查看，可以看到它具有了可执行权限。</p><p>kali &gt; .&#x2F;HelloKali</p><p>这里的.&#x2F; 可以理解为在当前目录下查找文件。</p><p>按下回车可以看到屏幕上输出：</p><p>Hello, Kali!</p><p>这表明当前程序已经成功执行。</p><p>Nmap脚本：找出子网 192.168.1.0&#x2F;24 内所有开放了445端口的主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\#! /bin/bash</span><br><span class="line"></span><br><span class="line">nmap -sT 192.168.1.0/24 -p 445 &gt;/dev/null -oG EternalBluescan</span><br><span class="line">cat EternalBluescan | grep open &gt; EternalBluescan2</span><br><span class="line">cat EternalBluescan2</span><br></pre></td></tr></table></figure><p>将该文件保存为EternalBluescanner.sh，然后执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kali &gt; ./EternalBluescanner.sh</span><br></pre></td></tr></table></figure><h3 id="Linux命令：查看服务器IP地址-1"><a href="#Linux命令：查看服务器IP地址-1" class="headerlink" title="Linux命令：查看服务器IP地址"></a>Linux命令：查看服务器IP地址</h3><p>1.查看当前登录的服务器的ip地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主机的 ip</span></span><br><span class="line">hostname -i</span><br><span class="line"></span><br><span class="line">hostname -I</span><br></pre></td></tr></table></figure><p>2.ifconfig</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前系统中所有网络接口的配置信息，包括IP地址、子网掩码和网关等。</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>3.ip addr</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 列出当前系统中所有网络接口的详细信息，包括IP地址、子网掩码和网关等。</span><br><span class="line">ip addr</span><br><span class="line"></span><br><span class="line">ip a</span><br><span class="line"># 或者</span><br><span class="line">ip a | more</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.nmcli命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 显示网络管理器中所有网络设备的信息，包括IP地址、子网掩码和网关等</span><br><span class="line">nmcli device show</span><br></pre></td></tr></table></figure>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/Linux-Kali-Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/Linux-Kali-Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h3 id="1、Kali-Linux中的文件系统"><a href="#1、Kali-Linux中的文件系统" class="headerlink" title="1、Kali Linux中的文件系统"></a>1、Kali Linux中的文件系统</h3><p>通过系统界面可以看到一个“file system”，这个就是文件系统，双击点开，会看到如下界面：</p>
<p>右侧就是该文件下的文件系统目录</p>
<h3 id="1、Kali-Linux中的文件系统-1"><a href="#1、Kali-Linux中的文件系统-1" class="headerlink"]]>
    </summary>
    <title>Kali Linux常用操作</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<p>[TOC]</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h3><table><thead><tr><th>图书名称:</th><th>Kali Linux: Assuring Security by Penetration Testing</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td></td><td></td></tr></tbody></table><p>[TOC]</p><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="参考书-1"><a href="#参考书-1" class="headerlink" title="参考书"></a>参考书</h3><table><thead><tr><th>图书名称:</th><th>Kali Linux: Assuring Security by Penetration Testing</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://jobrest.gitbooks.io/kali-linux-cn/content/assets/feng_mian.jpeg" alt="封面"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2015-2</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>Lee Allen &#x2F; Tedi Heriyanto &#x2F; Shakeel Ali 著</td><td></td></tr><tr><td>译者</td><td>Archer 译</td><td></td></tr><tr><td>ISBN:</td><td>9787115378446</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Kali Linux2 网络渗透测试实践指南 第2版</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34261078.jpg" alt="Kali Linux2 网络渗透测试实践指南 第2版"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-3</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>李华峰 著</td><td></td></tr><tr><td>ISBN:</td><td>9787115555410</td><td></td></tr></tbody></table><h3 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h3><p>书籍在线阅读地址：<a href="https://jobrest.gitbooks.io/kali-linux-cn/content/index.html">Kali Linux 渗透测试的艺术（中文版） | Kali Linux 渗透测试的艺术（中文版） (gitbooks.io)</a></p><p>官网：<a href="https://www.kali.org/">Kali Linux 操作系统 |渗透测试和道德黑客 Linux 发行版</a></p><p>文档：<a href="https://www.kali.org/docs/">Kali Docs | Kali Linux Documentation</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="何为玩转kali？"><a href="#何为玩转kali？" class="headerlink" title="何为玩转kali？"></a>何为玩转kali？</h3><p>当然是想随心所欲，让“所见即所得”，让“所想立即实现”，那么此篇就是完成这个任务。</p><h2 id="第1章-Kali-Linux入门"><a href="#第1章-Kali-Linux入门" class="headerlink" title="第1章 Kali Linux入门"></a>第1章 Kali Linux入门</h2><h3 id="1-1-Kali的发展简史"><a href="#1-1-Kali的发展简史" class="headerlink" title="1.1 Kali的发展简史"></a>1.1 Kali的发展简史</h3><p>Kali Linux（Kali）是专门用于渗透测试的Linux操作系统，它由BackTrack 发展而来。在整合了IWHAX、WHOPPIX 和Auditor 这3 种渗透测试专用Live Linux 之后，BackTrack正式改名为Kali Linux。</p><p>BackTrack是相当著名的Linux发行版本。在BackTrack发布4.0预览版的时候，它的下载次数已经超过了400万次。</p><p>Kali Linux 1.0 版于2013年3 月12 日问世。在5天之后，官方为修复USB 键盘的支持问题而发布了1.0.1 版。在这短短的5 天之内，Kali 的下载次数就超过了9 万次。</p><p>根据官网的介绍（<a href="http://docs.kali.org/introduction/what-is-kali-linux%EF%BC%89%EF%BC%8C">http://docs.kali.org/introduction/what-is-kali-linux），</a> Kali的主要特色有：</p><p>● 它是基于Debian 的Linux 发行版；</p><p>● 它集成300 多个渗透测试程序；</p><p>● 它支持绝大多数的无线网卡；</p><p>● 它修改了内核以支持（无线）数据包注入；</p><p>● 所有的软件包都有研发团队的PGP 签名；</p><p>● 用户可以自制满足各自需求的Kali Linux 发行版；</p><p>● 支持基于ARM 的硬件系统。</p><h3 id="1-2-Kali-Linux工具包"><a href="#1-2-Kali-Linux工具包" class="headerlink" title="1.2 Kali Linux工具包"></a>1.2 Kali Linux工具包</h3><p>Kali Linux 含有可用于渗透测试的各种工具。这些工具程序大体可以分为以下几类。</p><p>● 信息收集：这类工具可用来收集目标的 DNS、IDS&#x2F;IPS、网络扫描、操作系统、路由、SSL、SMB、VPN、VoIP、SNMP信息和E-mail地址。</p><p>● 漏洞评估：这类工具都可以扫描目标系统上的漏洞。部分工具可以检测Cisco 网络系统缺陷，有些还可以评估各种数据库系统的安全问题。很多模糊测试软件都属于漏洞评估工具。</p><p>● Web应用：即与Web应用有关的工具。它包括CMS（内容管理系统）扫描器、数据库漏洞利用程序、Web应用模糊测试、Web应用代理、Web爬虫及Web漏洞扫描器。</p><p>● 密码攻击：无论是在线攻击还是离线破解，只要是能够实施密码攻击的工具都属于密码攻击类工具。</p><p>● 漏洞利用：这类工具可以利用在目标系统中发现的漏洞。攻击网络、Web 和数据库漏洞的软件，都属于漏洞利用（exploitation）工具。Kali 中的某些软件可以针对漏洞情况进行社会工程学攻击。</p><p>● 网络监听：这类工具用于监听网络和Web 流量。网络监听需要进行网络欺骗，所以Ettercap和Yersinia这类软件也归于这类软件。</p><p>● 访问维护：这类工具帮助渗透人员维持他们对目标主机的访问权。某些情况下，渗透人员必须先获取主机的最高权限才能安装这类软件。这类软件包括用于在 Web应用和操作系统安装后门的程序，以及隧道类工具。</p><p>● 报告工具：如果您需要撰写渗透测试的报告文件，您应该用得上这些软件。</p><p>● 系统服务：这是渗透人员在渗透测试时可能用到的常见服务类软件，它包括Apache服务、MySQL服务、SSH服务和Metasploit服务。</p><p>为了降低渗透测试人员筛选工具的难度，Kali Linux 单独划分了一类软件——Top 10 Security Tools，即10 大首选安全工具。这10 大工具分别是aircrack-ng、burp-suite、hydra、john、maltego、metasploit、nmap、sqlmap、wireshark和zaproxy。</p><p>除了可用于渗透测试的各种工具以外，Kali Linux 还整合了以下几类工具。</p><p>● 无线攻击：可攻击蓝牙、RFID&#x2F;NFC 和其他无线设备的工具。</p><p>● 逆向工程：可用于调试程序或反汇编的工具。</p><p>● 压力测试：用于各类压力测试的工具集。它们可测试网络、无线、Web 和 VoIP 系统的负载能力。</p><p>● 硬件破解：用于调试Android 和Arduino 程序的工具。</p><p>● 法证调查：即电子取证的工具。它的各种工具可以用于制作硬盘磁盘镜像、文件分析、硬盘镜像分析。如需使用这类程序，首先要在启动菜单里选择 Kali Linux Forensics | No Drives or Swap Mount。在开启这个选项以后，Kali Linux不会自动加载硬盘驱动器，以保护硬盘数据的完整性。</p><h3 id="1-3下载Kali-Linux"><a href="#1-3下载Kali-Linux" class="headerlink" title="1.3下载Kali Linux"></a>1.3下载Kali Linux</h3><p>下载是第一步要做的事情，经常使用计算机的人对下载肯定不陌生，但要想面向大众还是要解释清楚。</p><ul><li><p><input disabled="" type="checkbox"> 待补充</p></li><li><p><input disabled="" type="checkbox"> 验证哈希值</p></li></ul><h5 id="在虚拟机里使用-VM-镜像安装-Kali-Linux"><a href="#在虚拟机里使用-VM-镜像安装-Kali-Linux" class="headerlink" title="在虚拟机里使用 VM 镜像安装 Kali Linux"></a>在虚拟机里使用 VM 镜像安装 Kali Linux</h5><p>Kali Linux的iso镜像和虚拟机vmx文件等在Kali官网都有，直接下载就可以，而且下载速度也不赖。</p><p>这里我推荐直接下载Kali官方的虚拟机vmx文件，下载好了直接打开就能用，免去了很多配置环节。之前也尝试过用iso镜像做VMware，但试了几次遇到很多麻烦，因此就不搞了。</p><blockquote><p>使用硬盘镜像方式安装Kali Linux之后，系统的默认设置值如下所示。</p><p>● 硬盘容量：30 GB。</p><p>● 联网方式：NAT。</p><p>● 用户名：root。</p><p>● 密码：toor。</p><p>如果要把 Kali当做渗透测试平台使用，应当避免以 NAT方式接入网络。本文推荐您以桥接（bridged）方式联网。</p><p>在配置Kali VM 的时候，应当尽快更改默认密码。</p></blockquote><h4 id="portable-Kali-Linux"><a href="#portable-Kali-Linux" class="headerlink" title="portable Kali Linux"></a>portable Kali Linux</h4><ul><li><input disabled="" type="checkbox"> 未实操，待修改</li></ul><p>安装Kali Linux 的第三种方法，就是把它安装到USB 闪存里。通常，人们把安装在闪存上的Kali Linux 叫做portable（便携）Kali Linux。按照Kali官方文件的说法，这种安装方式的启动和安装速度最快，是Kali研发人员最喜欢的安装方式。相比在硬盘上安装，只能在一台机器上启动Kali 系统而言，装有Kali Linux 的闪存盘可以在所有支持USB 启动的主机上使用Kali系统。</p><p>这种安装方法同样适合在内存卡（SSD、SDHC、SDXC 等）上安装Kali Linux。</p><p>很多工具都可以制作portable Kali Linux。其中，Rufus（<a href="http://rufus.akeo.ie)就不错.这个工具只能在windows操作系统下运行./">http://rufus.akeo.ie）就不错。这个工具只能在Windows操作系统下运行。</a></p><p>其他可从ISO镜像文件制作可启动USB的工具如下所示：</p><p>● Win32DiskImager（<a href="https://launchpad.net/win32-image-writer%EF%BC%89%EF%BC%9B">https://launchpad.net/win32-image-writer）；</a></p><p>● Universal USB Installer（<a href="http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/%EF%BC%89%EF%BC%9B">http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/）；</a></p><p>● Linux Live USB Creator（<a href="http://www.linuxliveusb.com/">http://www.linuxliveusb.com</a>)</p><p>在制作portable Kali Linux 之前，您需要准备好几样素材。</p><p>● Kali Linux 的ISO 镜像文件：虽然您可以使用启动磁盘创建工具直接下载镜像文件，但是我们仍然认为提前下载好ISO镜像文件，再用Rufus使用镜像文件比较稳妥。</p><p>● USB 闪存盘：您需要一个容量足够大的 USB 闪存盘。我们推荐您使用 16GB 以上的闪存盘。</p><p>在下载Rufus之后，在Windows里双击rufus.exe文件就可以运行它。它会显示出程序界面。</p><p>如果您使用的是基于UNIX的操作系统，您可以直接使用dd指令创建可启动闪存盘。例如：</p><p>dd if&#x3D;kali-linux-1.0.1-i386.iso of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;512k</p><p>此处的&#x2F;dev&#x2F;sdb应当是您USB闪存盘的设备名称。</p><p>使用Rufus 创建可启动的Kali USB 闪存盘的设置如下。</p><p>● Device：选择USB 闪存驱动器。本例中，它是Windows 系统的E 盘。</p><p>● Partition scheme and target system type：设置为MBR partition scheme for BIOS or UEFI computers。</p><p>● Create a bootable disk using：设置为ISO Image 并使用右侧磁盘图标选取ISO 镜像文件。</p><p>然后点击Start创建可启动闪存盘。</p><p>在完成这些步骤之后，如果您想要立即测试USB闪存盘，则应在保存好所有文件的情况下重启计算机。您可能需要配置计算机的 BIOS，使其从 USB 磁盘启动计算机。如果没有问题的话，您应该可以通过USB 闪存盘启动Kali Linux 系统。</p><p>在USB闪存盘上安装系统之后，如果您想要让系统能够保存您所更改的文件（即persistence capabilities），您可参照Kali官方文档进行设置。请参见 Adding Persistence to Your Kali Live USB，地址为<a href="http://docs.kali.org/installation/kali-linux-live-usb-install">http://docs.kali.org/installation/kali-linux-live-usb-install</a></p><h3 id="1-4-虚拟机配置"><a href="#1-4-虚拟机配置" class="headerlink" title="1.4 虚拟机配置"></a>1.4 虚拟机配置</h3><h4 id="1-4-1-设置中文"><a href="#1-4-1-设置中文" class="headerlink" title="1.4.1 设置中文"></a>1.4.1 设置中文</h4><p>刚下好kali linux，就被全英文劝退可不太好。一看到密密麻麻的英文就敲起了退堂鼓，所以首先把系统语言设置成中文。</p><p>Learn more：<a href="https://blog.csdn.net/KNIGH_YUN/article/details/105543094">Kali Linux系统设置中文语言环境-1_kali中文设置-CSDN博客</a></p><p>具体步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>选择语言，使用空格键选中。选择en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8</p><p><img src="https://img-blog.csdnimg.cn/4346e90fd26c4a17835bcd4d3ddc6474.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>选中zh_CN.UTF-8为默认语言。</p><p><img src="https://img-blog.csdnimg.cn/8fc88465e1ee4af9b87e0f029e8c2859.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br></pre></td></tr></table></figure><p>下载字体</p><p>重启虚拟机。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-settings-zh_en.png" alt="设置中文界面"></p><p>当然，以上方法并非唯一方法，如果安装了图形界面也可以直接在设置里修改语言（X-windows），或者通过CLI修改系统配置文件。</p><h4 id="1-4-2-网络设置"><a href="#1-4-2-网络设置" class="headerlink" title="1.4.2 网络设置"></a>1.4.2 网络设置</h4><p>1．配置有线网络</p><p>无论是通过VMware 磁盘镜像还是通过ISO镜像安装Kali Linux，默认情况下Kali Linux接入网络的方式都是NAT（网络地址转换）。在NAT方式下，Kali Linux的虚拟机可以通过物理主机联入外部网络，而外部网络甚至是物理主机自身都无法直接访问安装有Kali Linux的虚拟机。</p><p>进行实地的渗透测试时，您可能需要把网络结构变更为Bridged Adapter。</p><p>如需使用桥接连接，首先要使物理主机与网络设备连接，例如路由器或交换机。同时，接入的网络里应当有DHCP服务，以分配IP地址给虚拟机。</p><p>您可能已经注意到了，通过DHCP获取的IP地址并不是固定的IP地址，这种IP地址在一定时间后可能会发生变化。如果Kali Linux 通过DHCP 获取IP 地址，在超过固定周期（DHCP的租赁时间）之后，DHCP会重新给虚拟机分配一次IP地址。重新分配的IP地址可能和上次分配的IP地址相同，也可能不同。</p><p>如果虚拟机需要使用固定的 IP 地址，应该修改虚拟机的网络设置文件&#x2F;etc&#x2F;network&#x2F;interfaces。</p><p>默认情况下，Kali Linux 的网络设置文件如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line"></span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>这个配置文件指定所有网卡都通过DHCP获取IP地址。如需为虚拟机绑定固定IP地址，就不得不对这个文件进行相应修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"></span><br><span class="line">iface eth0 inet static</span><br><span class="line"></span><br><span class="line">address 10.0.2.15</span><br><span class="line"></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">network 10.0.2.0</span><br><span class="line"></span><br><span class="line">broadcast 10.0.2.255</span><br><span class="line"></span><br><span class="line">gateway 10.0.2.2</span><br></pre></td></tr></table></figure><p>上述文件令第一个有线网卡eth0 绑定了 IP 地址10.0.2.15。您可能需要根据实际情况修改上述设置。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-查看网络配置.png"></p><p>手动设置网络：</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-网络配置.png"></p><p>error：</p><p>配置了域名服务器后导致ping其他网站都无法解析域名。</p><h4 id="1-5-3-文件夹共享"><a href="#1-5-3-文件夹共享" class="headerlink" title="1.5.3 文件夹共享"></a>1.5.3 文件夹共享</h4><h4 id="1-5-4-快照备份"><a href="#1-5-4-快照备份" class="headerlink" title="1.5.4 快照备份"></a>1.5.4 快照备份</h4><p>一旦您把虚拟机配置到理想的可工作状态，我们建议您立刻对虚拟机进行快照备份。万一日后出现配置故障，可利用快照备份把虚拟机迅速恢复到正常工作状态。</p><h4 id="1-5-5-导出虚拟机"><a href="#1-5-5-导出虚拟机" class="headerlink" title="1.5.5 导出虚拟机"></a>1.5.5 导出虚拟机</h4><p>人们时常需要以文件形式备份虚拟机，或通过这种方法把虚拟机分享给他人使用。VirtualBox的虚拟机导出功能简化了这种操作。在关闭需要导出的虚拟机之后，在菜单栏选中File | Export Appliance 就可导出所选的虚拟机。</p><h3 id="1-5-系统更新"><a href="#1-5-系统更新" class="headerlink" title="1.5 系统更新"></a>1.5 系统更新</h3><p>Kali Linux 由操作系统内核和数百个软件构成。如果需要使用软件的最新功能，您就需要将其更新到最新的版本。</p><p>我们建议您仅从Kali Linux 官方的软件仓库（repository）进行更新。</p><p>在您安装和配置好Kali Linux 之后，就应当立即进行系统更新。因为Kali 是基于Debian的操作系统，您需要使用Debian的指令（apt-get）进行系统更新。</p><p>更新指令apt-get会查询&#x2F;etc&#x2F;apt&#x2F;sources.list文件，从中获取更新服务器的信息。您需要确定这个文件指定了正确的升级服务器。</p><p>默认情况下，Kali Linux 的sources.list 文件包含下述信息。</p><h4 id="其他：apt更换国内源"><a href="#其他：apt更换国内源" class="headerlink" title="其他：apt更换国内源"></a>其他：apt更换国内源</h4><p>Kali Linux 会从系统默认的软件源去安装软件，但默认的软件源速度通常比较慢（国外的源），因此需要将其替换成国内的源。</p><p>以下是常用的国内源网站：</p><p><a href="https://opsx.alibaba.com/mirror?lang=zh-CN">阿里云镜像开源镜像站（已经更换地址）</a><br><a href="https://developer.aliyun.com/mirror/">阿里云镜像开源社区镜像站（新地址）</a><br><a href="http://mirrors.163.com/.help/ubuntu.html">网易开源镜像站</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源镜像站</a><br><a href="https://mirrors.ustc.edu.cn/">中科大开源镜像站</a></p><p>修改方式：apt源的文件位置：&#x2F;etc&#x2F;apt&#x2F;sources.list</p><blockquote><p>注意：是&#x2F;etc&#x2F;apt&#x2F;sources.list，不是&#x2F;etc&#x2F;apt&#x2F;source.list（非常重要）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.bak1</span><br><span class="line">#第一个参数时拷贝的文件路径和文件名称,第二个是拷贝到(粘贴)的文件路径和文件名</span><br><span class="line"></span><br><span class="line">sudo mousepad /etc/apt/sources.list</span><br><span class="line">#用mousepad可以直接从系统粘贴板粘贴，比vim和vi更方便操作</span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line"># deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#根据需要自己选一个，中科大的还可以</span><br><span class="line">#中科大</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">#阿里云</span><br><span class="line">#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#清华大学</span><br><span class="line">#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#浙大</span><br><span class="line">#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#东软大学</span><br><span class="line">#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#重庆大学</span><br><span class="line">#deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><blockquote><p>注：vim和vi的操作习惯很”程序员风格”，不熟悉的情况下很难使用，以下是一个vim操作的视频</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p></blockquote><p>一个小插曲：我之前的Kali虚拟机就是因为vim操作不当修改了root文件，加上安装了很多包之后经常卡顿死机，所以重新装了一个新的，实在是血的教训。</p><p>更新完之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update 更新索引</span><br><span class="line"></span><br><span class="line">apt-get upgrade 更新软件</span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade 升级</span><br><span class="line"></span><br><span class="line">apt-get clean 删除缓存包</span><br><span class="line"></span><br><span class="line">apt-get autoclean 删除未安装的deb包</span><br></pre></td></tr></table></figure><p>error:</p><p><img src="D:/hexo/source/_posts/img/Network-attack/apt-无法解析域名.png"></p><p>目前网络配置有问题，解决后再写xia’wen<br> |      |<br>| 出版印刷时间: | 2015-2                                                       |      |<br>| 出版社:       | 人民邮电出版社                                               |      |<br>| 图书作者:     | Lee Allen &#x2F; Tedi Heriyanto &#x2F; Shakeel Ali 著                  |      |<br>| 译者          | Archer 译                                                    |      |<br>| ISBN:         | 9787115378446                                                |      |</p><table><thead><tr><th>图书名称:</th><th>Kali Linux2 网络渗透测试实践指南 第2版</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td></td><td></td></tr></tbody></table><p>[TOC]</p><h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="参考书-2"><a href="#参考书-2" class="headerlink" title="参考书"></a>参考书</h3><table><thead><tr><th>图书名称:</th><th>Kali Linux: Assuring Security by Penetration Testing</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://jobrest.gitbooks.io/kali-linux-cn/content/assets/feng_mian.jpeg" alt="封面"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2015-2</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>Lee Allen &#x2F; Tedi Heriyanto &#x2F; Shakeel Ali 著</td><td></td></tr><tr><td>译者</td><td>Archer 译</td><td></td></tr><tr><td>ISBN:</td><td>9787115378446</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Kali Linux2 网络渗透测试实践指南 第2版</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34261078.jpg" alt="Kali Linux2 网络渗透测试实践指南 第2版"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-3</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>李华峰 著</td><td></td></tr><tr><td>ISBN:</td><td>9787115555410</td><td></td></tr></tbody></table><h3 id="友链-1"><a href="#友链-1" class="headerlink" title="友链"></a>友链</h3><p>书籍在线阅读地址：<a href="https://jobrest.gitbooks.io/kali-linux-cn/content/index.html">Kali Linux 渗透测试的艺术（中文版） | Kali Linux 渗透测试的艺术（中文版） (gitbooks.io)</a></p><p>官网：<a href="https://www.kali.org/">Kali Linux 操作系统 |渗透测试和道德黑客 Linux 发行版</a></p><p>文档：<a href="https://www.kali.org/docs/">Kali Docs | Kali Linux Documentation</a></p><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><h3 id="何为玩转kali？-1"><a href="#何为玩转kali？-1" class="headerlink" title="何为玩转kali？"></a>何为玩转kali？</h3><p>当然是想随心所欲，让“所见即所得”，让“所想立即实现”，那么此篇就是完成这个任务。</p><h2 id="第1章-Kali-Linux入门-1"><a href="#第1章-Kali-Linux入门-1" class="headerlink" title="第1章 Kali Linux入门"></a>第1章 Kali Linux入门</h2><h3 id="1-1-Kali的发展简史-1"><a href="#1-1-Kali的发展简史-1" class="headerlink" title="1.1 Kali的发展简史"></a>1.1 Kali的发展简史</h3><p>Kali Linux（Kali）是专门用于渗透测试的Linux操作系统，它由BackTrack 发展而来。在整合了IWHAX、WHOPPIX 和Auditor 这3 种渗透测试专用Live Linux 之后，BackTrack正式改名为Kali Linux。</p><p>BackTrack是相当著名的Linux发行版本。在BackTrack发布4.0预览版的时候，它的下载次数已经超过了400万次。</p><p>Kali Linux 1.0 版于2013年3 月12 日问世。在5天之后，官方为修复USB 键盘的支持问题而发布了1.0.1 版。在这短短的5 天之内，Kali 的下载次数就超过了9 万次。</p><p>根据官网的介绍（<a href="http://docs.kali.org/introduction/what-is-kali-linux%EF%BC%89%EF%BC%8C">http://docs.kali.org/introduction/what-is-kali-linux），</a> Kali的主要特色有：</p><p>● 它是基于Debian 的Linux 发行版；</p><p>● 它集成300 多个渗透测试程序；</p><p>● 它支持绝大多数的无线网卡；</p><p>● 它修改了内核以支持（无线）数据包注入；</p><p>● 所有的软件包都有研发团队的PGP 签名；</p><p>● 用户可以自制满足各自需求的Kali Linux 发行版；</p><p>● 支持基于ARM 的硬件系统。</p><h3 id="1-2-Kali-Linux工具包-1"><a href="#1-2-Kali-Linux工具包-1" class="headerlink" title="1.2 Kali Linux工具包"></a>1.2 Kali Linux工具包</h3><p>Kali Linux 含有可用于渗透测试的各种工具。这些工具程序大体可以分为以下几类。</p><p>● 信息收集：这类工具可用来收集目标的 DNS、IDS&#x2F;IPS、网络扫描、操作系统、路由、SSL、SMB、VPN、VoIP、SNMP信息和E-mail地址。</p><p>● 漏洞评估：这类工具都可以扫描目标系统上的漏洞。部分工具可以检测Cisco 网络系统缺陷，有些还可以评估各种数据库系统的安全问题。很多模糊测试软件都属于漏洞评估工具。</p><p>● Web应用：即与Web应用有关的工具。它包括CMS（内容管理系统）扫描器、数据库漏洞利用程序、Web应用模糊测试、Web应用代理、Web爬虫及Web漏洞扫描器。</p><p>● 密码攻击：无论是在线攻击还是离线破解，只要是能够实施密码攻击的工具都属于密码攻击类工具。</p><p>● 漏洞利用：这类工具可以利用在目标系统中发现的漏洞。攻击网络、Web 和数据库漏洞的软件，都属于漏洞利用（exploitation）工具。Kali 中的某些软件可以针对漏洞情况进行社会工程学攻击。</p><p>● 网络监听：这类工具用于监听网络和Web 流量。网络监听需要进行网络欺骗，所以Ettercap和Yersinia这类软件也归于这类软件。</p><p>● 访问维护：这类工具帮助渗透人员维持他们对目标主机的访问权。某些情况下，渗透人员必须先获取主机的最高权限才能安装这类软件。这类软件包括用于在 Web应用和操作系统安装后门的程序，以及隧道类工具。</p><p>● 报告工具：如果您需要撰写渗透测试的报告文件，您应该用得上这些软件。</p><p>● 系统服务：这是渗透人员在渗透测试时可能用到的常见服务类软件，它包括Apache服务、MySQL服务、SSH服务和Metasploit服务。</p><p>为了降低渗透测试人员筛选工具的难度，Kali Linux 单独划分了一类软件——Top 10 Security Tools，即10 大首选安全工具。这10 大工具分别是aircrack-ng、burp-suite、hydra、john、maltego、metasploit、nmap、sqlmap、wireshark和zaproxy。</p><p>除了可用于渗透测试的各种工具以外，Kali Linux 还整合了以下几类工具。</p><p>● 无线攻击：可攻击蓝牙、RFID&#x2F;NFC 和其他无线设备的工具。</p><p>● 逆向工程：可用于调试程序或反汇编的工具。</p><p>● 压力测试：用于各类压力测试的工具集。它们可测试网络、无线、Web 和 VoIP 系统的负载能力。</p><p>● 硬件破解：用于调试Android 和Arduino 程序的工具。</p><p>● 法证调查：即电子取证的工具。它的各种工具可以用于制作硬盘磁盘镜像、文件分析、硬盘镜像分析。如需使用这类程序，首先要在启动菜单里选择 Kali Linux Forensics | No Drives or Swap Mount。在开启这个选项以后，Kali Linux不会自动加载硬盘驱动器，以保护硬盘数据的完整性。</p><h3 id="1-3下载Kali-Linux-1"><a href="#1-3下载Kali-Linux-1" class="headerlink" title="1.3下载Kali Linux"></a>1.3下载Kali Linux</h3><p>下载是第一步要做的事情，经常使用计算机的人对下载肯定不陌生，但要想面向大众还是要解释清楚。</p><ul><li><p><input disabled="" type="checkbox"> 待补充</p></li><li><p><input disabled="" type="checkbox"> 验证哈希值</p></li></ul><h5 id="在虚拟机里使用-VM-镜像安装-Kali-Linux-1"><a href="#在虚拟机里使用-VM-镜像安装-Kali-Linux-1" class="headerlink" title="在虚拟机里使用 VM 镜像安装 Kali Linux"></a>在虚拟机里使用 VM 镜像安装 Kali Linux</h5><p>Kali Linux的iso镜像和虚拟机vmx文件等在Kali官网都有，直接下载就可以，而且下载速度也不赖。</p><p>这里我推荐直接下载Kali官方的虚拟机vmx文件，下载好了直接打开就能用，免去了很多配置环节。之前也尝试过用iso镜像做VMware，但试了几次遇到很多麻烦，因此就不搞了。</p><blockquote><p>使用硬盘镜像方式安装Kali Linux之后，系统的默认设置值如下所示。</p><p>● 硬盘容量：30 GB。</p><p>● 联网方式：NAT。</p><p>● 用户名：root。</p><p>● 密码：toor。</p><p>如果要把 Kali当做渗透测试平台使用，应当避免以 NAT方式接入网络。本文推荐您以桥接（bridged）方式联网。</p><p>在配置Kali VM 的时候，应当尽快更改默认密码。</p></blockquote><h4 id="portable-Kali-Linux-1"><a href="#portable-Kali-Linux-1" class="headerlink" title="portable Kali Linux"></a>portable Kali Linux</h4><ul><li><input disabled="" type="checkbox"> 未实操，待修改</li></ul><p>安装Kali Linux 的第三种方法，就是把它安装到USB 闪存里。通常，人们把安装在闪存上的Kali Linux 叫做portable（便携）Kali Linux。按照Kali官方文件的说法，这种安装方式的启动和安装速度最快，是Kali研发人员最喜欢的安装方式。相比在硬盘上安装，只能在一台机器上启动Kali 系统而言，装有Kali Linux 的闪存盘可以在所有支持USB 启动的主机上使用Kali系统。</p><p>这种安装方法同样适合在内存卡（SSD、SDHC、SDXC 等）上安装Kali Linux。</p><p>很多工具都可以制作portable Kali Linux。其中，Rufus（<a href="http://rufus.akeo.ie)就不错.这个工具只能在windows操作系统下运行./">http://rufus.akeo.ie）就不错。这个工具只能在Windows操作系统下运行。</a></p><p>其他可从ISO镜像文件制作可启动USB的工具如下所示：</p><p>● Win32DiskImager（<a href="https://launchpad.net/win32-image-writer%EF%BC%89%EF%BC%9B">https://launchpad.net/win32-image-writer）；</a></p><p>● Universal USB Installer（<a href="http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/%EF%BC%89%EF%BC%9B">http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/）；</a></p><p>● Linux Live USB Creator（<a href="http://www.linuxliveusb.com/">http://www.linuxliveusb.com</a>)</p><p>在制作portable Kali Linux 之前，您需要准备好几样素材。</p><p>● Kali Linux 的ISO 镜像文件：虽然您可以使用启动磁盘创建工具直接下载镜像文件，但是我们仍然认为提前下载好ISO镜像文件，再用Rufus使用镜像文件比较稳妥。</p><p>● USB 闪存盘：您需要一个容量足够大的 USB 闪存盘。我们推荐您使用 16GB 以上的闪存盘。</p><p>在下载Rufus之后，在Windows里双击rufus.exe文件就可以运行它。它会显示出程序界面。</p><p>如果您使用的是基于UNIX的操作系统，您可以直接使用dd指令创建可启动闪存盘。例如：</p><p>dd if&#x3D;kali-linux-1.0.1-i386.iso of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;512k</p><p>此处的&#x2F;dev&#x2F;sdb应当是您USB闪存盘的设备名称。</p><p>使用Rufus 创建可启动的Kali USB 闪存盘的设置如下。</p><p>● Device：选择USB 闪存驱动器。本例中，它是Windows 系统的E 盘。</p><p>● Partition scheme and target system type：设置为MBR partition scheme for BIOS or UEFI computers。</p><p>● Create a bootable disk using：设置为ISO Image 并使用右侧磁盘图标选取ISO 镜像文件。</p><p>然后点击Start创建可启动闪存盘。</p><p>在完成这些步骤之后，如果您想要立即测试USB闪存盘，则应在保存好所有文件的情况下重启计算机。您可能需要配置计算机的 BIOS，使其从 USB 磁盘启动计算机。如果没有问题的话，您应该可以通过USB 闪存盘启动Kali Linux 系统。</p><p>在USB闪存盘上安装系统之后，如果您想要让系统能够保存您所更改的文件（即persistence capabilities），您可参照Kali官方文档进行设置。请参见 Adding Persistence to Your Kali Live USB，地址为<a href="http://docs.kali.org/installation/kali-linux-live-usb-install">http://docs.kali.org/installation/kali-linux-live-usb-install</a></p><h3 id="1-4-虚拟机配置-1"><a href="#1-4-虚拟机配置-1" class="headerlink" title="1.4 虚拟机配置"></a>1.4 虚拟机配置</h3><h4 id="1-4-1-设置中文-1"><a href="#1-4-1-设置中文-1" class="headerlink" title="1.4.1 设置中文"></a>1.4.1 设置中文</h4><p>刚下好kali linux，就被全英文劝退可不太好。一看到密密麻麻的英文就敲起了退堂鼓，所以首先把系统语言设置成中文。</p><p>Learn more：<a href="https://blog.csdn.net/KNIGH_YUN/article/details/105543094">Kali Linux系统设置中文语言环境-1_kali中文设置-CSDN博客</a></p><p>具体步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>选择语言，使用空格键选中。选择en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8</p><p><img src="https://img-blog.csdnimg.cn/4346e90fd26c4a17835bcd4d3ddc6474.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>选中zh_CN.UTF-8为默认语言。</p><p><img src="https://img-blog.csdnimg.cn/8fc88465e1ee4af9b87e0f029e8c2859.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br></pre></td></tr></table></figure><p>下载字体</p><p>重启虚拟机。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-settings-zh_en.png" alt="设置中文界面"></p><p>当然，以上方法并非唯一方法，如果安装了图形界面也可以直接在设置里修改语言（X-windows），或者通过CLI修改系统配置文件。</p><h4 id="1-4-2-网络设置-1"><a href="#1-4-2-网络设置-1" class="headerlink" title="1.4.2 网络设置"></a>1.4.2 网络设置</h4><p>1．配置有线网络</p><p>无论是通过VMware 磁盘镜像还是通过ISO镜像安装Kali Linux，默认情况下Kali Linux接入网络的方式都是NAT（网络地址转换）。在NAT方式下，Kali Linux的虚拟机可以通过物理主机联入外部网络，而外部网络甚至是物理主机自身都无法直接访问安装有Kali Linux的虚拟机。</p><p>进行实地的渗透测试时，您可能需要把网络结构变更为Bridged Adapter。</p><p>如需使用桥接连接，首先要使物理主机与网络设备连接，例如路由器或交换机。同时，接入的网络里应当有DHCP服务，以分配IP地址给虚拟机。</p><p>您可能已经注意到了，通过DHCP获取的IP地址并不是固定的IP地址，这种IP地址在一定时间后可能会发生变化。如果Kali Linux 通过DHCP 获取IP 地址，在超过固定周期（DHCP的租赁时间）之后，DHCP会重新给虚拟机分配一次IP地址。重新分配的IP地址可能和上次分配的IP地址相同，也可能不同。</p><p>如果虚拟机需要使用固定的 IP 地址，应该修改虚拟机的网络设置文件&#x2F;etc&#x2F;network&#x2F;interfaces。</p><p>默认情况下，Kali Linux 的网络设置文件如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line"></span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>这个配置文件指定所有网卡都通过DHCP获取IP地址。如需为虚拟机绑定固定IP地址，就不得不对这个文件进行相应修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"></span><br><span class="line">iface eth0 inet static</span><br><span class="line"></span><br><span class="line">address 10.0.2.15</span><br><span class="line"></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">network 10.0.2.0</span><br><span class="line"></span><br><span class="line">broadcast 10.0.2.255</span><br><span class="line"></span><br><span class="line">gateway 10.0.2.2</span><br></pre></td></tr></table></figure><p>上述文件令第一个有线网卡eth0 绑定了 IP 地址10.0.2.15。您可能需要根据实际情况修改上述设置。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-查看网络配置.png"></p><p>手动设置网络：</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-网络配置.png"></p><p>error：</p><p>配置了域名服务器后导致ping其他网站都无法解析域名。</p><h4 id="1-5-3-文件夹共享-1"><a href="#1-5-3-文件夹共享-1" class="headerlink" title="1.5.3 文件夹共享"></a>1.5.3 文件夹共享</h4><h4 id="1-5-4-快照备份-1"><a href="#1-5-4-快照备份-1" class="headerlink" title="1.5.4 快照备份"></a>1.5.4 快照备份</h4><p>一旦您把虚拟机配置到理想的可工作状态，我们建议您立刻对虚拟机进行快照备份。万一日后出现配置故障，可利用快照备份把虚拟机迅速恢复到正常工作状态。</p><h4 id="1-5-5-导出虚拟机-1"><a href="#1-5-5-导出虚拟机-1" class="headerlink" title="1.5.5 导出虚拟机"></a>1.5.5 导出虚拟机</h4><p>人们时常需要以文件形式备份虚拟机，或通过这种方法把虚拟机分享给他人使用。VirtualBox的虚拟机导出功能简化了这种操作。在关闭需要导出的虚拟机之后，在菜单栏选中File | Export Appliance 就可导出所选的虚拟机。</p><h3 id="1-5-系统更新-1"><a href="#1-5-系统更新-1" class="headerlink" title="1.5 系统更新"></a>1.5 系统更新</h3><p>Kali Linux 由操作系统内核和数百个软件构成。如果需要使用软件的最新功能，您就需要将其更新到最新的版本。</p><p>我们建议您仅从Kali Linux 官方的软件仓库（repository）进行更新。</p><p>在您安装和配置好Kali Linux 之后，就应当立即进行系统更新。因为Kali 是基于Debian的操作系统，您需要使用Debian的指令（apt-get）进行系统更新。</p><p>更新指令apt-get会查询&#x2F;etc&#x2F;apt&#x2F;sources.list文件，从中获取更新服务器的信息。您需要确定这个文件指定了正确的升级服务器。</p><p>默认情况下，Kali Linux 的sources.list 文件包含下述信息。</p><h4 id="其他：apt更换国内源-1"><a href="#其他：apt更换国内源-1" class="headerlink" title="其他：apt更换国内源"></a>其他：apt更换国内源</h4><p>Kali Linux 会从系统默认的软件源去安装软件，但默认的软件源速度通常比较慢（国外的源），因此需要将其替换成国内的源。</p><p>以下是常用的国内源网站：</p><p><a href="https://opsx.alibaba.com/mirror?lang=zh-CN">阿里云镜像开源镜像站（已经更换地址）</a><br><a href="https://developer.aliyun.com/mirror/">阿里云镜像开源社区镜像站（新地址）</a><br><a href="http://mirrors.163.com/.help/ubuntu.html">网易开源镜像站</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源镜像站</a><br><a href="https://mirrors.ustc.edu.cn/">中科大开源镜像站</a></p><p>修改方式：apt源的文件位置：&#x2F;etc&#x2F;apt&#x2F;sources.list</p><blockquote><p>注意：是&#x2F;etc&#x2F;apt&#x2F;sources.list，不是&#x2F;etc&#x2F;apt&#x2F;source.list（非常重要）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.bak1</span><br><span class="line">#第一个参数时拷贝的文件路径和文件名称,第二个是拷贝到(粘贴)的文件路径和文件名</span><br><span class="line"></span><br><span class="line">sudo mousepad /etc/apt/sources.list</span><br><span class="line">#用mousepad可以直接从系统粘贴板粘贴，比vim和vi更方便操作</span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line"># deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#根据需要自己选一个，中科大的还可以</span><br><span class="line">#中科大</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">#阿里云</span><br><span class="line">#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#清华大学</span><br><span class="line">#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#浙大</span><br><span class="line">#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#东软大学</span><br><span class="line">#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#重庆大学</span><br><span class="line">#deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><blockquote><p>注：vim和vi的操作习惯很”程序员风格”，不熟悉的情况下很难使用，以下是一个vim操作的视频</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p></blockquote><p>一个小插曲：我之前的Kali虚拟机就是因为vim操作不当修改了root文件，加上安装了很多包之后经常卡顿死机，所以重新装了一个新的，实在是血的教训。</p><p>更新完之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update 更新索引</span><br><span class="line"></span><br><span class="line">apt-get upgrade 更新软件</span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade 升级</span><br><span class="line"></span><br><span class="line">apt-get clean 删除缓存包</span><br><span class="line"></span><br><span class="line">apt-get autoclean 删除未安装的deb包</span><br></pre></td></tr></table></figure><p>error:</p><p><img src="D:/hexo/source/_posts/img/Network-attack/apt-无法解析域名.png"></p><p>目前网络配置有问题，解决后再写xia’wen<br> |      |<br>| 出版印刷时间: | 2021-3                                                       |      |<br>| 出版社:       | 人民邮电出版社                                               |      |<br>| 图书作者:     | 李华峰 著                                                    |      |<br>| ISBN:         | 9787115555410                                                |      |</p><h3 id="友链-2"><a href="#友链-2" class="headerlink" title="友链"></a>友链</h3><p>书籍在线阅读地址：<a href="https://jobrest.gitbooks.io/kali-linux-cn/content/index.html">Kali Linux 渗透测试的艺术（中文版） | Kali Linux 渗透测试的艺术（中文版） (gitbooks.io)</a></p><p>官网：<a href="https://www.kali.org/">Kali Linux 操作系统 |渗透测试和道德黑客 Linux 发行版</a></p><p>文档：<a href="https://www.kali.org/docs/">Kali Docs | Kali Linux Documentation</a></p><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><h3 id="何为玩转kali？-2"><a href="#何为玩转kali？-2" class="headerlink" title="何为玩转kali？"></a>何为玩转kali？</h3><p>当然是想随心所欲，让“所见即所得”，让“所想立即实现”，那么此篇就是完成这个任务。</p><h2 id="第1章-Kali-Linux入门-2"><a href="#第1章-Kali-Linux入门-2" class="headerlink" title="第1章 Kali Linux入门"></a>第1章 Kali Linux入门</h2><h3 id="1-1-Kali的发展简史-2"><a href="#1-1-Kali的发展简史-2" class="headerlink" title="1.1 Kali的发展简史"></a>1.1 Kali的发展简史</h3><p>Kali Linux（Kali）是专门用于渗透测试的Linux操作系统，它由BackTrack 发展而来。在整合了IWHAX、WHOPPIX 和Auditor 这3 种渗透测试专用Live Linux 之后，BackTrack正式改名为Kali Linux。</p><p>BackTrack是相当著名的Linux发行版本。在BackTrack发布4.0预览版的时候，它的下载次数已经超过了400万次。</p><p>Kali Linux 1.0 版于2013年3 月12 日问世。在5天之后，官方为修复USB 键盘的支持问题而发布了1.0.1 版。在这短短的5 天之内，Kali 的下载次数就超过了9 万次。</p><p>根据官网的介绍（<a href="http://docs.kali.org/introduction/what-is-kali-linux%EF%BC%89%EF%BC%8C">http://docs.kali.org/introduction/what-is-kali-linux），</a> Kali的主要特色有：</p><p>● 它是基于Debian 的Linux 发行版；</p><p>● 它集成300 多个渗透测试程序；</p><p>● 它支持绝大多数的无线网卡；</p><p>● 它修改了内核以支持（无线）数据包注入；</p><p>● 所有的软件包都有研发团队的PGP 签名；</p><p>● 用户可以自制满足各自需求的Kali Linux 发行版；</p><p>● 支持基于ARM 的硬件系统。</p><h3 id="1-2-Kali-Linux工具包-2"><a href="#1-2-Kali-Linux工具包-2" class="headerlink" title="1.2 Kali Linux工具包"></a>1.2 Kali Linux工具包</h3><p>Kali Linux 含有可用于渗透测试的各种工具。这些工具程序大体可以分为以下几类。</p><p>● 信息收集：这类工具可用来收集目标的 DNS、IDS&#x2F;IPS、网络扫描、操作系统、路由、SSL、SMB、VPN、VoIP、SNMP信息和E-mail地址。</p><p>● 漏洞评估：这类工具都可以扫描目标系统上的漏洞。部分工具可以检测Cisco 网络系统缺陷，有些还可以评估各种数据库系统的安全问题。很多模糊测试软件都属于漏洞评估工具。</p><p>● Web应用：即与Web应用有关的工具。它包括CMS（内容管理系统）扫描器、数据库漏洞利用程序、Web应用模糊测试、Web应用代理、Web爬虫及Web漏洞扫描器。</p><p>● 密码攻击：无论是在线攻击还是离线破解，只要是能够实施密码攻击的工具都属于密码攻击类工具。</p><p>● 漏洞利用：这类工具可以利用在目标系统中发现的漏洞。攻击网络、Web 和数据库漏洞的软件，都属于漏洞利用（exploitation）工具。Kali 中的某些软件可以针对漏洞情况进行社会工程学攻击。</p><p>● 网络监听：这类工具用于监听网络和Web 流量。网络监听需要进行网络欺骗，所以Ettercap和Yersinia这类软件也归于这类软件。</p><p>● 访问维护：这类工具帮助渗透人员维持他们对目标主机的访问权。某些情况下，渗透人员必须先获取主机的最高权限才能安装这类软件。这类软件包括用于在 Web应用和操作系统安装后门的程序，以及隧道类工具。</p><p>● 报告工具：如果您需要撰写渗透测试的报告文件，您应该用得上这些软件。</p><p>● 系统服务：这是渗透人员在渗透测试时可能用到的常见服务类软件，它包括Apache服务、MySQL服务、SSH服务和Metasploit服务。</p><p>为了降低渗透测试人员筛选工具的难度，Kali Linux 单独划分了一类软件——Top 10 Security Tools，即10 大首选安全工具。这10 大工具分别是aircrack-ng、burp-suite、hydra、john、maltego、metasploit、nmap、sqlmap、wireshark和zaproxy。</p><p>除了可用于渗透测试的各种工具以外，Kali Linux 还整合了以下几类工具。</p><p>● 无线攻击：可攻击蓝牙、RFID&#x2F;NFC 和其他无线设备的工具。</p><p>● 逆向工程：可用于调试程序或反汇编的工具。</p><p>● 压力测试：用于各类压力测试的工具集。它们可测试网络、无线、Web 和 VoIP 系统的负载能力。</p><p>● 硬件破解：用于调试Android 和Arduino 程序的工具。</p><p>● 法证调查：即电子取证的工具。它的各种工具可以用于制作硬盘磁盘镜像、文件分析、硬盘镜像分析。如需使用这类程序，首先要在启动菜单里选择 Kali Linux Forensics | No Drives or Swap Mount。在开启这个选项以后，Kali Linux不会自动加载硬盘驱动器，以保护硬盘数据的完整性。</p><h3 id="1-3下载Kali-Linux-2"><a href="#1-3下载Kali-Linux-2" class="headerlink" title="1.3下载Kali Linux"></a>1.3下载Kali Linux</h3><p>下载是第一步要做的事情，经常使用计算机的人对下载肯定不陌生，但要想面向大众还是要解释清楚。</p><ul><li><p><input disabled="" type="checkbox"> 待补充</p></li><li><p><input disabled="" type="checkbox"> 验证哈希值</p></li></ul><h5 id="在虚拟机里使用-VM-镜像安装-Kali-Linux-2"><a href="#在虚拟机里使用-VM-镜像安装-Kali-Linux-2" class="headerlink" title="在虚拟机里使用 VM 镜像安装 Kali Linux"></a>在虚拟机里使用 VM 镜像安装 Kali Linux</h5><p>Kali Linux的iso镜像和虚拟机vmx文件等在Kali官网都有，直接下载就可以，而且下载速度也不赖。</p><p>这里我推荐直接下载Kali官方的虚拟机vmx文件，下载好了直接打开就能用，免去了很多配置环节。之前也尝试过用iso镜像做VMware，但试了几次遇到很多麻烦，因此就不搞了。</p><blockquote><p>使用硬盘镜像方式安装Kali Linux之后，系统的默认设置值如下所示。</p><p>● 硬盘容量：30 GB。</p><p>● 联网方式：NAT。</p><p>● 用户名：root。</p><p>● 密码：toor。</p><p>如果要把 Kali当做渗透测试平台使用，应当避免以 NAT方式接入网络。本文推荐您以桥接（bridged）方式联网。</p><p>在配置Kali VM 的时候，应当尽快更改默认密码。</p></blockquote><h4 id="portable-Kali-Linux-2"><a href="#portable-Kali-Linux-2" class="headerlink" title="portable Kali Linux"></a>portable Kali Linux</h4><ul><li><input disabled="" type="checkbox"> 未实操，待修改</li></ul><p>安装Kali Linux 的第三种方法，就是把它安装到USB 闪存里。通常，人们把安装在闪存上的Kali Linux 叫做portable（便携）Kali Linux。按照Kali官方文件的说法，这种安装方式的启动和安装速度最快，是Kali研发人员最喜欢的安装方式。相比在硬盘上安装，只能在一台机器上启动Kali 系统而言，装有Kali Linux 的闪存盘可以在所有支持USB 启动的主机上使用Kali系统。</p><p>这种安装方法同样适合在内存卡（SSD、SDHC、SDXC 等）上安装Kali Linux。</p><p>很多工具都可以制作portable Kali Linux。其中，Rufus（<a href="http://rufus.akeo.ie)就不错.这个工具只能在windows操作系统下运行./">http://rufus.akeo.ie）就不错。这个工具只能在Windows操作系统下运行。</a></p><p>其他可从ISO镜像文件制作可启动USB的工具如下所示：</p><p>● Win32DiskImager（<a href="https://launchpad.net/win32-image-writer%EF%BC%89%EF%BC%9B">https://launchpad.net/win32-image-writer）；</a></p><p>● Universal USB Installer（<a href="http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/%EF%BC%89%EF%BC%9B">http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/）；</a></p><p>● Linux Live USB Creator（<a href="http://www.linuxliveusb.com/">http://www.linuxliveusb.com</a>)</p><p>在制作portable Kali Linux 之前，您需要准备好几样素材。</p><p>● Kali Linux 的ISO 镜像文件：虽然您可以使用启动磁盘创建工具直接下载镜像文件，但是我们仍然认为提前下载好ISO镜像文件，再用Rufus使用镜像文件比较稳妥。</p><p>● USB 闪存盘：您需要一个容量足够大的 USB 闪存盘。我们推荐您使用 16GB 以上的闪存盘。</p><p>在下载Rufus之后，在Windows里双击rufus.exe文件就可以运行它。它会显示出程序界面。</p><p>如果您使用的是基于UNIX的操作系统，您可以直接使用dd指令创建可启动闪存盘。例如：</p><p>dd if&#x3D;kali-linux-1.0.1-i386.iso of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;512k</p><p>此处的&#x2F;dev&#x2F;sdb应当是您USB闪存盘的设备名称。</p><p>使用Rufus 创建可启动的Kali USB 闪存盘的设置如下。</p><p>● Device：选择USB 闪存驱动器。本例中，它是Windows 系统的E 盘。</p><p>● Partition scheme and target system type：设置为MBR partition scheme for BIOS or UEFI computers。</p><p>● Create a bootable disk using：设置为ISO Image 并使用右侧磁盘图标选取ISO 镜像文件。</p><p>然后点击Start创建可启动闪存盘。</p><p>在完成这些步骤之后，如果您想要立即测试USB闪存盘，则应在保存好所有文件的情况下重启计算机。您可能需要配置计算机的 BIOS，使其从 USB 磁盘启动计算机。如果没有问题的话，您应该可以通过USB 闪存盘启动Kali Linux 系统。</p><p>在USB闪存盘上安装系统之后，如果您想要让系统能够保存您所更改的文件（即persistence capabilities），您可参照Kali官方文档进行设置。请参见 Adding Persistence to Your Kali Live USB，地址为<a href="http://docs.kali.org/installation/kali-linux-live-usb-install">http://docs.kali.org/installation/kali-linux-live-usb-install</a></p><h3 id="1-4-虚拟机配置-2"><a href="#1-4-虚拟机配置-2" class="headerlink" title="1.4 虚拟机配置"></a>1.4 虚拟机配置</h3><h4 id="1-4-1-设置中文-2"><a href="#1-4-1-设置中文-2" class="headerlink" title="1.4.1 设置中文"></a>1.4.1 设置中文</h4><p>刚下好kali linux，就被全英文劝退可不太好。一看到密密麻麻的英文就敲起了退堂鼓，所以首先把系统语言设置成中文。</p><p>Learn more：<a href="https://blog.csdn.net/KNIGH_YUN/article/details/105543094">Kali Linux系统设置中文语言环境-1_kali中文设置-CSDN博客</a></p><p>具体步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>选择语言，使用空格键选中。选择en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8</p><p>[TOC]</p><h2 id="参考资料-3"><a href="#参考资料-3" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="参考书-3"><a href="#参考书-3" class="headerlink" title="参考书"></a>参考书</h3><table><thead><tr><th>图书名称:</th><th>Kali Linux: Assuring Security by Penetration Testing</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://jobrest.gitbooks.io/kali-linux-cn/content/assets/feng_mian.jpeg" alt="封面"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2015-2</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>Lee Allen &#x2F; Tedi Heriyanto &#x2F; Shakeel Ali 著</td><td></td></tr><tr><td>译者</td><td>Archer 译</td><td></td></tr><tr><td>ISBN:</td><td>9787115378446</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Kali Linux2 网络渗透测试实践指南 第2版</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34261078.jpg" alt="Kali Linux2 网络渗透测试实践指南 第2版"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-3</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>李华峰 著</td><td></td></tr><tr><td>ISBN:</td><td>9787115555410</td><td></td></tr></tbody></table><h3 id="友链-3"><a href="#友链-3" class="headerlink" title="友链"></a>友链</h3><p>书籍在线阅读地址：<a href="https://jobrest.gitbooks.io/kali-linux-cn/content/index.html">Kali Linux 渗透测试的艺术（中文版） | Kali Linux 渗透测试的艺术（中文版） (gitbooks.io)</a></p><p>官网：<a href="https://www.kali.org/">Kali Linux 操作系统 |渗透测试和道德黑客 Linux 发行版</a></p><p>文档：<a href="https://www.kali.org/docs/">Kali Docs | Kali Linux Documentation</a></p><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><h3 id="何为玩转kali？-3"><a href="#何为玩转kali？-3" class="headerlink" title="何为玩转kali？"></a>何为玩转kali？</h3><p>当然是想随心所欲，让“所见即所得”，让“所想立即实现”，那么此篇就是完成这个任务。</p><h2 id="第1章-Kali-Linux入门-3"><a href="#第1章-Kali-Linux入门-3" class="headerlink" title="第1章 Kali Linux入门"></a>第1章 Kali Linux入门</h2><h3 id="1-1-Kali的发展简史-3"><a href="#1-1-Kali的发展简史-3" class="headerlink" title="1.1 Kali的发展简史"></a>1.1 Kali的发展简史</h3><p>Kali Linux（Kali）是专门用于渗透测试的Linux操作系统，它由BackTrack 发展而来。在整合了IWHAX、WHOPPIX 和Auditor 这3 种渗透测试专用Live Linux 之后，BackTrack正式改名为Kali Linux。</p><p>BackTrack是相当著名的Linux发行版本。在BackTrack发布4.0预览版的时候，它的下载次数已经超过了400万次。</p><p>Kali Linux 1.0 版于2013年3 月12 日问世。在5天之后，官方为修复USB 键盘的支持问题而发布了1.0.1 版。在这短短的5 天之内，Kali 的下载次数就超过了9 万次。</p><p>根据官网的介绍（<a href="http://docs.kali.org/introduction/what-is-kali-linux%EF%BC%89%EF%BC%8C">http://docs.kali.org/introduction/what-is-kali-linux），</a> Kali的主要特色有：</p><p>● 它是基于Debian 的Linux 发行版；</p><p>● 它集成300 多个渗透测试程序；</p><p>● 它支持绝大多数的无线网卡；</p><p>● 它修改了内核以支持（无线）数据包注入；</p><p>● 所有的软件包都有研发团队的PGP 签名；</p><p>● 用户可以自制满足各自需求的Kali Linux 发行版；</p><p>● 支持基于ARM 的硬件系统。</p><h3 id="1-2-Kali-Linux工具包-3"><a href="#1-2-Kali-Linux工具包-3" class="headerlink" title="1.2 Kali Linux工具包"></a>1.2 Kali Linux工具包</h3><p>Kali Linux 含有可用于渗透测试的各种工具。这些工具程序大体可以分为以下几类。</p><p>● 信息收集：这类工具可用来收集目标的 DNS、IDS&#x2F;IPS、网络扫描、操作系统、路由、SSL、SMB、VPN、VoIP、SNMP信息和E-mail地址。</p><p>● 漏洞评估：这类工具都可以扫描目标系统上的漏洞。部分工具可以检测Cisco 网络系统缺陷，有些还可以评估各种数据库系统的安全问题。很多模糊测试软件都属于漏洞评估工具。</p><p>● Web应用：即与Web应用有关的工具。它包括CMS（内容管理系统）扫描器、数据库漏洞利用程序、Web应用模糊测试、Web应用代理、Web爬虫及Web漏洞扫描器。</p><p>● 密码攻击：无论是在线攻击还是离线破解，只要是能够实施密码攻击的工具都属于密码攻击类工具。</p><p>● 漏洞利用：这类工具可以利用在目标系统中发现的漏洞。攻击网络、Web 和数据库漏洞的软件，都属于漏洞利用（exploitation）工具。Kali 中的某些软件可以针对漏洞情况进行社会工程学攻击。</p><p>● 网络监听：这类工具用于监听网络和Web 流量。网络监听需要进行网络欺骗，所以Ettercap和Yersinia这类软件也归于这类软件。</p><p>● 访问维护：这类工具帮助渗透人员维持他们对目标主机的访问权。某些情况下，渗透人员必须先获取主机的最高权限才能安装这类软件。这类软件包括用于在 Web应用和操作系统安装后门的程序，以及隧道类工具。</p><p>● 报告工具：如果您需要撰写渗透测试的报告文件，您应该用得上这些软件。</p><p>● 系统服务：这是渗透人员在渗透测试时可能用到的常见服务类软件，它包括Apache服务、MySQL服务、SSH服务和Metasploit服务。</p><p>为了降低渗透测试人员筛选工具的难度，Kali Linux 单独划分了一类软件——Top 10 Security Tools，即10 大首选安全工具。这10 大工具分别是aircrack-ng、burp-suite、hydra、john、maltego、metasploit、nmap、sqlmap、wireshark和zaproxy。</p><p>除了可用于渗透测试的各种工具以外，Kali Linux 还整合了以下几类工具。</p><p>● 无线攻击：可攻击蓝牙、RFID&#x2F;NFC 和其他无线设备的工具。</p><p>● 逆向工程：可用于调试程序或反汇编的工具。</p><p>● 压力测试：用于各类压力测试的工具集。它们可测试网络、无线、Web 和 VoIP 系统的负载能力。</p><p>● 硬件破解：用于调试Android 和Arduino 程序的工具。</p><p>● 法证调查：即电子取证的工具。它的各种工具可以用于制作硬盘磁盘镜像、文件分析、硬盘镜像分析。如需使用这类程序，首先要在启动菜单里选择 Kali Linux Forensics | No Drives or Swap Mount。在开启这个选项以后，Kali Linux不会自动加载硬盘驱动器，以保护硬盘数据的完整性。</p><h3 id="1-3下载Kali-Linux-3"><a href="#1-3下载Kali-Linux-3" class="headerlink" title="1.3下载Kali Linux"></a>1.3下载Kali Linux</h3><p>下载是第一步要做的事情，经常使用计算机的人对下载肯定不陌生，但要想面向大众还是要解释清楚。</p><ul><li><p><input disabled="" type="checkbox"> 待补充</p></li><li><p><input disabled="" type="checkbox"> 验证哈希值</p></li></ul><h5 id="在虚拟机里使用-VM-镜像安装-Kali-Linux-3"><a href="#在虚拟机里使用-VM-镜像安装-Kali-Linux-3" class="headerlink" title="在虚拟机里使用 VM 镜像安装 Kali Linux"></a>在虚拟机里使用 VM 镜像安装 Kali Linux</h5><p>Kali Linux的iso镜像和虚拟机vmx文件等在Kali官网都有，直接下载就可以，而且下载速度也不赖。</p><p>这里我推荐直接下载Kali官方的虚拟机vmx文件，下载好了直接打开就能用，免去了很多配置环节。之前也尝试过用iso镜像做VMware，但试了几次遇到很多麻烦，因此就不搞了。</p><blockquote><p>使用硬盘镜像方式安装Kali Linux之后，系统的默认设置值如下所示。</p><p>● 硬盘容量：30 GB。</p><p>● 联网方式：NAT。</p><p>● 用户名：root。</p><p>● 密码：toor。</p><p>如果要把 Kali当做渗透测试平台使用，应当避免以 NAT方式接入网络。本文推荐您以桥接（bridged）方式联网。</p><p>在配置Kali VM 的时候，应当尽快更改默认密码。</p></blockquote><h4 id="portable-Kali-Linux-3"><a href="#portable-Kali-Linux-3" class="headerlink" title="portable Kali Linux"></a>portable Kali Linux</h4><ul><li><input disabled="" type="checkbox"> 未实操，待修改</li></ul><p>安装Kali Linux 的第三种方法，就是把它安装到USB 闪存里。通常，人们把安装在闪存上的Kali Linux 叫做portable（便携）Kali Linux。按照Kali官方文件的说法，这种安装方式的启动和安装速度最快，是Kali研发人员最喜欢的安装方式。相比在硬盘上安装，只能在一台机器上启动Kali 系统而言，装有Kali Linux 的闪存盘可以在所有支持USB 启动的主机上使用Kali系统。</p><p>这种安装方法同样适合在内存卡（SSD、SDHC、SDXC 等）上安装Kali Linux。</p><p>很多工具都可以制作portable Kali Linux。其中，Rufus（<a href="http://rufus.akeo.ie)就不错.这个工具只能在windows操作系统下运行./">http://rufus.akeo.ie）就不错。这个工具只能在Windows操作系统下运行。</a></p><p>其他可从ISO镜像文件制作可启动USB的工具如下所示：</p><p>● Win32DiskImager（<a href="https://launchpad.net/win32-image-writer%EF%BC%89%EF%BC%9B">https://launchpad.net/win32-image-writer）；</a></p><p>● Universal USB Installer（<a href="http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/%EF%BC%89%EF%BC%9B">http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/）；</a></p><p>● Linux Live USB Creator（<a href="http://www.linuxliveusb.com/">http://www.linuxliveusb.com</a>)</p><p>在制作portable Kali Linux 之前，您需要准备好几样素材。</p><p>● Kali Linux 的ISO 镜像文件：虽然您可以使用启动磁盘创建工具直接下载镜像文件，但是我们仍然认为提前下载好ISO镜像文件，再用Rufus使用镜像文件比较稳妥。</p><p>● USB 闪存盘：您需要一个容量足够大的 USB 闪存盘。我们推荐您使用 16GB 以上的闪存盘。</p><p>在下载Rufus之后，在Windows里双击rufus.exe文件就可以运行它。它会显示出程序界面。</p><p>如果您使用的是基于UNIX的操作系统，您可以直接使用dd指令创建可启动闪存盘。例如：</p><p>dd if&#x3D;kali-linux-1.0.1-i386.iso of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;512k</p><p>此处的&#x2F;dev&#x2F;sdb应当是您USB闪存盘的设备名称。</p><p>使用Rufus 创建可启动的Kali USB 闪存盘的设置如下。</p><p>● Device：选择USB 闪存驱动器。本例中，它是Windows 系统的E 盘。</p><p>● Partition scheme and target system type：设置为MBR partition scheme for BIOS or UEFI computers。</p><p>● Create a bootable disk using：设置为ISO Image 并使用右侧磁盘图标选取ISO 镜像文件。</p><p>然后点击Start创建可启动闪存盘。</p><p>在完成这些步骤之后，如果您想要立即测试USB闪存盘，则应在保存好所有文件的情况下重启计算机。您可能需要配置计算机的 BIOS，使其从 USB 磁盘启动计算机。如果没有问题的话，您应该可以通过USB 闪存盘启动Kali Linux 系统。</p><p>在USB闪存盘上安装系统之后，如果您想要让系统能够保存您所更改的文件（即persistence capabilities），您可参照Kali官方文档进行设置。请参见 Adding Persistence to Your Kali Live USB，地址为<a href="http://docs.kali.org/installation/kali-linux-live-usb-install">http://docs.kali.org/installation/kali-linux-live-usb-install</a></p><h3 id="1-4-虚拟机配置-3"><a href="#1-4-虚拟机配置-3" class="headerlink" title="1.4 虚拟机配置"></a>1.4 虚拟机配置</h3><h4 id="1-4-1-设置中文-3"><a href="#1-4-1-设置中文-3" class="headerlink" title="1.4.1 设置中文"></a>1.4.1 设置中文</h4><p>刚下好kali linux，就被全英文劝退可不太好。一看到密密麻麻的英文就敲起了退堂鼓，所以首先把系统语言设置成中文。</p><p>Learn more：<a href="https://blog.csdn.net/KNIGH_YUN/article/details/105543094">Kali Linux系统设置中文语言环境-1_kali中文设置-CSDN博客</a></p><p>具体步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>选择语言，使用空格键选中。选择en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8</p><p><img src="https://img-blog.csdnimg.cn/4346e90fd26c4a17835bcd4d3ddc6474.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>选中zh_CN.UTF-8为默认语言。</p><p><img src="https://img-blog.csdnimg.cn/8fc88465e1ee4af9b87e0f029e8c2859.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br></pre></td></tr></table></figure><p>下载字体</p><p>重启虚拟机。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-settings-zh_en.png" alt="设置中文界面"></p><p>当然，以上方法并非唯一方法，如果安装了图形界面也可以直接在设置里修改语言（X-windows），或者通过CLI修改系统配置文件。</p><h4 id="1-4-2-网络设置-2"><a href="#1-4-2-网络设置-2" class="headerlink" title="1.4.2 网络设置"></a>1.4.2 网络设置</h4><p>1．配置有线网络</p><p>无论是通过VMware 磁盘镜像还是通过ISO镜像安装Kali Linux，默认情况下Kali Linux接入网络的方式都是NAT（网络地址转换）。在NAT方式下，Kali Linux的虚拟机可以通过物理主机联入外部网络，而外部网络甚至是物理主机自身都无法直接访问安装有Kali Linux的虚拟机。</p><p>进行实地的渗透测试时，您可能需要把网络结构变更为Bridged Adapter。</p><p>如需使用桥接连接，首先要使物理主机与网络设备连接，例如路由器或交换机。同时，接入的网络里应当有DHCP服务，以分配IP地址给虚拟机。</p><p>您可能已经注意到了，通过DHCP获取的IP地址并不是固定的IP地址，这种IP地址在一定时间后可能会发生变化。如果Kali Linux 通过DHCP 获取IP 地址，在超过固定周期（DHCP的租赁时间）之后，DHCP会重新给虚拟机分配一次IP地址。重新分配的IP地址可能和上次分配的IP地址相同，也可能不同。</p><p>如果虚拟机需要使用固定的 IP 地址，应该修改虚拟机的网络设置文件&#x2F;etc&#x2F;network&#x2F;interfaces。</p><p>默认情况下，Kali Linux 的网络设置文件如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line"></span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>这个配置文件指定所有网卡都通过DHCP获取IP地址。如需为虚拟机绑定固定IP地址，就不得不对这个文件进行相应修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"></span><br><span class="line">iface eth0 inet static</span><br><span class="line"></span><br><span class="line">address 10.0.2.15</span><br><span class="line"></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">network 10.0.2.0</span><br><span class="line"></span><br><span class="line">broadcast 10.0.2.255</span><br><span class="line"></span><br><span class="line">gateway 10.0.2.2</span><br></pre></td></tr></table></figure><p>上述文件令第一个有线网卡eth0 绑定了 IP 地址10.0.2.15。您可能需要根据实际情况修改上述设置。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-查看网络配置.png"></p><p>手动设置网络：</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-网络配置.png"></p><p>error：</p><p>配置了域名服务器后导致ping其他网站都无法解析域名。</p><h4 id="1-5-3-文件夹共享-2"><a href="#1-5-3-文件夹共享-2" class="headerlink" title="1.5.3 文件夹共享"></a>1.5.3 文件夹共享</h4><h4 id="1-5-4-快照备份-2"><a href="#1-5-4-快照备份-2" class="headerlink" title="1.5.4 快照备份"></a>1.5.4 快照备份</h4><p>一旦您把虚拟机配置到理想的可工作状态，我们建议您立刻对虚拟机进行快照备份。万一日后出现配置故障，可利用快照备份把虚拟机迅速恢复到正常工作状态。</p><h4 id="1-5-5-导出虚拟机-2"><a href="#1-5-5-导出虚拟机-2" class="headerlink" title="1.5.5 导出虚拟机"></a>1.5.5 导出虚拟机</h4><p>人们时常需要以文件形式备份虚拟机，或通过这种方法把虚拟机分享给他人使用。VirtualBox的虚拟机导出功能简化了这种操作。在关闭需要导出的虚拟机之后，在菜单栏选中File | Export Appliance 就可导出所选的虚拟机。</p><h3 id="1-5-系统更新-2"><a href="#1-5-系统更新-2" class="headerlink" title="1.5 系统更新"></a>1.5 系统更新</h3><p>Kali Linux 由操作系统内核和数百个软件构成。如果需要使用软件的最新功能，您就需要将其更新到最新的版本。</p><p>我们建议您仅从Kali Linux 官方的软件仓库（repository）进行更新。</p><p>在您安装和配置好Kali Linux 之后，就应当立即进行系统更新。因为Kali 是基于Debian的操作系统，您需要使用Debian的指令（apt-get）进行系统更新。</p><p>更新指令apt-get会查询&#x2F;etc&#x2F;apt&#x2F;sources.list文件，从中获取更新服务器的信息。您需要确定这个文件指定了正确的升级服务器。</p><p>默认情况下，Kali Linux 的sources.list 文件包含下述信息。</p><h4 id="其他：apt更换国内源-2"><a href="#其他：apt更换国内源-2" class="headerlink" title="其他：apt更换国内源"></a>其他：apt更换国内源</h4><p>Kali Linux 会从系统默认的软件源去安装软件，但默认的软件源速度通常比较慢（国外的源），因此需要将其替换成国内的源。</p><p>以下是常用的国内源网站：</p><p><a href="https://opsx.alibaba.com/mirror?lang=zh-CN">阿里云镜像开源镜像站（已经更换地址）</a><br><a href="https://developer.aliyun.com/mirror/">阿里云镜像开源社区镜像站（新地址）</a><br><a href="http://mirrors.163.com/.help/ubuntu.html">网易开源镜像站</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源镜像站</a><br><a href="https://mirrors.ustc.edu.cn/">中科大开源镜像站</a></p><p>修改方式：apt源的文件位置：&#x2F;etc&#x2F;apt&#x2F;sources.list</p><blockquote><p>注意：是&#x2F;etc&#x2F;apt&#x2F;sources.list，不是&#x2F;etc&#x2F;apt&#x2F;source.list（非常重要）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.bak1</span><br><span class="line">#第一个参数时拷贝的文件路径和文件名称,第二个是拷贝到(粘贴)的文件路径和文件名</span><br><span class="line"></span><br><span class="line">sudo mousepad /etc/apt/sources.list</span><br><span class="line">#用mousepad可以直接从系统粘贴板粘贴，比vim和vi更方便操作</span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line"># deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#根据需要自己选一个，中科大的还可以</span><br><span class="line">#中科大</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">#阿里云</span><br><span class="line">#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#清华大学</span><br><span class="line">#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#浙大</span><br><span class="line">#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#东软大学</span><br><span class="line">#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#重庆大学</span><br><span class="line">#deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><blockquote><p>注：vim和vi的操作习惯很”程序员风格”，不熟悉的情况下很难使用，以下是一个vim操作的视频</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p></blockquote><p>一个小插曲：我之前的Kali虚拟机就是因为vim操作不当修改了root文件，加上安装了很多包之后经常卡顿死机，所以重新装了一个新的，实在是血的教训。</p><p>更新完之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update 更新索引</span><br><span class="line"></span><br><span class="line">apt-get upgrade 更新软件</span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade 升级</span><br><span class="line"></span><br><span class="line">apt-get clean 删除缓存包</span><br><span class="line"></span><br><span class="line">apt-get autoclean 删除未安装的deb包</span><br></pre></td></tr></table></figure><p>error:</p><p><img src="D:/hexo/source/_posts/img/Network-attack/apt-无法解析域名.png"></p><p>目前网络配置有问题，解决后再写xia’wen</p><p>选中zh_CN.UTF-8为默认语言。</p><p>[TOC]</p><h2 id="参考资料-4"><a href="#参考资料-4" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="参考书-4"><a href="#参考书-4" class="headerlink" title="参考书"></a>参考书</h3><table><thead><tr><th>图书名称:</th><th>Kali Linux: Assuring Security by Penetration Testing</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://jobrest.gitbooks.io/kali-linux-cn/content/assets/feng_mian.jpeg" alt="封面"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2015-2</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>Lee Allen &#x2F; Tedi Heriyanto &#x2F; Shakeel Ali 著</td><td></td></tr><tr><td>译者</td><td>Archer 译</td><td></td></tr><tr><td>ISBN:</td><td>9787115378446</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Kali Linux2 网络渗透测试实践指南 第2版</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34261078.jpg" alt="Kali Linux2 网络渗透测试实践指南 第2版"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-3</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>李华峰 著</td><td></td></tr><tr><td>ISBN:</td><td>9787115555410</td><td></td></tr></tbody></table><h3 id="友链-4"><a href="#友链-4" class="headerlink" title="友链"></a>友链</h3><p>书籍在线阅读地址：<a href="https://jobrest.gitbooks.io/kali-linux-cn/content/index.html">Kali Linux 渗透测试的艺术（中文版） | Kali Linux 渗透测试的艺术（中文版） (gitbooks.io)</a></p><p>官网：<a href="https://www.kali.org/">Kali Linux 操作系统 |渗透测试和道德黑客 Linux 发行版</a></p><p>文档：<a href="https://www.kali.org/docs/">Kali Docs | Kali Linux Documentation</a></p><h2 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h2><h3 id="何为玩转kali？-4"><a href="#何为玩转kali？-4" class="headerlink" title="何为玩转kali？"></a>何为玩转kali？</h3><p>当然是想随心所欲，让“所见即所得”，让“所想立即实现”，那么此篇就是完成这个任务。</p><h2 id="第1章-Kali-Linux入门-4"><a href="#第1章-Kali-Linux入门-4" class="headerlink" title="第1章 Kali Linux入门"></a>第1章 Kali Linux入门</h2><h3 id="1-1-Kali的发展简史-4"><a href="#1-1-Kali的发展简史-4" class="headerlink" title="1.1 Kali的发展简史"></a>1.1 Kali的发展简史</h3><p>Kali Linux（Kali）是专门用于渗透测试的Linux操作系统，它由BackTrack 发展而来。在整合了IWHAX、WHOPPIX 和Auditor 这3 种渗透测试专用Live Linux 之后，BackTrack正式改名为Kali Linux。</p><p>BackTrack是相当著名的Linux发行版本。在BackTrack发布4.0预览版的时候，它的下载次数已经超过了400万次。</p><p>Kali Linux 1.0 版于2013年3 月12 日问世。在5天之后，官方为修复USB 键盘的支持问题而发布了1.0.1 版。在这短短的5 天之内，Kali 的下载次数就超过了9 万次。</p><p>根据官网的介绍（<a href="http://docs.kali.org/introduction/what-is-kali-linux%EF%BC%89%EF%BC%8C">http://docs.kali.org/introduction/what-is-kali-linux），</a> Kali的主要特色有：</p><p>● 它是基于Debian 的Linux 发行版；</p><p>● 它集成300 多个渗透测试程序；</p><p>● 它支持绝大多数的无线网卡；</p><p>● 它修改了内核以支持（无线）数据包注入；</p><p>● 所有的软件包都有研发团队的PGP 签名；</p><p>● 用户可以自制满足各自需求的Kali Linux 发行版；</p><p>● 支持基于ARM 的硬件系统。</p><h3 id="1-2-Kali-Linux工具包-4"><a href="#1-2-Kali-Linux工具包-4" class="headerlink" title="1.2 Kali Linux工具包"></a>1.2 Kali Linux工具包</h3><p>Kali Linux 含有可用于渗透测试的各种工具。这些工具程序大体可以分为以下几类。</p><p>● 信息收集：这类工具可用来收集目标的 DNS、IDS&#x2F;IPS、网络扫描、操作系统、路由、SSL、SMB、VPN、VoIP、SNMP信息和E-mail地址。</p><p>● 漏洞评估：这类工具都可以扫描目标系统上的漏洞。部分工具可以检测Cisco 网络系统缺陷，有些还可以评估各种数据库系统的安全问题。很多模糊测试软件都属于漏洞评估工具。</p><p>● Web应用：即与Web应用有关的工具。它包括CMS（内容管理系统）扫描器、数据库漏洞利用程序、Web应用模糊测试、Web应用代理、Web爬虫及Web漏洞扫描器。</p><p>● 密码攻击：无论是在线攻击还是离线破解，只要是能够实施密码攻击的工具都属于密码攻击类工具。</p><p>● 漏洞利用：这类工具可以利用在目标系统中发现的漏洞。攻击网络、Web 和数据库漏洞的软件，都属于漏洞利用（exploitation）工具。Kali 中的某些软件可以针对漏洞情况进行社会工程学攻击。</p><p>● 网络监听：这类工具用于监听网络和Web 流量。网络监听需要进行网络欺骗，所以Ettercap和Yersinia这类软件也归于这类软件。</p><p>● 访问维护：这类工具帮助渗透人员维持他们对目标主机的访问权。某些情况下，渗透人员必须先获取主机的最高权限才能安装这类软件。这类软件包括用于在 Web应用和操作系统安装后门的程序，以及隧道类工具。</p><p>● 报告工具：如果您需要撰写渗透测试的报告文件，您应该用得上这些软件。</p><p>● 系统服务：这是渗透人员在渗透测试时可能用到的常见服务类软件，它包括Apache服务、MySQL服务、SSH服务和Metasploit服务。</p><p>为了降低渗透测试人员筛选工具的难度，Kali Linux 单独划分了一类软件——Top 10 Security Tools，即10 大首选安全工具。这10 大工具分别是aircrack-ng、burp-suite、hydra、john、maltego、metasploit、nmap、sqlmap、wireshark和zaproxy。</p><p>除了可用于渗透测试的各种工具以外，Kali Linux 还整合了以下几类工具。</p><p>● 无线攻击：可攻击蓝牙、RFID&#x2F;NFC 和其他无线设备的工具。</p><p>● 逆向工程：可用于调试程序或反汇编的工具。</p><p>● 压力测试：用于各类压力测试的工具集。它们可测试网络、无线、Web 和 VoIP 系统的负载能力。</p><p>● 硬件破解：用于调试Android 和Arduino 程序的工具。</p><p>● 法证调查：即电子取证的工具。它的各种工具可以用于制作硬盘磁盘镜像、文件分析、硬盘镜像分析。如需使用这类程序，首先要在启动菜单里选择 Kali Linux Forensics | No Drives or Swap Mount。在开启这个选项以后，Kali Linux不会自动加载硬盘驱动器，以保护硬盘数据的完整性。</p><h3 id="1-3下载Kali-Linux-4"><a href="#1-3下载Kali-Linux-4" class="headerlink" title="1.3下载Kali Linux"></a>1.3下载Kali Linux</h3><p>下载是第一步要做的事情，经常使用计算机的人对下载肯定不陌生，但要想面向大众还是要解释清楚。</p><ul><li><p><input disabled="" type="checkbox"> 待补充</p></li><li><p><input disabled="" type="checkbox"> 验证哈希值</p></li></ul><h5 id="在虚拟机里使用-VM-镜像安装-Kali-Linux-4"><a href="#在虚拟机里使用-VM-镜像安装-Kali-Linux-4" class="headerlink" title="在虚拟机里使用 VM 镜像安装 Kali Linux"></a>在虚拟机里使用 VM 镜像安装 Kali Linux</h5><p>Kali Linux的iso镜像和虚拟机vmx文件等在Kali官网都有，直接下载就可以，而且下载速度也不赖。</p><p>这里我推荐直接下载Kali官方的虚拟机vmx文件，下载好了直接打开就能用，免去了很多配置环节。之前也尝试过用iso镜像做VMware，但试了几次遇到很多麻烦，因此就不搞了。</p><blockquote><p>使用硬盘镜像方式安装Kali Linux之后，系统的默认设置值如下所示。</p><p>● 硬盘容量：30 GB。</p><p>● 联网方式：NAT。</p><p>● 用户名：root。</p><p>● 密码：toor。</p><p>如果要把 Kali当做渗透测试平台使用，应当避免以 NAT方式接入网络。本文推荐您以桥接（bridged）方式联网。</p><p>在配置Kali VM 的时候，应当尽快更改默认密码。</p></blockquote><h4 id="portable-Kali-Linux-4"><a href="#portable-Kali-Linux-4" class="headerlink" title="portable Kali Linux"></a>portable Kali Linux</h4><ul><li><input disabled="" type="checkbox"> 未实操，待修改</li></ul><p>安装Kali Linux 的第三种方法，就是把它安装到USB 闪存里。通常，人们把安装在闪存上的Kali Linux 叫做portable（便携）Kali Linux。按照Kali官方文件的说法，这种安装方式的启动和安装速度最快，是Kali研发人员最喜欢的安装方式。相比在硬盘上安装，只能在一台机器上启动Kali 系统而言，装有Kali Linux 的闪存盘可以在所有支持USB 启动的主机上使用Kali系统。</p><p>这种安装方法同样适合在内存卡（SSD、SDHC、SDXC 等）上安装Kali Linux。</p><p>很多工具都可以制作portable Kali Linux。其中，Rufus（<a href="http://rufus.akeo.ie)就不错.这个工具只能在windows操作系统下运行./">http://rufus.akeo.ie）就不错。这个工具只能在Windows操作系统下运行。</a></p><p>其他可从ISO镜像文件制作可启动USB的工具如下所示：</p><p>● Win32DiskImager（<a href="https://launchpad.net/win32-image-writer%EF%BC%89%EF%BC%9B">https://launchpad.net/win32-image-writer）；</a></p><p>● Universal USB Installer（<a href="http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/%EF%BC%89%EF%BC%9B">http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/）；</a></p><p>● Linux Live USB Creator（<a href="http://www.linuxliveusb.com/">http://www.linuxliveusb.com</a>)</p><p>在制作portable Kali Linux 之前，您需要准备好几样素材。</p><p>● Kali Linux 的ISO 镜像文件：虽然您可以使用启动磁盘创建工具直接下载镜像文件，但是我们仍然认为提前下载好ISO镜像文件，再用Rufus使用镜像文件比较稳妥。</p><p>● USB 闪存盘：您需要一个容量足够大的 USB 闪存盘。我们推荐您使用 16GB 以上的闪存盘。</p><p>在下载Rufus之后，在Windows里双击rufus.exe文件就可以运行它。它会显示出程序界面。</p><p>如果您使用的是基于UNIX的操作系统，您可以直接使用dd指令创建可启动闪存盘。例如：</p><p>dd if&#x3D;kali-linux-1.0.1-i386.iso of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;512k</p><p>此处的&#x2F;dev&#x2F;sdb应当是您USB闪存盘的设备名称。</p><p>使用Rufus 创建可启动的Kali USB 闪存盘的设置如下。</p><p>● Device：选择USB 闪存驱动器。本例中，它是Windows 系统的E 盘。</p><p>● Partition scheme and target system type：设置为MBR partition scheme for BIOS or UEFI computers。</p><p>● Create a bootable disk using：设置为ISO Image 并使用右侧磁盘图标选取ISO 镜像文件。</p><p>然后点击Start创建可启动闪存盘。</p><p>在完成这些步骤之后，如果您想要立即测试USB闪存盘，则应在保存好所有文件的情况下重启计算机。您可能需要配置计算机的 BIOS，使其从 USB 磁盘启动计算机。如果没有问题的话，您应该可以通过USB 闪存盘启动Kali Linux 系统。</p><p>在USB闪存盘上安装系统之后，如果您想要让系统能够保存您所更改的文件（即persistence capabilities），您可参照Kali官方文档进行设置。请参见 Adding Persistence to Your Kali Live USB，地址为<a href="http://docs.kali.org/installation/kali-linux-live-usb-install">http://docs.kali.org/installation/kali-linux-live-usb-install</a></p><h3 id="1-4-虚拟机配置-4"><a href="#1-4-虚拟机配置-4" class="headerlink" title="1.4 虚拟机配置"></a>1.4 虚拟机配置</h3><h4 id="1-4-1-设置中文-4"><a href="#1-4-1-设置中文-4" class="headerlink" title="1.4.1 设置中文"></a>1.4.1 设置中文</h4><p>刚下好kali linux，就被全英文劝退可不太好。一看到密密麻麻的英文就敲起了退堂鼓，所以首先把系统语言设置成中文。</p><p>Learn more：<a href="https://blog.csdn.net/KNIGH_YUN/article/details/105543094">Kali Linux系统设置中文语言环境-1_kali中文设置-CSDN博客</a></p><p>具体步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>选择语言，使用空格键选中。选择en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8</p><p><img src="https://img-blog.csdnimg.cn/4346e90fd26c4a17835bcd4d3ddc6474.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>选中zh_CN.UTF-8为默认语言。</p><p><img src="https://img-blog.csdnimg.cn/8fc88465e1ee4af9b87e0f029e8c2859.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br></pre></td></tr></table></figure><p>下载字体</p><p>重启虚拟机。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-settings-zh_en.png" alt="设置中文界面"></p><p>当然，以上方法并非唯一方法，如果安装了图形界面也可以直接在设置里修改语言（X-windows），或者通过CLI修改系统配置文件。</p><h4 id="1-4-2-网络设置-3"><a href="#1-4-2-网络设置-3" class="headerlink" title="1.4.2 网络设置"></a>1.4.2 网络设置</h4><p>1．配置有线网络</p><p>无论是通过VMware 磁盘镜像还是通过ISO镜像安装Kali Linux，默认情况下Kali Linux接入网络的方式都是NAT（网络地址转换）。在NAT方式下，Kali Linux的虚拟机可以通过物理主机联入外部网络，而外部网络甚至是物理主机自身都无法直接访问安装有Kali Linux的虚拟机。</p><p>进行实地的渗透测试时，您可能需要把网络结构变更为Bridged Adapter。</p><p>如需使用桥接连接，首先要使物理主机与网络设备连接，例如路由器或交换机。同时，接入的网络里应当有DHCP服务，以分配IP地址给虚拟机。</p><p>您可能已经注意到了，通过DHCP获取的IP地址并不是固定的IP地址，这种IP地址在一定时间后可能会发生变化。如果Kali Linux 通过DHCP 获取IP 地址，在超过固定周期（DHCP的租赁时间）之后，DHCP会重新给虚拟机分配一次IP地址。重新分配的IP地址可能和上次分配的IP地址相同，也可能不同。</p><p>如果虚拟机需要使用固定的 IP 地址，应该修改虚拟机的网络设置文件&#x2F;etc&#x2F;network&#x2F;interfaces。</p><p>默认情况下，Kali Linux 的网络设置文件如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line"></span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>这个配置文件指定所有网卡都通过DHCP获取IP地址。如需为虚拟机绑定固定IP地址，就不得不对这个文件进行相应修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"></span><br><span class="line">iface eth0 inet static</span><br><span class="line"></span><br><span class="line">address 10.0.2.15</span><br><span class="line"></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">network 10.0.2.0</span><br><span class="line"></span><br><span class="line">broadcast 10.0.2.255</span><br><span class="line"></span><br><span class="line">gateway 10.0.2.2</span><br></pre></td></tr></table></figure><p>上述文件令第一个有线网卡eth0 绑定了 IP 地址10.0.2.15。您可能需要根据实际情况修改上述设置。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-查看网络配置.png"></p><p>手动设置网络：</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-网络配置.png"></p><p>error：</p><p>配置了域名服务器后导致ping其他网站都无法解析域名。</p><h4 id="1-5-3-文件夹共享-3"><a href="#1-5-3-文件夹共享-3" class="headerlink" title="1.5.3 文件夹共享"></a>1.5.3 文件夹共享</h4><h4 id="1-5-4-快照备份-3"><a href="#1-5-4-快照备份-3" class="headerlink" title="1.5.4 快照备份"></a>1.5.4 快照备份</h4><p>一旦您把虚拟机配置到理想的可工作状态，我们建议您立刻对虚拟机进行快照备份。万一日后出现配置故障，可利用快照备份把虚拟机迅速恢复到正常工作状态。</p><h4 id="1-5-5-导出虚拟机-3"><a href="#1-5-5-导出虚拟机-3" class="headerlink" title="1.5.5 导出虚拟机"></a>1.5.5 导出虚拟机</h4><p>人们时常需要以文件形式备份虚拟机，或通过这种方法把虚拟机分享给他人使用。VirtualBox的虚拟机导出功能简化了这种操作。在关闭需要导出的虚拟机之后，在菜单栏选中File | Export Appliance 就可导出所选的虚拟机。</p><h3 id="1-5-系统更新-3"><a href="#1-5-系统更新-3" class="headerlink" title="1.5 系统更新"></a>1.5 系统更新</h3><p>Kali Linux 由操作系统内核和数百个软件构成。如果需要使用软件的最新功能，您就需要将其更新到最新的版本。</p><p>我们建议您仅从Kali Linux 官方的软件仓库（repository）进行更新。</p><p>在您安装和配置好Kali Linux 之后，就应当立即进行系统更新。因为Kali 是基于Debian的操作系统，您需要使用Debian的指令（apt-get）进行系统更新。</p><p>更新指令apt-get会查询&#x2F;etc&#x2F;apt&#x2F;sources.list文件，从中获取更新服务器的信息。您需要确定这个文件指定了正确的升级服务器。</p><p>默认情况下，Kali Linux 的sources.list 文件包含下述信息。</p><h4 id="其他：apt更换国内源-3"><a href="#其他：apt更换国内源-3" class="headerlink" title="其他：apt更换国内源"></a>其他：apt更换国内源</h4><p>Kali Linux 会从系统默认的软件源去安装软件，但默认的软件源速度通常比较慢（国外的源），因此需要将其替换成国内的源。</p><p>以下是常用的国内源网站：</p><p><a href="https://opsx.alibaba.com/mirror?lang=zh-CN">阿里云镜像开源镜像站（已经更换地址）</a><br><a href="https://developer.aliyun.com/mirror/">阿里云镜像开源社区镜像站（新地址）</a><br><a href="http://mirrors.163.com/.help/ubuntu.html">网易开源镜像站</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源镜像站</a><br><a href="https://mirrors.ustc.edu.cn/">中科大开源镜像站</a></p><p>修改方式：apt源的文件位置：&#x2F;etc&#x2F;apt&#x2F;sources.list</p><blockquote><p>注意：是&#x2F;etc&#x2F;apt&#x2F;sources.list，不是&#x2F;etc&#x2F;apt&#x2F;source.list（非常重要）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.bak1</span><br><span class="line">#第一个参数时拷贝的文件路径和文件名称,第二个是拷贝到(粘贴)的文件路径和文件名</span><br><span class="line"></span><br><span class="line">sudo mousepad /etc/apt/sources.list</span><br><span class="line">#用mousepad可以直接从系统粘贴板粘贴，比vim和vi更方便操作</span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line"># deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#根据需要自己选一个，中科大的还可以</span><br><span class="line">#中科大</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">#阿里云</span><br><span class="line">#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#清华大学</span><br><span class="line">#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#浙大</span><br><span class="line">#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#东软大学</span><br><span class="line">#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#重庆大学</span><br><span class="line">#deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><blockquote><p>注：vim和vi的操作习惯很”程序员风格”，不熟悉的情况下很难使用，以下是一个vim操作的视频</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p></blockquote><p>一个小插曲：我之前的Kali虚拟机就是因为vim操作不当修改了root文件，加上安装了很多包之后经常卡顿死机，所以重新装了一个新的，实在是血的教训。</p><p>更新完之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update 更新索引</span><br><span class="line"></span><br><span class="line">apt-get upgrade 更新软件</span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade 升级</span><br><span class="line"></span><br><span class="line">apt-get clean 删除缓存包</span><br><span class="line"></span><br><span class="line">apt-get autoclean 删除未安装的deb包</span><br></pre></td></tr></table></figure><p>error:</p><p><img src="D:/hexo/source/_posts/img/Network-attack/apt-无法解析域名.png"></p><p>目前网络配置有问题，解决后再写xia’wen</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br></pre></td></tr></table></figure><p>下载字体</p><p>重启虚拟机。</p><p>[TOC]</p><h2 id="参考资料-5"><a href="#参考资料-5" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="参考书-5"><a href="#参考书-5" class="headerlink" title="参考书"></a>参考书</h3><table><thead><tr><th>图书名称:</th><th>Kali Linux: Assuring Security by Penetration Testing</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://jobrest.gitbooks.io/kali-linux-cn/content/assets/feng_mian.jpeg" alt="封面"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2015-2</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>Lee Allen &#x2F; Tedi Heriyanto &#x2F; Shakeel Ali 著</td><td></td></tr><tr><td>译者</td><td>Archer 译</td><td></td></tr><tr><td>ISBN:</td><td>9787115378446</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Kali Linux2 网络渗透测试实践指南 第2版</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34261078.jpg" alt="Kali Linux2 网络渗透测试实践指南 第2版"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-3</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>李华峰 著</td><td></td></tr><tr><td>ISBN:</td><td>9787115555410</td><td></td></tr></tbody></table><h3 id="友链-5"><a href="#友链-5" class="headerlink" title="友链"></a>友链</h3><p>书籍在线阅读地址：<a href="https://jobrest.gitbooks.io/kali-linux-cn/content/index.html">Kali Linux 渗透测试的艺术（中文版） | Kali Linux 渗透测试的艺术（中文版） (gitbooks.io)</a></p><p>官网：<a href="https://www.kali.org/">Kali Linux 操作系统 |渗透测试和道德黑客 Linux 发行版</a></p><p>文档：<a href="https://www.kali.org/docs/">Kali Docs | Kali Linux Documentation</a></p><h2 id="前言-5"><a href="#前言-5" class="headerlink" title="前言"></a>前言</h2><h3 id="何为玩转kali？-5"><a href="#何为玩转kali？-5" class="headerlink" title="何为玩转kali？"></a>何为玩转kali？</h3><p>当然是想随心所欲，让“所见即所得”，让“所想立即实现”，那么此篇就是完成这个任务。</p><h2 id="第1章-Kali-Linux入门-5"><a href="#第1章-Kali-Linux入门-5" class="headerlink" title="第1章 Kali Linux入门"></a>第1章 Kali Linux入门</h2><h3 id="1-1-Kali的发展简史-5"><a href="#1-1-Kali的发展简史-5" class="headerlink" title="1.1 Kali的发展简史"></a>1.1 Kali的发展简史</h3><p>Kali Linux（Kali）是专门用于渗透测试的Linux操作系统，它由BackTrack 发展而来。在整合了IWHAX、WHOPPIX 和Auditor 这3 种渗透测试专用Live Linux 之后，BackTrack正式改名为Kali Linux。</p><p>BackTrack是相当著名的Linux发行版本。在BackTrack发布4.0预览版的时候，它的下载次数已经超过了400万次。</p><p>Kali Linux 1.0 版于2013年3 月12 日问世。在5天之后，官方为修复USB 键盘的支持问题而发布了1.0.1 版。在这短短的5 天之内，Kali 的下载次数就超过了9 万次。</p><p>根据官网的介绍（<a href="http://docs.kali.org/introduction/what-is-kali-linux%EF%BC%89%EF%BC%8C">http://docs.kali.org/introduction/what-is-kali-linux），</a> Kali的主要特色有：</p><p>● 它是基于Debian 的Linux 发行版；</p><p>● 它集成300 多个渗透测试程序；</p><p>● 它支持绝大多数的无线网卡；</p><p>● 它修改了内核以支持（无线）数据包注入；</p><p>● 所有的软件包都有研发团队的PGP 签名；</p><p>● 用户可以自制满足各自需求的Kali Linux 发行版；</p><p>● 支持基于ARM 的硬件系统。</p><h3 id="1-2-Kali-Linux工具包-5"><a href="#1-2-Kali-Linux工具包-5" class="headerlink" title="1.2 Kali Linux工具包"></a>1.2 Kali Linux工具包</h3><p>Kali Linux 含有可用于渗透测试的各种工具。这些工具程序大体可以分为以下几类。</p><p>● 信息收集：这类工具可用来收集目标的 DNS、IDS&#x2F;IPS、网络扫描、操作系统、路由、SSL、SMB、VPN、VoIP、SNMP信息和E-mail地址。</p><p>● 漏洞评估：这类工具都可以扫描目标系统上的漏洞。部分工具可以检测Cisco 网络系统缺陷，有些还可以评估各种数据库系统的安全问题。很多模糊测试软件都属于漏洞评估工具。</p><p>● Web应用：即与Web应用有关的工具。它包括CMS（内容管理系统）扫描器、数据库漏洞利用程序、Web应用模糊测试、Web应用代理、Web爬虫及Web漏洞扫描器。</p><p>● 密码攻击：无论是在线攻击还是离线破解，只要是能够实施密码攻击的工具都属于密码攻击类工具。</p><p>● 漏洞利用：这类工具可以利用在目标系统中发现的漏洞。攻击网络、Web 和数据库漏洞的软件，都属于漏洞利用（exploitation）工具。Kali 中的某些软件可以针对漏洞情况进行社会工程学攻击。</p><p>● 网络监听：这类工具用于监听网络和Web 流量。网络监听需要进行网络欺骗，所以Ettercap和Yersinia这类软件也归于这类软件。</p><p>● 访问维护：这类工具帮助渗透人员维持他们对目标主机的访问权。某些情况下，渗透人员必须先获取主机的最高权限才能安装这类软件。这类软件包括用于在 Web应用和操作系统安装后门的程序，以及隧道类工具。</p><p>● 报告工具：如果您需要撰写渗透测试的报告文件，您应该用得上这些软件。</p><p>● 系统服务：这是渗透人员在渗透测试时可能用到的常见服务类软件，它包括Apache服务、MySQL服务、SSH服务和Metasploit服务。</p><p>为了降低渗透测试人员筛选工具的难度，Kali Linux 单独划分了一类软件——Top 10 Security Tools，即10 大首选安全工具。这10 大工具分别是aircrack-ng、burp-suite、hydra、john、maltego、metasploit、nmap、sqlmap、wireshark和zaproxy。</p><p>除了可用于渗透测试的各种工具以外，Kali Linux 还整合了以下几类工具。</p><p>● 无线攻击：可攻击蓝牙、RFID&#x2F;NFC 和其他无线设备的工具。</p><p>● 逆向工程：可用于调试程序或反汇编的工具。</p><p>● 压力测试：用于各类压力测试的工具集。它们可测试网络、无线、Web 和 VoIP 系统的负载能力。</p><p>● 硬件破解：用于调试Android 和Arduino 程序的工具。</p><p>● 法证调查：即电子取证的工具。它的各种工具可以用于制作硬盘磁盘镜像、文件分析、硬盘镜像分析。如需使用这类程序，首先要在启动菜单里选择 Kali Linux Forensics | No Drives or Swap Mount。在开启这个选项以后，Kali Linux不会自动加载硬盘驱动器，以保护硬盘数据的完整性。</p><h3 id="1-3下载Kali-Linux-5"><a href="#1-3下载Kali-Linux-5" class="headerlink" title="1.3下载Kali Linux"></a>1.3下载Kali Linux</h3><p>下载是第一步要做的事情，经常使用计算机的人对下载肯定不陌生，但要想面向大众还是要解释清楚。</p><ul><li><p><input disabled="" type="checkbox"> 待补充</p></li><li><p><input disabled="" type="checkbox"> 验证哈希值</p></li></ul><h5 id="在虚拟机里使用-VM-镜像安装-Kali-Linux-5"><a href="#在虚拟机里使用-VM-镜像安装-Kali-Linux-5" class="headerlink" title="在虚拟机里使用 VM 镜像安装 Kali Linux"></a>在虚拟机里使用 VM 镜像安装 Kali Linux</h5><p>Kali Linux的iso镜像和虚拟机vmx文件等在Kali官网都有，直接下载就可以，而且下载速度也不赖。</p><p>这里我推荐直接下载Kali官方的虚拟机vmx文件，下载好了直接打开就能用，免去了很多配置环节。之前也尝试过用iso镜像做VMware，但试了几次遇到很多麻烦，因此就不搞了。</p><blockquote><p>使用硬盘镜像方式安装Kali Linux之后，系统的默认设置值如下所示。</p><p>● 硬盘容量：30 GB。</p><p>● 联网方式：NAT。</p><p>● 用户名：root。</p><p>● 密码：toor。</p><p>如果要把 Kali当做渗透测试平台使用，应当避免以 NAT方式接入网络。本文推荐您以桥接（bridged）方式联网。</p><p>在配置Kali VM 的时候，应当尽快更改默认密码。</p></blockquote><h4 id="portable-Kali-Linux-5"><a href="#portable-Kali-Linux-5" class="headerlink" title="portable Kali Linux"></a>portable Kali Linux</h4><ul><li><input disabled="" type="checkbox"> 未实操，待修改</li></ul><p>安装Kali Linux 的第三种方法，就是把它安装到USB 闪存里。通常，人们把安装在闪存上的Kali Linux 叫做portable（便携）Kali Linux。按照Kali官方文件的说法，这种安装方式的启动和安装速度最快，是Kali研发人员最喜欢的安装方式。相比在硬盘上安装，只能在一台机器上启动Kali 系统而言，装有Kali Linux 的闪存盘可以在所有支持USB 启动的主机上使用Kali系统。</p><p>这种安装方法同样适合在内存卡（SSD、SDHC、SDXC 等）上安装Kali Linux。</p><p>很多工具都可以制作portable Kali Linux。其中，Rufus（<a href="http://rufus.akeo.ie)就不错.这个工具只能在windows操作系统下运行./">http://rufus.akeo.ie）就不错。这个工具只能在Windows操作系统下运行。</a></p><p>其他可从ISO镜像文件制作可启动USB的工具如下所示：</p><p>● Win32DiskImager（<a href="https://launchpad.net/win32-image-writer%EF%BC%89%EF%BC%9B">https://launchpad.net/win32-image-writer）；</a></p><p>● Universal USB Installer（<a href="http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/%EF%BC%89%EF%BC%9B">http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/）；</a></p><p>● Linux Live USB Creator（<a href="http://www.linuxliveusb.com/">http://www.linuxliveusb.com</a>)</p><p>在制作portable Kali Linux 之前，您需要准备好几样素材。</p><p>● Kali Linux 的ISO 镜像文件：虽然您可以使用启动磁盘创建工具直接下载镜像文件，但是我们仍然认为提前下载好ISO镜像文件，再用Rufus使用镜像文件比较稳妥。</p><p>● USB 闪存盘：您需要一个容量足够大的 USB 闪存盘。我们推荐您使用 16GB 以上的闪存盘。</p><p>在下载Rufus之后，在Windows里双击rufus.exe文件就可以运行它。它会显示出程序界面。</p><p>如果您使用的是基于UNIX的操作系统，您可以直接使用dd指令创建可启动闪存盘。例如：</p><p>dd if&#x3D;kali-linux-1.0.1-i386.iso of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;512k</p><p>此处的&#x2F;dev&#x2F;sdb应当是您USB闪存盘的设备名称。</p><p>使用Rufus 创建可启动的Kali USB 闪存盘的设置如下。</p><p>● Device：选择USB 闪存驱动器。本例中，它是Windows 系统的E 盘。</p><p>● Partition scheme and target system type：设置为MBR partition scheme for BIOS or UEFI computers。</p><p>● Create a bootable disk using：设置为ISO Image 并使用右侧磁盘图标选取ISO 镜像文件。</p><p>然后点击Start创建可启动闪存盘。</p><p>在完成这些步骤之后，如果您想要立即测试USB闪存盘，则应在保存好所有文件的情况下重启计算机。您可能需要配置计算机的 BIOS，使其从 USB 磁盘启动计算机。如果没有问题的话，您应该可以通过USB 闪存盘启动Kali Linux 系统。</p><p>在USB闪存盘上安装系统之后，如果您想要让系统能够保存您所更改的文件（即persistence capabilities），您可参照Kali官方文档进行设置。请参见 Adding Persistence to Your Kali Live USB，地址为<a href="http://docs.kali.org/installation/kali-linux-live-usb-install">http://docs.kali.org/installation/kali-linux-live-usb-install</a></p><h3 id="1-4-虚拟机配置-5"><a href="#1-4-虚拟机配置-5" class="headerlink" title="1.4 虚拟机配置"></a>1.4 虚拟机配置</h3><h4 id="1-4-1-设置中文-5"><a href="#1-4-1-设置中文-5" class="headerlink" title="1.4.1 设置中文"></a>1.4.1 设置中文</h4><p>刚下好kali linux，就被全英文劝退可不太好。一看到密密麻麻的英文就敲起了退堂鼓，所以首先把系统语言设置成中文。</p><p>Learn more：<a href="https://blog.csdn.net/KNIGH_YUN/article/details/105543094">Kali Linux系统设置中文语言环境-1_kali中文设置-CSDN博客</a></p><p>具体步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>选择语言，使用空格键选中。选择en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8</p><p><img src="https://img-blog.csdnimg.cn/4346e90fd26c4a17835bcd4d3ddc6474.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>选中zh_CN.UTF-8为默认语言。</p><p><img src="https://img-blog.csdnimg.cn/8fc88465e1ee4af9b87e0f029e8c2859.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br></pre></td></tr></table></figure><p>下载字体</p><p>重启虚拟机。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-settings-zh_en.png" alt="设置中文界面"></p><p>当然，以上方法并非唯一方法，如果安装了图形界面也可以直接在设置里修改语言（X-windows），或者通过CLI修改系统配置文件。</p><h4 id="1-4-2-网络设置-4"><a href="#1-4-2-网络设置-4" class="headerlink" title="1.4.2 网络设置"></a>1.4.2 网络设置</h4><p>1．配置有线网络</p><p>无论是通过VMware 磁盘镜像还是通过ISO镜像安装Kali Linux，默认情况下Kali Linux接入网络的方式都是NAT（网络地址转换）。在NAT方式下，Kali Linux的虚拟机可以通过物理主机联入外部网络，而外部网络甚至是物理主机自身都无法直接访问安装有Kali Linux的虚拟机。</p><p>进行实地的渗透测试时，您可能需要把网络结构变更为Bridged Adapter。</p><p>如需使用桥接连接，首先要使物理主机与网络设备连接，例如路由器或交换机。同时，接入的网络里应当有DHCP服务，以分配IP地址给虚拟机。</p><p>您可能已经注意到了，通过DHCP获取的IP地址并不是固定的IP地址，这种IP地址在一定时间后可能会发生变化。如果Kali Linux 通过DHCP 获取IP 地址，在超过固定周期（DHCP的租赁时间）之后，DHCP会重新给虚拟机分配一次IP地址。重新分配的IP地址可能和上次分配的IP地址相同，也可能不同。</p><p>如果虚拟机需要使用固定的 IP 地址，应该修改虚拟机的网络设置文件&#x2F;etc&#x2F;network&#x2F;interfaces。</p><p>默认情况下，Kali Linux 的网络设置文件如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line"></span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>这个配置文件指定所有网卡都通过DHCP获取IP地址。如需为虚拟机绑定固定IP地址，就不得不对这个文件进行相应修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"></span><br><span class="line">iface eth0 inet static</span><br><span class="line"></span><br><span class="line">address 10.0.2.15</span><br><span class="line"></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">network 10.0.2.0</span><br><span class="line"></span><br><span class="line">broadcast 10.0.2.255</span><br><span class="line"></span><br><span class="line">gateway 10.0.2.2</span><br></pre></td></tr></table></figure><p>上述文件令第一个有线网卡eth0 绑定了 IP 地址10.0.2.15。您可能需要根据实际情况修改上述设置。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-查看网络配置.png"></p><p>手动设置网络：</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-网络配置.png"></p><p>error：</p><p>配置了域名服务器后导致ping其他网站都无法解析域名。</p><h4 id="1-5-3-文件夹共享-4"><a href="#1-5-3-文件夹共享-4" class="headerlink" title="1.5.3 文件夹共享"></a>1.5.3 文件夹共享</h4><h4 id="1-5-4-快照备份-4"><a href="#1-5-4-快照备份-4" class="headerlink" title="1.5.4 快照备份"></a>1.5.4 快照备份</h4><p>一旦您把虚拟机配置到理想的可工作状态，我们建议您立刻对虚拟机进行快照备份。万一日后出现配置故障，可利用快照备份把虚拟机迅速恢复到正常工作状态。</p><h4 id="1-5-5-导出虚拟机-4"><a href="#1-5-5-导出虚拟机-4" class="headerlink" title="1.5.5 导出虚拟机"></a>1.5.5 导出虚拟机</h4><p>人们时常需要以文件形式备份虚拟机，或通过这种方法把虚拟机分享给他人使用。VirtualBox的虚拟机导出功能简化了这种操作。在关闭需要导出的虚拟机之后，在菜单栏选中File | Export Appliance 就可导出所选的虚拟机。</p><h3 id="1-5-系统更新-4"><a href="#1-5-系统更新-4" class="headerlink" title="1.5 系统更新"></a>1.5 系统更新</h3><p>Kali Linux 由操作系统内核和数百个软件构成。如果需要使用软件的最新功能，您就需要将其更新到最新的版本。</p><p>我们建议您仅从Kali Linux 官方的软件仓库（repository）进行更新。</p><p>在您安装和配置好Kali Linux 之后，就应当立即进行系统更新。因为Kali 是基于Debian的操作系统，您需要使用Debian的指令（apt-get）进行系统更新。</p><p>更新指令apt-get会查询&#x2F;etc&#x2F;apt&#x2F;sources.list文件，从中获取更新服务器的信息。您需要确定这个文件指定了正确的升级服务器。</p><p>默认情况下，Kali Linux 的sources.list 文件包含下述信息。</p><h4 id="其他：apt更换国内源-4"><a href="#其他：apt更换国内源-4" class="headerlink" title="其他：apt更换国内源"></a>其他：apt更换国内源</h4><p>Kali Linux 会从系统默认的软件源去安装软件，但默认的软件源速度通常比较慢（国外的源），因此需要将其替换成国内的源。</p><p>以下是常用的国内源网站：</p><p><a href="https://opsx.alibaba.com/mirror?lang=zh-CN">阿里云镜像开源镜像站（已经更换地址）</a><br><a href="https://developer.aliyun.com/mirror/">阿里云镜像开源社区镜像站（新地址）</a><br><a href="http://mirrors.163.com/.help/ubuntu.html">网易开源镜像站</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源镜像站</a><br><a href="https://mirrors.ustc.edu.cn/">中科大开源镜像站</a></p><p>修改方式：apt源的文件位置：&#x2F;etc&#x2F;apt&#x2F;sources.list</p><blockquote><p>注意：是&#x2F;etc&#x2F;apt&#x2F;sources.list，不是&#x2F;etc&#x2F;apt&#x2F;source.list（非常重要）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.bak1</span><br><span class="line">#第一个参数时拷贝的文件路径和文件名称,第二个是拷贝到(粘贴)的文件路径和文件名</span><br><span class="line"></span><br><span class="line">sudo mousepad /etc/apt/sources.list</span><br><span class="line">#用mousepad可以直接从系统粘贴板粘贴，比vim和vi更方便操作</span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line"># deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#根据需要自己选一个，中科大的还可以</span><br><span class="line">#中科大</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">#阿里云</span><br><span class="line">#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#清华大学</span><br><span class="line">#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#浙大</span><br><span class="line">#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#东软大学</span><br><span class="line">#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#重庆大学</span><br><span class="line">#deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><blockquote><p>注：vim和vi的操作习惯很”程序员风格”，不熟悉的情况下很难使用，以下是一个vim操作的视频</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p></blockquote><p>一个小插曲：我之前的Kali虚拟机就是因为vim操作不当修改了root文件，加上安装了很多包之后经常卡顿死机，所以重新装了一个新的，实在是血的教训。</p><p>更新完之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update 更新索引</span><br><span class="line"></span><br><span class="line">apt-get upgrade 更新软件</span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade 升级</span><br><span class="line"></span><br><span class="line">apt-get clean 删除缓存包</span><br><span class="line"></span><br><span class="line">apt-get autoclean 删除未安装的deb包</span><br></pre></td></tr></table></figure><p>error:</p><p><img src="D:/hexo/source/_posts/img/Network-attack/apt-无法解析域名.png"></p><p>目前网络配置有问题，解决后再写xia’wen</p><p>当然，以上方法并非唯一方法，如果安装了图形界面也可以直接在设置里修改语言（X-windows），或者通过CLI修改系统配置文件。</p><h4 id="1-4-2-网络设置-5"><a href="#1-4-2-网络设置-5" class="headerlink" title="1.4.2 网络设置"></a>1.4.2 网络设置</h4><p>1．配置有线网络</p><p>无论是通过VMware 磁盘镜像还是通过ISO镜像安装Kali Linux，默认情况下Kali Linux接入网络的方式都是NAT（网络地址转换）。在NAT方式下，Kali Linux的虚拟机可以通过物理主机联入外部网络，而外部网络甚至是物理主机自身都无法直接访问安装有Kali Linux的虚拟机。</p><p>进行实地的渗透测试时，您可能需要把网络结构变更为Bridged Adapter。</p><p>如需使用桥接连接，首先要使物理主机与网络设备连接，例如路由器或交换机。同时，接入的网络里应当有DHCP服务，以分配IP地址给虚拟机。</p><p>您可能已经注意到了，通过DHCP获取的IP地址并不是固定的IP地址，这种IP地址在一定时间后可能会发生变化。如果Kali Linux 通过DHCP 获取IP 地址，在超过固定周期（DHCP的租赁时间）之后，DHCP会重新给虚拟机分配一次IP地址。重新分配的IP地址可能和上次分配的IP地址相同，也可能不同。</p><p>如果虚拟机需要使用固定的 IP 地址，应该修改虚拟机的网络设置文件&#x2F;etc&#x2F;network&#x2F;interfaces。</p><p>默认情况下，Kali Linux 的网络设置文件如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line"></span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>这个配置文件指定所有网卡都通过DHCP获取IP地址。如需为虚拟机绑定固定IP地址，就不得不对这个文件进行相应修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"></span><br><span class="line">iface eth0 inet static</span><br><span class="line"></span><br><span class="line">address 10.0.2.15</span><br><span class="line"></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">network 10.0.2.0</span><br><span class="line"></span><br><span class="line">broadcast 10.0.2.255</span><br><span class="line"></span><br><span class="line">gateway 10.0.2.2</span><br></pre></td></tr></table></figure><p>上述文件令第一个有线网卡eth0 绑定了 IP 地址10.0.2.15。您可能需要根据实际情况修改上述设置。</p><p>[TOC]</p><h2 id="参考资料-6"><a href="#参考资料-6" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="参考书-6"><a href="#参考书-6" class="headerlink" title="参考书"></a>参考书</h3><table><thead><tr><th>图书名称:</th><th>Kali Linux: Assuring Security by Penetration Testing</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://jobrest.gitbooks.io/kali-linux-cn/content/assets/feng_mian.jpeg" alt="封面"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2015-2</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>Lee Allen &#x2F; Tedi Heriyanto &#x2F; Shakeel Ali 著</td><td></td></tr><tr><td>译者</td><td>Archer 译</td><td></td></tr><tr><td>ISBN:</td><td>9787115378446</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Kali Linux2 网络渗透测试实践指南 第2版</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34261078.jpg" alt="Kali Linux2 网络渗透测试实践指南 第2版"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-3</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>李华峰 著</td><td></td></tr><tr><td>ISBN:</td><td>9787115555410</td><td></td></tr></tbody></table><h3 id="友链-6"><a href="#友链-6" class="headerlink" title="友链"></a>友链</h3><p>书籍在线阅读地址：<a href="https://jobrest.gitbooks.io/kali-linux-cn/content/index.html">Kali Linux 渗透测试的艺术（中文版） | Kali Linux 渗透测试的艺术（中文版） (gitbooks.io)</a></p><p>官网：<a href="https://www.kali.org/">Kali Linux 操作系统 |渗透测试和道德黑客 Linux 发行版</a></p><p>文档：<a href="https://www.kali.org/docs/">Kali Docs | Kali Linux Documentation</a></p><h2 id="前言-6"><a href="#前言-6" class="headerlink" title="前言"></a>前言</h2><h3 id="何为玩转kali？-6"><a href="#何为玩转kali？-6" class="headerlink" title="何为玩转kali？"></a>何为玩转kali？</h3><p>当然是想随心所欲，让“所见即所得”，让“所想立即实现”，那么此篇就是完成这个任务。</p><h2 id="第1章-Kali-Linux入门-6"><a href="#第1章-Kali-Linux入门-6" class="headerlink" title="第1章 Kali Linux入门"></a>第1章 Kali Linux入门</h2><h3 id="1-1-Kali的发展简史-6"><a href="#1-1-Kali的发展简史-6" class="headerlink" title="1.1 Kali的发展简史"></a>1.1 Kali的发展简史</h3><p>Kali Linux（Kali）是专门用于渗透测试的Linux操作系统，它由BackTrack 发展而来。在整合了IWHAX、WHOPPIX 和Auditor 这3 种渗透测试专用Live Linux 之后，BackTrack正式改名为Kali Linux。</p><p>BackTrack是相当著名的Linux发行版本。在BackTrack发布4.0预览版的时候，它的下载次数已经超过了400万次。</p><p>Kali Linux 1.0 版于2013年3 月12 日问世。在5天之后，官方为修复USB 键盘的支持问题而发布了1.0.1 版。在这短短的5 天之内，Kali 的下载次数就超过了9 万次。</p><p>根据官网的介绍（<a href="http://docs.kali.org/introduction/what-is-kali-linux%EF%BC%89%EF%BC%8C">http://docs.kali.org/introduction/what-is-kali-linux），</a> Kali的主要特色有：</p><p>● 它是基于Debian 的Linux 发行版；</p><p>● 它集成300 多个渗透测试程序；</p><p>● 它支持绝大多数的无线网卡；</p><p>● 它修改了内核以支持（无线）数据包注入；</p><p>● 所有的软件包都有研发团队的PGP 签名；</p><p>● 用户可以自制满足各自需求的Kali Linux 发行版；</p><p>● 支持基于ARM 的硬件系统。</p><h3 id="1-2-Kali-Linux工具包-6"><a href="#1-2-Kali-Linux工具包-6" class="headerlink" title="1.2 Kali Linux工具包"></a>1.2 Kali Linux工具包</h3><p>Kali Linux 含有可用于渗透测试的各种工具。这些工具程序大体可以分为以下几类。</p><p>● 信息收集：这类工具可用来收集目标的 DNS、IDS&#x2F;IPS、网络扫描、操作系统、路由、SSL、SMB、VPN、VoIP、SNMP信息和E-mail地址。</p><p>● 漏洞评估：这类工具都可以扫描目标系统上的漏洞。部分工具可以检测Cisco 网络系统缺陷，有些还可以评估各种数据库系统的安全问题。很多模糊测试软件都属于漏洞评估工具。</p><p>● Web应用：即与Web应用有关的工具。它包括CMS（内容管理系统）扫描器、数据库漏洞利用程序、Web应用模糊测试、Web应用代理、Web爬虫及Web漏洞扫描器。</p><p>● 密码攻击：无论是在线攻击还是离线破解，只要是能够实施密码攻击的工具都属于密码攻击类工具。</p><p>● 漏洞利用：这类工具可以利用在目标系统中发现的漏洞。攻击网络、Web 和数据库漏洞的软件，都属于漏洞利用（exploitation）工具。Kali 中的某些软件可以针对漏洞情况进行社会工程学攻击。</p><p>● 网络监听：这类工具用于监听网络和Web 流量。网络监听需要进行网络欺骗，所以Ettercap和Yersinia这类软件也归于这类软件。</p><p>● 访问维护：这类工具帮助渗透人员维持他们对目标主机的访问权。某些情况下，渗透人员必须先获取主机的最高权限才能安装这类软件。这类软件包括用于在 Web应用和操作系统安装后门的程序，以及隧道类工具。</p><p>● 报告工具：如果您需要撰写渗透测试的报告文件，您应该用得上这些软件。</p><p>● 系统服务：这是渗透人员在渗透测试时可能用到的常见服务类软件，它包括Apache服务、MySQL服务、SSH服务和Metasploit服务。</p><p>为了降低渗透测试人员筛选工具的难度，Kali Linux 单独划分了一类软件——Top 10 Security Tools，即10 大首选安全工具。这10 大工具分别是aircrack-ng、burp-suite、hydra、john、maltego、metasploit、nmap、sqlmap、wireshark和zaproxy。</p><p>除了可用于渗透测试的各种工具以外，Kali Linux 还整合了以下几类工具。</p><p>● 无线攻击：可攻击蓝牙、RFID&#x2F;NFC 和其他无线设备的工具。</p><p>● 逆向工程：可用于调试程序或反汇编的工具。</p><p>● 压力测试：用于各类压力测试的工具集。它们可测试网络、无线、Web 和 VoIP 系统的负载能力。</p><p>● 硬件破解：用于调试Android 和Arduino 程序的工具。</p><p>● 法证调查：即电子取证的工具。它的各种工具可以用于制作硬盘磁盘镜像、文件分析、硬盘镜像分析。如需使用这类程序，首先要在启动菜单里选择 Kali Linux Forensics | No Drives or Swap Mount。在开启这个选项以后，Kali Linux不会自动加载硬盘驱动器，以保护硬盘数据的完整性。</p><h3 id="1-3下载Kali-Linux-6"><a href="#1-3下载Kali-Linux-6" class="headerlink" title="1.3下载Kali Linux"></a>1.3下载Kali Linux</h3><p>下载是第一步要做的事情，经常使用计算机的人对下载肯定不陌生，但要想面向大众还是要解释清楚。</p><ul><li><p><input disabled="" type="checkbox"> 待补充</p></li><li><p><input disabled="" type="checkbox"> 验证哈希值</p></li></ul><h5 id="在虚拟机里使用-VM-镜像安装-Kali-Linux-6"><a href="#在虚拟机里使用-VM-镜像安装-Kali-Linux-6" class="headerlink" title="在虚拟机里使用 VM 镜像安装 Kali Linux"></a>在虚拟机里使用 VM 镜像安装 Kali Linux</h5><p>Kali Linux的iso镜像和虚拟机vmx文件等在Kali官网都有，直接下载就可以，而且下载速度也不赖。</p><p>这里我推荐直接下载Kali官方的虚拟机vmx文件，下载好了直接打开就能用，免去了很多配置环节。之前也尝试过用iso镜像做VMware，但试了几次遇到很多麻烦，因此就不搞了。</p><blockquote><p>使用硬盘镜像方式安装Kali Linux之后，系统的默认设置值如下所示。</p><p>● 硬盘容量：30 GB。</p><p>● 联网方式：NAT。</p><p>● 用户名：root。</p><p>● 密码：toor。</p><p>如果要把 Kali当做渗透测试平台使用，应当避免以 NAT方式接入网络。本文推荐您以桥接（bridged）方式联网。</p><p>在配置Kali VM 的时候，应当尽快更改默认密码。</p></blockquote><h4 id="portable-Kali-Linux-6"><a href="#portable-Kali-Linux-6" class="headerlink" title="portable Kali Linux"></a>portable Kali Linux</h4><ul><li><input disabled="" type="checkbox"> 未实操，待修改</li></ul><p>安装Kali Linux 的第三种方法，就是把它安装到USB 闪存里。通常，人们把安装在闪存上的Kali Linux 叫做portable（便携）Kali Linux。按照Kali官方文件的说法，这种安装方式的启动和安装速度最快，是Kali研发人员最喜欢的安装方式。相比在硬盘上安装，只能在一台机器上启动Kali 系统而言，装有Kali Linux 的闪存盘可以在所有支持USB 启动的主机上使用Kali系统。</p><p>这种安装方法同样适合在内存卡（SSD、SDHC、SDXC 等）上安装Kali Linux。</p><p>很多工具都可以制作portable Kali Linux。其中，Rufus（<a href="http://rufus.akeo.ie)就不错.这个工具只能在windows操作系统下运行./">http://rufus.akeo.ie）就不错。这个工具只能在Windows操作系统下运行。</a></p><p>其他可从ISO镜像文件制作可启动USB的工具如下所示：</p><p>● Win32DiskImager（<a href="https://launchpad.net/win32-image-writer%EF%BC%89%EF%BC%9B">https://launchpad.net/win32-image-writer）；</a></p><p>● Universal USB Installer（<a href="http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/%EF%BC%89%EF%BC%9B">http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/）；</a></p><p>● Linux Live USB Creator（<a href="http://www.linuxliveusb.com/">http://www.linuxliveusb.com</a>)</p><p>在制作portable Kali Linux 之前，您需要准备好几样素材。</p><p>● Kali Linux 的ISO 镜像文件：虽然您可以使用启动磁盘创建工具直接下载镜像文件，但是我们仍然认为提前下载好ISO镜像文件，再用Rufus使用镜像文件比较稳妥。</p><p>● USB 闪存盘：您需要一个容量足够大的 USB 闪存盘。我们推荐您使用 16GB 以上的闪存盘。</p><p>在下载Rufus之后，在Windows里双击rufus.exe文件就可以运行它。它会显示出程序界面。</p><p>如果您使用的是基于UNIX的操作系统，您可以直接使用dd指令创建可启动闪存盘。例如：</p><p>dd if&#x3D;kali-linux-1.0.1-i386.iso of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;512k</p><p>此处的&#x2F;dev&#x2F;sdb应当是您USB闪存盘的设备名称。</p><p>使用Rufus 创建可启动的Kali USB 闪存盘的设置如下。</p><p>● Device：选择USB 闪存驱动器。本例中，它是Windows 系统的E 盘。</p><p>● Partition scheme and target system type：设置为MBR partition scheme for BIOS or UEFI computers。</p><p>● Create a bootable disk using：设置为ISO Image 并使用右侧磁盘图标选取ISO 镜像文件。</p><p>然后点击Start创建可启动闪存盘。</p><p>在完成这些步骤之后，如果您想要立即测试USB闪存盘，则应在保存好所有文件的情况下重启计算机。您可能需要配置计算机的 BIOS，使其从 USB 磁盘启动计算机。如果没有问题的话，您应该可以通过USB 闪存盘启动Kali Linux 系统。</p><p>在USB闪存盘上安装系统之后，如果您想要让系统能够保存您所更改的文件（即persistence capabilities），您可参照Kali官方文档进行设置。请参见 Adding Persistence to Your Kali Live USB，地址为<a href="http://docs.kali.org/installation/kali-linux-live-usb-install">http://docs.kali.org/installation/kali-linux-live-usb-install</a></p><h3 id="1-4-虚拟机配置-6"><a href="#1-4-虚拟机配置-6" class="headerlink" title="1.4 虚拟机配置"></a>1.4 虚拟机配置</h3><h4 id="1-4-1-设置中文-6"><a href="#1-4-1-设置中文-6" class="headerlink" title="1.4.1 设置中文"></a>1.4.1 设置中文</h4><p>刚下好kali linux，就被全英文劝退可不太好。一看到密密麻麻的英文就敲起了退堂鼓，所以首先把系统语言设置成中文。</p><p>Learn more：<a href="https://blog.csdn.net/KNIGH_YUN/article/details/105543094">Kali Linux系统设置中文语言环境-1_kali中文设置-CSDN博客</a></p><p>具体步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>选择语言，使用空格键选中。选择en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8</p><p><img src="https://img-blog.csdnimg.cn/4346e90fd26c4a17835bcd4d3ddc6474.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>选中zh_CN.UTF-8为默认语言。</p><p><img src="https://img-blog.csdnimg.cn/8fc88465e1ee4af9b87e0f029e8c2859.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br></pre></td></tr></table></figure><p>下载字体</p><p>重启虚拟机。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-settings-zh_en.png" alt="设置中文界面"></p><p>当然，以上方法并非唯一方法，如果安装了图形界面也可以直接在设置里修改语言（X-windows），或者通过CLI修改系统配置文件。</p><h4 id="1-4-2-网络设置-6"><a href="#1-4-2-网络设置-6" class="headerlink" title="1.4.2 网络设置"></a>1.4.2 网络设置</h4><p>1．配置有线网络</p><p>无论是通过VMware 磁盘镜像还是通过ISO镜像安装Kali Linux，默认情况下Kali Linux接入网络的方式都是NAT（网络地址转换）。在NAT方式下，Kali Linux的虚拟机可以通过物理主机联入外部网络，而外部网络甚至是物理主机自身都无法直接访问安装有Kali Linux的虚拟机。</p><p>进行实地的渗透测试时，您可能需要把网络结构变更为Bridged Adapter。</p><p>如需使用桥接连接，首先要使物理主机与网络设备连接，例如路由器或交换机。同时，接入的网络里应当有DHCP服务，以分配IP地址给虚拟机。</p><p>您可能已经注意到了，通过DHCP获取的IP地址并不是固定的IP地址，这种IP地址在一定时间后可能会发生变化。如果Kali Linux 通过DHCP 获取IP 地址，在超过固定周期（DHCP的租赁时间）之后，DHCP会重新给虚拟机分配一次IP地址。重新分配的IP地址可能和上次分配的IP地址相同，也可能不同。</p><p>如果虚拟机需要使用固定的 IP 地址，应该修改虚拟机的网络设置文件&#x2F;etc&#x2F;network&#x2F;interfaces。</p><p>默认情况下，Kali Linux 的网络设置文件如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line"></span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>这个配置文件指定所有网卡都通过DHCP获取IP地址。如需为虚拟机绑定固定IP地址，就不得不对这个文件进行相应修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"></span><br><span class="line">iface eth0 inet static</span><br><span class="line"></span><br><span class="line">address 10.0.2.15</span><br><span class="line"></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">network 10.0.2.0</span><br><span class="line"></span><br><span class="line">broadcast 10.0.2.255</span><br><span class="line"></span><br><span class="line">gateway 10.0.2.2</span><br></pre></td></tr></table></figure><p>上述文件令第一个有线网卡eth0 绑定了 IP 地址10.0.2.15。您可能需要根据实际情况修改上述设置。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-查看网络配置.png"></p><p>手动设置网络：</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-网络配置.png"></p><p>error：</p><p>配置了域名服务器后导致ping其他网站都无法解析域名。</p><h4 id="1-5-3-文件夹共享-5"><a href="#1-5-3-文件夹共享-5" class="headerlink" title="1.5.3 文件夹共享"></a>1.5.3 文件夹共享</h4><h4 id="1-5-4-快照备份-5"><a href="#1-5-4-快照备份-5" class="headerlink" title="1.5.4 快照备份"></a>1.5.4 快照备份</h4><p>一旦您把虚拟机配置到理想的可工作状态，我们建议您立刻对虚拟机进行快照备份。万一日后出现配置故障，可利用快照备份把虚拟机迅速恢复到正常工作状态。</p><h4 id="1-5-5-导出虚拟机-5"><a href="#1-5-5-导出虚拟机-5" class="headerlink" title="1.5.5 导出虚拟机"></a>1.5.5 导出虚拟机</h4><p>人们时常需要以文件形式备份虚拟机，或通过这种方法把虚拟机分享给他人使用。VirtualBox的虚拟机导出功能简化了这种操作。在关闭需要导出的虚拟机之后，在菜单栏选中File | Export Appliance 就可导出所选的虚拟机。</p><h3 id="1-5-系统更新-5"><a href="#1-5-系统更新-5" class="headerlink" title="1.5 系统更新"></a>1.5 系统更新</h3><p>Kali Linux 由操作系统内核和数百个软件构成。如果需要使用软件的最新功能，您就需要将其更新到最新的版本。</p><p>我们建议您仅从Kali Linux 官方的软件仓库（repository）进行更新。</p><p>在您安装和配置好Kali Linux 之后，就应当立即进行系统更新。因为Kali 是基于Debian的操作系统，您需要使用Debian的指令（apt-get）进行系统更新。</p><p>更新指令apt-get会查询&#x2F;etc&#x2F;apt&#x2F;sources.list文件，从中获取更新服务器的信息。您需要确定这个文件指定了正确的升级服务器。</p><p>默认情况下，Kali Linux 的sources.list 文件包含下述信息。</p><h4 id="其他：apt更换国内源-5"><a href="#其他：apt更换国内源-5" class="headerlink" title="其他：apt更换国内源"></a>其他：apt更换国内源</h4><p>Kali Linux 会从系统默认的软件源去安装软件，但默认的软件源速度通常比较慢（国外的源），因此需要将其替换成国内的源。</p><p>以下是常用的国内源网站：</p><p><a href="https://opsx.alibaba.com/mirror?lang=zh-CN">阿里云镜像开源镜像站（已经更换地址）</a><br><a href="https://developer.aliyun.com/mirror/">阿里云镜像开源社区镜像站（新地址）</a><br><a href="http://mirrors.163.com/.help/ubuntu.html">网易开源镜像站</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源镜像站</a><br><a href="https://mirrors.ustc.edu.cn/">中科大开源镜像站</a></p><p>修改方式：apt源的文件位置：&#x2F;etc&#x2F;apt&#x2F;sources.list</p><blockquote><p>注意：是&#x2F;etc&#x2F;apt&#x2F;sources.list，不是&#x2F;etc&#x2F;apt&#x2F;source.list（非常重要）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.bak1</span><br><span class="line">#第一个参数时拷贝的文件路径和文件名称,第二个是拷贝到(粘贴)的文件路径和文件名</span><br><span class="line"></span><br><span class="line">sudo mousepad /etc/apt/sources.list</span><br><span class="line">#用mousepad可以直接从系统粘贴板粘贴，比vim和vi更方便操作</span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line"># deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#根据需要自己选一个，中科大的还可以</span><br><span class="line">#中科大</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">#阿里云</span><br><span class="line">#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#清华大学</span><br><span class="line">#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#浙大</span><br><span class="line">#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#东软大学</span><br><span class="line">#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#重庆大学</span><br><span class="line">#deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><blockquote><p>注：vim和vi的操作习惯很”程序员风格”，不熟悉的情况下很难使用，以下是一个vim操作的视频</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p></blockquote><p>一个小插曲：我之前的Kali虚拟机就是因为vim操作不当修改了root文件，加上安装了很多包之后经常卡顿死机，所以重新装了一个新的，实在是血的教训。</p><p>更新完之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update 更新索引</span><br><span class="line"></span><br><span class="line">apt-get upgrade 更新软件</span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade 升级</span><br><span class="line"></span><br><span class="line">apt-get clean 删除缓存包</span><br><span class="line"></span><br><span class="line">apt-get autoclean 删除未安装的deb包</span><br></pre></td></tr></table></figure><p>error:</p><p><img src="D:/hexo/source/_posts/img/Network-attack/apt-无法解析域名.png"></p><p>目前网络配置有问题，解决后再写xia’wen</p><p>手动设置网络：</p><p>[TOC]</p><h2 id="参考资料-7"><a href="#参考资料-7" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="参考书-7"><a href="#参考书-7" class="headerlink" title="参考书"></a>参考书</h3><table><thead><tr><th>图书名称:</th><th>Kali Linux: Assuring Security by Penetration Testing</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://jobrest.gitbooks.io/kali-linux-cn/content/assets/feng_mian.jpeg" alt="封面"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2015-2</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>Lee Allen &#x2F; Tedi Heriyanto &#x2F; Shakeel Ali 著</td><td></td></tr><tr><td>译者</td><td>Archer 译</td><td></td></tr><tr><td>ISBN:</td><td>9787115378446</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Kali Linux2 网络渗透测试实践指南 第2版</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34261078.jpg" alt="Kali Linux2 网络渗透测试实践指南 第2版"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-3</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>李华峰 著</td><td></td></tr><tr><td>ISBN:</td><td>9787115555410</td><td></td></tr></tbody></table><h3 id="友链-7"><a href="#友链-7" class="headerlink" title="友链"></a>友链</h3><p>书籍在线阅读地址：<a href="https://jobrest.gitbooks.io/kali-linux-cn/content/index.html">Kali Linux 渗透测试的艺术（中文版） | Kali Linux 渗透测试的艺术（中文版） (gitbooks.io)</a></p><p>官网：<a href="https://www.kali.org/">Kali Linux 操作系统 |渗透测试和道德黑客 Linux 发行版</a></p><p>文档：<a href="https://www.kali.org/docs/">Kali Docs | Kali Linux Documentation</a></p><h2 id="前言-7"><a href="#前言-7" class="headerlink" title="前言"></a>前言</h2><h3 id="何为玩转kali？-7"><a href="#何为玩转kali？-7" class="headerlink" title="何为玩转kali？"></a>何为玩转kali？</h3><p>当然是想随心所欲，让“所见即所得”，让“所想立即实现”，那么此篇就是完成这个任务。</p><h2 id="第1章-Kali-Linux入门-7"><a href="#第1章-Kali-Linux入门-7" class="headerlink" title="第1章 Kali Linux入门"></a>第1章 Kali Linux入门</h2><h3 id="1-1-Kali的发展简史-7"><a href="#1-1-Kali的发展简史-7" class="headerlink" title="1.1 Kali的发展简史"></a>1.1 Kali的发展简史</h3><p>Kali Linux（Kali）是专门用于渗透测试的Linux操作系统，它由BackTrack 发展而来。在整合了IWHAX、WHOPPIX 和Auditor 这3 种渗透测试专用Live Linux 之后，BackTrack正式改名为Kali Linux。</p><p>BackTrack是相当著名的Linux发行版本。在BackTrack发布4.0预览版的时候，它的下载次数已经超过了400万次。</p><p>Kali Linux 1.0 版于2013年3 月12 日问世。在5天之后，官方为修复USB 键盘的支持问题而发布了1.0.1 版。在这短短的5 天之内，Kali 的下载次数就超过了9 万次。</p><p>根据官网的介绍（<a href="http://docs.kali.org/introduction/what-is-kali-linux%EF%BC%89%EF%BC%8C">http://docs.kali.org/introduction/what-is-kali-linux），</a> Kali的主要特色有：</p><p>● 它是基于Debian 的Linux 发行版；</p><p>● 它集成300 多个渗透测试程序；</p><p>● 它支持绝大多数的无线网卡；</p><p>● 它修改了内核以支持（无线）数据包注入；</p><p>● 所有的软件包都有研发团队的PGP 签名；</p><p>● 用户可以自制满足各自需求的Kali Linux 发行版；</p><p>● 支持基于ARM 的硬件系统。</p><h3 id="1-2-Kali-Linux工具包-7"><a href="#1-2-Kali-Linux工具包-7" class="headerlink" title="1.2 Kali Linux工具包"></a>1.2 Kali Linux工具包</h3><p>Kali Linux 含有可用于渗透测试的各种工具。这些工具程序大体可以分为以下几类。</p><p>● 信息收集：这类工具可用来收集目标的 DNS、IDS&#x2F;IPS、网络扫描、操作系统、路由、SSL、SMB、VPN、VoIP、SNMP信息和E-mail地址。</p><p>● 漏洞评估：这类工具都可以扫描目标系统上的漏洞。部分工具可以检测Cisco 网络系统缺陷，有些还可以评估各种数据库系统的安全问题。很多模糊测试软件都属于漏洞评估工具。</p><p>● Web应用：即与Web应用有关的工具。它包括CMS（内容管理系统）扫描器、数据库漏洞利用程序、Web应用模糊测试、Web应用代理、Web爬虫及Web漏洞扫描器。</p><p>● 密码攻击：无论是在线攻击还是离线破解，只要是能够实施密码攻击的工具都属于密码攻击类工具。</p><p>● 漏洞利用：这类工具可以利用在目标系统中发现的漏洞。攻击网络、Web 和数据库漏洞的软件，都属于漏洞利用（exploitation）工具。Kali 中的某些软件可以针对漏洞情况进行社会工程学攻击。</p><p>● 网络监听：这类工具用于监听网络和Web 流量。网络监听需要进行网络欺骗，所以Ettercap和Yersinia这类软件也归于这类软件。</p><p>● 访问维护：这类工具帮助渗透人员维持他们对目标主机的访问权。某些情况下，渗透人员必须先获取主机的最高权限才能安装这类软件。这类软件包括用于在 Web应用和操作系统安装后门的程序，以及隧道类工具。</p><p>● 报告工具：如果您需要撰写渗透测试的报告文件，您应该用得上这些软件。</p><p>● 系统服务：这是渗透人员在渗透测试时可能用到的常见服务类软件，它包括Apache服务、MySQL服务、SSH服务和Metasploit服务。</p><p>为了降低渗透测试人员筛选工具的难度，Kali Linux 单独划分了一类软件——Top 10 Security Tools，即10 大首选安全工具。这10 大工具分别是aircrack-ng、burp-suite、hydra、john、maltego、metasploit、nmap、sqlmap、wireshark和zaproxy。</p><p>除了可用于渗透测试的各种工具以外，Kali Linux 还整合了以下几类工具。</p><p>● 无线攻击：可攻击蓝牙、RFID&#x2F;NFC 和其他无线设备的工具。</p><p>● 逆向工程：可用于调试程序或反汇编的工具。</p><p>● 压力测试：用于各类压力测试的工具集。它们可测试网络、无线、Web 和 VoIP 系统的负载能力。</p><p>● 硬件破解：用于调试Android 和Arduino 程序的工具。</p><p>● 法证调查：即电子取证的工具。它的各种工具可以用于制作硬盘磁盘镜像、文件分析、硬盘镜像分析。如需使用这类程序，首先要在启动菜单里选择 Kali Linux Forensics | No Drives or Swap Mount。在开启这个选项以后，Kali Linux不会自动加载硬盘驱动器，以保护硬盘数据的完整性。</p><h3 id="1-3下载Kali-Linux-7"><a href="#1-3下载Kali-Linux-7" class="headerlink" title="1.3下载Kali Linux"></a>1.3下载Kali Linux</h3><p>下载是第一步要做的事情，经常使用计算机的人对下载肯定不陌生，但要想面向大众还是要解释清楚。</p><ul><li><p><input disabled="" type="checkbox"> 待补充</p></li><li><p><input disabled="" type="checkbox"> 验证哈希值</p></li></ul><h5 id="在虚拟机里使用-VM-镜像安装-Kali-Linux-7"><a href="#在虚拟机里使用-VM-镜像安装-Kali-Linux-7" class="headerlink" title="在虚拟机里使用 VM 镜像安装 Kali Linux"></a>在虚拟机里使用 VM 镜像安装 Kali Linux</h5><p>Kali Linux的iso镜像和虚拟机vmx文件等在Kali官网都有，直接下载就可以，而且下载速度也不赖。</p><p>这里我推荐直接下载Kali官方的虚拟机vmx文件，下载好了直接打开就能用，免去了很多配置环节。之前也尝试过用iso镜像做VMware，但试了几次遇到很多麻烦，因此就不搞了。</p><blockquote><p>使用硬盘镜像方式安装Kali Linux之后，系统的默认设置值如下所示。</p><p>● 硬盘容量：30 GB。</p><p>● 联网方式：NAT。</p><p>● 用户名：root。</p><p>● 密码：toor。</p><p>如果要把 Kali当做渗透测试平台使用，应当避免以 NAT方式接入网络。本文推荐您以桥接（bridged）方式联网。</p><p>在配置Kali VM 的时候，应当尽快更改默认密码。</p></blockquote><h4 id="portable-Kali-Linux-7"><a href="#portable-Kali-Linux-7" class="headerlink" title="portable Kali Linux"></a>portable Kali Linux</h4><ul><li><input disabled="" type="checkbox"> 未实操，待修改</li></ul><p>安装Kali Linux 的第三种方法，就是把它安装到USB 闪存里。通常，人们把安装在闪存上的Kali Linux 叫做portable（便携）Kali Linux。按照Kali官方文件的说法，这种安装方式的启动和安装速度最快，是Kali研发人员最喜欢的安装方式。相比在硬盘上安装，只能在一台机器上启动Kali 系统而言，装有Kali Linux 的闪存盘可以在所有支持USB 启动的主机上使用Kali系统。</p><p>这种安装方法同样适合在内存卡（SSD、SDHC、SDXC 等）上安装Kali Linux。</p><p>很多工具都可以制作portable Kali Linux。其中，Rufus（<a href="http://rufus.akeo.ie)就不错.这个工具只能在windows操作系统下运行./">http://rufus.akeo.ie）就不错。这个工具只能在Windows操作系统下运行。</a></p><p>其他可从ISO镜像文件制作可启动USB的工具如下所示：</p><p>● Win32DiskImager（<a href="https://launchpad.net/win32-image-writer%EF%BC%89%EF%BC%9B">https://launchpad.net/win32-image-writer）；</a></p><p>● Universal USB Installer（<a href="http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/%EF%BC%89%EF%BC%9B">http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/）；</a></p><p>● Linux Live USB Creator（<a href="http://www.linuxliveusb.com/">http://www.linuxliveusb.com</a>)</p><p>在制作portable Kali Linux 之前，您需要准备好几样素材。</p><p>● Kali Linux 的ISO 镜像文件：虽然您可以使用启动磁盘创建工具直接下载镜像文件，但是我们仍然认为提前下载好ISO镜像文件，再用Rufus使用镜像文件比较稳妥。</p><p>● USB 闪存盘：您需要一个容量足够大的 USB 闪存盘。我们推荐您使用 16GB 以上的闪存盘。</p><p>在下载Rufus之后，在Windows里双击rufus.exe文件就可以运行它。它会显示出程序界面。</p><p>如果您使用的是基于UNIX的操作系统，您可以直接使用dd指令创建可启动闪存盘。例如：</p><p>dd if&#x3D;kali-linux-1.0.1-i386.iso of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;512k</p><p>此处的&#x2F;dev&#x2F;sdb应当是您USB闪存盘的设备名称。</p><p>使用Rufus 创建可启动的Kali USB 闪存盘的设置如下。</p><p>● Device：选择USB 闪存驱动器。本例中，它是Windows 系统的E 盘。</p><p>● Partition scheme and target system type：设置为MBR partition scheme for BIOS or UEFI computers。</p><p>● Create a bootable disk using：设置为ISO Image 并使用右侧磁盘图标选取ISO 镜像文件。</p><p>然后点击Start创建可启动闪存盘。</p><p>在完成这些步骤之后，如果您想要立即测试USB闪存盘，则应在保存好所有文件的情况下重启计算机。您可能需要配置计算机的 BIOS，使其从 USB 磁盘启动计算机。如果没有问题的话，您应该可以通过USB 闪存盘启动Kali Linux 系统。</p><p>在USB闪存盘上安装系统之后，如果您想要让系统能够保存您所更改的文件（即persistence capabilities），您可参照Kali官方文档进行设置。请参见 Adding Persistence to Your Kali Live USB，地址为<a href="http://docs.kali.org/installation/kali-linux-live-usb-install">http://docs.kali.org/installation/kali-linux-live-usb-install</a></p><h3 id="1-4-虚拟机配置-7"><a href="#1-4-虚拟机配置-7" class="headerlink" title="1.4 虚拟机配置"></a>1.4 虚拟机配置</h3><h4 id="1-4-1-设置中文-7"><a href="#1-4-1-设置中文-7" class="headerlink" title="1.4.1 设置中文"></a>1.4.1 设置中文</h4><p>刚下好kali linux，就被全英文劝退可不太好。一看到密密麻麻的英文就敲起了退堂鼓，所以首先把系统语言设置成中文。</p><p>Learn more：<a href="https://blog.csdn.net/KNIGH_YUN/article/details/105543094">Kali Linux系统设置中文语言环境-1_kali中文设置-CSDN博客</a></p><p>具体步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>选择语言，使用空格键选中。选择en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8</p><p><img src="https://img-blog.csdnimg.cn/4346e90fd26c4a17835bcd4d3ddc6474.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>选中zh_CN.UTF-8为默认语言。</p><p><img src="https://img-blog.csdnimg.cn/8fc88465e1ee4af9b87e0f029e8c2859.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br></pre></td></tr></table></figure><p>下载字体</p><p>重启虚拟机。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-settings-zh_en.png" alt="设置中文界面"></p><p>当然，以上方法并非唯一方法，如果安装了图形界面也可以直接在设置里修改语言（X-windows），或者通过CLI修改系统配置文件。</p><h4 id="1-4-2-网络设置-7"><a href="#1-4-2-网络设置-7" class="headerlink" title="1.4.2 网络设置"></a>1.4.2 网络设置</h4><p>1．配置有线网络</p><p>无论是通过VMware 磁盘镜像还是通过ISO镜像安装Kali Linux，默认情况下Kali Linux接入网络的方式都是NAT（网络地址转换）。在NAT方式下，Kali Linux的虚拟机可以通过物理主机联入外部网络，而外部网络甚至是物理主机自身都无法直接访问安装有Kali Linux的虚拟机。</p><p>进行实地的渗透测试时，您可能需要把网络结构变更为Bridged Adapter。</p><p>如需使用桥接连接，首先要使物理主机与网络设备连接，例如路由器或交换机。同时，接入的网络里应当有DHCP服务，以分配IP地址给虚拟机。</p><p>您可能已经注意到了，通过DHCP获取的IP地址并不是固定的IP地址，这种IP地址在一定时间后可能会发生变化。如果Kali Linux 通过DHCP 获取IP 地址，在超过固定周期（DHCP的租赁时间）之后，DHCP会重新给虚拟机分配一次IP地址。重新分配的IP地址可能和上次分配的IP地址相同，也可能不同。</p><p>如果虚拟机需要使用固定的 IP 地址，应该修改虚拟机的网络设置文件&#x2F;etc&#x2F;network&#x2F;interfaces。</p><p>默认情况下，Kali Linux 的网络设置文件如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line"></span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>这个配置文件指定所有网卡都通过DHCP获取IP地址。如需为虚拟机绑定固定IP地址，就不得不对这个文件进行相应修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"></span><br><span class="line">iface eth0 inet static</span><br><span class="line"></span><br><span class="line">address 10.0.2.15</span><br><span class="line"></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">network 10.0.2.0</span><br><span class="line"></span><br><span class="line">broadcast 10.0.2.255</span><br><span class="line"></span><br><span class="line">gateway 10.0.2.2</span><br></pre></td></tr></table></figure><p>上述文件令第一个有线网卡eth0 绑定了 IP 地址10.0.2.15。您可能需要根据实际情况修改上述设置。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-查看网络配置.png"></p><p>手动设置网络：</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-网络配置.png"></p><p>error：</p><p>配置了域名服务器后导致ping其他网站都无法解析域名。</p><h4 id="1-5-3-文件夹共享-6"><a href="#1-5-3-文件夹共享-6" class="headerlink" title="1.5.3 文件夹共享"></a>1.5.3 文件夹共享</h4><h4 id="1-5-4-快照备份-6"><a href="#1-5-4-快照备份-6" class="headerlink" title="1.5.4 快照备份"></a>1.5.4 快照备份</h4><p>一旦您把虚拟机配置到理想的可工作状态，我们建议您立刻对虚拟机进行快照备份。万一日后出现配置故障，可利用快照备份把虚拟机迅速恢复到正常工作状态。</p><h4 id="1-5-5-导出虚拟机-6"><a href="#1-5-5-导出虚拟机-6" class="headerlink" title="1.5.5 导出虚拟机"></a>1.5.5 导出虚拟机</h4><p>人们时常需要以文件形式备份虚拟机，或通过这种方法把虚拟机分享给他人使用。VirtualBox的虚拟机导出功能简化了这种操作。在关闭需要导出的虚拟机之后，在菜单栏选中File | Export Appliance 就可导出所选的虚拟机。</p><h3 id="1-5-系统更新-6"><a href="#1-5-系统更新-6" class="headerlink" title="1.5 系统更新"></a>1.5 系统更新</h3><p>Kali Linux 由操作系统内核和数百个软件构成。如果需要使用软件的最新功能，您就需要将其更新到最新的版本。</p><p>我们建议您仅从Kali Linux 官方的软件仓库（repository）进行更新。</p><p>在您安装和配置好Kali Linux 之后，就应当立即进行系统更新。因为Kali 是基于Debian的操作系统，您需要使用Debian的指令（apt-get）进行系统更新。</p><p>更新指令apt-get会查询&#x2F;etc&#x2F;apt&#x2F;sources.list文件，从中获取更新服务器的信息。您需要确定这个文件指定了正确的升级服务器。</p><p>默认情况下，Kali Linux 的sources.list 文件包含下述信息。</p><h4 id="其他：apt更换国内源-6"><a href="#其他：apt更换国内源-6" class="headerlink" title="其他：apt更换国内源"></a>其他：apt更换国内源</h4><p>Kali Linux 会从系统默认的软件源去安装软件，但默认的软件源速度通常比较慢（国外的源），因此需要将其替换成国内的源。</p><p>以下是常用的国内源网站：</p><p><a href="https://opsx.alibaba.com/mirror?lang=zh-CN">阿里云镜像开源镜像站（已经更换地址）</a><br><a href="https://developer.aliyun.com/mirror/">阿里云镜像开源社区镜像站（新地址）</a><br><a href="http://mirrors.163.com/.help/ubuntu.html">网易开源镜像站</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源镜像站</a><br><a href="https://mirrors.ustc.edu.cn/">中科大开源镜像站</a></p><p>修改方式：apt源的文件位置：&#x2F;etc&#x2F;apt&#x2F;sources.list</p><blockquote><p>注意：是&#x2F;etc&#x2F;apt&#x2F;sources.list，不是&#x2F;etc&#x2F;apt&#x2F;source.list（非常重要）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.bak1</span><br><span class="line">#第一个参数时拷贝的文件路径和文件名称,第二个是拷贝到(粘贴)的文件路径和文件名</span><br><span class="line"></span><br><span class="line">sudo mousepad /etc/apt/sources.list</span><br><span class="line">#用mousepad可以直接从系统粘贴板粘贴，比vim和vi更方便操作</span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line"># deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#根据需要自己选一个，中科大的还可以</span><br><span class="line">#中科大</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">#阿里云</span><br><span class="line">#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#清华大学</span><br><span class="line">#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#浙大</span><br><span class="line">#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#东软大学</span><br><span class="line">#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#重庆大学</span><br><span class="line">#deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><blockquote><p>注：vim和vi的操作习惯很”程序员风格”，不熟悉的情况下很难使用，以下是一个vim操作的视频</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p></blockquote><p>一个小插曲：我之前的Kali虚拟机就是因为vim操作不当修改了root文件，加上安装了很多包之后经常卡顿死机，所以重新装了一个新的，实在是血的教训。</p><p>更新完之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update 更新索引</span><br><span class="line"></span><br><span class="line">apt-get upgrade 更新软件</span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade 升级</span><br><span class="line"></span><br><span class="line">apt-get clean 删除缓存包</span><br><span class="line"></span><br><span class="line">apt-get autoclean 删除未安装的deb包</span><br></pre></td></tr></table></figure><p>error:</p><p><img src="D:/hexo/source/_posts/img/Network-attack/apt-无法解析域名.png"></p><p>目前网络配置有问题，解决后再写xia’wen</p><p>error：</p><p>配置了域名服务器后导致ping其他网站都无法解析域名。</p><h4 id="1-5-3-文件夹共享-7"><a href="#1-5-3-文件夹共享-7" class="headerlink" title="1.5.3 文件夹共享"></a>1.5.3 文件夹共享</h4><h4 id="1-5-4-快照备份-7"><a href="#1-5-4-快照备份-7" class="headerlink" title="1.5.4 快照备份"></a>1.5.4 快照备份</h4><p>一旦您把虚拟机配置到理想的可工作状态，我们建议您立刻对虚拟机进行快照备份。万一日后出现配置故障，可利用快照备份把虚拟机迅速恢复到正常工作状态。</p><h4 id="1-5-5-导出虚拟机-7"><a href="#1-5-5-导出虚拟机-7" class="headerlink" title="1.5.5 导出虚拟机"></a>1.5.5 导出虚拟机</h4><p>人们时常需要以文件形式备份虚拟机，或通过这种方法把虚拟机分享给他人使用。VirtualBox的虚拟机导出功能简化了这种操作。在关闭需要导出的虚拟机之后，在菜单栏选中File | Export Appliance 就可导出所选的虚拟机。</p><h3 id="1-5-系统更新-7"><a href="#1-5-系统更新-7" class="headerlink" title="1.5 系统更新"></a>1.5 系统更新</h3><p>Kali Linux 由操作系统内核和数百个软件构成。如果需要使用软件的最新功能，您就需要将其更新到最新的版本。</p><p>我们建议您仅从Kali Linux 官方的软件仓库（repository）进行更新。</p><p>在您安装和配置好Kali Linux 之后，就应当立即进行系统更新。因为Kali 是基于Debian的操作系统，您需要使用Debian的指令（apt-get）进行系统更新。</p><p>更新指令apt-get会查询&#x2F;etc&#x2F;apt&#x2F;sources.list文件，从中获取更新服务器的信息。您需要确定这个文件指定了正确的升级服务器。</p><p>默认情况下，Kali Linux 的sources.list 文件包含下述信息。</p><h4 id="其他：apt更换国内源-7"><a href="#其他：apt更换国内源-7" class="headerlink" title="其他：apt更换国内源"></a>其他：apt更换国内源</h4><p>Kali Linux 会从系统默认的软件源去安装软件，但默认的软件源速度通常比较慢（国外的源），因此需要将其替换成国内的源。</p><p>以下是常用的国内源网站：</p><p><a href="https://opsx.alibaba.com/mirror?lang=zh-CN">阿里云镜像开源镜像站（已经更换地址）</a><br><a href="https://developer.aliyun.com/mirror/">阿里云镜像开源社区镜像站（新地址）</a><br><a href="http://mirrors.163.com/.help/ubuntu.html">网易开源镜像站</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源镜像站</a><br><a href="https://mirrors.ustc.edu.cn/">中科大开源镜像站</a></p><p>修改方式：apt源的文件位置：&#x2F;etc&#x2F;apt&#x2F;sources.list</p><blockquote><p>注意：是&#x2F;etc&#x2F;apt&#x2F;sources.list，不是&#x2F;etc&#x2F;apt&#x2F;source.list（非常重要）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.bak1</span><br><span class="line">#第一个参数时拷贝的文件路径和文件名称,第二个是拷贝到(粘贴)的文件路径和文件名</span><br><span class="line"></span><br><span class="line">sudo mousepad /etc/apt/sources.list</span><br><span class="line">#用mousepad可以直接从系统粘贴板粘贴，比vim和vi更方便操作</span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line"># deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#根据需要自己选一个，中科大的还可以</span><br><span class="line">#中科大</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">#阿里云</span><br><span class="line">#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#清华大学</span><br><span class="line">#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#浙大</span><br><span class="line">#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#东软大学</span><br><span class="line">#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#重庆大学</span><br><span class="line">#deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><blockquote><p>注：vim和vi的操作习惯很”程序员风格”，不熟悉的情况下很难使用，以下是一个vim操作的视频</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p></blockquote><p>一个小插曲：我之前的Kali虚拟机就是因为vim操作不当修改了root文件，加上安装了很多包之后经常卡顿死机，所以重新装了一个新的，实在是血的教训。</p><p>更新完之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update 更新索引</span><br><span class="line"></span><br><span class="line">apt-get upgrade 更新软件</span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade 升级</span><br><span class="line"></span><br><span class="line">apt-get clean 删除缓存包</span><br><span class="line"></span><br><span class="line">apt-get autoclean 删除未安装的deb包</span><br></pre></td></tr></table></figure><p>error:</p><p>[TOC]</p><h2 id="参考资料-8"><a href="#参考资料-8" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="参考书-8"><a href="#参考书-8" class="headerlink" title="参考书"></a>参考书</h3><table><thead><tr><th>图书名称:</th><th>Kali Linux: Assuring Security by Penetration Testing</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://jobrest.gitbooks.io/kali-linux-cn/content/assets/feng_mian.jpeg" alt="封面"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2015-2</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>Lee Allen &#x2F; Tedi Heriyanto &#x2F; Shakeel Ali 著</td><td></td></tr><tr><td>译者</td><td>Archer 译</td><td></td></tr><tr><td>ISBN:</td><td>9787115378446</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Kali Linux2 网络渗透测试实践指南 第2版</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34261078.jpg" alt="Kali Linux2 网络渗透测试实践指南 第2版"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-3</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>李华峰 著</td><td></td></tr><tr><td>ISBN:</td><td>9787115555410</td><td></td></tr></tbody></table><h3 id="友链-8"><a href="#友链-8" class="headerlink" title="友链"></a>友链</h3><p>书籍在线阅读地址：<a href="https://jobrest.gitbooks.io/kali-linux-cn/content/index.html">Kali Linux 渗透测试的艺术（中文版） | Kali Linux 渗透测试的艺术（中文版） (gitbooks.io)</a></p><p>官网：<a href="https://www.kali.org/">Kali Linux 操作系统 |渗透测试和道德黑客 Linux 发行版</a></p><p>文档：<a href="https://www.kali.org/docs/">Kali Docs | Kali Linux Documentation</a></p><h2 id="前言-8"><a href="#前言-8" class="headerlink" title="前言"></a>前言</h2><h3 id="何为玩转kali？-8"><a href="#何为玩转kali？-8" class="headerlink" title="何为玩转kali？"></a>何为玩转kali？</h3><p>当然是想随心所欲，让“所见即所得”，让“所想立即实现”，那么此篇就是完成这个任务。</p><h2 id="第1章-Kali-Linux入门-8"><a href="#第1章-Kali-Linux入门-8" class="headerlink" title="第1章 Kali Linux入门"></a>第1章 Kali Linux入门</h2><h3 id="1-1-Kali的发展简史-8"><a href="#1-1-Kali的发展简史-8" class="headerlink" title="1.1 Kali的发展简史"></a>1.1 Kali的发展简史</h3><p>Kali Linux（Kali）是专门用于渗透测试的Linux操作系统，它由BackTrack 发展而来。在整合了IWHAX、WHOPPIX 和Auditor 这3 种渗透测试专用Live Linux 之后，BackTrack正式改名为Kali Linux。</p><p>BackTrack是相当著名的Linux发行版本。在BackTrack发布4.0预览版的时候，它的下载次数已经超过了400万次。</p><p>Kali Linux 1.0 版于2013年3 月12 日问世。在5天之后，官方为修复USB 键盘的支持问题而发布了1.0.1 版。在这短短的5 天之内，Kali 的下载次数就超过了9 万次。</p><p>根据官网的介绍（<a href="http://docs.kali.org/introduction/what-is-kali-linux%EF%BC%89%EF%BC%8C">http://docs.kali.org/introduction/what-is-kali-linux），</a> Kali的主要特色有：</p><p>● 它是基于Debian 的Linux 发行版；</p><p>● 它集成300 多个渗透测试程序；</p><p>● 它支持绝大多数的无线网卡；</p><p>● 它修改了内核以支持（无线）数据包注入；</p><p>● 所有的软件包都有研发团队的PGP 签名；</p><p>● 用户可以自制满足各自需求的Kali Linux 发行版；</p><p>● 支持基于ARM 的硬件系统。</p><h3 id="1-2-Kali-Linux工具包-8"><a href="#1-2-Kali-Linux工具包-8" class="headerlink" title="1.2 Kali Linux工具包"></a>1.2 Kali Linux工具包</h3><p>Kali Linux 含有可用于渗透测试的各种工具。这些工具程序大体可以分为以下几类。</p><p>● 信息收集：这类工具可用来收集目标的 DNS、IDS&#x2F;IPS、网络扫描、操作系统、路由、SSL、SMB、VPN、VoIP、SNMP信息和E-mail地址。</p><p>● 漏洞评估：这类工具都可以扫描目标系统上的漏洞。部分工具可以检测Cisco 网络系统缺陷，有些还可以评估各种数据库系统的安全问题。很多模糊测试软件都属于漏洞评估工具。</p><p>● Web应用：即与Web应用有关的工具。它包括CMS（内容管理系统）扫描器、数据库漏洞利用程序、Web应用模糊测试、Web应用代理、Web爬虫及Web漏洞扫描器。</p><p>● 密码攻击：无论是在线攻击还是离线破解，只要是能够实施密码攻击的工具都属于密码攻击类工具。</p><p>● 漏洞利用：这类工具可以利用在目标系统中发现的漏洞。攻击网络、Web 和数据库漏洞的软件，都属于漏洞利用（exploitation）工具。Kali 中的某些软件可以针对漏洞情况进行社会工程学攻击。</p><p>● 网络监听：这类工具用于监听网络和Web 流量。网络监听需要进行网络欺骗，所以Ettercap和Yersinia这类软件也归于这类软件。</p><p>● 访问维护：这类工具帮助渗透人员维持他们对目标主机的访问权。某些情况下，渗透人员必须先获取主机的最高权限才能安装这类软件。这类软件包括用于在 Web应用和操作系统安装后门的程序，以及隧道类工具。</p><p>● 报告工具：如果您需要撰写渗透测试的报告文件，您应该用得上这些软件。</p><p>● 系统服务：这是渗透人员在渗透测试时可能用到的常见服务类软件，它包括Apache服务、MySQL服务、SSH服务和Metasploit服务。</p><p>为了降低渗透测试人员筛选工具的难度，Kali Linux 单独划分了一类软件——Top 10 Security Tools，即10 大首选安全工具。这10 大工具分别是aircrack-ng、burp-suite、hydra、john、maltego、metasploit、nmap、sqlmap、wireshark和zaproxy。</p><p>除了可用于渗透测试的各种工具以外，Kali Linux 还整合了以下几类工具。</p><p>● 无线攻击：可攻击蓝牙、RFID&#x2F;NFC 和其他无线设备的工具。</p><p>● 逆向工程：可用于调试程序或反汇编的工具。</p><p>● 压力测试：用于各类压力测试的工具集。它们可测试网络、无线、Web 和 VoIP 系统的负载能力。</p><p>● 硬件破解：用于调试Android 和Arduino 程序的工具。</p><p>● 法证调查：即电子取证的工具。它的各种工具可以用于制作硬盘磁盘镜像、文件分析、硬盘镜像分析。如需使用这类程序，首先要在启动菜单里选择 Kali Linux Forensics | No Drives or Swap Mount。在开启这个选项以后，Kali Linux不会自动加载硬盘驱动器，以保护硬盘数据的完整性。</p><h3 id="1-3下载Kali-Linux-8"><a href="#1-3下载Kali-Linux-8" class="headerlink" title="1.3下载Kali Linux"></a>1.3下载Kali Linux</h3><p>下载是第一步要做的事情，经常使用计算机的人对下载肯定不陌生，但要想面向大众还是要解释清楚。</p><ul><li><p><input disabled="" type="checkbox"> 待补充</p></li><li><p><input disabled="" type="checkbox"> 验证哈希值</p></li></ul><h5 id="在虚拟机里使用-VM-镜像安装-Kali-Linux-8"><a href="#在虚拟机里使用-VM-镜像安装-Kali-Linux-8" class="headerlink" title="在虚拟机里使用 VM 镜像安装 Kali Linux"></a>在虚拟机里使用 VM 镜像安装 Kali Linux</h5><p>Kali Linux的iso镜像和虚拟机vmx文件等在Kali官网都有，直接下载就可以，而且下载速度也不赖。</p><p>这里我推荐直接下载Kali官方的虚拟机vmx文件，下载好了直接打开就能用，免去了很多配置环节。之前也尝试过用iso镜像做VMware，但试了几次遇到很多麻烦，因此就不搞了。</p><blockquote><p>使用硬盘镜像方式安装Kali Linux之后，系统的默认设置值如下所示。</p><p>● 硬盘容量：30 GB。</p><p>● 联网方式：NAT。</p><p>● 用户名：root。</p><p>● 密码：toor。</p><p>如果要把 Kali当做渗透测试平台使用，应当避免以 NAT方式接入网络。本文推荐您以桥接（bridged）方式联网。</p><p>在配置Kali VM 的时候，应当尽快更改默认密码。</p></blockquote><h4 id="portable-Kali-Linux-8"><a href="#portable-Kali-Linux-8" class="headerlink" title="portable Kali Linux"></a>portable Kali Linux</h4><ul><li><input disabled="" type="checkbox"> 未实操，待修改</li></ul><p>安装Kali Linux 的第三种方法，就是把它安装到USB 闪存里。通常，人们把安装在闪存上的Kali Linux 叫做portable（便携）Kali Linux。按照Kali官方文件的说法，这种安装方式的启动和安装速度最快，是Kali研发人员最喜欢的安装方式。相比在硬盘上安装，只能在一台机器上启动Kali 系统而言，装有Kali Linux 的闪存盘可以在所有支持USB 启动的主机上使用Kali系统。</p><p>这种安装方法同样适合在内存卡（SSD、SDHC、SDXC 等）上安装Kali Linux。</p><p>很多工具都可以制作portable Kali Linux。其中，Rufus（<a href="http://rufus.akeo.ie)就不错.这个工具只能在windows操作系统下运行./">http://rufus.akeo.ie）就不错。这个工具只能在Windows操作系统下运行。</a></p><p>其他可从ISO镜像文件制作可启动USB的工具如下所示：</p><p>● Win32DiskImager（<a href="https://launchpad.net/win32-image-writer%EF%BC%89%EF%BC%9B">https://launchpad.net/win32-image-writer）；</a></p><p>● Universal USB Installer（<a href="http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/%EF%BC%89%EF%BC%9B">http://www.pendrivelinux.com/universal-usbinstaller-easy-as-1-2-3/）；</a></p><p>● Linux Live USB Creator（<a href="http://www.linuxliveusb.com/">http://www.linuxliveusb.com</a>)</p><p>在制作portable Kali Linux 之前，您需要准备好几样素材。</p><p>● Kali Linux 的ISO 镜像文件：虽然您可以使用启动磁盘创建工具直接下载镜像文件，但是我们仍然认为提前下载好ISO镜像文件，再用Rufus使用镜像文件比较稳妥。</p><p>● USB 闪存盘：您需要一个容量足够大的 USB 闪存盘。我们推荐您使用 16GB 以上的闪存盘。</p><p>在下载Rufus之后，在Windows里双击rufus.exe文件就可以运行它。它会显示出程序界面。</p><p>如果您使用的是基于UNIX的操作系统，您可以直接使用dd指令创建可启动闪存盘。例如：</p><p>dd if&#x3D;kali-linux-1.0.1-i386.iso of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;512k</p><p>此处的&#x2F;dev&#x2F;sdb应当是您USB闪存盘的设备名称。</p><p>使用Rufus 创建可启动的Kali USB 闪存盘的设置如下。</p><p>● Device：选择USB 闪存驱动器。本例中，它是Windows 系统的E 盘。</p><p>● Partition scheme and target system type：设置为MBR partition scheme for BIOS or UEFI computers。</p><p>● Create a bootable disk using：设置为ISO Image 并使用右侧磁盘图标选取ISO 镜像文件。</p><p>然后点击Start创建可启动闪存盘。</p><p>在完成这些步骤之后，如果您想要立即测试USB闪存盘，则应在保存好所有文件的情况下重启计算机。您可能需要配置计算机的 BIOS，使其从 USB 磁盘启动计算机。如果没有问题的话，您应该可以通过USB 闪存盘启动Kali Linux 系统。</p><p>在USB闪存盘上安装系统之后，如果您想要让系统能够保存您所更改的文件（即persistence capabilities），您可参照Kali官方文档进行设置。请参见 Adding Persistence to Your Kali Live USB，地址为<a href="http://docs.kali.org/installation/kali-linux-live-usb-install">http://docs.kali.org/installation/kali-linux-live-usb-install</a></p><h3 id="1-4-虚拟机配置-8"><a href="#1-4-虚拟机配置-8" class="headerlink" title="1.4 虚拟机配置"></a>1.4 虚拟机配置</h3><h4 id="1-4-1-设置中文-8"><a href="#1-4-1-设置中文-8" class="headerlink" title="1.4.1 设置中文"></a>1.4.1 设置中文</h4><p>刚下好kali linux，就被全英文劝退可不太好。一看到密密麻麻的英文就敲起了退堂鼓，所以首先把系统语言设置成中文。</p><p>Learn more：<a href="https://blog.csdn.net/KNIGH_YUN/article/details/105543094">Kali Linux系统设置中文语言环境-1_kali中文设置-CSDN博客</a></p><p>具体步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>选择语言，使用空格键选中。选择en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8</p><p><img src="https://img-blog.csdnimg.cn/4346e90fd26c4a17835bcd4d3ddc6474.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>选中zh_CN.UTF-8为默认语言。</p><p><img src="https://img-blog.csdnimg.cn/8fc88465e1ee4af9b87e0f029e8c2859.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riFNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br></pre></td></tr></table></figure><p>下载字体</p><p>重启虚拟机。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-settings-zh_en.png" alt="设置中文界面"></p><p>当然，以上方法并非唯一方法，如果安装了图形界面也可以直接在设置里修改语言（X-windows），或者通过CLI修改系统配置文件。</p><h4 id="1-4-2-网络设置-8"><a href="#1-4-2-网络设置-8" class="headerlink" title="1.4.2 网络设置"></a>1.4.2 网络设置</h4><p>1．配置有线网络</p><p>无论是通过VMware 磁盘镜像还是通过ISO镜像安装Kali Linux，默认情况下Kali Linux接入网络的方式都是NAT（网络地址转换）。在NAT方式下，Kali Linux的虚拟机可以通过物理主机联入外部网络，而外部网络甚至是物理主机自身都无法直接访问安装有Kali Linux的虚拟机。</p><p>进行实地的渗透测试时，您可能需要把网络结构变更为Bridged Adapter。</p><p>如需使用桥接连接，首先要使物理主机与网络设备连接，例如路由器或交换机。同时，接入的网络里应当有DHCP服务，以分配IP地址给虚拟机。</p><p>您可能已经注意到了，通过DHCP获取的IP地址并不是固定的IP地址，这种IP地址在一定时间后可能会发生变化。如果Kali Linux 通过DHCP 获取IP 地址，在超过固定周期（DHCP的租赁时间）之后，DHCP会重新给虚拟机分配一次IP地址。重新分配的IP地址可能和上次分配的IP地址相同，也可能不同。</p><p>如果虚拟机需要使用固定的 IP 地址，应该修改虚拟机的网络设置文件&#x2F;etc&#x2F;network&#x2F;interfaces。</p><p>默认情况下，Kali Linux 的网络设置文件如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line"></span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>这个配置文件指定所有网卡都通过DHCP获取IP地址。如需为虚拟机绑定固定IP地址，就不得不对这个文件进行相应修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"></span><br><span class="line">iface eth0 inet static</span><br><span class="line"></span><br><span class="line">address 10.0.2.15</span><br><span class="line"></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">network 10.0.2.0</span><br><span class="line"></span><br><span class="line">broadcast 10.0.2.255</span><br><span class="line"></span><br><span class="line">gateway 10.0.2.2</span><br></pre></td></tr></table></figure><p>上述文件令第一个有线网卡eth0 绑定了 IP 地址10.0.2.15。您可能需要根据实际情况修改上述设置。</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-查看网络配置.png"></p><p>手动设置网络：</p><p><img src="D:/hexo/source/_posts/img/Network-attack/kali-网络配置.png"></p><p>error：</p><p>配置了域名服务器后导致ping其他网站都无法解析域名。</p><h4 id="1-5-3-文件夹共享-8"><a href="#1-5-3-文件夹共享-8" class="headerlink" title="1.5.3 文件夹共享"></a>1.5.3 文件夹共享</h4><h4 id="1-5-4-快照备份-8"><a href="#1-5-4-快照备份-8" class="headerlink" title="1.5.4 快照备份"></a>1.5.4 快照备份</h4><p>一旦您把虚拟机配置到理想的可工作状态，我们建议您立刻对虚拟机进行快照备份。万一日后出现配置故障，可利用快照备份把虚拟机迅速恢复到正常工作状态。</p><h4 id="1-5-5-导出虚拟机-8"><a href="#1-5-5-导出虚拟机-8" class="headerlink" title="1.5.5 导出虚拟机"></a>1.5.5 导出虚拟机</h4><p>人们时常需要以文件形式备份虚拟机，或通过这种方法把虚拟机分享给他人使用。VirtualBox的虚拟机导出功能简化了这种操作。在关闭需要导出的虚拟机之后，在菜单栏选中File | Export Appliance 就可导出所选的虚拟机。</p><h3 id="1-5-系统更新-8"><a href="#1-5-系统更新-8" class="headerlink" title="1.5 系统更新"></a>1.5 系统更新</h3><p>Kali Linux 由操作系统内核和数百个软件构成。如果需要使用软件的最新功能，您就需要将其更新到最新的版本。</p><p>我们建议您仅从Kali Linux 官方的软件仓库（repository）进行更新。</p><p>在您安装和配置好Kali Linux 之后，就应当立即进行系统更新。因为Kali 是基于Debian的操作系统，您需要使用Debian的指令（apt-get）进行系统更新。</p><p>更新指令apt-get会查询&#x2F;etc&#x2F;apt&#x2F;sources.list文件，从中获取更新服务器的信息。您需要确定这个文件指定了正确的升级服务器。</p><p>默认情况下，Kali Linux 的sources.list 文件包含下述信息。</p><h4 id="其他：apt更换国内源-8"><a href="#其他：apt更换国内源-8" class="headerlink" title="其他：apt更换国内源"></a>其他：apt更换国内源</h4><p>Kali Linux 会从系统默认的软件源去安装软件，但默认的软件源速度通常比较慢（国外的源），因此需要将其替换成国内的源。</p><p>以下是常用的国内源网站：</p><p><a href="https://opsx.alibaba.com/mirror?lang=zh-CN">阿里云镜像开源镜像站（已经更换地址）</a><br><a href="https://developer.aliyun.com/mirror/">阿里云镜像开源社区镜像站（新地址）</a><br><a href="http://mirrors.163.com/.help/ubuntu.html">网易开源镜像站</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源镜像站</a><br><a href="https://mirrors.ustc.edu.cn/">中科大开源镜像站</a></p><p>修改方式：apt源的文件位置：&#x2F;etc&#x2F;apt&#x2F;sources.list</p><blockquote><p>注意：是&#x2F;etc&#x2F;apt&#x2F;sources.list，不是&#x2F;etc&#x2F;apt&#x2F;source.list（非常重要）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.bak1</span><br><span class="line">#第一个参数时拷贝的文件路径和文件名称,第二个是拷贝到(粘贴)的文件路径和文件名</span><br><span class="line"></span><br><span class="line">sudo mousepad /etc/apt/sources.list</span><br><span class="line">#用mousepad可以直接从系统粘贴板粘贴，比vim和vi更方便操作</span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line"># deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#根据需要自己选一个，中科大的还可以</span><br><span class="line">#中科大</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">#阿里云</span><br><span class="line">#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#清华大学</span><br><span class="line">#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#浙大</span><br><span class="line">#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">#东软大学</span><br><span class="line">#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">#重庆大学</span><br><span class="line">#deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><blockquote><p>注：vim和vi的操作习惯很”程序员风格”，不熟悉的情况下很难使用，以下是一个vim操作的视频</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p></blockquote><p>一个小插曲：我之前的Kali虚拟机就是因为vim操作不当修改了root文件，加上安装了很多包之后经常卡顿死机，所以重新装了一个新的，实在是血的教训。</p><p>更新完之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update 更新索引</span><br><span class="line"></span><br><span class="line">apt-get upgrade 更新软件</span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade 升级</span><br><span class="line"></span><br><span class="line">apt-get clean 删除缓存包</span><br><span class="line"></span><br><span class="line">apt-get autoclean 删除未安装的deb包</span><br></pre></td></tr></table></figure><p>error:</p><p><img src="D:/hexo/source/_posts/img/Network-attack/apt-无法解析域名.png"></p><p>目前网络配置有问题，解决后再写xia’wen</p><p>目前网络配置有问题，解决后再写xia’wen</p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/Linux-%E7%8E%A9%E8%BD%ACkali/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/Linux-%E7%8E%A9%E8%BD%ACkali/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<p>[TOC]</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h3><table>
<thead>
<tr>
<th>图书名称:</th>
<th>Kali Linux: Assuring Security by Penetration]]>
    </summary>
    <title>玩转kali</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h3 id="linux下普通用户变为root权限的三种方法"><a href="#linux下普通用户变为root权限的三种方法" class="headerlink" title="linux下普通用户变为root权限的三种方法"></a>linux下普通用户变为root权限的三种方法</h3><p><a href="https://blog.csdn.net/weixin_43886632/article/details/108244302">Linux下普通用户变为root权限的三种方法_19.如何从普通用户xiaoming切换到root?-CSDN博客</a></p><p><strong>0x01加普通用户</strong><br>useradd xiaoming 创建用户小明<br>passwd xiaoming 创建小明的密码</p><p><strong>0x02 将xiaoming的权限变为root权限</strong></p><p><strong>方法1</strong></p><p>1、修改 &#x2F;etc&#x2F;sudoers 文件，找到107行，把前面的注释（#）去掉</p><p>2、将xiaoming添加到root组（wheel）<br>命令：<code>usermod -g root xiaoming</code><br>之后xiaoming就能执行root的命令了，但是权限不是root还是xiaoming权限.</p><p><strong>方法2</strong><br>1、修改 &#x2F;etc&#x2F;sudoers 文件，找到下面一行，在root下面添加一行<br>内容：<code>xiaoming All=(All) All</code></p><p>修改完后。登录xiaoming。输入命令 <code>sudo -l</code>，然后输入xiaoming的密码认证后使用sudo执行任意命令即可</p><p><strong>方法3</strong></p><p>修改 &#x2F;etc&#x2F;passwd 文件，找到xiaoming，把用户ID修改为 0 </p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/Linux-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/Linux-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h3 id="linux下普通用户变为root权限的三种方法"><a href="#linux下普通用户变为root权限的三种方法" class="headerlink" title="linux下普通用户变为root权限的三种方法"></a>linux下普通用户变为root权限的三种方法</h3><p><a]]>
    </summary>
    <title>用户权限</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书"><a href="#主要参考书" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></td><td></td></tr></tbody></table><p>符号：『』❑ ➢ </p><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-1"><a href="#主要参考书-1" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述"><a href="#Chapter-1-Linux-概述" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述"><a href="#1-1-Linux-操作系统简述" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell"><a href="#强大好用的Shell" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史"><a href="#1-2-发展史" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成"><a href="#1-3-Linux-的特点与组成" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本"><a href="#1-4-Linux-发行版本" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux"><a href="#Fedora-Linux" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux"><a href="#Debian-Linux" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux"><a href="#Ubuntu-Linux" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux"><a href="#Kali-Linux" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神"><a href="#开源共享精神" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令"><a href="#Chapter-2-Linux-基本命令" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识"><a href="#执行命令的必备知识" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键"><a href="#常用的按键" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令"><a href="#2-1-常用系统工作命令" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令"><a href="#timedatectl命令" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令"><a href="#poweroff命令" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令"><a href="#history命令" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理"><a href="#2-2-文件管理" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令"><a href="#管理文件和目录的命令" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令"><a href="#文件阅读命令" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令"><a href="#文件备份和压缩命令" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令"><a href="#有关磁盘空间的命令" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理"><a href="#2-3-权限管理" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理"><a href="#2-4-进程管理" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令"><a href="#pstree命令" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令"><a href="#nice命令" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令"><a href="#pidof命令" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令"><a href="#2-5-有关网络操作的命令" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符"><a href="#管道命令符" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统"><a href="#Chapter-3-Linux-文件系统" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型"><a href="#文件和文件类型" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则"><a href="#文件命名规则" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径"><a href="#路径：绝对路径和相对路径" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理"><a href="#Chapter-4-Linux-权限管理" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力"><a href="#4-1-用户身份与能力" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属"><a href="#4-2-文件权限与归属" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具"><a href="#Chapter-5-Linux-常用工具" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit"><a href="#gedit" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换"><a href="#命令模式和输入模式切换" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换"><a href="#命令模式和底线命令模式切换" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理"><a href="#Chapter-6-Linux-进程管理" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell"><a href="#Chapter-7-Linux-Shell" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell"><a href="#各种shell" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习"><a href="#Shell脚本练习" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念"><a href="#Linux-一些概念" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明"><a href="#Linux-常见目录说明" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量"><a href="#Linux-环境变量" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习"><a href="#考试复习" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a><br> |      |<br>| 出版印刷时间: | 2009-4                                                       |      |<br>| 出版社:       | 清华大学出版社                                               |      |<br>| 图书作者:     | 陈明 编著                                                    |      |<br>| ISBN:         | 9787302193289                                                |      |</p><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></td><td></td></tr></tbody></table><p>符号：『』❑ ➢ </p><h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-2"><a href="#主要参考书-2" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-1"><a href="#Chapter-1-Linux-概述-1" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-1"><a href="#1-1-Linux-操作系统简述-1" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-1"><a href="#强大好用的Shell-1" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-1"><a href="#1-2-发展史-1" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-1"><a href="#1-3-Linux-的特点与组成-1" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-1"><a href="#1-4-Linux-发行版本-1" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-1"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-1" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-1"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-1" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-1"><a href="#Fedora-Linux-1" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-1"><a href="#Debian-Linux-1" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-1"><a href="#Ubuntu-Linux-1" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-1"><a href="#Kali-Linux-1" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-1"><a href="#开源共享精神-1" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-1"><a href="#Chapter-2-Linux-基本命令-1" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-1"><a href="#执行命令的必备知识-1" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-1"><a href="#常用的按键-1" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-1"><a href="#2-1-常用系统工作命令-1" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-1"><a href="#echo命令-1" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-1"><a href="#date命令-1" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-1"><a href="#timedatectl命令-1" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-1"><a href="#reboot命令-1" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-1"><a href="#poweroff命令-1" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-1"><a href="#wget命令-1" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-1"><a href="#history命令-1" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-1"><a href="#2-2-文件管理-1" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-1"><a href="#管理文件和目录的命令-1" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-1"><a href="#pwd-命令-1" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-1"><a href="#cd命令-1" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-1"><a href="#ls命令-1" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-1"><a href="#cat命令-1" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-1"><a href="#grep命令-1" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-1"><a href="#cp命令-1" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-1"><a href="#touch命令-1" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-1"><a href="#mv命令-1" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-1"><a href="#rm命令-1" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-1"><a href="#文件阅读命令-1" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-1"><a href="#文件备份和压缩命令-1" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-1"><a href="#有关磁盘空间的命令-1" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-1"><a href="#2-3-权限管理-1" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-1"><a href="#2-4-进程管理-1" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-1"><a href="#ps命令-1" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-1"><a href="#pstree命令-1" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-1"><a href="#top命令-1" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-1"><a href="#nice命令-1" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-1"><a href="#pidof命令-1" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-1"><a href="#kill命令-1" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-1"><a href="#killall命令-1" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-1"><a href="#2-5-有关网络操作的命令-1" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-1"><a href="#ping命令-1" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-1"><a href="#netstat命令-1" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-1"><a href="#输入输出重定向-1" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-1"><a href="#管道命令符-1" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-1"><a href="#常用的转义字符-1" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-1"><a href="#Chapter-3-Linux-文件系统-1" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-1"><a href="#文件系统概述-1" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-1"><a href="#文件和文件类型-1" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-1"><a href="#文件命名规则-1" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-1"><a href="#文件类型-1" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-1"><a href="#文件系统结构-1" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-1"><a href="#路径：绝对路径和相对路径-1" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-1"><a href="#软链接和硬链接-1" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-1"><a href="#软链接-1" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-1"><a href="#Chapter-4-Linux-权限管理-1" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-1"><a href="#4-1-用户身份与能力-1" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-1"><a href="#4-2-文件权限与归属-1" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-1"><a href="#Chapter-5-Linux-常用工具-1" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-1"><a href="#文本编辑器-1" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-1"><a href="#gedit-1" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-1"><a href="#vi-1" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-1"><a href="#命令模式和输入模式切换-1" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-1"><a href="#命令模式和底线命令模式切换-1" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-1"><a href="#软件包管理-1" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-1"><a href="#Samba-1" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-1"><a href="#Chapter-6-Linux-进程管理-1" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-1"><a href="#Chapter-7-Linux-Shell-1" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-1"><a href="#各种shell-1" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-1"><a href="#Shell脚本-1" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-1"><a href="#Shell脚本练习-1" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-1"><a href="#Linux-一些概念-1" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-1"><a href="#Linux-常见目录说明-1" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-1"><a href="#Linux-环境变量-1" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-1"><a href="#考试复习-1" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-1"><a href="#后续-1" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a><br> |      |<br>| 出版印刷时间: | 2021-9                                                       |      |<br>| 出版社:       | 人民邮电出版社                                               |      |<br>| 图书作者:     | 刘遄 编著                                                    |      |<br>| ISBN:         | 9787115570116                                                |      |</p><h3 id="链接-2"><a href="#链接-2" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-2"><a href="#目录-2" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-2"><a href="#Chapter-1-Linux-概述-2" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-2"><a href="#1-1-Linux-操作系统简述-2" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-2"><a href="#强大好用的Shell-2" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-3"><a href="#参考资料-3" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-3"><a href="#主要参考书-3" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-3"><a href="#链接-3" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-3"><a href="#目录-3" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-3"><a href="#Chapter-1-Linux-概述-3" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-3"><a href="#1-1-Linux-操作系统简述-3" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-3"><a href="#强大好用的Shell-3" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-2"><a href="#1-2-发展史-2" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-2"><a href="#1-3-Linux-的特点与组成-2" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-2"><a href="#1-4-Linux-发行版本-2" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-2"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-2" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-2"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-2" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-2"><a href="#Fedora-Linux-2" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-2"><a href="#Debian-Linux-2" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-2"><a href="#Ubuntu-Linux-2" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-2"><a href="#Kali-Linux-2" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-2"><a href="#开源共享精神-2" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-2"><a href="#Chapter-2-Linux-基本命令-2" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-2"><a href="#执行命令的必备知识-2" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-2"><a href="#常用的按键-2" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-2"><a href="#2-1-常用系统工作命令-2" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-2"><a href="#echo命令-2" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-2"><a href="#date命令-2" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-2"><a href="#timedatectl命令-2" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-2"><a href="#reboot命令-2" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-2"><a href="#poweroff命令-2" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-2"><a href="#wget命令-2" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-2"><a href="#history命令-2" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-2"><a href="#2-2-文件管理-2" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-2"><a href="#管理文件和目录的命令-2" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-2"><a href="#pwd-命令-2" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-2"><a href="#cd命令-2" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-2"><a href="#ls命令-2" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-2"><a href="#cat命令-2" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-2"><a href="#grep命令-2" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-2"><a href="#cp命令-2" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-2"><a href="#touch命令-2" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-2"><a href="#mv命令-2" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-2"><a href="#rm命令-2" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-2"><a href="#文件阅读命令-2" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-2"><a href="#文件备份和压缩命令-2" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-2"><a href="#有关磁盘空间的命令-2" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-2"><a href="#2-3-权限管理-2" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-2"><a href="#2-4-进程管理-2" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-2"><a href="#ps命令-2" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-2"><a href="#pstree命令-2" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-2"><a href="#top命令-2" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-2"><a href="#nice命令-2" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-2"><a href="#pidof命令-2" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-2"><a href="#kill命令-2" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-2"><a href="#killall命令-2" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-2"><a href="#2-5-有关网络操作的命令-2" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-2"><a href="#ping命令-2" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-2"><a href="#netstat命令-2" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-2"><a href="#输入输出重定向-2" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-2"><a href="#管道命令符-2" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-2"><a href="#常用的转义字符-2" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-2"><a href="#Chapter-3-Linux-文件系统-2" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-2"><a href="#文件系统概述-2" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-2"><a href="#文件和文件类型-2" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-2"><a href="#文件命名规则-2" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-2"><a href="#文件类型-2" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-2"><a href="#文件系统结构-2" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-2"><a href="#路径：绝对路径和相对路径-2" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-2"><a href="#软链接和硬链接-2" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-2"><a href="#软链接-2" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-2"><a href="#Chapter-4-Linux-权限管理-2" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-2"><a href="#4-1-用户身份与能力-2" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-2"><a href="#4-2-文件权限与归属-2" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-2"><a href="#Chapter-5-Linux-常用工具-2" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-2"><a href="#文本编辑器-2" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-2"><a href="#gedit-2" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-2"><a href="#vi-2" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-2"><a href="#命令模式和输入模式切换-2" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-2"><a href="#命令模式和底线命令模式切换-2" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-2"><a href="#软件包管理-2" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-2"><a href="#Samba-2" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-2"><a href="#Chapter-6-Linux-进程管理-2" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-2"><a href="#Chapter-7-Linux-Shell-2" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-2"><a href="#各种shell-2" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-2"><a href="#Shell脚本-2" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-2"><a href="#Shell脚本练习-2" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-2"><a href="#Linux-一些概念-2" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-2"><a href="#Linux-常见目录说明-2" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-2"><a href="#Linux-环境变量-2" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-2"><a href="#考试复习-2" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-2"><a href="#后续-2" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-3"><a href="#1-2-发展史-3" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-3"><a href="#1-3-Linux-的特点与组成-3" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-3"><a href="#1-4-Linux-发行版本-3" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-3"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-3" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-4"><a href="#参考资料-4" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-4"><a href="#主要参考书-4" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-4"><a href="#链接-4" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-4"><a href="#目录-4" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-4"><a href="#Chapter-1-Linux-概述-4" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-4"><a href="#1-1-Linux-操作系统简述-4" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-4"><a href="#强大好用的Shell-4" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-4"><a href="#1-2-发展史-4" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-4"><a href="#1-3-Linux-的特点与组成-4" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-4"><a href="#1-4-Linux-发行版本-4" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-4"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-4" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-3"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-3" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-3"><a href="#Fedora-Linux-3" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-3"><a href="#Debian-Linux-3" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-3"><a href="#Ubuntu-Linux-3" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-3"><a href="#Kali-Linux-3" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-3"><a href="#开源共享精神-3" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-3"><a href="#Chapter-2-Linux-基本命令-3" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-3"><a href="#执行命令的必备知识-3" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-3"><a href="#常用的按键-3" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-3"><a href="#2-1-常用系统工作命令-3" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-3"><a href="#echo命令-3" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-3"><a href="#date命令-3" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-3"><a href="#timedatectl命令-3" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-3"><a href="#reboot命令-3" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-3"><a href="#poweroff命令-3" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-3"><a href="#wget命令-3" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-3"><a href="#history命令-3" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-3"><a href="#2-2-文件管理-3" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-3"><a href="#管理文件和目录的命令-3" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-3"><a href="#pwd-命令-3" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-3"><a href="#cd命令-3" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-3"><a href="#ls命令-3" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-3"><a href="#cat命令-3" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-3"><a href="#grep命令-3" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-3"><a href="#cp命令-3" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-3"><a href="#touch命令-3" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-3"><a href="#mv命令-3" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-3"><a href="#rm命令-3" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-3"><a href="#文件阅读命令-3" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-3"><a href="#文件备份和压缩命令-3" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-3"><a href="#有关磁盘空间的命令-3" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-3"><a href="#2-3-权限管理-3" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-3"><a href="#2-4-进程管理-3" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-3"><a href="#ps命令-3" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-3"><a href="#pstree命令-3" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-3"><a href="#top命令-3" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-3"><a href="#nice命令-3" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-3"><a href="#pidof命令-3" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-3"><a href="#kill命令-3" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-3"><a href="#killall命令-3" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-3"><a href="#2-5-有关网络操作的命令-3" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-3"><a href="#ping命令-3" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-3"><a href="#netstat命令-3" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-3"><a href="#输入输出重定向-3" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-3"><a href="#管道命令符-3" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-3"><a href="#常用的转义字符-3" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-3"><a href="#Chapter-3-Linux-文件系统-3" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-3"><a href="#文件系统概述-3" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-3"><a href="#文件和文件类型-3" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-3"><a href="#文件命名规则-3" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-3"><a href="#文件类型-3" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-3"><a href="#文件系统结构-3" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-3"><a href="#路径：绝对路径和相对路径-3" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-3"><a href="#软链接和硬链接-3" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-3"><a href="#软链接-3" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-3"><a href="#Chapter-4-Linux-权限管理-3" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-3"><a href="#4-1-用户身份与能力-3" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-3"><a href="#4-2-文件权限与归属-3" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-3"><a href="#Chapter-5-Linux-常用工具-3" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-3"><a href="#文本编辑器-3" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-3"><a href="#gedit-3" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-3"><a href="#vi-3" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-3"><a href="#命令模式和输入模式切换-3" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-3"><a href="#命令模式和底线命令模式切换-3" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-3"><a href="#软件包管理-3" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-3"><a href="#Samba-3" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-3"><a href="#Chapter-6-Linux-进程管理-3" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-3"><a href="#Chapter-7-Linux-Shell-3" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-3"><a href="#各种shell-3" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-3"><a href="#Shell脚本-3" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-3"><a href="#Shell脚本练习-3" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-3"><a href="#Linux-一些概念-3" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-3"><a href="#Linux-常见目录说明-3" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-3"><a href="#Linux-环境变量-3" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-3"><a href="#考试复习-3" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-3"><a href="#后续-3" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-4"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-4" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-5"><a href="#参考资料-5" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-5"><a href="#主要参考书-5" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-5"><a href="#链接-5" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-5"><a href="#目录-5" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-5"><a href="#Chapter-1-Linux-概述-5" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-5"><a href="#1-1-Linux-操作系统简述-5" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-5"><a href="#强大好用的Shell-5" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-5"><a href="#1-2-发展史-5" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-5"><a href="#1-3-Linux-的特点与组成-5" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-5"><a href="#1-4-Linux-发行版本-5" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-5"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-5" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-5"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-5" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-4"><a href="#Fedora-Linux-4" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-4"><a href="#Debian-Linux-4" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-4"><a href="#Ubuntu-Linux-4" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-4"><a href="#Kali-Linux-4" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-4"><a href="#开源共享精神-4" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-4"><a href="#Chapter-2-Linux-基本命令-4" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-4"><a href="#执行命令的必备知识-4" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-4"><a href="#常用的按键-4" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-4"><a href="#2-1-常用系统工作命令-4" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-4"><a href="#echo命令-4" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-4"><a href="#date命令-4" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-4"><a href="#timedatectl命令-4" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-4"><a href="#reboot命令-4" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-4"><a href="#poweroff命令-4" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-4"><a href="#wget命令-4" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-4"><a href="#history命令-4" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-4"><a href="#2-2-文件管理-4" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-4"><a href="#管理文件和目录的命令-4" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-4"><a href="#pwd-命令-4" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-4"><a href="#cd命令-4" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-4"><a href="#ls命令-4" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-4"><a href="#cat命令-4" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-4"><a href="#grep命令-4" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-4"><a href="#cp命令-4" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-4"><a href="#touch命令-4" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-4"><a href="#mv命令-4" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-4"><a href="#rm命令-4" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-4"><a href="#文件阅读命令-4" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-4"><a href="#文件备份和压缩命令-4" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-4"><a href="#有关磁盘空间的命令-4" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-4"><a href="#2-3-权限管理-4" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-4"><a href="#2-4-进程管理-4" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-4"><a href="#ps命令-4" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-4"><a href="#pstree命令-4" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-4"><a href="#top命令-4" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-4"><a href="#nice命令-4" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-4"><a href="#pidof命令-4" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-4"><a href="#kill命令-4" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-4"><a href="#killall命令-4" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-4"><a href="#2-5-有关网络操作的命令-4" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-4"><a href="#ping命令-4" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-4"><a href="#netstat命令-4" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-4"><a href="#输入输出重定向-4" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-4"><a href="#管道命令符-4" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-4"><a href="#常用的转义字符-4" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-4"><a href="#Chapter-3-Linux-文件系统-4" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-4"><a href="#文件系统概述-4" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-4"><a href="#文件和文件类型-4" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-4"><a href="#文件命名规则-4" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-4"><a href="#文件类型-4" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-4"><a href="#文件系统结构-4" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-4"><a href="#路径：绝对路径和相对路径-4" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-4"><a href="#软链接和硬链接-4" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-4"><a href="#软链接-4" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-4"><a href="#Chapter-4-Linux-权限管理-4" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-4"><a href="#4-1-用户身份与能力-4" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-4"><a href="#4-2-文件权限与归属-4" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-4"><a href="#Chapter-5-Linux-常用工具-4" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-4"><a href="#文本编辑器-4" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-4"><a href="#gedit-4" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-4"><a href="#vi-4" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-4"><a href="#命令模式和输入模式切换-4" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-4"><a href="#命令模式和底线命令模式切换-4" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-4"><a href="#软件包管理-4" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-4"><a href="#Samba-4" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-4"><a href="#Chapter-6-Linux-进程管理-4" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-4"><a href="#Chapter-7-Linux-Shell-4" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-4"><a href="#各种shell-4" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-4"><a href="#Shell脚本-4" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-4"><a href="#Shell脚本练习-4" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-4"><a href="#Linux-一些概念-4" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-4"><a href="#Linux-常见目录说明-4" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-4"><a href="#Linux-环境变量-4" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-4"><a href="#考试复习-4" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-4"><a href="#后续-4" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-5"><a href="#Fedora-Linux-5" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-6"><a href="#参考资料-6" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-6"><a href="#主要参考书-6" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-6"><a href="#链接-6" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-6"><a href="#目录-6" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-6"><a href="#Chapter-1-Linux-概述-6" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-6"><a href="#1-1-Linux-操作系统简述-6" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-6"><a href="#强大好用的Shell-6" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-6"><a href="#1-2-发展史-6" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-6"><a href="#1-3-Linux-的特点与组成-6" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-6"><a href="#1-4-Linux-发行版本-6" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-6"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-6" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-6"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-6" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-6"><a href="#Fedora-Linux-6" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-5"><a href="#Debian-Linux-5" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-5"><a href="#Ubuntu-Linux-5" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-5"><a href="#Kali-Linux-5" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-5"><a href="#开源共享精神-5" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-5"><a href="#Chapter-2-Linux-基本命令-5" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-5"><a href="#执行命令的必备知识-5" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-5"><a href="#常用的按键-5" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-5"><a href="#2-1-常用系统工作命令-5" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-5"><a href="#echo命令-5" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-5"><a href="#date命令-5" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-5"><a href="#timedatectl命令-5" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-5"><a href="#reboot命令-5" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-5"><a href="#poweroff命令-5" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-5"><a href="#wget命令-5" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-5"><a href="#history命令-5" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-5"><a href="#2-2-文件管理-5" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-5"><a href="#管理文件和目录的命令-5" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-5"><a href="#pwd-命令-5" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-5"><a href="#cd命令-5" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-5"><a href="#ls命令-5" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-5"><a href="#cat命令-5" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-5"><a href="#grep命令-5" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-5"><a href="#cp命令-5" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-5"><a href="#touch命令-5" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-5"><a href="#mv命令-5" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-5"><a href="#rm命令-5" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-5"><a href="#文件阅读命令-5" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-5"><a href="#文件备份和压缩命令-5" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-5"><a href="#有关磁盘空间的命令-5" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-5"><a href="#2-3-权限管理-5" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-5"><a href="#2-4-进程管理-5" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-5"><a href="#ps命令-5" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-5"><a href="#pstree命令-5" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-5"><a href="#top命令-5" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-5"><a href="#nice命令-5" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-5"><a href="#pidof命令-5" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-5"><a href="#kill命令-5" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-5"><a href="#killall命令-5" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-5"><a href="#2-5-有关网络操作的命令-5" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-5"><a href="#ping命令-5" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-5"><a href="#netstat命令-5" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-5"><a href="#输入输出重定向-5" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-5"><a href="#管道命令符-5" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-5"><a href="#常用的转义字符-5" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-5"><a href="#Chapter-3-Linux-文件系统-5" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-5"><a href="#文件系统概述-5" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-5"><a href="#文件和文件类型-5" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-5"><a href="#文件命名规则-5" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-5"><a href="#文件类型-5" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-5"><a href="#文件系统结构-5" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-5"><a href="#路径：绝对路径和相对路径-5" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-5"><a href="#软链接和硬链接-5" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-5"><a href="#软链接-5" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-5"><a href="#Chapter-4-Linux-权限管理-5" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-5"><a href="#4-1-用户身份与能力-5" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-5"><a href="#4-2-文件权限与归属-5" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-5"><a href="#Chapter-5-Linux-常用工具-5" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-5"><a href="#文本编辑器-5" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-5"><a href="#gedit-5" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-5"><a href="#vi-5" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-5"><a href="#命令模式和输入模式切换-5" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-5"><a href="#命令模式和底线命令模式切换-5" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-5"><a href="#软件包管理-5" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-5"><a href="#Samba-5" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-5"><a href="#Chapter-6-Linux-进程管理-5" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-5"><a href="#Chapter-7-Linux-Shell-5" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-5"><a href="#各种shell-5" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-5"><a href="#Shell脚本-5" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-5"><a href="#Shell脚本练习-5" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-5"><a href="#Linux-一些概念-5" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-5"><a href="#Linux-常见目录说明-5" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-5"><a href="#Linux-环境变量-5" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-5"><a href="#考试复习-5" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-5"><a href="#后续-5" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-6"><a href="#Debian-Linux-6" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-7"><a href="#参考资料-7" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-7"><a href="#主要参考书-7" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-7"><a href="#链接-7" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-7"><a href="#目录-7" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-7"><a href="#Chapter-1-Linux-概述-7" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-7"><a href="#1-1-Linux-操作系统简述-7" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-7"><a href="#强大好用的Shell-7" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-7"><a href="#1-2-发展史-7" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-7"><a href="#1-3-Linux-的特点与组成-7" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-7"><a href="#1-4-Linux-发行版本-7" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-7"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-7" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-7"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-7" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-7"><a href="#Fedora-Linux-7" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-7"><a href="#Debian-Linux-7" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-6"><a href="#Ubuntu-Linux-6" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-6"><a href="#Kali-Linux-6" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-6"><a href="#开源共享精神-6" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-6"><a href="#Chapter-2-Linux-基本命令-6" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-6"><a href="#执行命令的必备知识-6" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-6"><a href="#常用的按键-6" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-6"><a href="#2-1-常用系统工作命令-6" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-6"><a href="#echo命令-6" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-6"><a href="#date命令-6" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-6"><a href="#timedatectl命令-6" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-6"><a href="#reboot命令-6" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-6"><a href="#poweroff命令-6" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-6"><a href="#wget命令-6" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-6"><a href="#history命令-6" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-6"><a href="#2-2-文件管理-6" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-6"><a href="#管理文件和目录的命令-6" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-6"><a href="#pwd-命令-6" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-6"><a href="#cd命令-6" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-6"><a href="#ls命令-6" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-6"><a href="#cat命令-6" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-6"><a href="#grep命令-6" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-6"><a href="#cp命令-6" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-6"><a href="#touch命令-6" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-6"><a href="#mv命令-6" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-6"><a href="#rm命令-6" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-6"><a href="#文件阅读命令-6" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-6"><a href="#文件备份和压缩命令-6" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-6"><a href="#有关磁盘空间的命令-6" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-6"><a href="#2-3-权限管理-6" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-6"><a href="#2-4-进程管理-6" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-6"><a href="#ps命令-6" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-6"><a href="#pstree命令-6" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-6"><a href="#top命令-6" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-6"><a href="#nice命令-6" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-6"><a href="#pidof命令-6" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-6"><a href="#kill命令-6" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-6"><a href="#killall命令-6" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-6"><a href="#2-5-有关网络操作的命令-6" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-6"><a href="#ping命令-6" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-6"><a href="#netstat命令-6" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-6"><a href="#输入输出重定向-6" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-6"><a href="#管道命令符-6" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-6"><a href="#常用的转义字符-6" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-6"><a href="#Chapter-3-Linux-文件系统-6" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-6"><a href="#文件系统概述-6" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-6"><a href="#文件和文件类型-6" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-6"><a href="#文件命名规则-6" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-6"><a href="#文件类型-6" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-6"><a href="#文件系统结构-6" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-6"><a href="#路径：绝对路径和相对路径-6" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-6"><a href="#软链接和硬链接-6" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-6"><a href="#软链接-6" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-6"><a href="#Chapter-4-Linux-权限管理-6" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-6"><a href="#4-1-用户身份与能力-6" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-6"><a href="#4-2-文件权限与归属-6" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-6"><a href="#Chapter-5-Linux-常用工具-6" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-6"><a href="#文本编辑器-6" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-6"><a href="#gedit-6" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-6"><a href="#vi-6" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-6"><a href="#命令模式和输入模式切换-6" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-6"><a href="#命令模式和底线命令模式切换-6" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-6"><a href="#软件包管理-6" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-6"><a href="#Samba-6" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-6"><a href="#Chapter-6-Linux-进程管理-6" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-6"><a href="#Chapter-7-Linux-Shell-6" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-6"><a href="#各种shell-6" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-6"><a href="#Shell脚本-6" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-6"><a href="#Shell脚本练习-6" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-6"><a href="#Linux-一些概念-6" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-6"><a href="#Linux-常见目录说明-6" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-6"><a href="#Linux-环境变量-6" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-6"><a href="#考试复习-6" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-6"><a href="#后续-6" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-7"><a href="#Ubuntu-Linux-7" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-8"><a href="#参考资料-8" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-8"><a href="#主要参考书-8" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-8"><a href="#链接-8" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-8"><a href="#目录-8" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-8"><a href="#Chapter-1-Linux-概述-8" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-8"><a href="#1-1-Linux-操作系统简述-8" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-8"><a href="#强大好用的Shell-8" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-8"><a href="#1-2-发展史-8" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-8"><a href="#1-3-Linux-的特点与组成-8" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-8"><a href="#1-4-Linux-发行版本-8" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-8"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-8" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-8"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-8" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-8"><a href="#Fedora-Linux-8" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-8"><a href="#Debian-Linux-8" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-8"><a href="#Ubuntu-Linux-8" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-7"><a href="#Kali-Linux-7" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-7"><a href="#开源共享精神-7" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-7"><a href="#Chapter-2-Linux-基本命令-7" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-7"><a href="#执行命令的必备知识-7" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-7"><a href="#常用的按键-7" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-7"><a href="#2-1-常用系统工作命令-7" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-7"><a href="#echo命令-7" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-7"><a href="#date命令-7" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-7"><a href="#timedatectl命令-7" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-7"><a href="#reboot命令-7" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-7"><a href="#poweroff命令-7" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-7"><a href="#wget命令-7" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-7"><a href="#history命令-7" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-7"><a href="#2-2-文件管理-7" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-7"><a href="#管理文件和目录的命令-7" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-7"><a href="#pwd-命令-7" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-7"><a href="#cd命令-7" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-7"><a href="#ls命令-7" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-7"><a href="#cat命令-7" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-7"><a href="#grep命令-7" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-7"><a href="#cp命令-7" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-7"><a href="#touch命令-7" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-7"><a href="#mv命令-7" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-7"><a href="#rm命令-7" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-7"><a href="#文件阅读命令-7" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-7"><a href="#文件备份和压缩命令-7" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-7"><a href="#有关磁盘空间的命令-7" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-7"><a href="#2-3-权限管理-7" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-7"><a href="#2-4-进程管理-7" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-7"><a href="#ps命令-7" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-7"><a href="#pstree命令-7" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-7"><a href="#top命令-7" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-7"><a href="#nice命令-7" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-7"><a href="#pidof命令-7" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-7"><a href="#kill命令-7" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-7"><a href="#killall命令-7" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-7"><a href="#2-5-有关网络操作的命令-7" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-7"><a href="#ping命令-7" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-7"><a href="#netstat命令-7" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-7"><a href="#输入输出重定向-7" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-7"><a href="#管道命令符-7" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-7"><a href="#常用的转义字符-7" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-7"><a href="#Chapter-3-Linux-文件系统-7" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-7"><a href="#文件系统概述-7" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-7"><a href="#文件和文件类型-7" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-7"><a href="#文件命名规则-7" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-7"><a href="#文件类型-7" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-7"><a href="#文件系统结构-7" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-7"><a href="#路径：绝对路径和相对路径-7" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-7"><a href="#软链接和硬链接-7" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-7"><a href="#软链接-7" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-7"><a href="#Chapter-4-Linux-权限管理-7" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-7"><a href="#4-1-用户身份与能力-7" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-7"><a href="#4-2-文件权限与归属-7" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-7"><a href="#Chapter-5-Linux-常用工具-7" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-7"><a href="#文本编辑器-7" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-7"><a href="#gedit-7" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-7"><a href="#vi-7" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-7"><a href="#命令模式和输入模式切换-7" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-7"><a href="#命令模式和底线命令模式切换-7" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-7"><a href="#软件包管理-7" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-7"><a href="#Samba-7" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-7"><a href="#Chapter-6-Linux-进程管理-7" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-7"><a href="#Chapter-7-Linux-Shell-7" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-7"><a href="#各种shell-7" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-7"><a href="#Shell脚本-7" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-7"><a href="#Shell脚本练习-7" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-7"><a href="#Linux-一些概念-7" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-7"><a href="#Linux-常见目录说明-7" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-7"><a href="#Linux-环境变量-7" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-7"><a href="#考试复习-7" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-7"><a href="#后续-7" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-8"><a href="#Kali-Linux-8" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-9"><a href="#参考资料-9" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-9"><a href="#主要参考书-9" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-9"><a href="#链接-9" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-9"><a href="#目录-9" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-9"><a href="#Chapter-1-Linux-概述-9" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-9"><a href="#1-1-Linux-操作系统简述-9" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-9"><a href="#强大好用的Shell-9" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-9"><a href="#1-2-发展史-9" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-9"><a href="#1-3-Linux-的特点与组成-9" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-9"><a href="#1-4-Linux-发行版本-9" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-9"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-9" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-9"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-9" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-9"><a href="#Fedora-Linux-9" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-9"><a href="#Debian-Linux-9" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-9"><a href="#Ubuntu-Linux-9" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-9"><a href="#Kali-Linux-9" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-8"><a href="#开源共享精神-8" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-8"><a href="#Chapter-2-Linux-基本命令-8" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-8"><a href="#执行命令的必备知识-8" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-8"><a href="#常用的按键-8" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-8"><a href="#2-1-常用系统工作命令-8" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-8"><a href="#echo命令-8" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-8"><a href="#date命令-8" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-8"><a href="#timedatectl命令-8" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-8"><a href="#reboot命令-8" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-8"><a href="#poweroff命令-8" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-8"><a href="#wget命令-8" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-8"><a href="#history命令-8" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-8"><a href="#2-2-文件管理-8" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-8"><a href="#管理文件和目录的命令-8" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-8"><a href="#pwd-命令-8" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-8"><a href="#cd命令-8" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-8"><a href="#ls命令-8" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-8"><a href="#cat命令-8" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-8"><a href="#grep命令-8" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-8"><a href="#cp命令-8" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-8"><a href="#touch命令-8" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-8"><a href="#mv命令-8" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-8"><a href="#rm命令-8" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-8"><a href="#文件阅读命令-8" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-8"><a href="#文件备份和压缩命令-8" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-8"><a href="#有关磁盘空间的命令-8" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-8"><a href="#2-3-权限管理-8" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-8"><a href="#2-4-进程管理-8" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-8"><a href="#ps命令-8" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-8"><a href="#pstree命令-8" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-8"><a href="#top命令-8" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-8"><a href="#nice命令-8" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-8"><a href="#pidof命令-8" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-8"><a href="#kill命令-8" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-8"><a href="#killall命令-8" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-8"><a href="#2-5-有关网络操作的命令-8" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-8"><a href="#ping命令-8" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-8"><a href="#netstat命令-8" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-8"><a href="#输入输出重定向-8" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-8"><a href="#管道命令符-8" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-8"><a href="#常用的转义字符-8" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-8"><a href="#Chapter-3-Linux-文件系统-8" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-8"><a href="#文件系统概述-8" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-8"><a href="#文件和文件类型-8" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-8"><a href="#文件命名规则-8" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-8"><a href="#文件类型-8" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-8"><a href="#文件系统结构-8" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-8"><a href="#路径：绝对路径和相对路径-8" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-8"><a href="#软链接和硬链接-8" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-8"><a href="#软链接-8" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-8"><a href="#Chapter-4-Linux-权限管理-8" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-8"><a href="#4-1-用户身份与能力-8" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-8"><a href="#4-2-文件权限与归属-8" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-8"><a href="#Chapter-5-Linux-常用工具-8" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-8"><a href="#文本编辑器-8" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-8"><a href="#gedit-8" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-8"><a href="#vi-8" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-8"><a href="#命令模式和输入模式切换-8" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-8"><a href="#命令模式和底线命令模式切换-8" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-8"><a href="#软件包管理-8" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-8"><a href="#Samba-8" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-8"><a href="#Chapter-6-Linux-进程管理-8" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-8"><a href="#Chapter-7-Linux-Shell-8" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-8"><a href="#各种shell-8" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-8"><a href="#Shell脚本-8" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-8"><a href="#Shell脚本练习-8" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-8"><a href="#Linux-一些概念-8" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-8"><a href="#Linux-常见目录说明-8" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-8"><a href="#Linux-环境变量-8" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-8"><a href="#考试复习-8" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-8"><a href="#后续-8" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-9"><a href="#开源共享精神-9" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-10"><a href="#参考资料-10" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-10"><a href="#主要参考书-10" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-10"><a href="#链接-10" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-10"><a href="#目录-10" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-10"><a href="#Chapter-1-Linux-概述-10" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-10"><a href="#1-1-Linux-操作系统简述-10" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-10"><a href="#强大好用的Shell-10" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-10"><a href="#1-2-发展史-10" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-10"><a href="#1-3-Linux-的特点与组成-10" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-10"><a href="#1-4-Linux-发行版本-10" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-10"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-10" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-10"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-10" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-10"><a href="#Fedora-Linux-10" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-10"><a href="#Debian-Linux-10" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-10"><a href="#Ubuntu-Linux-10" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-10"><a href="#Kali-Linux-10" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-10"><a href="#开源共享精神-10" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-9"><a href="#Chapter-2-Linux-基本命令-9" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-9"><a href="#执行命令的必备知识-9" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-9"><a href="#常用的按键-9" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-9"><a href="#2-1-常用系统工作命令-9" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-9"><a href="#echo命令-9" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-9"><a href="#date命令-9" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-9"><a href="#timedatectl命令-9" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-9"><a href="#reboot命令-9" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-9"><a href="#poweroff命令-9" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-9"><a href="#wget命令-9" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-9"><a href="#history命令-9" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-9"><a href="#2-2-文件管理-9" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-9"><a href="#管理文件和目录的命令-9" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-9"><a href="#pwd-命令-9" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-9"><a href="#cd命令-9" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-9"><a href="#ls命令-9" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-9"><a href="#cat命令-9" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-9"><a href="#grep命令-9" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-9"><a href="#cp命令-9" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-9"><a href="#touch命令-9" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-9"><a href="#mv命令-9" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-9"><a href="#rm命令-9" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-9"><a href="#文件阅读命令-9" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-9"><a href="#文件备份和压缩命令-9" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-9"><a href="#有关磁盘空间的命令-9" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-9"><a href="#2-3-权限管理-9" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-9"><a href="#2-4-进程管理-9" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-9"><a href="#ps命令-9" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-9"><a href="#pstree命令-9" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-9"><a href="#top命令-9" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-9"><a href="#nice命令-9" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-9"><a href="#pidof命令-9" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-9"><a href="#kill命令-9" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-9"><a href="#killall命令-9" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-9"><a href="#2-5-有关网络操作的命令-9" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-9"><a href="#ping命令-9" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-9"><a href="#netstat命令-9" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-9"><a href="#输入输出重定向-9" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-9"><a href="#管道命令符-9" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-9"><a href="#常用的转义字符-9" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-9"><a href="#Chapter-3-Linux-文件系统-9" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-9"><a href="#文件系统概述-9" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-9"><a href="#文件和文件类型-9" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-9"><a href="#文件命名规则-9" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-9"><a href="#文件类型-9" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-9"><a href="#文件系统结构-9" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-9"><a href="#路径：绝对路径和相对路径-9" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-9"><a href="#软链接和硬链接-9" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-9"><a href="#软链接-9" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-9"><a href="#Chapter-4-Linux-权限管理-9" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-9"><a href="#4-1-用户身份与能力-9" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-9"><a href="#4-2-文件权限与归属-9" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-9"><a href="#Chapter-5-Linux-常用工具-9" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-9"><a href="#文本编辑器-9" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-9"><a href="#gedit-9" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-9"><a href="#vi-9" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-9"><a href="#命令模式和输入模式切换-9" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-9"><a href="#命令模式和底线命令模式切换-9" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-9"><a href="#软件包管理-9" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-9"><a href="#Samba-9" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-9"><a href="#Chapter-6-Linux-进程管理-9" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-9"><a href="#Chapter-7-Linux-Shell-9" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-9"><a href="#各种shell-9" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-9"><a href="#Shell脚本-9" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-9"><a href="#Shell脚本练习-9" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-9"><a href="#Linux-一些概念-9" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-9"><a href="#Linux-常见目录说明-9" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-9"><a href="#Linux-环境变量-9" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-9"><a href="#考试复习-9" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-9"><a href="#后续-9" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-10"><a href="#Chapter-2-Linux-基本命令-10" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-10"><a href="#执行命令的必备知识-10" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-10"><a href="#常用的按键-10" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-10"><a href="#2-1-常用系统工作命令-10" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-10"><a href="#echo命令-10" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-10"><a href="#date命令-10" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-10"><a href="#timedatectl命令-10" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-10"><a href="#reboot命令-10" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-10"><a href="#poweroff命令-10" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-10"><a href="#wget命令-10" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-10"><a href="#history命令-10" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-10"><a href="#2-2-文件管理-10" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-10"><a href="#管理文件和目录的命令-10" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-10"><a href="#pwd-命令-10" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-10"><a href="#cd命令-10" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-10"><a href="#ls命令-10" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-10"><a href="#cat命令-10" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-10"><a href="#grep命令-10" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-10"><a href="#cp命令-10" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-10"><a href="#touch命令-10" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-10"><a href="#mv命令-10" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-10"><a href="#rm命令-10" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-10"><a href="#文件阅读命令-10" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-10"><a href="#文件备份和压缩命令-10" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-10"><a href="#有关磁盘空间的命令-10" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-10"><a href="#2-3-权限管理-10" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-10"><a href="#2-4-进程管理-10" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-10"><a href="#ps命令-10" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-10"><a href="#pstree命令-10" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-10"><a href="#top命令-10" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-10"><a href="#nice命令-10" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-10"><a href="#pidof命令-10" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-10"><a href="#kill命令-10" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-10"><a href="#killall命令-10" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-10"><a href="#2-5-有关网络操作的命令-10" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-10"><a href="#ping命令-10" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-10"><a href="#netstat命令-10" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-10"><a href="#输入输出重定向-10" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-10"><a href="#管道命令符-10" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-10"><a href="#常用的转义字符-10" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-10"><a href="#Chapter-3-Linux-文件系统-10" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-10"><a href="#文件系统概述-10" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-10"><a href="#文件和文件类型-10" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-10"><a href="#文件命名规则-10" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-10"><a href="#文件类型-10" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-10"><a href="#文件系统结构-10" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-10"><a href="#路径：绝对路径和相对路径-10" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-10"><a href="#软链接和硬链接-10" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-11"><a href="#参考资料-11" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-11"><a href="#主要参考书-11" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-11"><a href="#链接-11" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-11"><a href="#目录-11" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-11"><a href="#Chapter-1-Linux-概述-11" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-11"><a href="#1-1-Linux-操作系统简述-11" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-11"><a href="#强大好用的Shell-11" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-11"><a href="#1-2-发展史-11" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-11"><a href="#1-3-Linux-的特点与组成-11" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-11"><a href="#1-4-Linux-发行版本-11" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-11"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-11" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-11"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-11" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-11"><a href="#Fedora-Linux-11" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-11"><a href="#Debian-Linux-11" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-11"><a href="#Ubuntu-Linux-11" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-11"><a href="#Kali-Linux-11" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-11"><a href="#开源共享精神-11" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-11"><a href="#Chapter-2-Linux-基本命令-11" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-11"><a href="#执行命令的必备知识-11" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-11"><a href="#常用的按键-11" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-11"><a href="#2-1-常用系统工作命令-11" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-11"><a href="#echo命令-11" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-11"><a href="#date命令-11" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-11"><a href="#timedatectl命令-11" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-11"><a href="#reboot命令-11" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-11"><a href="#poweroff命令-11" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-11"><a href="#wget命令-11" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-11"><a href="#history命令-11" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-11"><a href="#2-2-文件管理-11" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-11"><a href="#管理文件和目录的命令-11" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-11"><a href="#pwd-命令-11" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-11"><a href="#cd命令-11" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-11"><a href="#ls命令-11" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-11"><a href="#cat命令-11" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-11"><a href="#grep命令-11" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-11"><a href="#cp命令-11" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-11"><a href="#touch命令-11" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-11"><a href="#mv命令-11" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-11"><a href="#rm命令-11" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-11"><a href="#文件阅读命令-11" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-11"><a href="#文件备份和压缩命令-11" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-11"><a href="#有关磁盘空间的命令-11" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-11"><a href="#2-3-权限管理-11" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-11"><a href="#2-4-进程管理-11" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-11"><a href="#ps命令-11" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-11"><a href="#pstree命令-11" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-11"><a href="#top命令-11" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-11"><a href="#nice命令-11" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-11"><a href="#pidof命令-11" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-11"><a href="#kill命令-11" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-11"><a href="#killall命令-11" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-11"><a href="#2-5-有关网络操作的命令-11" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-11"><a href="#ping命令-11" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-11"><a href="#netstat命令-11" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-11"><a href="#输入输出重定向-11" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-11"><a href="#管道命令符-11" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-11"><a href="#常用的转义字符-11" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-11"><a href="#Chapter-3-Linux-文件系统-11" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-11"><a href="#文件系统概述-11" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-11"><a href="#文件和文件类型-11" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-11"><a href="#文件命名规则-11" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-11"><a href="#文件类型-11" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-11"><a href="#文件系统结构-11" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-11"><a href="#路径：绝对路径和相对路径-11" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-11"><a href="#软链接和硬链接-11" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-10"><a href="#软链接-10" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-10"><a href="#Chapter-4-Linux-权限管理-10" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-10"><a href="#4-1-用户身份与能力-10" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-10"><a href="#4-2-文件权限与归属-10" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-10"><a href="#Chapter-5-Linux-常用工具-10" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-10"><a href="#文本编辑器-10" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-10"><a href="#gedit-10" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-10"><a href="#vi-10" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-10"><a href="#命令模式和输入模式切换-10" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-10"><a href="#命令模式和底线命令模式切换-10" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-10"><a href="#软件包管理-10" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-10"><a href="#Samba-10" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-10"><a href="#Chapter-6-Linux-进程管理-10" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-10"><a href="#Chapter-7-Linux-Shell-10" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-10"><a href="#各种shell-10" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-10"><a href="#Shell脚本-10" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-10"><a href="#Shell脚本练习-10" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-10"><a href="#Linux-一些概念-10" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-10"><a href="#Linux-常见目录说明-10" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-10"><a href="#Linux-环境变量-10" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-10"><a href="#考试复习-10" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-10"><a href="#后续-10" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><h4 id="软链接-11"><a href="#软链接-11" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-12"><a href="#参考资料-12" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-12"><a href="#主要参考书-12" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-12"><a href="#链接-12" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-12"><a href="#目录-12" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-12"><a href="#Chapter-1-Linux-概述-12" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-12"><a href="#1-1-Linux-操作系统简述-12" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-12"><a href="#强大好用的Shell-12" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-12"><a href="#1-2-发展史-12" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-12"><a href="#1-3-Linux-的特点与组成-12" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-12"><a href="#1-4-Linux-发行版本-12" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-12"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-12" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-12"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-12" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-12"><a href="#Fedora-Linux-12" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-12"><a href="#Debian-Linux-12" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-12"><a href="#Ubuntu-Linux-12" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-12"><a href="#Kali-Linux-12" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-12"><a href="#开源共享精神-12" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-12"><a href="#Chapter-2-Linux-基本命令-12" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-12"><a href="#执行命令的必备知识-12" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-12"><a href="#常用的按键-12" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-12"><a href="#2-1-常用系统工作命令-12" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-12"><a href="#echo命令-12" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-12"><a href="#date命令-12" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-12"><a href="#timedatectl命令-12" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-12"><a href="#reboot命令-12" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-12"><a href="#poweroff命令-12" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-12"><a href="#wget命令-12" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-12"><a href="#history命令-12" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-12"><a href="#2-2-文件管理-12" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-12"><a href="#管理文件和目录的命令-12" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-12"><a href="#pwd-命令-12" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-12"><a href="#cd命令-12" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-12"><a href="#ls命令-12" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-12"><a href="#cat命令-12" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-12"><a href="#grep命令-12" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-12"><a href="#cp命令-12" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-12"><a href="#touch命令-12" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-12"><a href="#mv命令-12" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-12"><a href="#rm命令-12" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-12"><a href="#文件阅读命令-12" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-12"><a href="#文件备份和压缩命令-12" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-12"><a href="#有关磁盘空间的命令-12" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-12"><a href="#2-3-权限管理-12" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-12"><a href="#2-4-进程管理-12" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-12"><a href="#ps命令-12" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-12"><a href="#pstree命令-12" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-12"><a href="#top命令-12" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-12"><a href="#nice命令-12" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-12"><a href="#pidof命令-12" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-12"><a href="#kill命令-12" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-12"><a href="#killall命令-12" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-12"><a href="#2-5-有关网络操作的命令-12" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-12"><a href="#ping命令-12" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-12"><a href="#netstat命令-12" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-12"><a href="#输入输出重定向-12" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-12"><a href="#管道命令符-12" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-12"><a href="#常用的转义字符-12" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-12"><a href="#Chapter-3-Linux-文件系统-12" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-12"><a href="#文件系统概述-12" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-12"><a href="#文件和文件类型-12" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-12"><a href="#文件命名规则-12" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-12"><a href="#文件类型-12" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-12"><a href="#文件系统结构-12" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-12"><a href="#路径：绝对路径和相对路径-12" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-12"><a href="#软链接和硬链接-12" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-12"><a href="#软链接-12" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-11"><a href="#Chapter-4-Linux-权限管理-11" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-11"><a href="#4-1-用户身份与能力-11" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-11"><a href="#4-2-文件权限与归属-11" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-11"><a href="#Chapter-5-Linux-常用工具-11" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-11"><a href="#文本编辑器-11" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-11"><a href="#gedit-11" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-11"><a href="#vi-11" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-11"><a href="#命令模式和输入模式切换-11" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-11"><a href="#命令模式和底线命令模式切换-11" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-11"><a href="#软件包管理-11" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-11"><a href="#Samba-11" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-11"><a href="#Chapter-6-Linux-进程管理-11" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-11"><a href="#Chapter-7-Linux-Shell-11" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-11"><a href="#各种shell-11" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-11"><a href="#Shell脚本-11" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-11"><a href="#Shell脚本练习-11" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-11"><a href="#Linux-一些概念-11" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-11"><a href="#Linux-常见目录说明-11" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-11"><a href="#Linux-环境变量-11" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-11"><a href="#考试复习-11" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-11"><a href="#后续-11" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-13"><a href="#参考资料-13" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-13"><a href="#主要参考书-13" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-13"><a href="#链接-13" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-13"><a href="#目录-13" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-13"><a href="#Chapter-1-Linux-概述-13" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-13"><a href="#1-1-Linux-操作系统简述-13" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-13"><a href="#强大好用的Shell-13" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-13"><a href="#1-2-发展史-13" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-13"><a href="#1-3-Linux-的特点与组成-13" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-13"><a href="#1-4-Linux-发行版本-13" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-13"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-13" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-13"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-13" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-13"><a href="#Fedora-Linux-13" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-13"><a href="#Debian-Linux-13" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-13"><a href="#Ubuntu-Linux-13" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-13"><a href="#Kali-Linux-13" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-13"><a href="#开源共享精神-13" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-13"><a href="#Chapter-2-Linux-基本命令-13" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-13"><a href="#执行命令的必备知识-13" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-13"><a href="#常用的按键-13" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-13"><a href="#2-1-常用系统工作命令-13" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-13"><a href="#echo命令-13" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-13"><a href="#date命令-13" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-13"><a href="#timedatectl命令-13" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-13"><a href="#reboot命令-13" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-13"><a href="#poweroff命令-13" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-13"><a href="#wget命令-13" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-13"><a href="#history命令-13" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-13"><a href="#2-2-文件管理-13" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-13"><a href="#管理文件和目录的命令-13" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-13"><a href="#pwd-命令-13" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-13"><a href="#cd命令-13" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-13"><a href="#ls命令-13" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-13"><a href="#cat命令-13" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-13"><a href="#grep命令-13" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-13"><a href="#cp命令-13" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-13"><a href="#touch命令-13" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-13"><a href="#mv命令-13" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-13"><a href="#rm命令-13" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-13"><a href="#文件阅读命令-13" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-13"><a href="#文件备份和压缩命令-13" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-13"><a href="#有关磁盘空间的命令-13" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-13"><a href="#2-3-权限管理-13" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-13"><a href="#2-4-进程管理-13" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-13"><a href="#ps命令-13" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-13"><a href="#pstree命令-13" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-13"><a href="#top命令-13" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-13"><a href="#nice命令-13" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-13"><a href="#pidof命令-13" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-13"><a href="#kill命令-13" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-13"><a href="#killall命令-13" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-13"><a href="#2-5-有关网络操作的命令-13" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-13"><a href="#ping命令-13" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-13"><a href="#netstat命令-13" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-13"><a href="#输入输出重定向-13" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-13"><a href="#管道命令符-13" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-13"><a href="#常用的转义字符-13" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-13"><a href="#Chapter-3-Linux-文件系统-13" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-13"><a href="#文件系统概述-13" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-13"><a href="#文件和文件类型-13" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-13"><a href="#文件命名规则-13" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-13"><a href="#文件类型-13" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-13"><a href="#文件系统结构-13" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-13"><a href="#路径：绝对路径和相对路径-13" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-13"><a href="#软链接和硬链接-13" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-13"><a href="#软链接-13" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-12"><a href="#Chapter-4-Linux-权限管理-12" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-12"><a href="#4-1-用户身份与能力-12" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-12"><a href="#4-2-文件权限与归属-12" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-12"><a href="#Chapter-5-Linux-常用工具-12" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-12"><a href="#文本编辑器-12" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-12"><a href="#gedit-12" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-12"><a href="#vi-12" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-12"><a href="#命令模式和输入模式切换-12" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-12"><a href="#命令模式和底线命令模式切换-12" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-12"><a href="#软件包管理-12" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-12"><a href="#Samba-12" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-12"><a href="#Chapter-6-Linux-进程管理-12" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-12"><a href="#Chapter-7-Linux-Shell-12" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-12"><a href="#各种shell-12" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-12"><a href="#Shell脚本-12" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-12"><a href="#Shell脚本练习-12" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-12"><a href="#Linux-一些概念-12" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-12"><a href="#Linux-常见目录说明-12" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-12"><a href="#Linux-环境变量-12" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-12"><a href="#考试复习-12" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-12"><a href="#后续-12" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-14"><a href="#参考资料-14" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-14"><a href="#主要参考书-14" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-14"><a href="#链接-14" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-14"><a href="#目录-14" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-14"><a href="#Chapter-1-Linux-概述-14" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-14"><a href="#1-1-Linux-操作系统简述-14" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-14"><a href="#强大好用的Shell-14" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-14"><a href="#1-2-发展史-14" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-14"><a href="#1-3-Linux-的特点与组成-14" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-14"><a href="#1-4-Linux-发行版本-14" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-14"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-14" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-14"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-14" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-14"><a href="#Fedora-Linux-14" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-14"><a href="#Debian-Linux-14" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-14"><a href="#Ubuntu-Linux-14" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-14"><a href="#Kali-Linux-14" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-14"><a href="#开源共享精神-14" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-14"><a href="#Chapter-2-Linux-基本命令-14" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-14"><a href="#执行命令的必备知识-14" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-14"><a href="#常用的按键-14" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-14"><a href="#2-1-常用系统工作命令-14" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-14"><a href="#echo命令-14" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-14"><a href="#date命令-14" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-14"><a href="#timedatectl命令-14" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-14"><a href="#reboot命令-14" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-14"><a href="#poweroff命令-14" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-14"><a href="#wget命令-14" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-14"><a href="#history命令-14" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-14"><a href="#2-2-文件管理-14" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-14"><a href="#管理文件和目录的命令-14" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-14"><a href="#pwd-命令-14" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-14"><a href="#cd命令-14" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-14"><a href="#ls命令-14" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-14"><a href="#cat命令-14" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-14"><a href="#grep命令-14" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-14"><a href="#cp命令-14" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-14"><a href="#touch命令-14" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-14"><a href="#mv命令-14" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-14"><a href="#rm命令-14" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-14"><a href="#文件阅读命令-14" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-14"><a href="#文件备份和压缩命令-14" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-14"><a href="#有关磁盘空间的命令-14" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-14"><a href="#2-3-权限管理-14" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-14"><a href="#2-4-进程管理-14" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-14"><a href="#ps命令-14" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-14"><a href="#pstree命令-14" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-14"><a href="#top命令-14" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-14"><a href="#nice命令-14" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-14"><a href="#pidof命令-14" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-14"><a href="#kill命令-14" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-14"><a href="#killall命令-14" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-14"><a href="#2-5-有关网络操作的命令-14" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-14"><a href="#ping命令-14" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-14"><a href="#netstat命令-14" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-14"><a href="#输入输出重定向-14" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-14"><a href="#管道命令符-14" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-14"><a href="#常用的转义字符-14" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-14"><a href="#Chapter-3-Linux-文件系统-14" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-14"><a href="#文件系统概述-14" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-14"><a href="#文件和文件类型-14" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-14"><a href="#文件命名规则-14" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-14"><a href="#文件类型-14" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-14"><a href="#文件系统结构-14" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-14"><a href="#路径：绝对路径和相对路径-14" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-14"><a href="#软链接和硬链接-14" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-14"><a href="#软链接-14" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-13"><a href="#Chapter-4-Linux-权限管理-13" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-13"><a href="#4-1-用户身份与能力-13" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-13"><a href="#4-2-文件权限与归属-13" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-13"><a href="#Chapter-5-Linux-常用工具-13" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-13"><a href="#文本编辑器-13" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-13"><a href="#gedit-13" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-13"><a href="#vi-13" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-13"><a href="#命令模式和输入模式切换-13" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-13"><a href="#命令模式和底线命令模式切换-13" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-13"><a href="#软件包管理-13" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-13"><a href="#Samba-13" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-13"><a href="#Chapter-6-Linux-进程管理-13" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-13"><a href="#Chapter-7-Linux-Shell-13" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-13"><a href="#各种shell-13" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-13"><a href="#Shell脚本-13" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-13"><a href="#Shell脚本练习-13" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-13"><a href="#Linux-一些概念-13" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-13"><a href="#Linux-常见目录说明-13" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-13"><a href="#Linux-环境变量-13" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-13"><a href="#考试复习-13" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-13"><a href="#后续-13" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><h2 id="Chapter-4-Linux-权限管理-14"><a href="#Chapter-4-Linux-权限管理-14" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-14"><a href="#4-1-用户身份与能力-14" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-14"><a href="#4-2-文件权限与归属-14" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-15"><a href="#参考资料-15" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-15"><a href="#主要参考书-15" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-15"><a href="#链接-15" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-15"><a href="#目录-15" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-15"><a href="#Chapter-1-Linux-概述-15" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-15"><a href="#1-1-Linux-操作系统简述-15" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-15"><a href="#强大好用的Shell-15" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-15"><a href="#1-2-发展史-15" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-15"><a href="#1-3-Linux-的特点与组成-15" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-15"><a href="#1-4-Linux-发行版本-15" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-15"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-15" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-15"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-15" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-15"><a href="#Fedora-Linux-15" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-15"><a href="#Debian-Linux-15" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-15"><a href="#Ubuntu-Linux-15" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-15"><a href="#Kali-Linux-15" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-15"><a href="#开源共享精神-15" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-15"><a href="#Chapter-2-Linux-基本命令-15" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-15"><a href="#执行命令的必备知识-15" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-15"><a href="#常用的按键-15" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-15"><a href="#2-1-常用系统工作命令-15" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-15"><a href="#echo命令-15" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-15"><a href="#date命令-15" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-15"><a href="#timedatectl命令-15" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-15"><a href="#reboot命令-15" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-15"><a href="#poweroff命令-15" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-15"><a href="#wget命令-15" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-15"><a href="#history命令-15" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-15"><a href="#2-2-文件管理-15" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-15"><a href="#管理文件和目录的命令-15" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-15"><a href="#pwd-命令-15" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-15"><a href="#cd命令-15" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-15"><a href="#ls命令-15" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-15"><a href="#cat命令-15" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-15"><a href="#grep命令-15" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-15"><a href="#cp命令-15" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-15"><a href="#touch命令-15" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-15"><a href="#mv命令-15" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-15"><a href="#rm命令-15" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-15"><a href="#文件阅读命令-15" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-15"><a href="#文件备份和压缩命令-15" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-15"><a href="#有关磁盘空间的命令-15" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-15"><a href="#2-3-权限管理-15" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-15"><a href="#2-4-进程管理-15" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-15"><a href="#ps命令-15" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-15"><a href="#pstree命令-15" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-15"><a href="#top命令-15" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-15"><a href="#nice命令-15" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-15"><a href="#pidof命令-15" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-15"><a href="#kill命令-15" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-15"><a href="#killall命令-15" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-15"><a href="#2-5-有关网络操作的命令-15" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-15"><a href="#ping命令-15" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-15"><a href="#netstat命令-15" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-15"><a href="#输入输出重定向-15" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-15"><a href="#管道命令符-15" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-15"><a href="#常用的转义字符-15" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-15"><a href="#Chapter-3-Linux-文件系统-15" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-15"><a href="#文件系统概述-15" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-15"><a href="#文件和文件类型-15" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-15"><a href="#文件命名规则-15" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-15"><a href="#文件类型-15" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-15"><a href="#文件系统结构-15" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-15"><a href="#路径：绝对路径和相对路径-15" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-15"><a href="#软链接和硬链接-15" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-15"><a href="#软链接-15" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-15"><a href="#Chapter-4-Linux-权限管理-15" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-15"><a href="#4-1-用户身份与能力-15" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-15"><a href="#4-2-文件权限与归属-15" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-14"><a href="#Chapter-5-Linux-常用工具-14" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-14"><a href="#文本编辑器-14" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-14"><a href="#gedit-14" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-14"><a href="#vi-14" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-14"><a href="#命令模式和输入模式切换-14" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-14"><a href="#命令模式和底线命令模式切换-14" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-14"><a href="#软件包管理-14" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-14"><a href="#Samba-14" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-14"><a href="#Chapter-6-Linux-进程管理-14" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-14"><a href="#Chapter-7-Linux-Shell-14" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-14"><a href="#各种shell-14" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-14"><a href="#Shell脚本-14" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-14"><a href="#Shell脚本练习-14" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-14"><a href="#Linux-一些概念-14" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-14"><a href="#Linux-常见目录说明-14" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-14"><a href="#Linux-环境变量-14" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-14"><a href="#考试复习-14" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-14"><a href="#后续-14" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-16"><a href="#参考资料-16" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-16"><a href="#主要参考书-16" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-16"><a href="#链接-16" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-16"><a href="#目录-16" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-16"><a href="#Chapter-1-Linux-概述-16" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-16"><a href="#1-1-Linux-操作系统简述-16" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-16"><a href="#强大好用的Shell-16" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-16"><a href="#1-2-发展史-16" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-16"><a href="#1-3-Linux-的特点与组成-16" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-16"><a href="#1-4-Linux-发行版本-16" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-16"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-16" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-16"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-16" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-16"><a href="#Fedora-Linux-16" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-16"><a href="#Debian-Linux-16" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-16"><a href="#Ubuntu-Linux-16" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-16"><a href="#Kali-Linux-16" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-16"><a href="#开源共享精神-16" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-16"><a href="#Chapter-2-Linux-基本命令-16" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-16"><a href="#执行命令的必备知识-16" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-16"><a href="#常用的按键-16" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-16"><a href="#2-1-常用系统工作命令-16" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-16"><a href="#echo命令-16" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-16"><a href="#date命令-16" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-16"><a href="#timedatectl命令-16" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-16"><a href="#reboot命令-16" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-16"><a href="#poweroff命令-16" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-16"><a href="#wget命令-16" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-16"><a href="#history命令-16" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-16"><a href="#2-2-文件管理-16" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-16"><a href="#管理文件和目录的命令-16" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-16"><a href="#pwd-命令-16" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-16"><a href="#cd命令-16" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-16"><a href="#ls命令-16" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-16"><a href="#cat命令-16" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-16"><a href="#grep命令-16" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-16"><a href="#cp命令-16" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-16"><a href="#touch命令-16" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-16"><a href="#mv命令-16" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-16"><a href="#rm命令-16" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-16"><a href="#文件阅读命令-16" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-16"><a href="#文件备份和压缩命令-16" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-16"><a href="#有关磁盘空间的命令-16" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-16"><a href="#2-3-权限管理-16" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-16"><a href="#2-4-进程管理-16" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-16"><a href="#ps命令-16" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-16"><a href="#pstree命令-16" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-16"><a href="#top命令-16" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-16"><a href="#nice命令-16" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-16"><a href="#pidof命令-16" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-16"><a href="#kill命令-16" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-16"><a href="#killall命令-16" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-16"><a href="#2-5-有关网络操作的命令-16" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-16"><a href="#ping命令-16" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-16"><a href="#netstat命令-16" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-16"><a href="#输入输出重定向-16" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-16"><a href="#管道命令符-16" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-16"><a href="#常用的转义字符-16" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-16"><a href="#Chapter-3-Linux-文件系统-16" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-16"><a href="#文件系统概述-16" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-16"><a href="#文件和文件类型-16" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-16"><a href="#文件命名规则-16" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-16"><a href="#文件类型-16" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-16"><a href="#文件系统结构-16" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-16"><a href="#路径：绝对路径和相对路径-16" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-16"><a href="#软链接和硬链接-16" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-16"><a href="#软链接-16" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-16"><a href="#Chapter-4-Linux-权限管理-16" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-16"><a href="#4-1-用户身份与能力-16" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-16"><a href="#4-2-文件权限与归属-16" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-15"><a href="#Chapter-5-Linux-常用工具-15" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-15"><a href="#文本编辑器-15" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-15"><a href="#gedit-15" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-15"><a href="#vi-15" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-15"><a href="#命令模式和输入模式切换-15" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-15"><a href="#命令模式和底线命令模式切换-15" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-15"><a href="#软件包管理-15" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-15"><a href="#Samba-15" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-15"><a href="#Chapter-6-Linux-进程管理-15" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-15"><a href="#Chapter-7-Linux-Shell-15" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-15"><a href="#各种shell-15" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-15"><a href="#Shell脚本-15" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-15"><a href="#Shell脚本练习-15" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-15"><a href="#Linux-一些概念-15" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-15"><a href="#Linux-常见目录说明-15" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-15"><a href="#Linux-环境变量-15" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-15"><a href="#考试复习-15" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-15"><a href="#后续-15" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-17"><a href="#参考资料-17" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-17"><a href="#主要参考书-17" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-17"><a href="#链接-17" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-17"><a href="#目录-17" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-17"><a href="#Chapter-1-Linux-概述-17" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-17"><a href="#1-1-Linux-操作系统简述-17" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-17"><a href="#强大好用的Shell-17" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-17"><a href="#1-2-发展史-17" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-17"><a href="#1-3-Linux-的特点与组成-17" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-17"><a href="#1-4-Linux-发行版本-17" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-17"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-17" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-17"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-17" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-17"><a href="#Fedora-Linux-17" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-17"><a href="#Debian-Linux-17" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-17"><a href="#Ubuntu-Linux-17" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-17"><a href="#Kali-Linux-17" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-17"><a href="#开源共享精神-17" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-17"><a href="#Chapter-2-Linux-基本命令-17" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-17"><a href="#执行命令的必备知识-17" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-17"><a href="#常用的按键-17" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-17"><a href="#2-1-常用系统工作命令-17" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-17"><a href="#echo命令-17" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-17"><a href="#date命令-17" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-17"><a href="#timedatectl命令-17" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-17"><a href="#reboot命令-17" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-17"><a href="#poweroff命令-17" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-17"><a href="#wget命令-17" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-17"><a href="#history命令-17" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-17"><a href="#2-2-文件管理-17" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-17"><a href="#管理文件和目录的命令-17" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-17"><a href="#pwd-命令-17" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-17"><a href="#cd命令-17" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-17"><a href="#ls命令-17" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-17"><a href="#cat命令-17" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-17"><a href="#grep命令-17" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-17"><a href="#cp命令-17" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-17"><a href="#touch命令-17" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-17"><a href="#mv命令-17" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-17"><a href="#rm命令-17" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-17"><a href="#文件阅读命令-17" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-17"><a href="#文件备份和压缩命令-17" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-17"><a href="#有关磁盘空间的命令-17" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-17"><a href="#2-3-权限管理-17" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-17"><a href="#2-4-进程管理-17" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-17"><a href="#ps命令-17" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-17"><a href="#pstree命令-17" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-17"><a href="#top命令-17" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-17"><a href="#nice命令-17" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-17"><a href="#pidof命令-17" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-17"><a href="#kill命令-17" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-17"><a href="#killall命令-17" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-17"><a href="#2-5-有关网络操作的命令-17" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-17"><a href="#ping命令-17" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-17"><a href="#netstat命令-17" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-17"><a href="#输入输出重定向-17" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-17"><a href="#管道命令符-17" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-17"><a href="#常用的转义字符-17" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-17"><a href="#Chapter-3-Linux-文件系统-17" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-17"><a href="#文件系统概述-17" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-17"><a href="#文件和文件类型-17" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-17"><a href="#定义-17" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-17"><a href="#文件命名规则-17" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-17"><a href="#文件类型-17" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-17"><a href="#文件系统结构-17" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-17"><a href="#路径：绝对路径和相对路径-17" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-17"><a href="#软链接和硬链接-17" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-17"><a href="#软链接-17" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-17"><a href="#Chapter-4-Linux-权限管理-17" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-17"><a href="#4-1-用户身份与能力-17" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-17"><a href="#4-2-文件权限与归属-17" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-16"><a href="#Chapter-5-Linux-常用工具-16" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-16"><a href="#文本编辑器-16" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-16"><a href="#gedit-16" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-16"><a href="#vi-16" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-16"><a href="#命令模式和输入模式切换-16" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-16"><a href="#命令模式和底线命令模式切换-16" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-16"><a href="#软件包管理-16" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-16"><a href="#Samba-16" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-16"><a href="#Chapter-6-Linux-进程管理-16" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-16"><a href="#Chapter-7-Linux-Shell-16" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-16"><a href="#各种shell-16" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-16"><a href="#Shell脚本-16" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-16"><a href="#Shell脚本练习-16" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-16"><a href="#Linux-一些概念-16" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-16"><a href="#Linux-常见目录说明-16" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-16"><a href="#Linux-环境变量-16" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-16"><a href="#考试复习-16" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-16"><a href="#后续-16" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-18"><a href="#参考资料-18" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-18"><a href="#主要参考书-18" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-18"><a href="#链接-18" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-18"><a href="#目录-18" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-18"><a href="#Chapter-1-Linux-概述-18" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-18"><a href="#1-1-Linux-操作系统简述-18" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-18"><a href="#强大好用的Shell-18" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-18"><a href="#1-2-发展史-18" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-18"><a href="#1-3-Linux-的特点与组成-18" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-18"><a href="#1-4-Linux-发行版本-18" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-18"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-18" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-18"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-18" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-18"><a href="#Fedora-Linux-18" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-18"><a href="#Debian-Linux-18" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-18"><a href="#Ubuntu-Linux-18" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-18"><a href="#Kali-Linux-18" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-18"><a href="#开源共享精神-18" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-18"><a href="#Chapter-2-Linux-基本命令-18" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-18"><a href="#执行命令的必备知识-18" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-18"><a href="#常用的按键-18" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-18"><a href="#2-1-常用系统工作命令-18" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-18"><a href="#echo命令-18" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-18"><a href="#date命令-18" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-18"><a href="#timedatectl命令-18" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-18"><a href="#reboot命令-18" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-18"><a href="#poweroff命令-18" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-18"><a href="#wget命令-18" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-18"><a href="#history命令-18" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-18"><a href="#2-2-文件管理-18" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-18"><a href="#管理文件和目录的命令-18" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-18"><a href="#pwd-命令-18" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-18"><a href="#cd命令-18" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-18"><a href="#ls命令-18" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-18"><a href="#cat命令-18" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-18"><a href="#grep命令-18" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-18"><a href="#cp命令-18" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-18"><a href="#touch命令-18" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-18"><a href="#mv命令-18" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-18"><a href="#rm命令-18" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-18"><a href="#文件阅读命令-18" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-18"><a href="#文件备份和压缩命令-18" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-18"><a href="#有关磁盘空间的命令-18" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-18"><a href="#2-3-权限管理-18" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-18"><a href="#2-4-进程管理-18" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-18"><a href="#ps命令-18" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-18"><a href="#pstree命令-18" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-18"><a href="#top命令-18" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-18"><a href="#nice命令-18" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-18"><a href="#pidof命令-18" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-18"><a href="#kill命令-18" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-18"><a href="#killall命令-18" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-18"><a href="#2-5-有关网络操作的命令-18" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-18"><a href="#ping命令-18" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-18"><a href="#netstat命令-18" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-18"><a href="#输入输出重定向-18" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-18"><a href="#管道命令符-18" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-18"><a href="#常用的转义字符-18" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-18"><a href="#Chapter-3-Linux-文件系统-18" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-18"><a href="#文件系统概述-18" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-18"><a href="#文件和文件类型-18" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-18"><a href="#定义-18" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-18"><a href="#文件命名规则-18" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-18"><a href="#文件类型-18" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-18"><a href="#文件系统结构-18" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-18"><a href="#路径：绝对路径和相对路径-18" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-18"><a href="#软链接和硬链接-18" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-18"><a href="#软链接-18" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-18"><a href="#Chapter-4-Linux-权限管理-18" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-18"><a href="#4-1-用户身份与能力-18" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-18"><a href="#4-2-文件权限与归属-18" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-17"><a href="#Chapter-5-Linux-常用工具-17" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-17"><a href="#文本编辑器-17" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-17"><a href="#gedit-17" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-17"><a href="#vi-17" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-17"><a href="#命令模式和输入模式切换-17" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-17"><a href="#命令模式和底线命令模式切换-17" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-17"><a href="#软件包管理-17" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-17"><a href="#Samba-17" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-17"><a href="#Chapter-6-Linux-进程管理-17" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-17"><a href="#Chapter-7-Linux-Shell-17" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-17"><a href="#各种shell-17" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-17"><a href="#Shell脚本-17" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-17"><a href="#Shell脚本练习-17" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-17"><a href="#Linux-一些概念-17" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-17"><a href="#Linux-常见目录说明-17" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-17"><a href="#Linux-环境变量-17" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-17"><a href="#考试复习-17" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-17"><a href="#后续-17" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><h2 id="Chapter-5-Linux-常用工具-18"><a href="#Chapter-5-Linux-常用工具-18" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-18"><a href="#文本编辑器-18" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-18"><a href="#gedit-18" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-18"><a href="#vi-18" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-19"><a href="#参考资料-19" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-19"><a href="#主要参考书-19" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-19"><a href="#链接-19" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-19"><a href="#目录-19" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-19"><a href="#Chapter-1-Linux-概述-19" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-19"><a href="#1-1-Linux-操作系统简述-19" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-19"><a href="#强大好用的Shell-19" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-19"><a href="#1-2-发展史-19" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-19"><a href="#1-3-Linux-的特点与组成-19" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-19"><a href="#1-4-Linux-发行版本-19" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-19"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-19" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-19"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-19" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-19"><a href="#Fedora-Linux-19" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-19"><a href="#Debian-Linux-19" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-19"><a href="#Ubuntu-Linux-19" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-19"><a href="#Kali-Linux-19" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-19"><a href="#开源共享精神-19" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-19"><a href="#Chapter-2-Linux-基本命令-19" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-19"><a href="#执行命令的必备知识-19" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-19"><a href="#常用的按键-19" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-19"><a href="#2-1-常用系统工作命令-19" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-19"><a href="#echo命令-19" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-19"><a href="#date命令-19" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-19"><a href="#timedatectl命令-19" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-19"><a href="#reboot命令-19" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-19"><a href="#poweroff命令-19" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-19"><a href="#wget命令-19" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-19"><a href="#history命令-19" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-19"><a href="#2-2-文件管理-19" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-19"><a href="#管理文件和目录的命令-19" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-19"><a href="#pwd-命令-19" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-19"><a href="#cd命令-19" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-19"><a href="#ls命令-19" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-19"><a href="#cat命令-19" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-19"><a href="#grep命令-19" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-19"><a href="#cp命令-19" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-19"><a href="#touch命令-19" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-19"><a href="#mv命令-19" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-19"><a href="#rm命令-19" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-19"><a href="#文件阅读命令-19" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-19"><a href="#文件备份和压缩命令-19" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-19"><a href="#有关磁盘空间的命令-19" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-19"><a href="#2-3-权限管理-19" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-19"><a href="#2-4-进程管理-19" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-19"><a href="#ps命令-19" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-19"><a href="#pstree命令-19" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-19"><a href="#top命令-19" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-19"><a href="#nice命令-19" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-19"><a href="#pidof命令-19" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-19"><a href="#kill命令-19" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-19"><a href="#killall命令-19" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-19"><a href="#2-5-有关网络操作的命令-19" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-19"><a href="#ping命令-19" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-19"><a href="#netstat命令-19" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-19"><a href="#输入输出重定向-19" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-19"><a href="#管道命令符-19" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-19"><a href="#常用的转义字符-19" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-19"><a href="#Chapter-3-Linux-文件系统-19" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-19"><a href="#文件系统概述-19" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-19"><a href="#文件和文件类型-19" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-19"><a href="#定义-19" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-19"><a href="#文件命名规则-19" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-19"><a href="#文件类型-19" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-19"><a href="#文件系统结构-19" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-19"><a href="#路径：绝对路径和相对路径-19" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-19"><a href="#软链接和硬链接-19" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-19"><a href="#软链接-19" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-19"><a href="#Chapter-4-Linux-权限管理-19" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-19"><a href="#4-1-用户身份与能力-19" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-19"><a href="#4-2-文件权限与归属-19" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-19"><a href="#Chapter-5-Linux-常用工具-19" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-19"><a href="#文本编辑器-19" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-19"><a href="#gedit-19" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-19"><a href="#vi-19" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-18"><a href="#命令模式和输入模式切换-18" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-18"><a href="#命令模式和底线命令模式切换-18" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-18"><a href="#软件包管理-18" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-18"><a href="#Samba-18" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-18"><a href="#Chapter-6-Linux-进程管理-18" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-18"><a href="#Chapter-7-Linux-Shell-18" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-18"><a href="#各种shell-18" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-18"><a href="#Shell脚本-18" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-18"><a href="#Shell脚本练习-18" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-18"><a href="#Linux-一些概念-18" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-18"><a href="#Linux-常见目录说明-18" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-18"><a href="#Linux-环境变量-18" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-18"><a href="#考试复习-18" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-18"><a href="#后续-18" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><h5 id="命令模式和输入模式切换-19"><a href="#命令模式和输入模式切换-19" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-19"><a href="#命令模式和底线命令模式切换-19" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料-20"><a href="#参考资料-20" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书-20"><a href="#主要参考书-20" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接-20"><a href="#链接-20" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.gnu.org/gnu/manifesto.zh-cn.html">GNU宣言</a></p><h2 id="目录-20"><a href="#目录-20" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述-20"><a href="#Chapter-1-Linux-概述-20" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述-20"><a href="#1-1-Linux-操作系统简述-20" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell-20"><a href="#强大好用的Shell-20" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史-20"><a href="#1-2-发展史-20" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成-20"><a href="#1-3-Linux-的特点与组成-20" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本-20"><a href="#1-4-Linux-发行版本-20" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）-20"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）-20" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）-20"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）-20" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux-20"><a href="#Fedora-Linux-20" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux-20"><a href="#Debian-Linux-20" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux-20"><a href="#Ubuntu-Linux-20" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux-20"><a href="#Kali-Linux-20" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神-20"><a href="#开源共享精神-20" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令-20"><a href="#Chapter-2-Linux-基本命令-20" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识-20"><a href="#执行命令的必备知识-20" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键-20"><a href="#常用的按键-20" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令-20"><a href="#2-1-常用系统工作命令-20" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令-20"><a href="#echo命令-20" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令-20"><a href="#date命令-20" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令-20"><a href="#timedatectl命令-20" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令-20"><a href="#reboot命令-20" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令-20"><a href="#poweroff命令-20" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令-20"><a href="#wget命令-20" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令-20"><a href="#history命令-20" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理-20"><a href="#2-2-文件管理-20" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令-20"><a href="#管理文件和目录的命令-20" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令-20"><a href="#pwd-命令-20" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令-20"><a href="#cd命令-20" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令-20"><a href="#ls命令-20" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令-20"><a href="#cat命令-20" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令-20"><a href="#grep命令-20" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令-20"><a href="#cp命令-20" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令-20"><a href="#touch命令-20" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令-20"><a href="#mv命令-20" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令-20"><a href="#rm命令-20" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令-20"><a href="#文件阅读命令-20" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令-20"><a href="#文件备份和压缩命令-20" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令-20"><a href="#有关磁盘空间的命令-20" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理-20"><a href="#2-3-权限管理-20" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理-20"><a href="#2-4-进程管理-20" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令-20"><a href="#ps命令-20" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令-20"><a href="#pstree命令-20" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令-20"><a href="#top命令-20" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令-20"><a href="#nice命令-20" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令-20"><a href="#pidof命令-20" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令-20"><a href="#kill命令-20" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令-20"><a href="#killall命令-20" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令-20"><a href="#2-5-有关网络操作的命令-20" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令-20"><a href="#ping命令-20" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令-20"><a href="#netstat命令-20" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向-20"><a href="#输入输出重定向-20" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符-20"><a href="#管道命令符-20" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符-20"><a href="#常用的转义字符-20" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统-20"><a href="#Chapter-3-Linux-文件系统-20" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述-20"><a href="#文件系统概述-20" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型-20"><a href="#文件和文件类型-20" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义-20"><a href="#定义-20" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则-20"><a href="#文件命名规则-20" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型-20"><a href="#文件类型-20" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>  以二进制形式存储在电脑中<br>  用户一般只有通过相应的软件才能将其显示出来<br>  一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>  以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>  以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构-20"><a href="#文件系统结构-20" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径-20"><a href="#路径：绝对路径和相对路径-20" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接-20"><a href="#软链接和硬链接-20" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接-20"><a href="#软链接-20" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/文件系统-2.png"></p><h2 id="Chapter-4-Linux-权限管理-20"><a href="#Chapter-4-Linux-权限管理-20" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力-20"><a href="#4-1-用户身份与能力-20" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属-20"><a href="#4-2-文件权限与归属-20" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-1.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-2.png"></p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="D:/hexo/source/_posts/img/linux/权限管理-4.png"></p><h2 id="Chapter-5-Linux-常用工具-20"><a href="#Chapter-5-Linux-常用工具-20" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器-20"><a href="#文本编辑器-20" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit-20"><a href="#gedit-20" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi-20"><a href="#vi-20" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="D:/hexo/source/_posts/img/linux/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换-20"><a href="#命令模式和输入模式切换-20" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换-20"><a href="#命令模式和底线命令模式切换-20" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="D:/hexo/source/_posts/img/linux/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-19"><a href="#软件包管理-19" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-19"><a href="#Samba-19" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-19"><a href="#Chapter-6-Linux-进程管理-19" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-19"><a href="#Chapter-7-Linux-Shell-19" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-19"><a href="#各种shell-19" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-19"><a href="#Shell脚本-19" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-19"><a href="#Shell脚本练习-19" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-19"><a href="#Linux-一些概念-19" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-19"><a href="#Linux-常见目录说明-19" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-19"><a href="#Linux-环境变量-19" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-19"><a href="#考试复习-19" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-19"><a href="#后续-19" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理-20"><a href="#软件包管理-20" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba-20"><a href="#Samba-20" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理-20"><a href="#Chapter-6-Linux-进程管理-20" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell-20"><a href="#Chapter-7-Linux-Shell-20" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell-20"><a href="#各种shell-20" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本-20"><a href="#Shell脚本-20" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习-20"><a href="#Shell脚本练习-20" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="Linux-一些概念-20"><a href="#Linux-一些概念-20" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>  Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>  保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>  程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>  进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明-20"><a href="#Linux-常见目录说明-20" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量-20"><a href="#Linux-环境变量-20" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习-20"><a href="#考试复习-20" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p><h2 id="后续-20"><a href="#后续-20" class="headerlink" title="后续"></a>后续</h2><p><a href="https://www.linux.org/pages/download/">Download Linux | Linux.org</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution - Wikipedia</a></p><p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解 - 赛艇队长 - 博客园 (cnblogs.com)</a></p><p><a href="https://linux.cn/article-9798-1.html">技术|Linux 文件系统详解</a></p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/Linux-linux/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/Linux-linux/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p>
<p>符号：『』❑ ➢ </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书"><a href="#主要参考书"]]>
    </summary>
    <title>Linux</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h3 id="什么是被动扫描"><a href="#什么是被动扫描" class="headerlink" title="什么是被动扫描?"></a>什么是被动扫描?</h3><p>被动扫描主要指的是在目标无法察觉的情况下进行的信息收集，比如我们如果想了解一个远在天边的人，你会怎么做呢？显然我们可以选择在搜索引擎去搜索这个名字。其实这就是一次对目标的被动扫描。最经典的被动扫描技术其实要数“Google hack”技术，但是这种技术在我们所处的大陆地区暂时无法使用。在这一章中我们来介绍3个极为优秀的信息收集工具：</p><ul><li>Maltego</li><li>sn0int</li><li>ZoomEye</li></ul><h3 id="被动扫描的范围"><a href="#被动扫描的范围" class="headerlink" title="被动扫描的范围"></a>被动扫描的范围</h3><p>那么信息的收集要从哪几方面来下手呢？以目标a.test.com为例，我们就可以想方设法来获取如下的一些信息：</p><p>1）目标网站所有者的信息，例如姓名、地址、电话、电子邮件等。</p><p>2）目标网站相关的电子邮箱。</p><p>3）目标网站用户的社交信息，也就是该网站工作人员的微博、QQ、论坛发帖（这些都是国内渗透测试的标准，国外的话一般是推特、Youtube之类）。</p><p>4）a.test.com指向网站的DNS信息，是否使用了CDN（Content Delivery Network，内容分发网络）、网站应用级入侵防御系统（Web Application Firewall，WAF）等设备。</p><p>5）test.com的子域名信息。</p><h3 id="Maltego"><a href="#Maltego" class="headerlink" title="Maltego"></a>Maltego</h3><p>Maltego是一款十分令人惊喜的信息收集软件。这款工具可以通过域名注册、搜索引擎、社交网络、电子邮件等各种渠道收集目标的信息。</p><p>Kali Linux 2中包含Maltego，但是需要用户自行注册才能使用。</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><blockquote><p>注意：因为Maltego是国外网站，注册信息填写后出现页面404不能直接访问。所以需要在火狐&#x2F;谷歌浏览器上添加redirector插件，创建新的director就行了。</p><p><a href="https://blog.csdn.net/u010784611/article/details/109740060">kali之maltego注册-CSDN博客</a></p><p><a href="https://blog.csdn.net/u010784611/article/details/109732876">注册Maltego显示ReCaptcha is not valid，解决Google验证码服务reCaptcha失效问题_the recaptcha token provided is not valid or has e-CSDN博客</a></p></blockquote><p>犯了个蠢，注册后注意邮箱激活，不然就会出现下图的情况：（警告：你的账户未激活）</p><h3 id="什么是被动扫描-1"><a href="#什么是被动扫描-1" class="headerlink" title="什么是被动扫描?"></a>什么是被动扫描?</h3><p>被动扫描主要指的是在目标无法察觉的情况下进行的信息收集，比如我们如果想了解一个远在天边的人，你会怎么做呢？显然我们可以选择在搜索引擎去搜索这个名字。其实这就是一次对目标的被动扫描。最经典的被动扫描技术其实要数“Google hack”技术，但是这种技术在我们所处的大陆地区暂时无法使用。在这一章中我们来介绍3个极为优秀的信息收集工具：</p><ul><li>Maltego</li><li>sn0int</li><li>ZoomEye</li></ul><h3 id="被动扫描的范围-1"><a href="#被动扫描的范围-1" class="headerlink" title="被动扫描的范围"></a>被动扫描的范围</h3><p>那么信息的收集要从哪几方面来下手呢？以目标a.test.com为例，我们就可以想方设法来获取如下的一些信息：</p><p>1）目标网站所有者的信息，例如姓名、地址、电话、电子邮件等。</p><p>2）目标网站相关的电子邮箱。</p><p>3）目标网站用户的社交信息，也就是该网站工作人员的微博、QQ、论坛发帖（这些都是国内渗透测试的标准，国外的话一般是推特、Youtube之类）。</p><p>4）a.test.com指向网站的DNS信息，是否使用了CDN（Content Delivery Network，内容分发网络）、网站应用级入侵防御系统（Web Application Firewall，WAF）等设备。</p><p>5）test.com的子域名信息。</p><h3 id="Maltego-1"><a href="#Maltego-1" class="headerlink" title="Maltego"></a>Maltego</h3><p>Maltego是一款十分令人惊喜的信息收集软件。这款工具可以通过域名注册、搜索引擎、社交网络、电子邮件等各种渠道收集目标的信息。</p><p>Kali Linux 2中包含Maltego，但是需要用户自行注册才能使用。</p><h4 id="注册-1"><a href="#注册-1" class="headerlink" title="注册"></a>注册</h4><blockquote><p>注意：因为Maltego是国外网站，注册信息填写后出现页面404不能直接访问。所以需要在火狐&#x2F;谷歌浏览器上添加redirector插件，创建新的director就行了。</p><p><a href="https://blog.csdn.net/u010784611/article/details/109740060">kali之maltego注册-CSDN博客</a></p><p><a href="https://blog.csdn.net/u010784611/article/details/109732876">注册Maltego显示ReCaptcha is not valid，解决Google验证码服务reCaptcha失效问题_the recaptcha token provided is not valid or has e-CSDN博客</a></p></blockquote><p>犯了个蠢，注册后注意邮箱激活，不然就会出现下图的情况：（警告：你的账户未激活）</p><p><img src="D:/hexo/source/_posts/img/image-20231122164458195.png" alt="image-20231122164458195"></p><p>启动方法：</p><p>启动Maltogo的方法很简单，Kali Linux 2中已经安装了Maltego，只需要Applications&#x2F;01-Information Gathering&#x2F;maltegoce就可以打开这个工具:</p><p><img src="D:/hexo/source/_posts/img/image-20231122163158810.png" alt="image-20231122163158810"></p><p>打开的Maltego工作界面分成3个部分，最上方是菜单栏，这里面包含了所有的功能，左侧Entity Palette包含了所有的对象（例如设备、域名、IP地址等），右侧是收集到的信息，如下图：</p><p><img src="D:/hexo/source/_posts/img/image-20231122164810001.png" alt="image-20231122164810001"></p><p>接下来进入实战：</p><p>先点击左上角工具栏里的New创建一个Graph。</p><p>Maltego的使用是自动化的，你只需要提供要进行调查的内容。例如这里我们要调查的是<a href="http://www.testfire.net这个域名,那么我们就可以在左侧的entity/">www.testfire.net这个域名，那么我们就可以在左侧的Entity</a> Palette列表的Infarastructure分类中选择Domain，并拖动Domain到右侧的空白区中：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165335173.png" alt="image-20231122165335173"></p><p>在空白区将看到一个名为maltego.com的域对象，双击这个对象，就可以修改其内容。</p><p>然后我们可以有多种调查的方式，这里面选择一种最为常用的方式，也就是Maltego提供的自动化信息收集，在选择了空白区的maltego.com之后，然后单击最左侧的Run View按钮，在切换出来的Machines菜单中提供了Maltego提供的几种比较经典的信息收集方式，这里最为常用的是Footprint系列，其中后面的数字越大，调查的深度也就越大，这里我们以其中的Footprint L1为例。</p><p><img src="D:/hexo/source/_posts/img/image-20231122165101545.png" alt="image-20231122165101545"></p><p>选中了Footprint L1之后，单击右侧的run按钮即可，收集到的结果如图（如果使用的是免费版本的话，那么节点数是有限制的）：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165523854.png" alt="image-20231122165523854"></p><p>换个其他的域名试试：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165715200.png" alt="image-20231122165715200"></p><h3 id="sn0int"><a href="#sn0int" class="headerlink" title="sn0int"></a>sn0int</h3><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install debian-keyring</span><br></pre></td></tr></table></figure><h3 id="Shodan和ZoomEye"><a href="#Shodan和ZoomEye" class="headerlink" title="Shodan和ZoomEye"></a>Shodan和ZoomEye</h3><p>我认为最好的工具就是Shodan和ZoomEye，它们都是网络安全人员十分喜爱的搜索引擎。不同于Google的是，诸如Baidu等用于搜索网站页面的引擎，它们的目的是搜索网络上指定类型的设备。</p><p>Shodan和ZoomEye的使用方法都十分简单，它们都提供了图形化的操作界面，不过如果正确地使用这两个工具，我们还必须掌握“关键词”的用法。这个“关键词”的用法其实和Google、Baidu十分相似，只要你能正确地使用这些关键词，就可以快速在网络上找到那些你所需要的设备,比如轻松地找出位于非洲的一些没有设置口令的服务器。</p><p>随着互联网的快速发展，连接到整个网络上的不再只有计算机，各种各样的设备都出现在了这个时代的大舞台上。路由器、交换机、电话系统、网络打印机、工业控制设备、嵌入式系统、安保设备等都可以通过互联网进行访问，一方面为使用者带来了极大的便利，但另一方面，这些设备都暴露在互联网上，也带来了极大的安全隐患。</p><p>除了一些确实需要连入互联网的设备（例如网络摄像头）之外，我们经常会发现很多时候，用户并不是故意将设备连接到互联网上的。一些经验不够丰富的工作人员在对这些设备进行配置的时候，往往是在不经意间完成了到互联网的连接。后果更为严重的是，这些用户经常会使用系统默认的用户名和密码，甚至有些设备的密码为空。这种设备一旦被黑客发现，后果将不堪设想。</p><h4 id="ZoomEye"><a href="#ZoomEye" class="headerlink" title="ZoomEye"></a>ZoomEye</h4><p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p><p>启动方法：</p><p>启动Maltogo的方法很简单，Kali Linux 2中已经安装了Maltego，只需要Applications&#x2F;01-Information Gathering&#x2F;maltegoce就可以打开这个工具:</p><h3 id="什么是被动扫描-2"><a href="#什么是被动扫描-2" class="headerlink" title="什么是被动扫描?"></a>什么是被动扫描?</h3><p>被动扫描主要指的是在目标无法察觉的情况下进行的信息收集，比如我们如果想了解一个远在天边的人，你会怎么做呢？显然我们可以选择在搜索引擎去搜索这个名字。其实这就是一次对目标的被动扫描。最经典的被动扫描技术其实要数“Google hack”技术，但是这种技术在我们所处的大陆地区暂时无法使用。在这一章中我们来介绍3个极为优秀的信息收集工具：</p><ul><li>Maltego</li><li>sn0int</li><li>ZoomEye</li></ul><h3 id="被动扫描的范围-2"><a href="#被动扫描的范围-2" class="headerlink" title="被动扫描的范围"></a>被动扫描的范围</h3><p>那么信息的收集要从哪几方面来下手呢？以目标a.test.com为例，我们就可以想方设法来获取如下的一些信息：</p><p>1）目标网站所有者的信息，例如姓名、地址、电话、电子邮件等。</p><p>2）目标网站相关的电子邮箱。</p><p>3）目标网站用户的社交信息，也就是该网站工作人员的微博、QQ、论坛发帖（这些都是国内渗透测试的标准，国外的话一般是推特、Youtube之类）。</p><p>4）a.test.com指向网站的DNS信息，是否使用了CDN（Content Delivery Network，内容分发网络）、网站应用级入侵防御系统（Web Application Firewall，WAF）等设备。</p><p>5）test.com的子域名信息。</p><h3 id="Maltego-2"><a href="#Maltego-2" class="headerlink" title="Maltego"></a>Maltego</h3><p>Maltego是一款十分令人惊喜的信息收集软件。这款工具可以通过域名注册、搜索引擎、社交网络、电子邮件等各种渠道收集目标的信息。</p><p>Kali Linux 2中包含Maltego，但是需要用户自行注册才能使用。</p><h4 id="注册-2"><a href="#注册-2" class="headerlink" title="注册"></a>注册</h4><blockquote><p>注意：因为Maltego是国外网站，注册信息填写后出现页面404不能直接访问。所以需要在火狐&#x2F;谷歌浏览器上添加redirector插件，创建新的director就行了。</p><p><a href="https://blog.csdn.net/u010784611/article/details/109740060">kali之maltego注册-CSDN博客</a></p><p><a href="https://blog.csdn.net/u010784611/article/details/109732876">注册Maltego显示ReCaptcha is not valid，解决Google验证码服务reCaptcha失效问题_the recaptcha token provided is not valid or has e-CSDN博客</a></p></blockquote><p>犯了个蠢，注册后注意邮箱激活，不然就会出现下图的情况：（警告：你的账户未激活）</p><p><img src="D:/hexo/source/_posts/img/image-20231122164458195.png" alt="image-20231122164458195"></p><p>启动方法：</p><p>启动Maltogo的方法很简单，Kali Linux 2中已经安装了Maltego，只需要Applications&#x2F;01-Information Gathering&#x2F;maltegoce就可以打开这个工具:</p><p><img src="D:/hexo/source/_posts/img/image-20231122163158810.png" alt="image-20231122163158810"></p><p>打开的Maltego工作界面分成3个部分，最上方是菜单栏，这里面包含了所有的功能，左侧Entity Palette包含了所有的对象（例如设备、域名、IP地址等），右侧是收集到的信息，如下图：</p><p><img src="D:/hexo/source/_posts/img/image-20231122164810001.png" alt="image-20231122164810001"></p><p>接下来进入实战：</p><p>先点击左上角工具栏里的New创建一个Graph。</p><p>Maltego的使用是自动化的，你只需要提供要进行调查的内容。例如这里我们要调查的是<a href="http://www.testfire.net这个域名,那么我们就可以在左侧的entity/">www.testfire.net这个域名，那么我们就可以在左侧的Entity</a> Palette列表的Infarastructure分类中选择Domain，并拖动Domain到右侧的空白区中：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165335173.png" alt="image-20231122165335173"></p><p>在空白区将看到一个名为maltego.com的域对象，双击这个对象，就可以修改其内容。</p><p>然后我们可以有多种调查的方式，这里面选择一种最为常用的方式，也就是Maltego提供的自动化信息收集，在选择了空白区的maltego.com之后，然后单击最左侧的Run View按钮，在切换出来的Machines菜单中提供了Maltego提供的几种比较经典的信息收集方式，这里最为常用的是Footprint系列，其中后面的数字越大，调查的深度也就越大，这里我们以其中的Footprint L1为例。</p><p><img src="D:/hexo/source/_posts/img/image-20231122165101545.png" alt="image-20231122165101545"></p><p>选中了Footprint L1之后，单击右侧的run按钮即可，收集到的结果如图（如果使用的是免费版本的话，那么节点数是有限制的）：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165523854.png" alt="image-20231122165523854"></p><p>换个其他的域名试试：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165715200.png" alt="image-20231122165715200"></p><h3 id="sn0int-1"><a href="#sn0int-1" class="headerlink" title="sn0int"></a>sn0int</h3><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install debian-keyring</span><br></pre></td></tr></table></figure><h3 id="Shodan和ZoomEye-1"><a href="#Shodan和ZoomEye-1" class="headerlink" title="Shodan和ZoomEye"></a>Shodan和ZoomEye</h3><p>我认为最好的工具就是Shodan和ZoomEye，它们都是网络安全人员十分喜爱的搜索引擎。不同于Google的是，诸如Baidu等用于搜索网站页面的引擎，它们的目的是搜索网络上指定类型的设备。</p><p>Shodan和ZoomEye的使用方法都十分简单，它们都提供了图形化的操作界面，不过如果正确地使用这两个工具，我们还必须掌握“关键词”的用法。这个“关键词”的用法其实和Google、Baidu十分相似，只要你能正确地使用这些关键词，就可以快速在网络上找到那些你所需要的设备,比如轻松地找出位于非洲的一些没有设置口令的服务器。</p><p>随着互联网的快速发展，连接到整个网络上的不再只有计算机，各种各样的设备都出现在了这个时代的大舞台上。路由器、交换机、电话系统、网络打印机、工业控制设备、嵌入式系统、安保设备等都可以通过互联网进行访问，一方面为使用者带来了极大的便利，但另一方面，这些设备都暴露在互联网上，也带来了极大的安全隐患。</p><p>除了一些确实需要连入互联网的设备（例如网络摄像头）之外，我们经常会发现很多时候，用户并不是故意将设备连接到互联网上的。一些经验不够丰富的工作人员在对这些设备进行配置的时候，往往是在不经意间完成了到互联网的连接。后果更为严重的是，这些用户经常会使用系统默认的用户名和密码，甚至有些设备的密码为空。这种设备一旦被黑客发现，后果将不堪设想。</p><h4 id="ZoomEye-1"><a href="#ZoomEye-1" class="headerlink" title="ZoomEye"></a>ZoomEye</h4><p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p><p>打开的Maltego工作界面分成3个部分，最上方是菜单栏，这里面包含了所有的功能，左侧Entity Palette包含了所有的对象（例如设备、域名、IP地址等），右侧是收集到的信息，如下图：</p><h3 id="什么是被动扫描-3"><a href="#什么是被动扫描-3" class="headerlink" title="什么是被动扫描?"></a>什么是被动扫描?</h3><p>被动扫描主要指的是在目标无法察觉的情况下进行的信息收集，比如我们如果想了解一个远在天边的人，你会怎么做呢？显然我们可以选择在搜索引擎去搜索这个名字。其实这就是一次对目标的被动扫描。最经典的被动扫描技术其实要数“Google hack”技术，但是这种技术在我们所处的大陆地区暂时无法使用。在这一章中我们来介绍3个极为优秀的信息收集工具：</p><ul><li>Maltego</li><li>sn0int</li><li>ZoomEye</li></ul><h3 id="被动扫描的范围-3"><a href="#被动扫描的范围-3" class="headerlink" title="被动扫描的范围"></a>被动扫描的范围</h3><p>那么信息的收集要从哪几方面来下手呢？以目标a.test.com为例，我们就可以想方设法来获取如下的一些信息：</p><p>1）目标网站所有者的信息，例如姓名、地址、电话、电子邮件等。</p><p>2）目标网站相关的电子邮箱。</p><p>3）目标网站用户的社交信息，也就是该网站工作人员的微博、QQ、论坛发帖（这些都是国内渗透测试的标准，国外的话一般是推特、Youtube之类）。</p><p>4）a.test.com指向网站的DNS信息，是否使用了CDN（Content Delivery Network，内容分发网络）、网站应用级入侵防御系统（Web Application Firewall，WAF）等设备。</p><p>5）test.com的子域名信息。</p><h3 id="Maltego-3"><a href="#Maltego-3" class="headerlink" title="Maltego"></a>Maltego</h3><p>Maltego是一款十分令人惊喜的信息收集软件。这款工具可以通过域名注册、搜索引擎、社交网络、电子邮件等各种渠道收集目标的信息。</p><p>Kali Linux 2中包含Maltego，但是需要用户自行注册才能使用。</p><h4 id="注册-3"><a href="#注册-3" class="headerlink" title="注册"></a>注册</h4><blockquote><p>注意：因为Maltego是国外网站，注册信息填写后出现页面404不能直接访问。所以需要在火狐&#x2F;谷歌浏览器上添加redirector插件，创建新的director就行了。</p><p><a href="https://blog.csdn.net/u010784611/article/details/109740060">kali之maltego注册-CSDN博客</a></p><p><a href="https://blog.csdn.net/u010784611/article/details/109732876">注册Maltego显示ReCaptcha is not valid，解决Google验证码服务reCaptcha失效问题_the recaptcha token provided is not valid or has e-CSDN博客</a></p></blockquote><p>犯了个蠢，注册后注意邮箱激活，不然就会出现下图的情况：（警告：你的账户未激活）</p><p><img src="D:/hexo/source/_posts/img/image-20231122164458195.png" alt="image-20231122164458195"></p><p>启动方法：</p><p>启动Maltogo的方法很简单，Kali Linux 2中已经安装了Maltego，只需要Applications&#x2F;01-Information Gathering&#x2F;maltegoce就可以打开这个工具:</p><p><img src="D:/hexo/source/_posts/img/image-20231122163158810.png" alt="image-20231122163158810"></p><p>打开的Maltego工作界面分成3个部分，最上方是菜单栏，这里面包含了所有的功能，左侧Entity Palette包含了所有的对象（例如设备、域名、IP地址等），右侧是收集到的信息，如下图：</p><p><img src="D:/hexo/source/_posts/img/image-20231122164810001.png" alt="image-20231122164810001"></p><p>接下来进入实战：</p><p>先点击左上角工具栏里的New创建一个Graph。</p><p>Maltego的使用是自动化的，你只需要提供要进行调查的内容。例如这里我们要调查的是<a href="http://www.testfire.net这个域名,那么我们就可以在左侧的entity/">www.testfire.net这个域名，那么我们就可以在左侧的Entity</a> Palette列表的Infarastructure分类中选择Domain，并拖动Domain到右侧的空白区中：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165335173.png" alt="image-20231122165335173"></p><p>在空白区将看到一个名为maltego.com的域对象，双击这个对象，就可以修改其内容。</p><p>然后我们可以有多种调查的方式，这里面选择一种最为常用的方式，也就是Maltego提供的自动化信息收集，在选择了空白区的maltego.com之后，然后单击最左侧的Run View按钮，在切换出来的Machines菜单中提供了Maltego提供的几种比较经典的信息收集方式，这里最为常用的是Footprint系列，其中后面的数字越大，调查的深度也就越大，这里我们以其中的Footprint L1为例。</p><p><img src="D:/hexo/source/_posts/img/image-20231122165101545.png" alt="image-20231122165101545"></p><p>选中了Footprint L1之后，单击右侧的run按钮即可，收集到的结果如图（如果使用的是免费版本的话，那么节点数是有限制的）：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165523854.png" alt="image-20231122165523854"></p><p>换个其他的域名试试：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165715200.png" alt="image-20231122165715200"></p><h3 id="sn0int-2"><a href="#sn0int-2" class="headerlink" title="sn0int"></a>sn0int</h3><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install debian-keyring</span><br></pre></td></tr></table></figure><h3 id="Shodan和ZoomEye-2"><a href="#Shodan和ZoomEye-2" class="headerlink" title="Shodan和ZoomEye"></a>Shodan和ZoomEye</h3><p>我认为最好的工具就是Shodan和ZoomEye，它们都是网络安全人员十分喜爱的搜索引擎。不同于Google的是，诸如Baidu等用于搜索网站页面的引擎，它们的目的是搜索网络上指定类型的设备。</p><p>Shodan和ZoomEye的使用方法都十分简单，它们都提供了图形化的操作界面，不过如果正确地使用这两个工具，我们还必须掌握“关键词”的用法。这个“关键词”的用法其实和Google、Baidu十分相似，只要你能正确地使用这些关键词，就可以快速在网络上找到那些你所需要的设备,比如轻松地找出位于非洲的一些没有设置口令的服务器。</p><p>随着互联网的快速发展，连接到整个网络上的不再只有计算机，各种各样的设备都出现在了这个时代的大舞台上。路由器、交换机、电话系统、网络打印机、工业控制设备、嵌入式系统、安保设备等都可以通过互联网进行访问，一方面为使用者带来了极大的便利，但另一方面，这些设备都暴露在互联网上，也带来了极大的安全隐患。</p><p>除了一些确实需要连入互联网的设备（例如网络摄像头）之外，我们经常会发现很多时候，用户并不是故意将设备连接到互联网上的。一些经验不够丰富的工作人员在对这些设备进行配置的时候，往往是在不经意间完成了到互联网的连接。后果更为严重的是，这些用户经常会使用系统默认的用户名和密码，甚至有些设备的密码为空。这种设备一旦被黑客发现，后果将不堪设想。</p><h4 id="ZoomEye-2"><a href="#ZoomEye-2" class="headerlink" title="ZoomEye"></a>ZoomEye</h4><p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p><p>接下来进入实战：</p><p>先点击左上角工具栏里的New创建一个Graph。</p><p>Maltego的使用是自动化的，你只需要提供要进行调查的内容。例如这里我们要调查的是<a href="http://www.testfire.net这个域名,那么我们就可以在左侧的entity/">www.testfire.net这个域名，那么我们就可以在左侧的Entity</a> Palette列表的Infarastructure分类中选择Domain，并拖动Domain到右侧的空白区中：</p><h3 id="什么是被动扫描-4"><a href="#什么是被动扫描-4" class="headerlink" title="什么是被动扫描?"></a>什么是被动扫描?</h3><p>被动扫描主要指的是在目标无法察觉的情况下进行的信息收集，比如我们如果想了解一个远在天边的人，你会怎么做呢？显然我们可以选择在搜索引擎去搜索这个名字。其实这就是一次对目标的被动扫描。最经典的被动扫描技术其实要数“Google hack”技术，但是这种技术在我们所处的大陆地区暂时无法使用。在这一章中我们来介绍3个极为优秀的信息收集工具：</p><ul><li>Maltego</li><li>sn0int</li><li>ZoomEye</li></ul><h3 id="被动扫描的范围-4"><a href="#被动扫描的范围-4" class="headerlink" title="被动扫描的范围"></a>被动扫描的范围</h3><p>那么信息的收集要从哪几方面来下手呢？以目标a.test.com为例，我们就可以想方设法来获取如下的一些信息：</p><p>1）目标网站所有者的信息，例如姓名、地址、电话、电子邮件等。</p><p>2）目标网站相关的电子邮箱。</p><p>3）目标网站用户的社交信息，也就是该网站工作人员的微博、QQ、论坛发帖（这些都是国内渗透测试的标准，国外的话一般是推特、Youtube之类）。</p><p>4）a.test.com指向网站的DNS信息，是否使用了CDN（Content Delivery Network，内容分发网络）、网站应用级入侵防御系统（Web Application Firewall，WAF）等设备。</p><p>5）test.com的子域名信息。</p><h3 id="Maltego-4"><a href="#Maltego-4" class="headerlink" title="Maltego"></a>Maltego</h3><p>Maltego是一款十分令人惊喜的信息收集软件。这款工具可以通过域名注册、搜索引擎、社交网络、电子邮件等各种渠道收集目标的信息。</p><p>Kali Linux 2中包含Maltego，但是需要用户自行注册才能使用。</p><h4 id="注册-4"><a href="#注册-4" class="headerlink" title="注册"></a>注册</h4><blockquote><p>注意：因为Maltego是国外网站，注册信息填写后出现页面404不能直接访问。所以需要在火狐&#x2F;谷歌浏览器上添加redirector插件，创建新的director就行了。</p><p><a href="https://blog.csdn.net/u010784611/article/details/109740060">kali之maltego注册-CSDN博客</a></p><p><a href="https://blog.csdn.net/u010784611/article/details/109732876">注册Maltego显示ReCaptcha is not valid，解决Google验证码服务reCaptcha失效问题_the recaptcha token provided is not valid or has e-CSDN博客</a></p></blockquote><p>犯了个蠢，注册后注意邮箱激活，不然就会出现下图的情况：（警告：你的账户未激活）</p><p><img src="D:/hexo/source/_posts/img/image-20231122164458195.png" alt="image-20231122164458195"></p><p>启动方法：</p><p>启动Maltogo的方法很简单，Kali Linux 2中已经安装了Maltego，只需要Applications&#x2F;01-Information Gathering&#x2F;maltegoce就可以打开这个工具:</p><p><img src="D:/hexo/source/_posts/img/image-20231122163158810.png" alt="image-20231122163158810"></p><p>打开的Maltego工作界面分成3个部分，最上方是菜单栏，这里面包含了所有的功能，左侧Entity Palette包含了所有的对象（例如设备、域名、IP地址等），右侧是收集到的信息，如下图：</p><p><img src="D:/hexo/source/_posts/img/image-20231122164810001.png" alt="image-20231122164810001"></p><p>接下来进入实战：</p><p>先点击左上角工具栏里的New创建一个Graph。</p><p>Maltego的使用是自动化的，你只需要提供要进行调查的内容。例如这里我们要调查的是<a href="http://www.testfire.net这个域名,那么我们就可以在左侧的entity/">www.testfire.net这个域名，那么我们就可以在左侧的Entity</a> Palette列表的Infarastructure分类中选择Domain，并拖动Domain到右侧的空白区中：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165335173.png" alt="image-20231122165335173"></p><p>在空白区将看到一个名为maltego.com的域对象，双击这个对象，就可以修改其内容。</p><p>然后我们可以有多种调查的方式，这里面选择一种最为常用的方式，也就是Maltego提供的自动化信息收集，在选择了空白区的maltego.com之后，然后单击最左侧的Run View按钮，在切换出来的Machines菜单中提供了Maltego提供的几种比较经典的信息收集方式，这里最为常用的是Footprint系列，其中后面的数字越大，调查的深度也就越大，这里我们以其中的Footprint L1为例。</p><p><img src="D:/hexo/source/_posts/img/image-20231122165101545.png" alt="image-20231122165101545"></p><p>选中了Footprint L1之后，单击右侧的run按钮即可，收集到的结果如图（如果使用的是免费版本的话，那么节点数是有限制的）：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165523854.png" alt="image-20231122165523854"></p><p>换个其他的域名试试：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165715200.png" alt="image-20231122165715200"></p><h3 id="sn0int-3"><a href="#sn0int-3" class="headerlink" title="sn0int"></a>sn0int</h3><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install debian-keyring</span><br></pre></td></tr></table></figure><h3 id="Shodan和ZoomEye-3"><a href="#Shodan和ZoomEye-3" class="headerlink" title="Shodan和ZoomEye"></a>Shodan和ZoomEye</h3><p>我认为最好的工具就是Shodan和ZoomEye，它们都是网络安全人员十分喜爱的搜索引擎。不同于Google的是，诸如Baidu等用于搜索网站页面的引擎，它们的目的是搜索网络上指定类型的设备。</p><p>Shodan和ZoomEye的使用方法都十分简单，它们都提供了图形化的操作界面，不过如果正确地使用这两个工具，我们还必须掌握“关键词”的用法。这个“关键词”的用法其实和Google、Baidu十分相似，只要你能正确地使用这些关键词，就可以快速在网络上找到那些你所需要的设备,比如轻松地找出位于非洲的一些没有设置口令的服务器。</p><p>随着互联网的快速发展，连接到整个网络上的不再只有计算机，各种各样的设备都出现在了这个时代的大舞台上。路由器、交换机、电话系统、网络打印机、工业控制设备、嵌入式系统、安保设备等都可以通过互联网进行访问，一方面为使用者带来了极大的便利，但另一方面，这些设备都暴露在互联网上，也带来了极大的安全隐患。</p><p>除了一些确实需要连入互联网的设备（例如网络摄像头）之外，我们经常会发现很多时候，用户并不是故意将设备连接到互联网上的。一些经验不够丰富的工作人员在对这些设备进行配置的时候，往往是在不经意间完成了到互联网的连接。后果更为严重的是，这些用户经常会使用系统默认的用户名和密码，甚至有些设备的密码为空。这种设备一旦被黑客发现，后果将不堪设想。</p><h4 id="ZoomEye-3"><a href="#ZoomEye-3" class="headerlink" title="ZoomEye"></a>ZoomEye</h4><p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p><p>在空白区将看到一个名为maltego.com的域对象，双击这个对象，就可以修改其内容。</p><p>然后我们可以有多种调查的方式，这里面选择一种最为常用的方式，也就是Maltego提供的自动化信息收集，在选择了空白区的maltego.com之后，然后单击最左侧的Run View按钮，在切换出来的Machines菜单中提供了Maltego提供的几种比较经典的信息收集方式，这里最为常用的是Footprint系列，其中后面的数字越大，调查的深度也就越大，这里我们以其中的Footprint L1为例。</p><h3 id="什么是被动扫描-5"><a href="#什么是被动扫描-5" class="headerlink" title="什么是被动扫描?"></a>什么是被动扫描?</h3><p>被动扫描主要指的是在目标无法察觉的情况下进行的信息收集，比如我们如果想了解一个远在天边的人，你会怎么做呢？显然我们可以选择在搜索引擎去搜索这个名字。其实这就是一次对目标的被动扫描。最经典的被动扫描技术其实要数“Google hack”技术，但是这种技术在我们所处的大陆地区暂时无法使用。在这一章中我们来介绍3个极为优秀的信息收集工具：</p><ul><li>Maltego</li><li>sn0int</li><li>ZoomEye</li></ul><h3 id="被动扫描的范围-5"><a href="#被动扫描的范围-5" class="headerlink" title="被动扫描的范围"></a>被动扫描的范围</h3><p>那么信息的收集要从哪几方面来下手呢？以目标a.test.com为例，我们就可以想方设法来获取如下的一些信息：</p><p>1）目标网站所有者的信息，例如姓名、地址、电话、电子邮件等。</p><p>2）目标网站相关的电子邮箱。</p><p>3）目标网站用户的社交信息，也就是该网站工作人员的微博、QQ、论坛发帖（这些都是国内渗透测试的标准，国外的话一般是推特、Youtube之类）。</p><p>4）a.test.com指向网站的DNS信息，是否使用了CDN（Content Delivery Network，内容分发网络）、网站应用级入侵防御系统（Web Application Firewall，WAF）等设备。</p><p>5）test.com的子域名信息。</p><h3 id="Maltego-5"><a href="#Maltego-5" class="headerlink" title="Maltego"></a>Maltego</h3><p>Maltego是一款十分令人惊喜的信息收集软件。这款工具可以通过域名注册、搜索引擎、社交网络、电子邮件等各种渠道收集目标的信息。</p><p>Kali Linux 2中包含Maltego，但是需要用户自行注册才能使用。</p><h4 id="注册-5"><a href="#注册-5" class="headerlink" title="注册"></a>注册</h4><blockquote><p>注意：因为Maltego是国外网站，注册信息填写后出现页面404不能直接访问。所以需要在火狐&#x2F;谷歌浏览器上添加redirector插件，创建新的director就行了。</p><p><a href="https://blog.csdn.net/u010784611/article/details/109740060">kali之maltego注册-CSDN博客</a></p><p><a href="https://blog.csdn.net/u010784611/article/details/109732876">注册Maltego显示ReCaptcha is not valid，解决Google验证码服务reCaptcha失效问题_the recaptcha token provided is not valid or has e-CSDN博客</a></p></blockquote><p>犯了个蠢，注册后注意邮箱激活，不然就会出现下图的情况：（警告：你的账户未激活）</p><p><img src="D:/hexo/source/_posts/img/image-20231122164458195.png" alt="image-20231122164458195"></p><p>启动方法：</p><p>启动Maltogo的方法很简单，Kali Linux 2中已经安装了Maltego，只需要Applications&#x2F;01-Information Gathering&#x2F;maltegoce就可以打开这个工具:</p><p><img src="D:/hexo/source/_posts/img/image-20231122163158810.png" alt="image-20231122163158810"></p><p>打开的Maltego工作界面分成3个部分，最上方是菜单栏，这里面包含了所有的功能，左侧Entity Palette包含了所有的对象（例如设备、域名、IP地址等），右侧是收集到的信息，如下图：</p><p><img src="D:/hexo/source/_posts/img/image-20231122164810001.png" alt="image-20231122164810001"></p><p>接下来进入实战：</p><p>先点击左上角工具栏里的New创建一个Graph。</p><p>Maltego的使用是自动化的，你只需要提供要进行调查的内容。例如这里我们要调查的是<a href="http://www.testfire.net这个域名,那么我们就可以在左侧的entity/">www.testfire.net这个域名，那么我们就可以在左侧的Entity</a> Palette列表的Infarastructure分类中选择Domain，并拖动Domain到右侧的空白区中：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165335173.png" alt="image-20231122165335173"></p><p>在空白区将看到一个名为maltego.com的域对象，双击这个对象，就可以修改其内容。</p><p>然后我们可以有多种调查的方式，这里面选择一种最为常用的方式，也就是Maltego提供的自动化信息收集，在选择了空白区的maltego.com之后，然后单击最左侧的Run View按钮，在切换出来的Machines菜单中提供了Maltego提供的几种比较经典的信息收集方式，这里最为常用的是Footprint系列，其中后面的数字越大，调查的深度也就越大，这里我们以其中的Footprint L1为例。</p><p><img src="D:/hexo/source/_posts/img/image-20231122165101545.png" alt="image-20231122165101545"></p><p>选中了Footprint L1之后，单击右侧的run按钮即可，收集到的结果如图（如果使用的是免费版本的话，那么节点数是有限制的）：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165523854.png" alt="image-20231122165523854"></p><p>换个其他的域名试试：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165715200.png" alt="image-20231122165715200"></p><h3 id="sn0int-4"><a href="#sn0int-4" class="headerlink" title="sn0int"></a>sn0int</h3><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install debian-keyring</span><br></pre></td></tr></table></figure><h3 id="Shodan和ZoomEye-4"><a href="#Shodan和ZoomEye-4" class="headerlink" title="Shodan和ZoomEye"></a>Shodan和ZoomEye</h3><p>我认为最好的工具就是Shodan和ZoomEye，它们都是网络安全人员十分喜爱的搜索引擎。不同于Google的是，诸如Baidu等用于搜索网站页面的引擎，它们的目的是搜索网络上指定类型的设备。</p><p>Shodan和ZoomEye的使用方法都十分简单，它们都提供了图形化的操作界面，不过如果正确地使用这两个工具，我们还必须掌握“关键词”的用法。这个“关键词”的用法其实和Google、Baidu十分相似，只要你能正确地使用这些关键词，就可以快速在网络上找到那些你所需要的设备,比如轻松地找出位于非洲的一些没有设置口令的服务器。</p><p>随着互联网的快速发展，连接到整个网络上的不再只有计算机，各种各样的设备都出现在了这个时代的大舞台上。路由器、交换机、电话系统、网络打印机、工业控制设备、嵌入式系统、安保设备等都可以通过互联网进行访问，一方面为使用者带来了极大的便利，但另一方面，这些设备都暴露在互联网上，也带来了极大的安全隐患。</p><p>除了一些确实需要连入互联网的设备（例如网络摄像头）之外，我们经常会发现很多时候，用户并不是故意将设备连接到互联网上的。一些经验不够丰富的工作人员在对这些设备进行配置的时候，往往是在不经意间完成了到互联网的连接。后果更为严重的是，这些用户经常会使用系统默认的用户名和密码，甚至有些设备的密码为空。这种设备一旦被黑客发现，后果将不堪设想。</p><h4 id="ZoomEye-4"><a href="#ZoomEye-4" class="headerlink" title="ZoomEye"></a>ZoomEye</h4><p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p><p>选中了Footprint L1之后，单击右侧的run按钮即可，收集到的结果如图（如果使用的是免费版本的话，那么节点数是有限制的）：</p><h3 id="什么是被动扫描-6"><a href="#什么是被动扫描-6" class="headerlink" title="什么是被动扫描?"></a>什么是被动扫描?</h3><p>被动扫描主要指的是在目标无法察觉的情况下进行的信息收集，比如我们如果想了解一个远在天边的人，你会怎么做呢？显然我们可以选择在搜索引擎去搜索这个名字。其实这就是一次对目标的被动扫描。最经典的被动扫描技术其实要数“Google hack”技术，但是这种技术在我们所处的大陆地区暂时无法使用。在这一章中我们来介绍3个极为优秀的信息收集工具：</p><ul><li>Maltego</li><li>sn0int</li><li>ZoomEye</li></ul><h3 id="被动扫描的范围-6"><a href="#被动扫描的范围-6" class="headerlink" title="被动扫描的范围"></a>被动扫描的范围</h3><p>那么信息的收集要从哪几方面来下手呢？以目标a.test.com为例，我们就可以想方设法来获取如下的一些信息：</p><p>1）目标网站所有者的信息，例如姓名、地址、电话、电子邮件等。</p><p>2）目标网站相关的电子邮箱。</p><p>3）目标网站用户的社交信息，也就是该网站工作人员的微博、QQ、论坛发帖（这些都是国内渗透测试的标准，国外的话一般是推特、Youtube之类）。</p><p>4）a.test.com指向网站的DNS信息，是否使用了CDN（Content Delivery Network，内容分发网络）、网站应用级入侵防御系统（Web Application Firewall，WAF）等设备。</p><p>5）test.com的子域名信息。</p><h3 id="Maltego-6"><a href="#Maltego-6" class="headerlink" title="Maltego"></a>Maltego</h3><p>Maltego是一款十分令人惊喜的信息收集软件。这款工具可以通过域名注册、搜索引擎、社交网络、电子邮件等各种渠道收集目标的信息。</p><p>Kali Linux 2中包含Maltego，但是需要用户自行注册才能使用。</p><h4 id="注册-6"><a href="#注册-6" class="headerlink" title="注册"></a>注册</h4><blockquote><p>注意：因为Maltego是国外网站，注册信息填写后出现页面404不能直接访问。所以需要在火狐&#x2F;谷歌浏览器上添加redirector插件，创建新的director就行了。</p><p><a href="https://blog.csdn.net/u010784611/article/details/109740060">kali之maltego注册-CSDN博客</a></p><p><a href="https://blog.csdn.net/u010784611/article/details/109732876">注册Maltego显示ReCaptcha is not valid，解决Google验证码服务reCaptcha失效问题_the recaptcha token provided is not valid or has e-CSDN博客</a></p></blockquote><p>犯了个蠢，注册后注意邮箱激活，不然就会出现下图的情况：（警告：你的账户未激活）</p><p><img src="D:/hexo/source/_posts/img/image-20231122164458195.png" alt="image-20231122164458195"></p><p>启动方法：</p><p>启动Maltogo的方法很简单，Kali Linux 2中已经安装了Maltego，只需要Applications&#x2F;01-Information Gathering&#x2F;maltegoce就可以打开这个工具:</p><p><img src="D:/hexo/source/_posts/img/image-20231122163158810.png" alt="image-20231122163158810"></p><p>打开的Maltego工作界面分成3个部分，最上方是菜单栏，这里面包含了所有的功能，左侧Entity Palette包含了所有的对象（例如设备、域名、IP地址等），右侧是收集到的信息，如下图：</p><p><img src="D:/hexo/source/_posts/img/image-20231122164810001.png" alt="image-20231122164810001"></p><p>接下来进入实战：</p><p>先点击左上角工具栏里的New创建一个Graph。</p><p>Maltego的使用是自动化的，你只需要提供要进行调查的内容。例如这里我们要调查的是<a href="http://www.testfire.net这个域名,那么我们就可以在左侧的entity/">www.testfire.net这个域名，那么我们就可以在左侧的Entity</a> Palette列表的Infarastructure分类中选择Domain，并拖动Domain到右侧的空白区中：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165335173.png" alt="image-20231122165335173"></p><p>在空白区将看到一个名为maltego.com的域对象，双击这个对象，就可以修改其内容。</p><p>然后我们可以有多种调查的方式，这里面选择一种最为常用的方式，也就是Maltego提供的自动化信息收集，在选择了空白区的maltego.com之后，然后单击最左侧的Run View按钮，在切换出来的Machines菜单中提供了Maltego提供的几种比较经典的信息收集方式，这里最为常用的是Footprint系列，其中后面的数字越大，调查的深度也就越大，这里我们以其中的Footprint L1为例。</p><p><img src="D:/hexo/source/_posts/img/image-20231122165101545.png" alt="image-20231122165101545"></p><p>选中了Footprint L1之后，单击右侧的run按钮即可，收集到的结果如图（如果使用的是免费版本的话，那么节点数是有限制的）：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165523854.png" alt="image-20231122165523854"></p><p>换个其他的域名试试：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165715200.png" alt="image-20231122165715200"></p><h3 id="sn0int-5"><a href="#sn0int-5" class="headerlink" title="sn0int"></a>sn0int</h3><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install debian-keyring</span><br></pre></td></tr></table></figure><h3 id="Shodan和ZoomEye-5"><a href="#Shodan和ZoomEye-5" class="headerlink" title="Shodan和ZoomEye"></a>Shodan和ZoomEye</h3><p>我认为最好的工具就是Shodan和ZoomEye，它们都是网络安全人员十分喜爱的搜索引擎。不同于Google的是，诸如Baidu等用于搜索网站页面的引擎，它们的目的是搜索网络上指定类型的设备。</p><p>Shodan和ZoomEye的使用方法都十分简单，它们都提供了图形化的操作界面，不过如果正确地使用这两个工具，我们还必须掌握“关键词”的用法。这个“关键词”的用法其实和Google、Baidu十分相似，只要你能正确地使用这些关键词，就可以快速在网络上找到那些你所需要的设备,比如轻松地找出位于非洲的一些没有设置口令的服务器。</p><p>随着互联网的快速发展，连接到整个网络上的不再只有计算机，各种各样的设备都出现在了这个时代的大舞台上。路由器、交换机、电话系统、网络打印机、工业控制设备、嵌入式系统、安保设备等都可以通过互联网进行访问，一方面为使用者带来了极大的便利，但另一方面，这些设备都暴露在互联网上，也带来了极大的安全隐患。</p><p>除了一些确实需要连入互联网的设备（例如网络摄像头）之外，我们经常会发现很多时候，用户并不是故意将设备连接到互联网上的。一些经验不够丰富的工作人员在对这些设备进行配置的时候，往往是在不经意间完成了到互联网的连接。后果更为严重的是，这些用户经常会使用系统默认的用户名和密码，甚至有些设备的密码为空。这种设备一旦被黑客发现，后果将不堪设想。</p><h4 id="ZoomEye-5"><a href="#ZoomEye-5" class="headerlink" title="ZoomEye"></a>ZoomEye</h4><p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p><p>换个其他的域名试试：</p><h3 id="什么是被动扫描-7"><a href="#什么是被动扫描-7" class="headerlink" title="什么是被动扫描?"></a>什么是被动扫描?</h3><p>被动扫描主要指的是在目标无法察觉的情况下进行的信息收集，比如我们如果想了解一个远在天边的人，你会怎么做呢？显然我们可以选择在搜索引擎去搜索这个名字。其实这就是一次对目标的被动扫描。最经典的被动扫描技术其实要数“Google hack”技术，但是这种技术在我们所处的大陆地区暂时无法使用。在这一章中我们来介绍3个极为优秀的信息收集工具：</p><ul><li>Maltego</li><li>sn0int</li><li>ZoomEye</li></ul><h3 id="被动扫描的范围-7"><a href="#被动扫描的范围-7" class="headerlink" title="被动扫描的范围"></a>被动扫描的范围</h3><p>那么信息的收集要从哪几方面来下手呢？以目标a.test.com为例，我们就可以想方设法来获取如下的一些信息：</p><p>1）目标网站所有者的信息，例如姓名、地址、电话、电子邮件等。</p><p>2）目标网站相关的电子邮箱。</p><p>3）目标网站用户的社交信息，也就是该网站工作人员的微博、QQ、论坛发帖（这些都是国内渗透测试的标准，国外的话一般是推特、Youtube之类）。</p><p>4）a.test.com指向网站的DNS信息，是否使用了CDN（Content Delivery Network，内容分发网络）、网站应用级入侵防御系统（Web Application Firewall，WAF）等设备。</p><p>5）test.com的子域名信息。</p><h3 id="Maltego-7"><a href="#Maltego-7" class="headerlink" title="Maltego"></a>Maltego</h3><p>Maltego是一款十分令人惊喜的信息收集软件。这款工具可以通过域名注册、搜索引擎、社交网络、电子邮件等各种渠道收集目标的信息。</p><p>Kali Linux 2中包含Maltego，但是需要用户自行注册才能使用。</p><h4 id="注册-7"><a href="#注册-7" class="headerlink" title="注册"></a>注册</h4><blockquote><p>注意：因为Maltego是国外网站，注册信息填写后出现页面404不能直接访问。所以需要在火狐&#x2F;谷歌浏览器上添加redirector插件，创建新的director就行了。</p><p><a href="https://blog.csdn.net/u010784611/article/details/109740060">kali之maltego注册-CSDN博客</a></p><p><a href="https://blog.csdn.net/u010784611/article/details/109732876">注册Maltego显示ReCaptcha is not valid，解决Google验证码服务reCaptcha失效问题_the recaptcha token provided is not valid or has e-CSDN博客</a></p></blockquote><p>犯了个蠢，注册后注意邮箱激活，不然就会出现下图的情况：（警告：你的账户未激活）</p><p><img src="D:/hexo/source/_posts/img/image-20231122164458195.png" alt="image-20231122164458195"></p><p>启动方法：</p><p>启动Maltogo的方法很简单，Kali Linux 2中已经安装了Maltego，只需要Applications&#x2F;01-Information Gathering&#x2F;maltegoce就可以打开这个工具:</p><p><img src="D:/hexo/source/_posts/img/image-20231122163158810.png" alt="image-20231122163158810"></p><p>打开的Maltego工作界面分成3个部分，最上方是菜单栏，这里面包含了所有的功能，左侧Entity Palette包含了所有的对象（例如设备、域名、IP地址等），右侧是收集到的信息，如下图：</p><p><img src="D:/hexo/source/_posts/img/image-20231122164810001.png" alt="image-20231122164810001"></p><p>接下来进入实战：</p><p>先点击左上角工具栏里的New创建一个Graph。</p><p>Maltego的使用是自动化的，你只需要提供要进行调查的内容。例如这里我们要调查的是<a href="http://www.testfire.net这个域名,那么我们就可以在左侧的entity/">www.testfire.net这个域名，那么我们就可以在左侧的Entity</a> Palette列表的Infarastructure分类中选择Domain，并拖动Domain到右侧的空白区中：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165335173.png" alt="image-20231122165335173"></p><p>在空白区将看到一个名为maltego.com的域对象，双击这个对象，就可以修改其内容。</p><p>然后我们可以有多种调查的方式，这里面选择一种最为常用的方式，也就是Maltego提供的自动化信息收集，在选择了空白区的maltego.com之后，然后单击最左侧的Run View按钮，在切换出来的Machines菜单中提供了Maltego提供的几种比较经典的信息收集方式，这里最为常用的是Footprint系列，其中后面的数字越大，调查的深度也就越大，这里我们以其中的Footprint L1为例。</p><p><img src="D:/hexo/source/_posts/img/image-20231122165101545.png" alt="image-20231122165101545"></p><p>选中了Footprint L1之后，单击右侧的run按钮即可，收集到的结果如图（如果使用的是免费版本的话，那么节点数是有限制的）：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165523854.png" alt="image-20231122165523854"></p><p>换个其他的域名试试：</p><p><img src="D:/hexo/source/_posts/img/image-20231122165715200.png" alt="image-20231122165715200"></p><h3 id="sn0int-6"><a href="#sn0int-6" class="headerlink" title="sn0int"></a>sn0int</h3><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install debian-keyring</span><br></pre></td></tr></table></figure><h3 id="Shodan和ZoomEye-6"><a href="#Shodan和ZoomEye-6" class="headerlink" title="Shodan和ZoomEye"></a>Shodan和ZoomEye</h3><p>我认为最好的工具就是Shodan和ZoomEye，它们都是网络安全人员十分喜爱的搜索引擎。不同于Google的是，诸如Baidu等用于搜索网站页面的引擎，它们的目的是搜索网络上指定类型的设备。</p><p>Shodan和ZoomEye的使用方法都十分简单，它们都提供了图形化的操作界面，不过如果正确地使用这两个工具，我们还必须掌握“关键词”的用法。这个“关键词”的用法其实和Google、Baidu十分相似，只要你能正确地使用这些关键词，就可以快速在网络上找到那些你所需要的设备,比如轻松地找出位于非洲的一些没有设置口令的服务器。</p><p>随着互联网的快速发展，连接到整个网络上的不再只有计算机，各种各样的设备都出现在了这个时代的大舞台上。路由器、交换机、电话系统、网络打印机、工业控制设备、嵌入式系统、安保设备等都可以通过互联网进行访问，一方面为使用者带来了极大的便利，但另一方面，这些设备都暴露在互联网上，也带来了极大的安全隐患。</p><p>除了一些确实需要连入互联网的设备（例如网络摄像头）之外，我们经常会发现很多时候，用户并不是故意将设备连接到互联网上的。一些经验不够丰富的工作人员在对这些设备进行配置的时候，往往是在不经意间完成了到互联网的连接。后果更为严重的是，这些用户经常会使用系统默认的用户名和密码，甚至有些设备的密码为空。这种设备一旦被黑客发现，后果将不堪设想。</p><h4 id="ZoomEye-6"><a href="#ZoomEye-6" class="headerlink" title="ZoomEye"></a>ZoomEye</h4><p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p><h3 id="sn0int-7"><a href="#sn0int-7" class="headerlink" title="sn0int"></a>sn0int</h3><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install debian-keyring</span><br></pre></td></tr></table></figure><h3 id="Shodan和ZoomEye-7"><a href="#Shodan和ZoomEye-7" class="headerlink" title="Shodan和ZoomEye"></a>Shodan和ZoomEye</h3><p>我认为最好的工具就是Shodan和ZoomEye，它们都是网络安全人员十分喜爱的搜索引擎。不同于Google的是，诸如Baidu等用于搜索网站页面的引擎，它们的目的是搜索网络上指定类型的设备。</p><p>Shodan和ZoomEye的使用方法都十分简单，它们都提供了图形化的操作界面，不过如果正确地使用这两个工具，我们还必须掌握“关键词”的用法。这个“关键词”的用法其实和Google、Baidu十分相似，只要你能正确地使用这些关键词，就可以快速在网络上找到那些你所需要的设备,比如轻松地找出位于非洲的一些没有设置口令的服务器。</p><p>随着互联网的快速发展，连接到整个网络上的不再只有计算机，各种各样的设备都出现在了这个时代的大舞台上。路由器、交换机、电话系统、网络打印机、工业控制设备、嵌入式系统、安保设备等都可以通过互联网进行访问，一方面为使用者带来了极大的便利，但另一方面，这些设备都暴露在互联网上，也带来了极大的安全隐患。</p><p>除了一些确实需要连入互联网的设备（例如网络摄像头）之外，我们经常会发现很多时候，用户并不是故意将设备连接到互联网上的。一些经验不够丰富的工作人员在对这些设备进行配置的时候，往往是在不经意间完成了到互联网的连接。后果更为严重的是，这些用户经常会使用系统默认的用户名和密码，甚至有些设备的密码为空。这种设备一旦被黑客发现，后果将不堪设想。</p><h4 id="ZoomEye-7"><a href="#ZoomEye-7" class="headerlink" title="ZoomEye"></a>ZoomEye</h4><p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/Linux-%E8%A2%AB%E5%8A%A8%E6%89%AB%E6%8F%8F/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/Linux-%E8%A2%AB%E5%8A%A8%E6%89%AB%E6%8F%8F/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h3 id="什么是被动扫描"><a href="#什么是被动扫描" class="headerlink" title="什么是被动扫描?"></a>什么是被动扫描?</h3><p>被动扫描主要指的是在目标无法察觉的情况下进行的信息收集，比如我们如果想了解一个远在天边的人，你会怎么做呢？显然我们可以选择在搜索引擎去搜索这个名字。其实这就是一次对目标的被动扫描。最经典的被动扫描技术其实要数“Google]]>
    </summary>
    <title>被动扫描</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h2 id="使用-Docker-部署-Wiki-js"><a href="#使用-Docker-部署-Wiki-js" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端"><a href="#安装-Docker-端" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：</p><h2 id="使用-Docker-部署-Wiki-js-1"><a href="#使用-Docker-部署-Wiki-js-1" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-1"><a href="#安装-Docker-端-1" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-1"><a href="#获取镜像-1" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-1"><a href="#初始配置-1" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示"><a href="#1-效果展示" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对"><a href="#2-版本比对" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言"><a href="#3-修改语言" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索"><a href="#4-全文检索" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点"><a href="#5-修饰站点" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制"><a href="#6-权限控制" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展"><a href="#定制和扩展" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題"><a href="#主題" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置"><a href="#1-授权配置" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID"><a href="#1-1-Client-ID" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret"><a href="#1-2-Client-Secret" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL"><a href="#1-3-Authorization-Endpoint-URL" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL"><a href="#1-4-Token-Endpoint-URL" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL"><a href="#1-5-User-Info-Endpoint-URL" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim"><a href="#1-6-ID-Claim" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim"><a href="#1-7-Display-Name-Claim" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim"><a href="#1-8-Email-Claim" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置"><a href="#2-注册配置" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册"><a href="#2-1-启用开放注册" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册"><a href="#2-1-禁用开放注册" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p>[## 使用 Docker 部署 Wiki.js</p><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-2"><a href="#安装-Docker-端-2" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-2"><a href="#获取镜像-2" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-2"><a href="#初始配置-2" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-1"><a href="#开始使用-1" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-1"><a href="#1-效果展示-1" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-1"><a href="#2-版本比对-1" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-1"><a href="#3-修改语言-1" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-1"><a href="#4-全文检索-1" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-1"><a href="#5-修饰站点-1" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-1"><a href="#6-权限控制-1" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-1"><a href="#定制和扩展-1" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-1"><a href="#主題-1" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-1"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-1" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-1"><a href="#1-授权配置-1" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-1"><a href="#1-1-Client-ID-1" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-1"><a href="#1-2-Client-Secret-1" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-1"><a href="#1-3-Authorization-Endpoint-URL-1" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-1"><a href="#1-4-Token-Endpoint-URL-1" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-1"><a href="#1-5-User-Info-Endpoint-URL-1" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-1"><a href="#1-6-ID-Claim-1" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-1"><a href="#1-7-Display-Name-Claim-1" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-1"><a href="#1-8-Email-Claim-1" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-1"><a href="#2-注册配置-1" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-1"><a href="#2-1-启用开放注册-1" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-1"><a href="#2-1-禁用开放注册-1" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><h2 id="使用-Docker-部署-Wiki-js-2"><a href="#使用-Docker-部署-Wiki-js-2" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-3"><a href="#安装-Docker-端-3" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-3"><a href="#获取镜像-3" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-3"><a href="#初始配置-3" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-2"><a href="#开始使用-2" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-2"><a href="#1-效果展示-2" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-2"><a href="#2-版本比对-2" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-2"><a href="#3-修改语言-2" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-2"><a href="#4-全文检索-2" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-2"><a href="#5-修饰站点-2" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-2"><a href="#6-权限控制-2" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-2"><a href="#定制和扩展-2" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-2"><a href="#主題-2" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-2"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-2" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-2"><a href="#1-授权配置-2" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-2"><a href="#1-1-Client-ID-2" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-2"><a href="#1-2-Client-Secret-2" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-2"><a href="#1-3-Authorization-Endpoint-URL-2" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-2"><a href="#1-4-Token-Endpoint-URL-2" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-2"><a href="#1-5-User-Info-Endpoint-URL-2" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-2"><a href="#1-6-ID-Claim-2" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-2"><a href="#1-7-Display-Name-Claim-2" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-2"><a href="#1-8-Email-Claim-2" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-2"><a href="#2-注册配置-2" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-2"><a href="#2-1-启用开放注册-2" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-2"><a href="#2-1-禁用开放注册-2" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><h2 id="使用-Docker-部署-Wiki-js-3"><a href="#使用-Docker-部署-Wiki-js-3" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-4"><a href="#安装-Docker-端-4" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-4"><a href="#获取镜像-4" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-4"><a href="#初始配置-4" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-3"><a href="#开始使用-3" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-3"><a href="#1-效果展示-3" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-3"><a href="#2-版本比对-3" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-3"><a href="#3-修改语言-3" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-3"><a href="#4-全文检索-3" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-3"><a href="#5-修饰站点-3" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-3"><a href="#6-权限控制-3" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-3"><a href="#定制和扩展-3" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-3"><a href="#主題-3" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-3"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-3" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-3"><a href="#1-授权配置-3" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-3"><a href="#1-1-Client-ID-3" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-3"><a href="#1-2-Client-Secret-3" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-3"><a href="#1-3-Authorization-Endpoint-URL-3" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-3"><a href="#1-4-Token-Endpoint-URL-3" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-3"><a href="#1-5-User-Info-Endpoint-URL-3" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-3"><a href="#1-6-ID-Claim-3" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-3"><a href="#1-7-Display-Name-Claim-3" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-3"><a href="#1-8-Email-Claim-3" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-3"><a href="#2-注册配置-3" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-3"><a href="#2-1-启用开放注册-3" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-3"><a href="#2-1-禁用开放注册-3" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><h2 id="使用-Docker-部署-Wiki-js-4"><a href="#使用-Docker-部署-Wiki-js-4" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-5"><a href="#安装-Docker-端-5" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-5"><a href="#获取镜像-5" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-5"><a href="#初始配置-5" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-4"><a href="#开始使用-4" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-4"><a href="#1-效果展示-4" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-4"><a href="#2-版本比对-4" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-4"><a href="#3-修改语言-4" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-4"><a href="#4-全文检索-4" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-4"><a href="#5-修饰站点-4" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-4"><a href="#6-权限控制-4" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-4"><a href="#定制和扩展-4" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-4"><a href="#主題-4" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-4"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-4" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-4"><a href="#1-授权配置-4" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-4"><a href="#1-1-Client-ID-4" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-4"><a href="#1-2-Client-Secret-4" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-4"><a href="#1-3-Authorization-Endpoint-URL-4" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-4"><a href="#1-4-Token-Endpoint-URL-4" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-4"><a href="#1-5-User-Info-Endpoint-URL-4" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-4"><a href="#1-6-ID-Claim-4" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-4"><a href="#1-7-Display-Name-Claim-4" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-4"><a href="#1-8-Email-Claim-4" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-4"><a href="#2-注册配置-4" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-4"><a href="#2-1-启用开放注册-4" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-4"><a href="#2-1-禁用开放注册-4" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><h2 id="使用-Docker-部署-Wiki-js-5"><a href="#使用-Docker-部署-Wiki-js-5" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-6"><a href="#安装-Docker-端-6" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-6"><a href="#获取镜像-6" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-6"><a href="#初始配置-6" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-5"><a href="#开始使用-5" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-5"><a href="#1-效果展示-5" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-5"><a href="#2-版本比对-5" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-5"><a href="#3-修改语言-5" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-5"><a href="#4-全文检索-5" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-5"><a href="#5-修饰站点-5" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-5"><a href="#6-权限控制-5" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-5"><a href="#定制和扩展-5" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-5"><a href="#主題-5" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-5"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-5" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-5"><a href="#1-授权配置-5" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-5"><a href="#1-1-Client-ID-5" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-5"><a href="#1-2-Client-Secret-5" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-5"><a href="#1-3-Authorization-Endpoint-URL-5" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-5"><a href="#1-4-Token-Endpoint-URL-5" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-5"><a href="#1-5-User-Info-Endpoint-URL-5" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-5"><a href="#1-6-ID-Claim-5" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-5"><a href="#1-7-Display-Name-Claim-5" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-5"><a href="#1-8-Email-Claim-5" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-5"><a href="#2-注册配置-5" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-5"><a href="#2-1-启用开放注册-5" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-5"><a href="#2-1-禁用开放注册-5" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><h2 id="开始使用-6"><a href="#开始使用-6" class="headerlink" title="开始使用"></a>开始使用</h2><h2 id="使用-Docker-部署-Wiki-js-6"><a href="#使用-Docker-部署-Wiki-js-6" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-7"><a href="#安装-Docker-端-7" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-7"><a href="#获取镜像-7" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-7"><a href="#初始配置-7" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-7"><a href="#开始使用-7" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-6"><a href="#1-效果展示-6" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-6"><a href="#2-版本比对-6" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-6"><a href="#3-修改语言-6" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-6"><a href="#4-全文检索-6" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-6"><a href="#5-修饰站点-6" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-6"><a href="#6-权限控制-6" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-6"><a href="#定制和扩展-6" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-6"><a href="#主題-6" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-6"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-6" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-6"><a href="#1-授权配置-6" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-6"><a href="#1-1-Client-ID-6" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-6"><a href="#1-2-Client-Secret-6" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-6"><a href="#1-3-Authorization-Endpoint-URL-6" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-6"><a href="#1-4-Token-Endpoint-URL-6" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-6"><a href="#1-5-User-Info-Endpoint-URL-6" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-6"><a href="#1-6-ID-Claim-6" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-6"><a href="#1-7-Display-Name-Claim-6" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-6"><a href="#1-8-Email-Claim-6" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-6"><a href="#2-注册配置-6" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-6"><a href="#2-1-启用开放注册-6" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-6"><a href="#2-1-禁用开放注册-6" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><h3 id="1-效果展示-7"><a href="#1-效果展示-7" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><h2 id="使用-Docker-部署-Wiki-js-7"><a href="#使用-Docker-部署-Wiki-js-7" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-8"><a href="#安装-Docker-端-8" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-8"><a href="#获取镜像-8" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-8"><a href="#初始配置-8" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-8"><a href="#开始使用-8" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-8"><a href="#1-效果展示-8" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-7"><a href="#2-版本比对-7" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-7"><a href="#3-修改语言-7" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-7"><a href="#4-全文检索-7" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-7"><a href="#5-修饰站点-7" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-7"><a href="#6-权限控制-7" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-7"><a href="#定制和扩展-7" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-7"><a href="#主題-7" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-7"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-7" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-7"><a href="#1-授权配置-7" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-7"><a href="#1-1-Client-ID-7" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-7"><a href="#1-2-Client-Secret-7" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-7"><a href="#1-3-Authorization-Endpoint-URL-7" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-7"><a href="#1-4-Token-Endpoint-URL-7" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-7"><a href="#1-5-User-Info-Endpoint-URL-7" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-7"><a href="#1-6-ID-Claim-7" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-7"><a href="#1-7-Display-Name-Claim-7" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-7"><a href="#1-8-Email-Claim-7" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-7"><a href="#2-注册配置-7" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-7"><a href="#2-1-启用开放注册-7" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-7"><a href="#2-1-禁用开放注册-7" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><p>　　后台管理页面功能如下图所示。</p><h2 id="使用-Docker-部署-Wiki-js-8"><a href="#使用-Docker-部署-Wiki-js-8" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-9"><a href="#安装-Docker-端-9" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-9"><a href="#获取镜像-9" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-9"><a href="#初始配置-9" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-9"><a href="#开始使用-9" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-9"><a href="#1-效果展示-9" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-8"><a href="#2-版本比对-8" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-8"><a href="#3-修改语言-8" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-8"><a href="#4-全文检索-8" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-8"><a href="#5-修饰站点-8" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-8"><a href="#6-权限控制-8" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-8"><a href="#定制和扩展-8" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-8"><a href="#主題-8" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-8"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-8" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-8"><a href="#1-授权配置-8" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-8"><a href="#1-1-Client-ID-8" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-8"><a href="#1-2-Client-Secret-8" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-8"><a href="#1-3-Authorization-Endpoint-URL-8" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-8"><a href="#1-4-Token-Endpoint-URL-8" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-8"><a href="#1-5-User-Info-Endpoint-URL-8" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-8"><a href="#1-6-ID-Claim-8" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-8"><a href="#1-7-Display-Name-Claim-8" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-8"><a href="#1-8-Email-Claim-8" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-8"><a href="#2-注册配置-8" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-8"><a href="#2-1-启用开放注册-8" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-8"><a href="#2-1-禁用开放注册-8" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><h3 id="2-版本比对-9"><a href="#2-版本比对-9" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><h2 id="使用-Docker-部署-Wiki-js-9"><a href="#使用-Docker-部署-Wiki-js-9" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-10"><a href="#安装-Docker-端-10" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-10"><a href="#获取镜像-10" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-10"><a href="#初始配置-10" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-10"><a href="#开始使用-10" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-10"><a href="#1-效果展示-10" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-10"><a href="#2-版本比对-10" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-9"><a href="#3-修改语言-9" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-9"><a href="#4-全文检索-9" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-9"><a href="#5-修饰站点-9" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-9"><a href="#6-权限控制-9" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-9"><a href="#定制和扩展-9" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-9"><a href="#主題-9" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-9"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-9" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-9"><a href="#1-授权配置-9" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-9"><a href="#1-1-Client-ID-9" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-9"><a href="#1-2-Client-Secret-9" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-9"><a href="#1-3-Authorization-Endpoint-URL-9" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-9"><a href="#1-4-Token-Endpoint-URL-9" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-9"><a href="#1-5-User-Info-Endpoint-URL-9" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-9"><a href="#1-6-ID-Claim-9" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-9"><a href="#1-7-Display-Name-Claim-9" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-9"><a href="#1-8-Email-Claim-9" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-9"><a href="#2-注册配置-9" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-9"><a href="#2-1-启用开放注册-9" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-9"><a href="#2-1-禁用开放注册-9" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><h3 id="3-修改语言-10"><a href="#3-修改语言-10" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><h2 id="使用-Docker-部署-Wiki-js-10"><a href="#使用-Docker-部署-Wiki-js-10" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-11"><a href="#安装-Docker-端-11" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-11"><a href="#获取镜像-11" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-11"><a href="#初始配置-11" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-11"><a href="#开始使用-11" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-11"><a href="#1-效果展示-11" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-11"><a href="#2-版本比对-11" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-11"><a href="#3-修改语言-11" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-10"><a href="#4-全文检索-10" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-10"><a href="#5-修饰站点-10" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-10"><a href="#6-权限控制-10" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-10"><a href="#定制和扩展-10" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-10"><a href="#主題-10" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-10"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-10" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-10"><a href="#1-授权配置-10" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-10"><a href="#1-1-Client-ID-10" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-10"><a href="#1-2-Client-Secret-10" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-10"><a href="#1-3-Authorization-Endpoint-URL-10" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-10"><a href="#1-4-Token-Endpoint-URL-10" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-10"><a href="#1-5-User-Info-Endpoint-URL-10" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-10"><a href="#1-6-ID-Claim-10" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-10"><a href="#1-7-Display-Name-Claim-10" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-10"><a href="#1-8-Email-Claim-10" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-10"><a href="#2-注册配置-10" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-10"><a href="#2-1-启用开放注册-10" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-10"><a href="#2-1-禁用开放注册-10" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><h3 id="4-全文检索-11"><a href="#4-全文检索-11" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><h2 id="使用-Docker-部署-Wiki-js-11"><a href="#使用-Docker-部署-Wiki-js-11" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-12"><a href="#安装-Docker-端-12" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-12"><a href="#获取镜像-12" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-12"><a href="#初始配置-12" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-12"><a href="#开始使用-12" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-12"><a href="#1-效果展示-12" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-12"><a href="#2-版本比对-12" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-12"><a href="#3-修改语言-12" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-12"><a href="#4-全文检索-12" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-11"><a href="#5-修饰站点-11" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-11"><a href="#6-权限控制-11" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-11"><a href="#定制和扩展-11" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-11"><a href="#主題-11" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-11"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-11" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-11"><a href="#1-授权配置-11" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-11"><a href="#1-1-Client-ID-11" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-11"><a href="#1-2-Client-Secret-11" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-11"><a href="#1-3-Authorization-Endpoint-URL-11" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-11"><a href="#1-4-Token-Endpoint-URL-11" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-11"><a href="#1-5-User-Info-Endpoint-URL-11" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-11"><a href="#1-6-ID-Claim-11" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-11"><a href="#1-7-Display-Name-Claim-11" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-11"><a href="#1-8-Email-Claim-11" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-11"><a href="#2-注册配置-11" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-11"><a href="#2-1-启用开放注册-11" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-11"><a href="#2-1-禁用开放注册-11" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><p>　　配置好后，我们就可以验证中文搜索了。</p><h2 id="使用-Docker-部署-Wiki-js-12"><a href="#使用-Docker-部署-Wiki-js-12" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-13"><a href="#安装-Docker-端-13" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-13"><a href="#获取镜像-13" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-13"><a href="#初始配置-13" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-13"><a href="#开始使用-13" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-13"><a href="#1-效果展示-13" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-13"><a href="#2-版本比对-13" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-13"><a href="#3-修改语言-13" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-13"><a href="#4-全文检索-13" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-12"><a href="#5-修饰站点-12" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-12"><a href="#6-权限控制-12" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-12"><a href="#定制和扩展-12" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-12"><a href="#主題-12" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-12"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-12" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-12"><a href="#1-授权配置-12" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-12"><a href="#1-1-Client-ID-12" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-12"><a href="#1-2-Client-Secret-12" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-12"><a href="#1-3-Authorization-Endpoint-URL-12" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-12"><a href="#1-4-Token-Endpoint-URL-12" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-12"><a href="#1-5-User-Info-Endpoint-URL-12" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-12"><a href="#1-6-ID-Claim-12" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-12"><a href="#1-7-Display-Name-Claim-12" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-12"><a href="#1-8-Email-Claim-12" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-12"><a href="#2-注册配置-12" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-12"><a href="#2-1-启用开放注册-12" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-12"><a href="#2-1-禁用开放注册-12" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><h3 id="5-修饰站点-13"><a href="#5-修饰站点-13" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><h2 id="使用-Docker-部署-Wiki-js-13"><a href="#使用-Docker-部署-Wiki-js-13" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-14"><a href="#安装-Docker-端-14" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-14"><a href="#获取镜像-14" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-14"><a href="#初始配置-14" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-14"><a href="#开始使用-14" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-14"><a href="#1-效果展示-14" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-14"><a href="#2-版本比对-14" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-14"><a href="#3-修改语言-14" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-14"><a href="#4-全文检索-14" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-14"><a href="#5-修饰站点-14" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-13"><a href="#6-权限控制-13" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-13"><a href="#定制和扩展-13" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-13"><a href="#主題-13" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-13"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-13" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-13"><a href="#1-授权配置-13" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-13"><a href="#1-1-Client-ID-13" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-13"><a href="#1-2-Client-Secret-13" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-13"><a href="#1-3-Authorization-Endpoint-URL-13" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-13"><a href="#1-4-Token-Endpoint-URL-13" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-13"><a href="#1-5-User-Info-Endpoint-URL-13" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-13"><a href="#1-6-ID-Claim-13" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-13"><a href="#1-7-Display-Name-Claim-13" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-13"><a href="#1-8-Email-Claim-13" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-13"><a href="#2-注册配置-13" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-13"><a href="#2-1-启用开放注册-13" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-13"><a href="#2-1-禁用开放注册-13" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><h3 id="6-权限控制-14"><a href="#6-权限控制-14" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><h2 id="使用-Docker-部署-Wiki-js-14"><a href="#使用-Docker-部署-Wiki-js-14" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-15"><a href="#安装-Docker-端-15" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-15"><a href="#获取镜像-15" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-15"><a href="#初始配置-15" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-15"><a href="#开始使用-15" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-15"><a href="#1-效果展示-15" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-15"><a href="#2-版本比对-15" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-15"><a href="#3-修改语言-15" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-15"><a href="#4-全文检索-15" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-15"><a href="#5-修饰站点-15" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-15"><a href="#6-权限控制-15" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-14"><a href="#定制和扩展-14" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-14"><a href="#主題-14" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-14"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-14" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-14"><a href="#1-授权配置-14" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-14"><a href="#1-1-Client-ID-14" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-14"><a href="#1-2-Client-Secret-14" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-14"><a href="#1-3-Authorization-Endpoint-URL-14" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-14"><a href="#1-4-Token-Endpoint-URL-14" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-14"><a href="#1-5-User-Info-Endpoint-URL-14" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-14"><a href="#1-6-ID-Claim-14" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-14"><a href="#1-7-Display-Name-Claim-14" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-14"><a href="#1-8-Email-Claim-14" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-14"><a href="#2-注册配置-14" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-14"><a href="#2-1-启用开放注册-14" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-14"><a href="#2-1-禁用开放注册-14" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><p>　　可以通过建立组来统一管理用户。</p><h2 id="使用-Docker-部署-Wiki-js-15"><a href="#使用-Docker-部署-Wiki-js-15" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-16"><a href="#安装-Docker-端-16" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-16"><a href="#获取镜像-16" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-16"><a href="#初始配置-16" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-16"><a href="#开始使用-16" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-16"><a href="#1-效果展示-16" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-16"><a href="#2-版本比对-16" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-16"><a href="#3-修改语言-16" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-16"><a href="#4-全文检索-16" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-16"><a href="#5-修饰站点-16" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-16"><a href="#6-权限控制-16" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-15"><a href="#定制和扩展-15" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-15"><a href="#主題-15" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-15"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-15" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-15"><a href="#1-授权配置-15" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-15"><a href="#1-1-Client-ID-15" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-15"><a href="#1-2-Client-Secret-15" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-15"><a href="#1-3-Authorization-Endpoint-URL-15" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-15"><a href="#1-4-Token-Endpoint-URL-15" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-15"><a href="#1-5-User-Info-Endpoint-URL-15" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-15"><a href="#1-6-ID-Claim-15" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-15"><a href="#1-7-Display-Name-Claim-15" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-15"><a href="#1-8-Email-Claim-15" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-15"><a href="#2-注册配置-15" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-15"><a href="#2-1-启用开放注册-15" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-15"><a href="#2-1-禁用开放注册-15" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><h2 id="使用-Docker-部署-Wiki-js-16"><a href="#使用-Docker-部署-Wiki-js-16" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-17"><a href="#安装-Docker-端-17" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-17"><a href="#获取镜像-17" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-17"><a href="#初始配置-17" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-17"><a href="#开始使用-17" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-17"><a href="#1-效果展示-17" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-17"><a href="#2-版本比对-17" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-17"><a href="#3-修改语言-17" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-17"><a href="#4-全文检索-17" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-17"><a href="#5-修饰站点-17" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-17"><a href="#6-权限控制-17" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-16"><a href="#定制和扩展-16" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-16"><a href="#主題-16" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-16"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-16" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-16"><a href="#1-授权配置-16" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-16"><a href="#1-1-Client-ID-16" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-16"><a href="#1-2-Client-Secret-16" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-16"><a href="#1-3-Authorization-Endpoint-URL-16" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-16"><a href="#1-4-Token-Endpoint-URL-16" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-16"><a href="#1-5-User-Info-Endpoint-URL-16" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-16"><a href="#1-6-ID-Claim-16" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-16"><a href="#1-7-Display-Name-Claim-16" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-16"><a href="#1-8-Email-Claim-16" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-16"><a href="#2-注册配置-16" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-16"><a href="#2-1-启用开放注册-16" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-16"><a href="#2-1-禁用开放注册-16" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><h2 id="使用-Docker-部署-Wiki-js-17"><a href="#使用-Docker-部署-Wiki-js-17" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-18"><a href="#安装-Docker-端-18" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-18"><a href="#获取镜像-18" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-18"><a href="#初始配置-18" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-18"><a href="#开始使用-18" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-18"><a href="#1-效果展示-18" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-18"><a href="#2-版本比对-18" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-18"><a href="#3-修改语言-18" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-18"><a href="#4-全文检索-18" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-18"><a href="#5-修饰站点-18" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-18"><a href="#6-权限控制-18" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-17"><a href="#定制和扩展-17" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-17"><a href="#主題-17" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-17"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-17" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-17"><a href="#1-授权配置-17" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-17"><a href="#1-1-Client-ID-17" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-17"><a href="#1-2-Client-Secret-17" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-17"><a href="#1-3-Authorization-Endpoint-URL-17" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-17"><a href="#1-4-Token-Endpoint-URL-17" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-17"><a href="#1-5-User-Info-Endpoint-URL-17" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-17"><a href="#1-6-ID-Claim-17" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-17"><a href="#1-7-Display-Name-Claim-17" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-17"><a href="#1-8-Email-Claim-17" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-17"><a href="#2-注册配置-17" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-17"><a href="#2-1-启用开放注册-17" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-17"><a href="#2-1-禁用开放注册-17" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><h2 id="定制和扩展-18"><a href="#定制和扩展-18" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-18"><a href="#主題-18" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-18"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-18" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-18"><a href="#1-授权配置-18" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-18"><a href="#1-1-Client-ID-18" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-18"><a href="#1-2-Client-Secret-18" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-18"><a href="#1-3-Authorization-Endpoint-URL-18" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-18"><a href="#1-4-Token-Endpoint-URL-18" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-18"><a href="#1-5-User-Info-Endpoint-URL-18" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code></p><h2 id="使用-Docker-部署-Wiki-js-18"><a href="#使用-Docker-部署-Wiki-js-18" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2></blockquote><blockquote><p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker 容器技术可帮助我们简化部署过程，提高应用程序的可移植性和可扩展性。</p></blockquote><h3 id="安装-Docker-端-19"><a href="#安装-Docker-端-19" class="headerlink" title="安装 Docker 端"></a>安装 Docker 端</h3><p>开始部署之前，我们需要确保已经安装了 Docker。Docker 是一个开源应用容器引擎，可以轻松地为任何应用程序创建一个轻量级的、可移植的、自给自足容器。要安装 Docker，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure><p>其他安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置Docker的镜像仓库</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装Docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机自启</span><br><span class="line">systemctl enalbe docker</span><br></pre></td></tr></table></figure><p>可以运行一个hello-world镜像来验证Docker是否正确安装，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>这个命令会下载一个测试镜像并运行，在命令行里输出hello world信息后自动退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装Docker Compose</span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 查看docker compose版本，测试安装是否成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="获取镜像-19"><a href="#获取镜像-19" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在 Docker 中镜像是一个只读模板，可创建 Docker 容器。Wiki.js 官方提供了预构建 Docker 镜像，我们可直接从 Docker Hub 中拉取。</p><p>为了简化部署过程，我们先创建 <code>docker-compose.yml</code> 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:15-alpine</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB: wiki</span><br><span class="line">      POSTGRES_PASSWORD: wikijsrocks</span><br><span class="line">      POSTGRES_USER: wikijs</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;none&quot;</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">  wiki:</span><br><span class="line">    image: linuxserver/wikijs</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment:</span><br><span class="line">      DB_TYPE: postgres</span><br><span class="line">      DB_HOST: db</span><br><span class="line">      DB_PORT: 5432</span><br><span class="line">      DB_USER: wikijs</span><br><span class="line">      DB_PASS: wikijsrocks</span><br><span class="line">      DB_NAME: wiki</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:3000&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p>编辑好上面内容后，执行下面的命令即可部署 Wiki.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="初始配置-19"><a href="#初始配置-19" class="headerlink" title="初始配置"></a>初始配置</h3><p>通过浏览器打开 Wiki.js 所在的服务器，进行初始配置。需要依次输入管理员的邮箱、密码，访问地址，设置是否匿名反馈使用情况：<br><img src="https://cdn.dusays.com/2023/12/656-1.jpg" alt="img"></p><p>管理员用户创建完成后，会自动跳转到登录页面，输入刚刚创建好的管理员账号后，可以看到如下页面，这时我们先点击 ADMINISTRATION 进入后台：</p><p><a href="https://cdn.dusays.com/2023/12/656-2.jpg"><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-2.jpg" alt="img"></a></p><p>在后台面板中，我们首先汉化一下全站界面。点击左侧的 Locale，进入语言包设置页：</p><p><img src="https://cdn.dusays.com/2023/12/656-3.jpg" alt="img"></p><p>在右侧下载语言包，这里我们以 Chinese Simplified 为例，下载后在中间的 Site Localo 处选择 Chinese Simplified，最后点击右上角 APPLY 即可：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-4.jpg" alt="img"></p><p>切换至首页后，即可创建主页内容。这里可以选择使用何种编辑器来创建，这里我们以 Markdown 为例：</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/656-5.jpg" alt="img"></p><p>写在最后</p><p>通过 <code>docker-compose.yml</code> 可以看出来，服务已经做了 <code>80</code> 端口的映射，如果服务器中有其它的网站环境，建议修改 <code>docker-compose.yml</code> 中种 <code>80</code> 为其它端口。</p><p>另外如无 Nginx 等引擎，但需要 SSL 加密访问，推荐安装 Nginx Proxy Manager 来进行加密反代。</p><p>强烈建议先配置好访问环境「即配置好 Nginx Proxy Manager 后」再做 Wiki.js 初始化操作。</p><p><a href="https://dusays.com/656/">https://dusays.com/656/</a></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085158792-661022329.png" alt="img"></p><h2 id="开始使用-19"><a href="#开始使用-19" class="headerlink" title="开始使用"></a>开始使用</h2><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085226468-943909471.png" alt="img"></p><h3 id="1-效果展示-19"><a href="#1-效果展示-19" class="headerlink" title="1 效果展示"></a><strong>1 效果展示</strong></h3><p>　　Wiki.js 默认的前台页面布局和功能如下图所示，用户可根据自己需要来调整、启用或关闭。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085250986-296282782.png" alt="img"></p><p>　　后台管理页面功能如下图所示。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085330649-370392906.png" alt="img"></p><h3 id="2-版本比对-19"><a href="#2-版本比对-19" class="headerlink" title="2 版本比对"></a><strong>2 版本比对</strong></h3><p>　　Wiki.js 支持一个简单的版本比对工具。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085313066-1529105748.png" alt="img"></p><h3 id="3-修改语言-19"><a href="#3-修改语言-19" class="headerlink" title="3 修改语言"></a><strong>3 修改语言</strong></h3><p>　　Wiki.js 默认为英文，可下载对应语言包，切换语言设置。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085353539-1674712978.png" alt="img"></p><h3 id="4-全文检索-19"><a href="#4-全文检索-19" class="headerlink" title="4 全文检索"></a><strong>4 全文检索</strong></h3><p>　　本例我使用的是 PostgreSql 的搜索引擎，因为搭建起来比较方便。</p><p>　　在搜索引擎菜单中，选中“Database-PostgreSQL”，并在引擎配置中，选择我们在数据库中的配置名称。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085434425-269210813.png" alt="img"></p><p>　　配置好后，我们就可以验证中文搜索了。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906090717031-1656380835.png" alt="img"></p><h3 id="5-修饰站点-19"><a href="#5-修饰站点-19" class="headerlink" title="**5 修饰站点 **"></a>**5 修饰站点 **</h3><p>　　在“常规”菜单中，我们可以配置 Wiki 的基本信息，比如公司名称、Logo 等。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085535398-926066763.png" alt="img"></p><h3 id="6-权限控制-19"><a href="#6-权限控制-19" class="headerlink" title="6 权限控制"></a><strong>6 权限控制</strong></h3><p>　　Wiki.js 支持多种身份验证方式，可以按需要选择。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085558313-698544516.png" alt="img"></p><p>　　可以通过建立组来统一管理用户。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085615709-201045966.png" alt="img"></p><p>　　 基于 Permissions 和 Page Rules 灵活定义组权限。</p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085631811-1180650891.png" alt="img"></p><p><img src="https://img2023.cnblogs.com/blog/270073/202309/270073-20230906085639109-704909312.png" alt="img"></p><h2 id="定制和扩展-19"><a href="#定制和扩展-19" class="headerlink" title="定制和扩展"></a>定制和扩展</h2><p>　　在创建页面时，可以通过编写脚本和样式来定制和扩展页面功能。</p><p>　　Wiki.js 附带了一个默认主题，它支持明暗模式，对大多数用户来说应该足够了，用户也可以自行定制主题。</p><p>　　Wiki.js 是完全模块化的，所有模块都位于 server&#x2F;modules 下，允许任何开发人员编写自己的模块。</p><p>　　Wiki.js 公开了一个 GraphQL API，您可以从中访问和修改 Wiki 的所有资源。</p><h3 id="主題-19"><a href="#主題-19" class="headerlink" title="主題"></a>主題</h3><h2 id="Wiki-js-通过-Generic-OAuth2-进行身份验证-19"><a href="#Wiki-js-通过-Generic-OAuth2-进行身份验证-19" class="headerlink" title="Wiki.js 通过 Generic OAuth2 进行身份验证"></a>Wiki.js 通过 Generic OAuth2 进行身份验证</h2><p><a href="https://www.cnblogs.com/JiuLing-zhang/p/16899492.html">少走点弯路：Wiki.js 通过 Generic OAuth2 进行身份验证</a></p><p>基本的配置包含2个部分，分别是<strong>授权配置</strong>、<strong>注册配置</strong>。</p><h2 id="1-授权配置-19"><a href="#1-授权配置-19" class="headerlink" title="1. 授权配置"></a>1. 授权配置</h2><h3 id="1-1-Client-ID-19"><a href="#1-1-Client-ID-19" class="headerlink" title="1.1 Client ID"></a>1.1 Client ID</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-2-Client-Secret-19"><a href="#1-2-Client-Secret-19" class="headerlink" title="1.2 Client Secret"></a>1.2 Client Secret</h3><p>获取 <code>Token</code> 时会作为参数传递给接口。</p><h3 id="1-3-Authorization-Endpoint-URL-19"><a href="#1-3-Authorization-Endpoint-URL-19" class="headerlink" title="1.3 Authorization Endpoint URL"></a>1.3 Authorization Endpoint URL</h3><p>授权页面的地址。<br>当进入 <code>Wiki</code> 的登录页后，选择 <code>Generic OAuth2</code> 授权登录时跳转的地址。<br>如果同意授权，则需要跳转到 <code>Wiki</code> 指定的回调页面（跳转时可以加入自定义参数）。<br>每个项目的回调地址都不相同，最简单的办法就是在页面的最下面找到配置参考。<br><code>http://xxx:3000/login/bf4439-a770-fedee4be57df/callback?MyValue=test</code><br>如果回调地址配置的不对，可能会出现<code>Invalid authentication provider.</code>错误页。</p><h3 id="1-4-Token-Endpoint-URL-19"><a href="#1-4-Token-Endpoint-URL-19" class="headerlink" title="1.4 Token Endpoint URL"></a>1.4 Token Endpoint URL</h3><p>获取<code>Token</code>的接口地址。</p><p>在调用该地址时，<code>Wiki</code>会自动附带下面这些参数：</p><ol><li><code>grant_type=authorization_code</code></li><li><code>client_id=1.1中配置的值</code></li><li><code>client_secret=1.2中配置的值</code></li><li><code>自定义参数（1.3中配置的值）</code></li></ol><p>服务端验证逻辑完成后，接口必须返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Failed to obtain access token</code>。</p><h3 id="1-5-User-Info-Endpoint-URL-19"><a href="#1-5-User-Info-Endpoint-URL-19" class="headerlink" title="1.5 User Info Endpoint URL"></a>1.5 User Info Endpoint URL</h3><p>成功拿到<code>Token</code>后，获取用户信息的接口地址。</p><blockquote><p>可以设置 <code>Wiki</code> 获取用户信息时 <code>Token</code> 的传递方式：<code>Query string</code> 或 <code>Authorization header</code><br><img src="https://s2.loli.net/2022/11/17/qRtYNFA4ODhfeLU.png" alt="SetToken.png"></p></blockquote><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-18"><a href="#1-6-ID-Claim-18" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-18"><a href="#1-7-Display-Name-Claim-18" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-18"><a href="#1-8-Email-Claim-18" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-18"><a href="#2-注册配置-18" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-18"><a href="#2-1-启用开放注册-18" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-18"><a href="#2-1-禁用开放注册-18" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p><p>服务器根据 <code>Token</code> 获取用户信息，最终返回包含以下字段的返回值（<strong>注意区分大小写</strong>）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span><span class="punctuation">:</span><span class="number">10086</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zs@test.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回值不合法，会出现错误页<code>Missing or invalid email address from profile.</code></p><blockquote><p><strong><code>Wiki</code> 系统中是通过 <code>Email</code> 来标识唯一用户，因此不同用户的 <code>Email</code> 不能重复。</strong></p></blockquote><h3 id="1-6-ID-Claim-19"><a href="#1-6-ID-Claim-19" class="headerlink" title="1.6 ID Claim"></a>1.6 ID Claim</h3><p>用户信息接口中返回的<code>用户 ID</code> 字段名。</p><h3 id="1-7-Display-Name-Claim-19"><a href="#1-7-Display-Name-Claim-19" class="headerlink" title="1.7 Display Name Claim"></a>1.7 Display Name Claim</h3><p>用户信息接口中返回的<code>用户名称</code>字段名。</p><h3 id="1-8-Email-Claim-19"><a href="#1-8-Email-Claim-19" class="headerlink" title="1.8 Email Claim"></a>1.8 Email Claim</h3><p>用户信息接口中返回的<code>邮箱</code>字段名，该字段值必须保证唯一。</p><h2 id="2-注册配置-19"><a href="#2-注册配置-19" class="headerlink" title="2. 注册配置"></a>2. 注册配置</h2><h3 id="2-1-启用开放注册-19"><a href="#2-1-启用开放注册-19" class="headerlink" title="2.1 启用开放注册"></a>2.1 启用开放注册</h3><p>授权登录完成后，当用户信息在 <code>Wiki</code> 中不存在时，则会新建用户信息并完成登录。</p><h3 id="2-1-禁用开放注册-19"><a href="#2-1-禁用开放注册-19" class="headerlink" title="2.1 禁用开放注册"></a>2.1 禁用开放注册</h3><p>授权用户的 <code>Email</code> 必须已经在 <code>Wiki</code> 中注册，否则无法登录，出现错误页<code>You are not authorized to login.</code></p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/blog-Wiki-js/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/blog-Wiki-js/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h2 id="使用-Docker-部署-Wiki-js"><a href="#使用-Docker-部署-Wiki-js" class="headerlink" title="使用 Docker 部署 Wiki.js"></a>使用 Docker 部署 Wiki.js</h2><blockquote>
<p>本文将介绍如何用 Docker 容器技术部署 Wiki.js 应用程序。Wiki.js 是一个高度可定制 Wiki 平台，用 Node.js 编写，支持 Markdown 以及 HTML 文档。Docker]]>
    </summary>
    <title>Wiki.js</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/89020647">OAuth2.0 详解 - 知乎 (zhihu.com)</a></p><p><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p><a href="https://aaronparecki.com/oauth-2-simplified/#roles">OAuth 2 简化版 • Aaron Parecki</a></p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><h3 id="第三方应用程序：“客户端”"><a href="#第三方应用程序：“客户端”" class="headerlink" title="第三方应用程序：“客户端”"></a>第三方应用程序：“客户端”</h3><p>客户端是尝试访问用户帐户的应用程序。它需要先获得用户的许可，然后才能执行此操作。</p><h3 id="API：“资源服务器”"><a href="#API：“资源服务器”" class="headerlink" title="API：“资源服务器”"></a>API：“资源服务器”</h3><p>资源服务器是用于访问用户信息的 API 服务器。</p><h3 id="授权服务器"><a href="#授权服务器" class="headerlink" title="授权服务器"></a>授权服务器</h3><p>这是提供用户批准或拒绝请求的接口的服务器。在较小的实现中，这可能与 API 服务器是同一台服务器，但更大规模的部署通常会将其构建为单独的组件。</p><h3 id="用户：“资源所有者”"><a href="#用户：“资源所有者”" class="headerlink" title="用户：“资源所有者”"></a>用户：“资源所有者”</h3><p>资源所有者是授予访问其帐户某些部分的权限的人员。</p><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>OAuth 2 的第一步是从用户那里获得授权。对于基于浏览器或移动的应用程序，这通常是通过向用户显示服务提供的界面来实现的。</p><p>OAuth 2 为不同的用例提供了几种“授权类型”。定义的授权类型包括：</p><ul><li>在 Web 服务器、基于浏览器的应用程序和移动应用程序上运行的应用程序的<strong>授权代码</strong></li><li>使用用户名和密码登录的<strong>密码</strong>（仅适用于第一方应用）</li><li>在没有用户在场的情况下进行应用程序访问<strong>的客户端凭据</strong></li><li><strong>隐式</strong>以前被推荐给没有秘密的客户端，但已被使用授权代码授予与PKCE取代。</li></ul><p>下面将详细介绍每个用例。</p><h2 id="Web-服务器应用程序"><a href="#Web-服务器应用程序" class="headerlink" title="Web 服务器应用程序"></a>Web 服务器应用程序</h2><p>Web 服务器应用程序是您在处理 OAuth 服务器时遇到的最常见的应用程序类型。Web 应用程序是用服务器端语言编写的，并在应用程序源代码不向公众开放的服务器上运行。这意味着应用程序在与授权服务器通信时能够使用其客户端密钥，这有助于避免许多攻击媒介。</p><h3 id="授权-1"><a href="#授权-1" class="headerlink" title="授权"></a>授权</h3><p>创建一个“登录”链接，将用户发送到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://authorization-server.com/auth?response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;redirect_uri=REDIRECT_URI&amp;scope=photos&amp;state=1234zyx</span><br></pre></td></tr></table></figure><ul><li><strong>response_type&#x3D;code</strong> - 指示您的服务器希望收到授权代码</li><li><strong>client_id</strong> - 首次创建应用程序时收到的客户端 ID</li><li><strong>redirect_uri</strong> - 指示授权完成后要将用户返回到的 URI</li><li><strong>scope</strong> - 一个或多个范围值，指示您希望访问用户帐户的哪些部分</li><li><strong>state</strong> - 应用程序生成的随机字符串，稍后将对其进行验证</li></ul>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/blog-OAuth2/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/blog-OAuth2/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/89020647">OAuth2.0 详解 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
<p><a href="https://aaronparecki.com/oauth-2-simplified/#roles">OAuth 2 简化版 • Aaron]]>
    </summary>
    <title>OAuth2</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h1 id="如何在-2-分钟内重置忘记的-Ubuntu-密码"><a href="#如何在-2-分钟内重置忘记的-Ubuntu-密码" class="headerlink" title="如何在 2 分钟内重置忘记的 Ubuntu 密码"></a>如何在 2 分钟内重置忘记的 Ubuntu 密码</h1><hr><p><strong>如果您忘记了 Ubuntu 上的用户密码，请不要担心。您可以非常轻松地重置 Ubuntu 密码。本指南介绍了在 Ubuntu 上更改 root 密码的简单方法。该方法应该也适用于其他Linux发行版。</strong></p><p>忘记了 Ubuntu 登录密码？它发生了。</p><p>如果您已经有一段时间没有使用 Ubuntu，那么很自然地不记得密码。好消息是您不需要因此而重新安装整个操作系统。您可以轻松恢复 Ubuntu 密码。</p><p>这里提到的方法适用于在 VMware、双启动或单安装中重置 Ubuntu 密码。您所需要的只是一点耐心并运行几个命令。您将在几分钟内重置 root 密码。</p><p>**在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 上使用 Linux？**对于 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 来说有点不同。您可以按照此处在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 中重置 Linux 密码的步骤进行操作。</p><h2 id="从恢复模式重置-Ubuntu-密码"><a href="#从恢复模式重置-Ubuntu-密码" class="headerlink" title="从恢复模式重置 Ubuntu 密码"></a>从恢复模式重置 Ubuntu 密码</h2><p>如果您更喜欢观看视频而不是阅读文字，我还制作了本教程的视频。不要忘记订阅我们的 YouTube 频道以获取更多 Linux 教程视频。</p><h3 id="第-1-步：启动进入恢复模式"><a href="#第-1-步：启动进入恢复模式" class="headerlink" title="第 1 步：启动进入恢复模式"></a>第 1 步：启动进入恢复模式</h3><p>打开计算机。转到<strong>grub 菜单</strong>。一般来说，它会自动出现 - 如果没有，则<strong>按住 Shift 键</strong>或<strong>按 Esc 键</strong>直到出现启动菜单。</p><p>如果您使用的是 Oracle VirtualBox 或 VMware，当 Oracle 或 VMware 徽标出现时，您必须<strong>按住 Shift 键</strong>。</p><p>在 grub 菜单中，选择“Ubuntu 的高级选项”：</p><h1 id="如何在-2-分钟内重置忘记的-Ubuntu-密码-1"><a href="#如何在-2-分钟内重置忘记的-Ubuntu-密码-1" class="headerlink" title="如何在 2 分钟内重置忘记的 Ubuntu 密码"></a>如何在 2 分钟内重置忘记的 Ubuntu 密码</h1><hr><p><strong>如果您忘记了 Ubuntu 上的用户密码，请不要担心。您可以非常轻松地重置 Ubuntu 密码。本指南介绍了在 Ubuntu 上更改 root 密码的简单方法。该方法应该也适用于其他Linux发行版。</strong></p><p>忘记了 Ubuntu 登录密码？它发生了。</p><p>如果您已经有一段时间没有使用 Ubuntu，那么很自然地不记得密码。好消息是您不需要因此而重新安装整个操作系统。您可以轻松恢复 Ubuntu 密码。</p><p>这里提到的方法适用于在 VMware、双启动或单安装中重置 Ubuntu 密码。您所需要的只是一点耐心并运行几个命令。您将在几分钟内重置 root 密码。</p><p>**在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 上使用 Linux？**对于 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 来说有点不同。您可以按照此处在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 中重置 Linux 密码的步骤进行操作。</p><h2 id="从恢复模式重置-Ubuntu-密码-1"><a href="#从恢复模式重置-Ubuntu-密码-1" class="headerlink" title="从恢复模式重置 Ubuntu 密码"></a>从恢复模式重置 Ubuntu 密码</h2><p>如果您更喜欢观看视频而不是阅读文字，我还制作了本教程的视频。不要忘记订阅我们的 YouTube 频道以获取更多 Linux 教程视频。</p><h3 id="第-1-步：启动进入恢复模式-1"><a href="#第-1-步：启动进入恢复模式-1" class="headerlink" title="第 1 步：启动进入恢复模式"></a>第 1 步：启动进入恢复模式</h3><p>打开计算机。转到<strong>grub 菜单</strong>。一般来说，它会自动出现 - 如果没有，则<strong>按住 Shift 键</strong>或<strong>按 Esc 键</strong>直到出现启动菜单。</p><p>如果您使用的是 Oracle VirtualBox 或 VMware，当 Oracle 或 VMware 徽标出现时，您必须<strong>按住 Shift 键</strong>。</p><p>在 grub 菜单中，选择“Ubuntu 的高级选项”：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/new-grub-menu-ubuntu.png" alt="img"></p><p>在这里，您将看到进入恢复模式的选项：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/boot-into-recovery-mode-ubuntu.jpg" alt="img"></p><p>它将带您进入黑屏，并快速显示几行输出。在这里等待几秒钟。</p><h3 id="第-2-步：转到-root-shell-提示符"><a href="#第-2-步：转到-root-shell-提示符" class="headerlink" title="第 2 步：转到 root shell 提示符"></a>第 2 步：转到 root shell 提示符</h3><p>现在您将看到不同的恢复模式选项。这里您需要选择“<strong>Root – Drop to root shell提示</strong>”。只需按 Enter 键即可选择此选项。就像下图这样：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/drop-to-root-prompt-1.png" alt="img"></p><p>您会看到，当您选择 root shell 提示选项时，底部会出现一个输入命令的选项。这是您的 root shell 提示符，您将在此处使用命令来重置密码。</p><h3 id="步骤-3：重新挂载具有写权限的-root"><a href="#步骤-3：重新挂载具有写权限的-root" class="headerlink" title="步骤 3：重新挂载具有写权限的 root"></a>步骤 3：重新挂载具有写权限的 root</h3><p>您需要具有根分区的写入权限。默认情况下，它具有只读访问权限。</p><p>使用以下命令以写访问权限重新安装它：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><h3 id="第-4-步：重置用户名或密码"><a href="#第-4-步：重置用户名或密码" class="headerlink" title="第 4 步：重置用户名或密码"></a>第 4 步：重置用户名或密码</h3><p>在这里，您将获得 root 访问权限。使用以下命令列出所有可用的用户：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home</span><br></pre></td></tr></table></figure><p>根据此命令，选择您要重置或（例如）破解密码的“<strong>用户名</strong>”。现在，使用以下命令重置所选“<strong>用户名</strong>”的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>它提示输入新密码。输入新密码两次。</p><blockquote><p>*<strong>请注意，当您开始输入密码时，屏幕上不会显示任何内容。这是完全正常的*</strong>，实际上是 Linux 系统中的一个安全功能。只需盲目输入密码并按 Enter 键即可。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="keyword">new</span> UNIX password:</span><br><span class="line">Retype <span class="keyword">new</span> UNIX password:</span><br></pre></td></tr></table></figure><p>瞧！就这样吧。您刚刚成功重置了密码。现在退出 root shell 提示符：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>退出后，您将返回恢复模式菜单。此处选择正常启动选项。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/recovery-mode-menu-ubuntu.png" alt="img"></p><p>将会出现有关图形模式兼容性的警告。不用担心。完全重新启动将解决与此相关的任何问题。</p><p>您现在应该可以使用新密码登录。</p><h3 id="可能的故障排除："><a href="#可能的故障排除：" class="headerlink" title="可能的故障排除："></a>可能的故障排除：</h3><p>输入新密码时，系统可能会提示您<strong>身份验证令牌操作错误</strong>，如下所示：</p><p>passwd 用户名 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：身份验证令牌操作错误 passwd：密码未更改</p><p>出现此错误的原因是文件系统仅以读访问权限挂载。按以下方式更改访问权限并重新挂载文件系统：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><p>现在再次尝试重置密码。现在应该可以了。</p><p>正如您所看到的，即使您忘记了 Ubuntu 密码，更改它也非常容易。几乎不需要几分钟。</p><h2 id="重置-Ubuntu-密码的替代方法"><a href="#重置-Ubuntu-密码的替代方法" class="headerlink" title="重置 Ubuntu 密码的替代方法"></a>重置 Ubuntu 密码的替代方法</h2><p>如果由于某种原因您难以进入 root shell 并更改密码，您可以尝试这些步骤。</p><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>重新启动计算机。按住 Shift 键调出 grub 屏幕（如果它没有自动出现）。在 grub 提示符处<strong>按 E</strong> 编辑 grub 屏幕。</p><h3 id="第2步"><a href="#第2步" class="headerlink" title="第2步"></a>第2步</h3><p>找到以 linux 开头的行，将 ro 更改为 rw 并在该行末尾附加 init&#x3D;&#x2F;bin&#x2F;bash 。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/editing-grub-to-fix-nvidia-issue.jpg" alt="img"></p><h3 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h3><p>按 ctrl-x 保存更改并启动。</p><p>现在，您将使用读写权限启动 Linux 内核，并且不再进入图形用户界面，而是使用 bash shell。</p><p>换句话说，您的系统将启动到无密码 root shell。</p><h3 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h3><p>使用您的用户名输入 passwd 命令。如果您不知道用户名，请使用 <em>ls &#x2F;home</em> 命令进行检查（如方法 1 中所述）。</p><p>设置您的新密码。</p><p>设置新密码后，退出终端。只需在终端中输入 <strong>reboot</strong> 或使用 shutdown 命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><p>您的密码现在应该更改。</p><h2 id="如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？"><a href="#如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？" class="headerlink" title="如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？"></a>如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？</h2><p>这是一个公平的问题。 Linux 相对于 Windows 的主要优势之一是其安全性。但如果“任何人”都可以重置密码，为什么 Ubuntu 或其他 Linux 发行版可以被认为是安全的呢？</p><p>让我在这里解释一些事情。主要的安全风险是有人通过互联网从远程位置侵入您的帐户。这并没有发生在这里。</p><p>如果任何人能够物理访问您的计算机，那么您计算机中的数据就已经面临风险。除非整个磁盘都经过加密，否则任何人都可以使用实时 USB“窃取”您的数据，甚至无需进入您安装的操作系统。</p><p>默认情况下，Ubuntu 没有 root 密码，并且 root 帐户被锁定。您在安装 Ubuntu 时设置的用户帐户包含为具有 sudo 权限的管理员。但这并不意味着你就是root。</p><p>缺少root密码是一个故意的功能启动菜单中的“Ubuntu高级选项”允许您从“root shell提示符”执行一些特定的与root相关的任务。这就是为什么您可以通过此方法重置 Ubuntu 密码。</p><p>如果你想让你的系统更安全，你可以加密磁盘（以保存你的数据）或在 Ubuntu 中为 root 用户设置密码。</p><h2 id="额外提示：处理更改密码后可能出现的密钥环问题"><a href="#额外提示：处理更改密码后可能出现的密钥环问题" class="headerlink" title="额外提示：处理更改密码后可能出现的密钥环问题"></a>额外提示：处理更改密码后可能出现的密钥环问题</h2><p>Ubuntu 中有一个密钥环功能，用于保持密码锁定和安全。</p><p>当您重置忘记的密码时，密钥环保持解锁状态，您可能会看到类似这样的错误消息。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/enter-password-to-unlock-your-login-keyring-ubuntu.jpg" alt="img"></p><p>打开“密码和密钥”应用程序，然后在此处删除登录密码。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/delete-keyring-ubuntu.jpg" alt="img"></p><p>当您尝试在 Ubuntu 中再次使用 Google Chrome 时，它会要求您创建一个新的密钥环。使用新的登录密码作为密钥环密码。</p><p>我希望我已经清楚地说明了如何在 Ubuntu 中重置忘记的密码。</p><p><a href="https://cn.linux-console.net/?p=19579">如何在 2 分钟内重置忘记的 Ubuntu 密码 (linux-console.net)</a></p><p>在这里，您将看到进入恢复模式的选项：</p><h1 id="如何在-2-分钟内重置忘记的-Ubuntu-密码-2"><a href="#如何在-2-分钟内重置忘记的-Ubuntu-密码-2" class="headerlink" title="如何在 2 分钟内重置忘记的 Ubuntu 密码"></a>如何在 2 分钟内重置忘记的 Ubuntu 密码</h1><hr><p><strong>如果您忘记了 Ubuntu 上的用户密码，请不要担心。您可以非常轻松地重置 Ubuntu 密码。本指南介绍了在 Ubuntu 上更改 root 密码的简单方法。该方法应该也适用于其他Linux发行版。</strong></p><p>忘记了 Ubuntu 登录密码？它发生了。</p><p>如果您已经有一段时间没有使用 Ubuntu，那么很自然地不记得密码。好消息是您不需要因此而重新安装整个操作系统。您可以轻松恢复 Ubuntu 密码。</p><p>这里提到的方法适用于在 VMware、双启动或单安装中重置 Ubuntu 密码。您所需要的只是一点耐心并运行几个命令。您将在几分钟内重置 root 密码。</p><p>**在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 上使用 Linux？**对于 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 来说有点不同。您可以按照此处在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 中重置 Linux 密码的步骤进行操作。</p><h2 id="从恢复模式重置-Ubuntu-密码-2"><a href="#从恢复模式重置-Ubuntu-密码-2" class="headerlink" title="从恢复模式重置 Ubuntu 密码"></a>从恢复模式重置 Ubuntu 密码</h2><p>如果您更喜欢观看视频而不是阅读文字，我还制作了本教程的视频。不要忘记订阅我们的 YouTube 频道以获取更多 Linux 教程视频。</p><h3 id="第-1-步：启动进入恢复模式-2"><a href="#第-1-步：启动进入恢复模式-2" class="headerlink" title="第 1 步：启动进入恢复模式"></a>第 1 步：启动进入恢复模式</h3><p>打开计算机。转到<strong>grub 菜单</strong>。一般来说，它会自动出现 - 如果没有，则<strong>按住 Shift 键</strong>或<strong>按 Esc 键</strong>直到出现启动菜单。</p><p>如果您使用的是 Oracle VirtualBox 或 VMware，当 Oracle 或 VMware 徽标出现时，您必须<strong>按住 Shift 键</strong>。</p><p>在 grub 菜单中，选择“Ubuntu 的高级选项”：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/new-grub-menu-ubuntu.png" alt="img"></p><p>在这里，您将看到进入恢复模式的选项：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/boot-into-recovery-mode-ubuntu.jpg" alt="img"></p><p>它将带您进入黑屏，并快速显示几行输出。在这里等待几秒钟。</p><h3 id="第-2-步：转到-root-shell-提示符-1"><a href="#第-2-步：转到-root-shell-提示符-1" class="headerlink" title="第 2 步：转到 root shell 提示符"></a>第 2 步：转到 root shell 提示符</h3><p>现在您将看到不同的恢复模式选项。这里您需要选择“<strong>Root – Drop to root shell提示</strong>”。只需按 Enter 键即可选择此选项。就像下图这样：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/drop-to-root-prompt-1.png" alt="img"></p><p>您会看到，当您选择 root shell 提示选项时，底部会出现一个输入命令的选项。这是您的 root shell 提示符，您将在此处使用命令来重置密码。</p><h3 id="步骤-3：重新挂载具有写权限的-root-1"><a href="#步骤-3：重新挂载具有写权限的-root-1" class="headerlink" title="步骤 3：重新挂载具有写权限的 root"></a>步骤 3：重新挂载具有写权限的 root</h3><p>您需要具有根分区的写入权限。默认情况下，它具有只读访问权限。</p><p>使用以下命令以写访问权限重新安装它：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><h3 id="第-4-步：重置用户名或密码-1"><a href="#第-4-步：重置用户名或密码-1" class="headerlink" title="第 4 步：重置用户名或密码"></a>第 4 步：重置用户名或密码</h3><p>在这里，您将获得 root 访问权限。使用以下命令列出所有可用的用户：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home</span><br></pre></td></tr></table></figure><p>根据此命令，选择您要重置或（例如）破解密码的“<strong>用户名</strong>”。现在，使用以下命令重置所选“<strong>用户名</strong>”的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>它提示输入新密码。输入新密码两次。</p><blockquote><p>*<strong>请注意，当您开始输入密码时，屏幕上不会显示任何内容。这是完全正常的*</strong>，实际上是 Linux 系统中的一个安全功能。只需盲目输入密码并按 Enter 键即可。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="keyword">new</span> UNIX password:</span><br><span class="line">Retype <span class="keyword">new</span> UNIX password:</span><br></pre></td></tr></table></figure><p>瞧！就这样吧。您刚刚成功重置了密码。现在退出 root shell 提示符：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>退出后，您将返回恢复模式菜单。此处选择正常启动选项。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/recovery-mode-menu-ubuntu.png" alt="img"></p><p>将会出现有关图形模式兼容性的警告。不用担心。完全重新启动将解决与此相关的任何问题。</p><p>您现在应该可以使用新密码登录。</p><h3 id="可能的故障排除：-1"><a href="#可能的故障排除：-1" class="headerlink" title="可能的故障排除："></a>可能的故障排除：</h3><p>输入新密码时，系统可能会提示您<strong>身份验证令牌操作错误</strong>，如下所示：</p><p>passwd 用户名 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：身份验证令牌操作错误 passwd：密码未更改</p><p>出现此错误的原因是文件系统仅以读访问权限挂载。按以下方式更改访问权限并重新挂载文件系统：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><p>现在再次尝试重置密码。现在应该可以了。</p><p>正如您所看到的，即使您忘记了 Ubuntu 密码，更改它也非常容易。几乎不需要几分钟。</p><h2 id="重置-Ubuntu-密码的替代方法-1"><a href="#重置-Ubuntu-密码的替代方法-1" class="headerlink" title="重置 Ubuntu 密码的替代方法"></a>重置 Ubuntu 密码的替代方法</h2><p>如果由于某种原因您难以进入 root shell 并更改密码，您可以尝试这些步骤。</p><h3 id="步骤1-1"><a href="#步骤1-1" class="headerlink" title="步骤1"></a>步骤1</h3><p>重新启动计算机。按住 Shift 键调出 grub 屏幕（如果它没有自动出现）。在 grub 提示符处<strong>按 E</strong> 编辑 grub 屏幕。</p><h3 id="第2步-1"><a href="#第2步-1" class="headerlink" title="第2步"></a>第2步</h3><p>找到以 linux 开头的行，将 ro 更改为 rw 并在该行末尾附加 init&#x3D;&#x2F;bin&#x2F;bash 。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/editing-grub-to-fix-nvidia-issue.jpg" alt="img"></p><h3 id="步骤3-1"><a href="#步骤3-1" class="headerlink" title="步骤3"></a>步骤3</h3><p>按 ctrl-x 保存更改并启动。</p><p>现在，您将使用读写权限启动 Linux 内核，并且不再进入图形用户界面，而是使用 bash shell。</p><p>换句话说，您的系统将启动到无密码 root shell。</p><h3 id="步骤4-1"><a href="#步骤4-1" class="headerlink" title="步骤4"></a>步骤4</h3><p>使用您的用户名输入 passwd 命令。如果您不知道用户名，请使用 <em>ls &#x2F;home</em> 命令进行检查（如方法 1 中所述）。</p><p>设置您的新密码。</p><p>设置新密码后，退出终端。只需在终端中输入 <strong>reboot</strong> 或使用 shutdown 命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><p>您的密码现在应该更改。</p><h2 id="如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-1"><a href="#如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-1" class="headerlink" title="如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？"></a>如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？</h2><p>这是一个公平的问题。 Linux 相对于 Windows 的主要优势之一是其安全性。但如果“任何人”都可以重置密码，为什么 Ubuntu 或其他 Linux 发行版可以被认为是安全的呢？</p><p>让我在这里解释一些事情。主要的安全风险是有人通过互联网从远程位置侵入您的帐户。这并没有发生在这里。</p><p>如果任何人能够物理访问您的计算机，那么您计算机中的数据就已经面临风险。除非整个磁盘都经过加密，否则任何人都可以使用实时 USB“窃取”您的数据，甚至无需进入您安装的操作系统。</p><p>默认情况下，Ubuntu 没有 root 密码，并且 root 帐户被锁定。您在安装 Ubuntu 时设置的用户帐户包含为具有 sudo 权限的管理员。但这并不意味着你就是root。</p><p>缺少root密码是一个故意的功能启动菜单中的“Ubuntu高级选项”允许您从“root shell提示符”执行一些特定的与root相关的任务。这就是为什么您可以通过此方法重置 Ubuntu 密码。</p><p>如果你想让你的系统更安全，你可以加密磁盘（以保存你的数据）或在 Ubuntu 中为 root 用户设置密码。</p><h2 id="额外提示：处理更改密码后可能出现的密钥环问题-1"><a href="#额外提示：处理更改密码后可能出现的密钥环问题-1" class="headerlink" title="额外提示：处理更改密码后可能出现的密钥环问题"></a>额外提示：处理更改密码后可能出现的密钥环问题</h2><p>Ubuntu 中有一个密钥环功能，用于保持密码锁定和安全。</p><p>当您重置忘记的密码时，密钥环保持解锁状态，您可能会看到类似这样的错误消息。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/enter-password-to-unlock-your-login-keyring-ubuntu.jpg" alt="img"></p><p>打开“密码和密钥”应用程序，然后在此处删除登录密码。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/delete-keyring-ubuntu.jpg" alt="img"></p><p>当您尝试在 Ubuntu 中再次使用 Google Chrome 时，它会要求您创建一个新的密钥环。使用新的登录密码作为密钥环密码。</p><p>我希望我已经清楚地说明了如何在 Ubuntu 中重置忘记的密码。</p><p><a href="https://cn.linux-console.net/?p=19579">如何在 2 分钟内重置忘记的 Ubuntu 密码 (linux-console.net)</a></p><p>它将带您进入黑屏，并快速显示几行输出。在这里等待几秒钟。</p><h3 id="第-2-步：转到-root-shell-提示符-2"><a href="#第-2-步：转到-root-shell-提示符-2" class="headerlink" title="第 2 步：转到 root shell 提示符"></a>第 2 步：转到 root shell 提示符</h3><p>现在您将看到不同的恢复模式选项。这里您需要选择“<strong>Root – Drop to root shell提示</strong>”。只需按 Enter 键即可选择此选项。就像下图这样：</p><h1 id="如何在-2-分钟内重置忘记的-Ubuntu-密码-3"><a href="#如何在-2-分钟内重置忘记的-Ubuntu-密码-3" class="headerlink" title="如何在 2 分钟内重置忘记的 Ubuntu 密码"></a>如何在 2 分钟内重置忘记的 Ubuntu 密码</h1><hr><p><strong>如果您忘记了 Ubuntu 上的用户密码，请不要担心。您可以非常轻松地重置 Ubuntu 密码。本指南介绍了在 Ubuntu 上更改 root 密码的简单方法。该方法应该也适用于其他Linux发行版。</strong></p><p>忘记了 Ubuntu 登录密码？它发生了。</p><p>如果您已经有一段时间没有使用 Ubuntu，那么很自然地不记得密码。好消息是您不需要因此而重新安装整个操作系统。您可以轻松恢复 Ubuntu 密码。</p><p>这里提到的方法适用于在 VMware、双启动或单安装中重置 Ubuntu 密码。您所需要的只是一点耐心并运行几个命令。您将在几分钟内重置 root 密码。</p><p>**在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 上使用 Linux？**对于 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 来说有点不同。您可以按照此处在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 中重置 Linux 密码的步骤进行操作。</p><h2 id="从恢复模式重置-Ubuntu-密码-3"><a href="#从恢复模式重置-Ubuntu-密码-3" class="headerlink" title="从恢复模式重置 Ubuntu 密码"></a>从恢复模式重置 Ubuntu 密码</h2><p>如果您更喜欢观看视频而不是阅读文字，我还制作了本教程的视频。不要忘记订阅我们的 YouTube 频道以获取更多 Linux 教程视频。</p><h3 id="第-1-步：启动进入恢复模式-3"><a href="#第-1-步：启动进入恢复模式-3" class="headerlink" title="第 1 步：启动进入恢复模式"></a>第 1 步：启动进入恢复模式</h3><p>打开计算机。转到<strong>grub 菜单</strong>。一般来说，它会自动出现 - 如果没有，则<strong>按住 Shift 键</strong>或<strong>按 Esc 键</strong>直到出现启动菜单。</p><p>如果您使用的是 Oracle VirtualBox 或 VMware，当 Oracle 或 VMware 徽标出现时，您必须<strong>按住 Shift 键</strong>。</p><p>在 grub 菜单中，选择“Ubuntu 的高级选项”：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/new-grub-menu-ubuntu.png" alt="img"></p><p>在这里，您将看到进入恢复模式的选项：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/boot-into-recovery-mode-ubuntu.jpg" alt="img"></p><p>它将带您进入黑屏，并快速显示几行输出。在这里等待几秒钟。</p><h3 id="第-2-步：转到-root-shell-提示符-3"><a href="#第-2-步：转到-root-shell-提示符-3" class="headerlink" title="第 2 步：转到 root shell 提示符"></a>第 2 步：转到 root shell 提示符</h3><p>现在您将看到不同的恢复模式选项。这里您需要选择“<strong>Root – Drop to root shell提示</strong>”。只需按 Enter 键即可选择此选项。就像下图这样：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/drop-to-root-prompt-1.png" alt="img"></p><p>您会看到，当您选择 root shell 提示选项时，底部会出现一个输入命令的选项。这是您的 root shell 提示符，您将在此处使用命令来重置密码。</p><h3 id="步骤-3：重新挂载具有写权限的-root-2"><a href="#步骤-3：重新挂载具有写权限的-root-2" class="headerlink" title="步骤 3：重新挂载具有写权限的 root"></a>步骤 3：重新挂载具有写权限的 root</h3><p>您需要具有根分区的写入权限。默认情况下，它具有只读访问权限。</p><p>使用以下命令以写访问权限重新安装它：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><h3 id="第-4-步：重置用户名或密码-2"><a href="#第-4-步：重置用户名或密码-2" class="headerlink" title="第 4 步：重置用户名或密码"></a>第 4 步：重置用户名或密码</h3><p>在这里，您将获得 root 访问权限。使用以下命令列出所有可用的用户：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home</span><br></pre></td></tr></table></figure><p>根据此命令，选择您要重置或（例如）破解密码的“<strong>用户名</strong>”。现在，使用以下命令重置所选“<strong>用户名</strong>”的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>它提示输入新密码。输入新密码两次。</p><blockquote><p>*<strong>请注意，当您开始输入密码时，屏幕上不会显示任何内容。这是完全正常的*</strong>，实际上是 Linux 系统中的一个安全功能。只需盲目输入密码并按 Enter 键即可。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="keyword">new</span> UNIX password:</span><br><span class="line">Retype <span class="keyword">new</span> UNIX password:</span><br></pre></td></tr></table></figure><p>瞧！就这样吧。您刚刚成功重置了密码。现在退出 root shell 提示符：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>退出后，您将返回恢复模式菜单。此处选择正常启动选项。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/recovery-mode-menu-ubuntu.png" alt="img"></p><p>将会出现有关图形模式兼容性的警告。不用担心。完全重新启动将解决与此相关的任何问题。</p><p>您现在应该可以使用新密码登录。</p><h3 id="可能的故障排除：-2"><a href="#可能的故障排除：-2" class="headerlink" title="可能的故障排除："></a>可能的故障排除：</h3><p>输入新密码时，系统可能会提示您<strong>身份验证令牌操作错误</strong>，如下所示：</p><p>passwd 用户名 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：身份验证令牌操作错误 passwd：密码未更改</p><p>出现此错误的原因是文件系统仅以读访问权限挂载。按以下方式更改访问权限并重新挂载文件系统：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><p>现在再次尝试重置密码。现在应该可以了。</p><p>正如您所看到的，即使您忘记了 Ubuntu 密码，更改它也非常容易。几乎不需要几分钟。</p><h2 id="重置-Ubuntu-密码的替代方法-2"><a href="#重置-Ubuntu-密码的替代方法-2" class="headerlink" title="重置 Ubuntu 密码的替代方法"></a>重置 Ubuntu 密码的替代方法</h2><p>如果由于某种原因您难以进入 root shell 并更改密码，您可以尝试这些步骤。</p><h3 id="步骤1-2"><a href="#步骤1-2" class="headerlink" title="步骤1"></a>步骤1</h3><p>重新启动计算机。按住 Shift 键调出 grub 屏幕（如果它没有自动出现）。在 grub 提示符处<strong>按 E</strong> 编辑 grub 屏幕。</p><h3 id="第2步-2"><a href="#第2步-2" class="headerlink" title="第2步"></a>第2步</h3><p>找到以 linux 开头的行，将 ro 更改为 rw 并在该行末尾附加 init&#x3D;&#x2F;bin&#x2F;bash 。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/editing-grub-to-fix-nvidia-issue.jpg" alt="img"></p><h3 id="步骤3-2"><a href="#步骤3-2" class="headerlink" title="步骤3"></a>步骤3</h3><p>按 ctrl-x 保存更改并启动。</p><p>现在，您将使用读写权限启动 Linux 内核，并且不再进入图形用户界面，而是使用 bash shell。</p><p>换句话说，您的系统将启动到无密码 root shell。</p><h3 id="步骤4-2"><a href="#步骤4-2" class="headerlink" title="步骤4"></a>步骤4</h3><p>使用您的用户名输入 passwd 命令。如果您不知道用户名，请使用 <em>ls &#x2F;home</em> 命令进行检查（如方法 1 中所述）。</p><p>设置您的新密码。</p><p>设置新密码后，退出终端。只需在终端中输入 <strong>reboot</strong> 或使用 shutdown 命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><p>您的密码现在应该更改。</p><h2 id="如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-2"><a href="#如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-2" class="headerlink" title="如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？"></a>如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？</h2><p>这是一个公平的问题。 Linux 相对于 Windows 的主要优势之一是其安全性。但如果“任何人”都可以重置密码，为什么 Ubuntu 或其他 Linux 发行版可以被认为是安全的呢？</p><p>让我在这里解释一些事情。主要的安全风险是有人通过互联网从远程位置侵入您的帐户。这并没有发生在这里。</p><p>如果任何人能够物理访问您的计算机，那么您计算机中的数据就已经面临风险。除非整个磁盘都经过加密，否则任何人都可以使用实时 USB“窃取”您的数据，甚至无需进入您安装的操作系统。</p><p>默认情况下，Ubuntu 没有 root 密码，并且 root 帐户被锁定。您在安装 Ubuntu 时设置的用户帐户包含为具有 sudo 权限的管理员。但这并不意味着你就是root。</p><p>缺少root密码是一个故意的功能启动菜单中的“Ubuntu高级选项”允许您从“root shell提示符”执行一些特定的与root相关的任务。这就是为什么您可以通过此方法重置 Ubuntu 密码。</p><p>如果你想让你的系统更安全，你可以加密磁盘（以保存你的数据）或在 Ubuntu 中为 root 用户设置密码。</p><h2 id="额外提示：处理更改密码后可能出现的密钥环问题-2"><a href="#额外提示：处理更改密码后可能出现的密钥环问题-2" class="headerlink" title="额外提示：处理更改密码后可能出现的密钥环问题"></a>额外提示：处理更改密码后可能出现的密钥环问题</h2><p>Ubuntu 中有一个密钥环功能，用于保持密码锁定和安全。</p><p>当您重置忘记的密码时，密钥环保持解锁状态，您可能会看到类似这样的错误消息。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/enter-password-to-unlock-your-login-keyring-ubuntu.jpg" alt="img"></p><p>打开“密码和密钥”应用程序，然后在此处删除登录密码。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/delete-keyring-ubuntu.jpg" alt="img"></p><p>当您尝试在 Ubuntu 中再次使用 Google Chrome 时，它会要求您创建一个新的密钥环。使用新的登录密码作为密钥环密码。</p><p>我希望我已经清楚地说明了如何在 Ubuntu 中重置忘记的密码。</p><p><a href="https://cn.linux-console.net/?p=19579">如何在 2 分钟内重置忘记的 Ubuntu 密码 (linux-console.net)</a></p><p>您会看到，当您选择 root shell 提示选项时，底部会出现一个输入命令的选项。这是您的 root shell 提示符，您将在此处使用命令来重置密码。</p><h3 id="步骤-3：重新挂载具有写权限的-root-3"><a href="#步骤-3：重新挂载具有写权限的-root-3" class="headerlink" title="步骤 3：重新挂载具有写权限的 root"></a>步骤 3：重新挂载具有写权限的 root</h3><p>您需要具有根分区的写入权限。默认情况下，它具有只读访问权限。</p><p>使用以下命令以写访问权限重新安装它：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><h3 id="第-4-步：重置用户名或密码-3"><a href="#第-4-步：重置用户名或密码-3" class="headerlink" title="第 4 步：重置用户名或密码"></a>第 4 步：重置用户名或密码</h3><p>在这里，您将获得 root 访问权限。使用以下命令列出所有可用的用户：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home</span><br></pre></td></tr></table></figure><p>根据此命令，选择您要重置或（例如）破解密码的“<strong>用户名</strong>”。现在，使用以下命令重置所选“<strong>用户名</strong>”的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>它提示输入新密码。输入新密码两次。</p><blockquote><p>*<strong>请注意，当您开始输入密码时，屏幕上不会显示任何内容。这是完全正常的*</strong>，实际上是 Linux 系统中的一个安全功能。只需盲目输入密码并按 Enter 键即可。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="keyword">new</span> UNIX password:</span><br><span class="line">Retype <span class="keyword">new</span> UNIX password:</span><br></pre></td></tr></table></figure><p>瞧！就这样吧。您刚刚成功重置了密码。现在退出 root shell 提示符：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>退出后，您将返回恢复模式菜单。此处选择正常启动选项。</p><h1 id="如何在-2-分钟内重置忘记的-Ubuntu-密码-4"><a href="#如何在-2-分钟内重置忘记的-Ubuntu-密码-4" class="headerlink" title="如何在 2 分钟内重置忘记的 Ubuntu 密码"></a>如何在 2 分钟内重置忘记的 Ubuntu 密码</h1><hr><p><strong>如果您忘记了 Ubuntu 上的用户密码，请不要担心。您可以非常轻松地重置 Ubuntu 密码。本指南介绍了在 Ubuntu 上更改 root 密码的简单方法。该方法应该也适用于其他Linux发行版。</strong></p><p>忘记了 Ubuntu 登录密码？它发生了。</p><p>如果您已经有一段时间没有使用 Ubuntu，那么很自然地不记得密码。好消息是您不需要因此而重新安装整个操作系统。您可以轻松恢复 Ubuntu 密码。</p><p>这里提到的方法适用于在 VMware、双启动或单安装中重置 Ubuntu 密码。您所需要的只是一点耐心并运行几个命令。您将在几分钟内重置 root 密码。</p><p>**在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 上使用 Linux？**对于 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 来说有点不同。您可以按照此处在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 中重置 Linux 密码的步骤进行操作。</p><h2 id="从恢复模式重置-Ubuntu-密码-4"><a href="#从恢复模式重置-Ubuntu-密码-4" class="headerlink" title="从恢复模式重置 Ubuntu 密码"></a>从恢复模式重置 Ubuntu 密码</h2><p>如果您更喜欢观看视频而不是阅读文字，我还制作了本教程的视频。不要忘记订阅我们的 YouTube 频道以获取更多 Linux 教程视频。</p><h3 id="第-1-步：启动进入恢复模式-4"><a href="#第-1-步：启动进入恢复模式-4" class="headerlink" title="第 1 步：启动进入恢复模式"></a>第 1 步：启动进入恢复模式</h3><p>打开计算机。转到<strong>grub 菜单</strong>。一般来说，它会自动出现 - 如果没有，则<strong>按住 Shift 键</strong>或<strong>按 Esc 键</strong>直到出现启动菜单。</p><p>如果您使用的是 Oracle VirtualBox 或 VMware，当 Oracle 或 VMware 徽标出现时，您必须<strong>按住 Shift 键</strong>。</p><p>在 grub 菜单中，选择“Ubuntu 的高级选项”：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/new-grub-menu-ubuntu.png" alt="img"></p><p>在这里，您将看到进入恢复模式的选项：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/boot-into-recovery-mode-ubuntu.jpg" alt="img"></p><p>它将带您进入黑屏，并快速显示几行输出。在这里等待几秒钟。</p><h3 id="第-2-步：转到-root-shell-提示符-4"><a href="#第-2-步：转到-root-shell-提示符-4" class="headerlink" title="第 2 步：转到 root shell 提示符"></a>第 2 步：转到 root shell 提示符</h3><p>现在您将看到不同的恢复模式选项。这里您需要选择“<strong>Root – Drop to root shell提示</strong>”。只需按 Enter 键即可选择此选项。就像下图这样：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/drop-to-root-prompt-1.png" alt="img"></p><p>您会看到，当您选择 root shell 提示选项时，底部会出现一个输入命令的选项。这是您的 root shell 提示符，您将在此处使用命令来重置密码。</p><h3 id="步骤-3：重新挂载具有写权限的-root-4"><a href="#步骤-3：重新挂载具有写权限的-root-4" class="headerlink" title="步骤 3：重新挂载具有写权限的 root"></a>步骤 3：重新挂载具有写权限的 root</h3><p>您需要具有根分区的写入权限。默认情况下，它具有只读访问权限。</p><p>使用以下命令以写访问权限重新安装它：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><h3 id="第-4-步：重置用户名或密码-4"><a href="#第-4-步：重置用户名或密码-4" class="headerlink" title="第 4 步：重置用户名或密码"></a>第 4 步：重置用户名或密码</h3><p>在这里，您将获得 root 访问权限。使用以下命令列出所有可用的用户：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home</span><br></pre></td></tr></table></figure><p>根据此命令，选择您要重置或（例如）破解密码的“<strong>用户名</strong>”。现在，使用以下命令重置所选“<strong>用户名</strong>”的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>它提示输入新密码。输入新密码两次。</p><blockquote><p>*<strong>请注意，当您开始输入密码时，屏幕上不会显示任何内容。这是完全正常的*</strong>，实际上是 Linux 系统中的一个安全功能。只需盲目输入密码并按 Enter 键即可。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="keyword">new</span> UNIX password:</span><br><span class="line">Retype <span class="keyword">new</span> UNIX password:</span><br></pre></td></tr></table></figure><p>瞧！就这样吧。您刚刚成功重置了密码。现在退出 root shell 提示符：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>退出后，您将返回恢复模式菜单。此处选择正常启动选项。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/recovery-mode-menu-ubuntu.png" alt="img"></p><p>将会出现有关图形模式兼容性的警告。不用担心。完全重新启动将解决与此相关的任何问题。</p><p>您现在应该可以使用新密码登录。</p><h3 id="可能的故障排除：-3"><a href="#可能的故障排除：-3" class="headerlink" title="可能的故障排除："></a>可能的故障排除：</h3><p>输入新密码时，系统可能会提示您<strong>身份验证令牌操作错误</strong>，如下所示：</p><p>passwd 用户名 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：身份验证令牌操作错误 passwd：密码未更改</p><p>出现此错误的原因是文件系统仅以读访问权限挂载。按以下方式更改访问权限并重新挂载文件系统：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><p>现在再次尝试重置密码。现在应该可以了。</p><p>正如您所看到的，即使您忘记了 Ubuntu 密码，更改它也非常容易。几乎不需要几分钟。</p><h2 id="重置-Ubuntu-密码的替代方法-3"><a href="#重置-Ubuntu-密码的替代方法-3" class="headerlink" title="重置 Ubuntu 密码的替代方法"></a>重置 Ubuntu 密码的替代方法</h2><p>如果由于某种原因您难以进入 root shell 并更改密码，您可以尝试这些步骤。</p><h3 id="步骤1-3"><a href="#步骤1-3" class="headerlink" title="步骤1"></a>步骤1</h3><p>重新启动计算机。按住 Shift 键调出 grub 屏幕（如果它没有自动出现）。在 grub 提示符处<strong>按 E</strong> 编辑 grub 屏幕。</p><h3 id="第2步-3"><a href="#第2步-3" class="headerlink" title="第2步"></a>第2步</h3><p>找到以 linux 开头的行，将 ro 更改为 rw 并在该行末尾附加 init&#x3D;&#x2F;bin&#x2F;bash 。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/editing-grub-to-fix-nvidia-issue.jpg" alt="img"></p><h3 id="步骤3-3"><a href="#步骤3-3" class="headerlink" title="步骤3"></a>步骤3</h3><p>按 ctrl-x 保存更改并启动。</p><p>现在，您将使用读写权限启动 Linux 内核，并且不再进入图形用户界面，而是使用 bash shell。</p><p>换句话说，您的系统将启动到无密码 root shell。</p><h3 id="步骤4-3"><a href="#步骤4-3" class="headerlink" title="步骤4"></a>步骤4</h3><p>使用您的用户名输入 passwd 命令。如果您不知道用户名，请使用 <em>ls &#x2F;home</em> 命令进行检查（如方法 1 中所述）。</p><p>设置您的新密码。</p><p>设置新密码后，退出终端。只需在终端中输入 <strong>reboot</strong> 或使用 shutdown 命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><p>您的密码现在应该更改。</p><h2 id="如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-3"><a href="#如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-3" class="headerlink" title="如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？"></a>如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？</h2><p>这是一个公平的问题。 Linux 相对于 Windows 的主要优势之一是其安全性。但如果“任何人”都可以重置密码，为什么 Ubuntu 或其他 Linux 发行版可以被认为是安全的呢？</p><p>让我在这里解释一些事情。主要的安全风险是有人通过互联网从远程位置侵入您的帐户。这并没有发生在这里。</p><p>如果任何人能够物理访问您的计算机，那么您计算机中的数据就已经面临风险。除非整个磁盘都经过加密，否则任何人都可以使用实时 USB“窃取”您的数据，甚至无需进入您安装的操作系统。</p><p>默认情况下，Ubuntu 没有 root 密码，并且 root 帐户被锁定。您在安装 Ubuntu 时设置的用户帐户包含为具有 sudo 权限的管理员。但这并不意味着你就是root。</p><p>缺少root密码是一个故意的功能启动菜单中的“Ubuntu高级选项”允许您从“root shell提示符”执行一些特定的与root相关的任务。这就是为什么您可以通过此方法重置 Ubuntu 密码。</p><p>如果你想让你的系统更安全，你可以加密磁盘（以保存你的数据）或在 Ubuntu 中为 root 用户设置密码。</p><h2 id="额外提示：处理更改密码后可能出现的密钥环问题-3"><a href="#额外提示：处理更改密码后可能出现的密钥环问题-3" class="headerlink" title="额外提示：处理更改密码后可能出现的密钥环问题"></a>额外提示：处理更改密码后可能出现的密钥环问题</h2><p>Ubuntu 中有一个密钥环功能，用于保持密码锁定和安全。</p><p>当您重置忘记的密码时，密钥环保持解锁状态，您可能会看到类似这样的错误消息。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/enter-password-to-unlock-your-login-keyring-ubuntu.jpg" alt="img"></p><p>打开“密码和密钥”应用程序，然后在此处删除登录密码。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/delete-keyring-ubuntu.jpg" alt="img"></p><p>当您尝试在 Ubuntu 中再次使用 Google Chrome 时，它会要求您创建一个新的密钥环。使用新的登录密码作为密钥环密码。</p><p>我希望我已经清楚地说明了如何在 Ubuntu 中重置忘记的密码。</p><p><a href="https://cn.linux-console.net/?p=19579">如何在 2 分钟内重置忘记的 Ubuntu 密码 (linux-console.net)</a></p><p>将会出现有关图形模式兼容性的警告。不用担心。完全重新启动将解决与此相关的任何问题。</p><p>您现在应该可以使用新密码登录。</p><h3 id="可能的故障排除：-4"><a href="#可能的故障排除：-4" class="headerlink" title="可能的故障排除："></a>可能的故障排除：</h3><p>输入新密码时，系统可能会提示您<strong>身份验证令牌操作错误</strong>，如下所示：</p><p>passwd 用户名 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：身份验证令牌操作错误 passwd：密码未更改</p><p>出现此错误的原因是文件系统仅以读访问权限挂载。按以下方式更改访问权限并重新挂载文件系统：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><p>现在再次尝试重置密码。现在应该可以了。</p><p>正如您所看到的，即使您忘记了 Ubuntu 密码，更改它也非常容易。几乎不需要几分钟。</p><h2 id="重置-Ubuntu-密码的替代方法-4"><a href="#重置-Ubuntu-密码的替代方法-4" class="headerlink" title="重置 Ubuntu 密码的替代方法"></a>重置 Ubuntu 密码的替代方法</h2><p>如果由于某种原因您难以进入 root shell 并更改密码，您可以尝试这些步骤。</p><h3 id="步骤1-4"><a href="#步骤1-4" class="headerlink" title="步骤1"></a>步骤1</h3><p>重新启动计算机。按住 Shift 键调出 grub 屏幕（如果它没有自动出现）。在 grub 提示符处<strong>按 E</strong> 编辑 grub 屏幕。</p><h3 id="第2步-4"><a href="#第2步-4" class="headerlink" title="第2步"></a>第2步</h3><p>找到以 linux 开头的行，将 ro 更改为 rw 并在该行末尾附加 init&#x3D;&#x2F;bin&#x2F;bash 。</p><h1 id="如何在-2-分钟内重置忘记的-Ubuntu-密码-5"><a href="#如何在-2-分钟内重置忘记的-Ubuntu-密码-5" class="headerlink" title="如何在 2 分钟内重置忘记的 Ubuntu 密码"></a>如何在 2 分钟内重置忘记的 Ubuntu 密码</h1><hr><p><strong>如果您忘记了 Ubuntu 上的用户密码，请不要担心。您可以非常轻松地重置 Ubuntu 密码。本指南介绍了在 Ubuntu 上更改 root 密码的简单方法。该方法应该也适用于其他Linux发行版。</strong></p><p>忘记了 Ubuntu 登录密码？它发生了。</p><p>如果您已经有一段时间没有使用 Ubuntu，那么很自然地不记得密码。好消息是您不需要因此而重新安装整个操作系统。您可以轻松恢复 Ubuntu 密码。</p><p>这里提到的方法适用于在 VMware、双启动或单安装中重置 Ubuntu 密码。您所需要的只是一点耐心并运行几个命令。您将在几分钟内重置 root 密码。</p><p>**在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 上使用 Linux？**对于 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 来说有点不同。您可以按照此处在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 中重置 Linux 密码的步骤进行操作。</p><h2 id="从恢复模式重置-Ubuntu-密码-5"><a href="#从恢复模式重置-Ubuntu-密码-5" class="headerlink" title="从恢复模式重置 Ubuntu 密码"></a>从恢复模式重置 Ubuntu 密码</h2><p>如果您更喜欢观看视频而不是阅读文字，我还制作了本教程的视频。不要忘记订阅我们的 YouTube 频道以获取更多 Linux 教程视频。</p><h3 id="第-1-步：启动进入恢复模式-5"><a href="#第-1-步：启动进入恢复模式-5" class="headerlink" title="第 1 步：启动进入恢复模式"></a>第 1 步：启动进入恢复模式</h3><p>打开计算机。转到<strong>grub 菜单</strong>。一般来说，它会自动出现 - 如果没有，则<strong>按住 Shift 键</strong>或<strong>按 Esc 键</strong>直到出现启动菜单。</p><p>如果您使用的是 Oracle VirtualBox 或 VMware，当 Oracle 或 VMware 徽标出现时，您必须<strong>按住 Shift 键</strong>。</p><p>在 grub 菜单中，选择“Ubuntu 的高级选项”：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/new-grub-menu-ubuntu.png" alt="img"></p><p>在这里，您将看到进入恢复模式的选项：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/boot-into-recovery-mode-ubuntu.jpg" alt="img"></p><p>它将带您进入黑屏，并快速显示几行输出。在这里等待几秒钟。</p><h3 id="第-2-步：转到-root-shell-提示符-5"><a href="#第-2-步：转到-root-shell-提示符-5" class="headerlink" title="第 2 步：转到 root shell 提示符"></a>第 2 步：转到 root shell 提示符</h3><p>现在您将看到不同的恢复模式选项。这里您需要选择“<strong>Root – Drop to root shell提示</strong>”。只需按 Enter 键即可选择此选项。就像下图这样：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/drop-to-root-prompt-1.png" alt="img"></p><p>您会看到，当您选择 root shell 提示选项时，底部会出现一个输入命令的选项。这是您的 root shell 提示符，您将在此处使用命令来重置密码。</p><h3 id="步骤-3：重新挂载具有写权限的-root-5"><a href="#步骤-3：重新挂载具有写权限的-root-5" class="headerlink" title="步骤 3：重新挂载具有写权限的 root"></a>步骤 3：重新挂载具有写权限的 root</h3><p>您需要具有根分区的写入权限。默认情况下，它具有只读访问权限。</p><p>使用以下命令以写访问权限重新安装它：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><h3 id="第-4-步：重置用户名或密码-5"><a href="#第-4-步：重置用户名或密码-5" class="headerlink" title="第 4 步：重置用户名或密码"></a>第 4 步：重置用户名或密码</h3><p>在这里，您将获得 root 访问权限。使用以下命令列出所有可用的用户：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home</span><br></pre></td></tr></table></figure><p>根据此命令，选择您要重置或（例如）破解密码的“<strong>用户名</strong>”。现在，使用以下命令重置所选“<strong>用户名</strong>”的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>它提示输入新密码。输入新密码两次。</p><blockquote><p>*<strong>请注意，当您开始输入密码时，屏幕上不会显示任何内容。这是完全正常的*</strong>，实际上是 Linux 系统中的一个安全功能。只需盲目输入密码并按 Enter 键即可。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="keyword">new</span> UNIX password:</span><br><span class="line">Retype <span class="keyword">new</span> UNIX password:</span><br></pre></td></tr></table></figure><p>瞧！就这样吧。您刚刚成功重置了密码。现在退出 root shell 提示符：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>退出后，您将返回恢复模式菜单。此处选择正常启动选项。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/recovery-mode-menu-ubuntu.png" alt="img"></p><p>将会出现有关图形模式兼容性的警告。不用担心。完全重新启动将解决与此相关的任何问题。</p><p>您现在应该可以使用新密码登录。</p><h3 id="可能的故障排除：-5"><a href="#可能的故障排除：-5" class="headerlink" title="可能的故障排除："></a>可能的故障排除：</h3><p>输入新密码时，系统可能会提示您<strong>身份验证令牌操作错误</strong>，如下所示：</p><p>passwd 用户名 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：身份验证令牌操作错误 passwd：密码未更改</p><p>出现此错误的原因是文件系统仅以读访问权限挂载。按以下方式更改访问权限并重新挂载文件系统：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><p>现在再次尝试重置密码。现在应该可以了。</p><p>正如您所看到的，即使您忘记了 Ubuntu 密码，更改它也非常容易。几乎不需要几分钟。</p><h2 id="重置-Ubuntu-密码的替代方法-5"><a href="#重置-Ubuntu-密码的替代方法-5" class="headerlink" title="重置 Ubuntu 密码的替代方法"></a>重置 Ubuntu 密码的替代方法</h2><p>如果由于某种原因您难以进入 root shell 并更改密码，您可以尝试这些步骤。</p><h3 id="步骤1-5"><a href="#步骤1-5" class="headerlink" title="步骤1"></a>步骤1</h3><p>重新启动计算机。按住 Shift 键调出 grub 屏幕（如果它没有自动出现）。在 grub 提示符处<strong>按 E</strong> 编辑 grub 屏幕。</p><h3 id="第2步-5"><a href="#第2步-5" class="headerlink" title="第2步"></a>第2步</h3><p>找到以 linux 开头的行，将 ro 更改为 rw 并在该行末尾附加 init&#x3D;&#x2F;bin&#x2F;bash 。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/editing-grub-to-fix-nvidia-issue.jpg" alt="img"></p><h3 id="步骤3-4"><a href="#步骤3-4" class="headerlink" title="步骤3"></a>步骤3</h3><p>按 ctrl-x 保存更改并启动。</p><p>现在，您将使用读写权限启动 Linux 内核，并且不再进入图形用户界面，而是使用 bash shell。</p><p>换句话说，您的系统将启动到无密码 root shell。</p><h3 id="步骤4-4"><a href="#步骤4-4" class="headerlink" title="步骤4"></a>步骤4</h3><p>使用您的用户名输入 passwd 命令。如果您不知道用户名，请使用 <em>ls &#x2F;home</em> 命令进行检查（如方法 1 中所述）。</p><p>设置您的新密码。</p><p>设置新密码后，退出终端。只需在终端中输入 <strong>reboot</strong> 或使用 shutdown 命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><p>您的密码现在应该更改。</p><h2 id="如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-4"><a href="#如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-4" class="headerlink" title="如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？"></a>如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？</h2><p>这是一个公平的问题。 Linux 相对于 Windows 的主要优势之一是其安全性。但如果“任何人”都可以重置密码，为什么 Ubuntu 或其他 Linux 发行版可以被认为是安全的呢？</p><p>让我在这里解释一些事情。主要的安全风险是有人通过互联网从远程位置侵入您的帐户。这并没有发生在这里。</p><p>如果任何人能够物理访问您的计算机，那么您计算机中的数据就已经面临风险。除非整个磁盘都经过加密，否则任何人都可以使用实时 USB“窃取”您的数据，甚至无需进入您安装的操作系统。</p><p>默认情况下，Ubuntu 没有 root 密码，并且 root 帐户被锁定。您在安装 Ubuntu 时设置的用户帐户包含为具有 sudo 权限的管理员。但这并不意味着你就是root。</p><p>缺少root密码是一个故意的功能启动菜单中的“Ubuntu高级选项”允许您从“root shell提示符”执行一些特定的与root相关的任务。这就是为什么您可以通过此方法重置 Ubuntu 密码。</p><p>如果你想让你的系统更安全，你可以加密磁盘（以保存你的数据）或在 Ubuntu 中为 root 用户设置密码。</p><h2 id="额外提示：处理更改密码后可能出现的密钥环问题-4"><a href="#额外提示：处理更改密码后可能出现的密钥环问题-4" class="headerlink" title="额外提示：处理更改密码后可能出现的密钥环问题"></a>额外提示：处理更改密码后可能出现的密钥环问题</h2><p>Ubuntu 中有一个密钥环功能，用于保持密码锁定和安全。</p><p>当您重置忘记的密码时，密钥环保持解锁状态，您可能会看到类似这样的错误消息。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/enter-password-to-unlock-your-login-keyring-ubuntu.jpg" alt="img"></p><p>打开“密码和密钥”应用程序，然后在此处删除登录密码。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/delete-keyring-ubuntu.jpg" alt="img"></p><p>当您尝试在 Ubuntu 中再次使用 Google Chrome 时，它会要求您创建一个新的密钥环。使用新的登录密码作为密钥环密码。</p><p>我希望我已经清楚地说明了如何在 Ubuntu 中重置忘记的密码。</p><p><a href="https://cn.linux-console.net/?p=19579">如何在 2 分钟内重置忘记的 Ubuntu 密码 (linux-console.net)</a></p><h3 id="步骤3-5"><a href="#步骤3-5" class="headerlink" title="步骤3"></a>步骤3</h3><p>按 ctrl-x 保存更改并启动。</p><p>现在，您将使用读写权限启动 Linux 内核，并且不再进入图形用户界面，而是使用 bash shell。</p><p>换句话说，您的系统将启动到无密码 root shell。</p><h3 id="步骤4-5"><a href="#步骤4-5" class="headerlink" title="步骤4"></a>步骤4</h3><p>使用您的用户名输入 passwd 命令。如果您不知道用户名，请使用 <em>ls &#x2F;home</em> 命令进行检查（如方法 1 中所述）。</p><p>设置您的新密码。</p><p>设置新密码后，退出终端。只需在终端中输入 <strong>reboot</strong> 或使用 shutdown 命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><p>您的密码现在应该更改。</p><h2 id="如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-5"><a href="#如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-5" class="headerlink" title="如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？"></a>如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？</h2><p>这是一个公平的问题。 Linux 相对于 Windows 的主要优势之一是其安全性。但如果“任何人”都可以重置密码，为什么 Ubuntu 或其他 Linux 发行版可以被认为是安全的呢？</p><p>让我在这里解释一些事情。主要的安全风险是有人通过互联网从远程位置侵入您的帐户。这并没有发生在这里。</p><p>如果任何人能够物理访问您的计算机，那么您计算机中的数据就已经面临风险。除非整个磁盘都经过加密，否则任何人都可以使用实时 USB“窃取”您的数据，甚至无需进入您安装的操作系统。</p><p>默认情况下，Ubuntu 没有 root 密码，并且 root 帐户被锁定。您在安装 Ubuntu 时设置的用户帐户包含为具有 sudo 权限的管理员。但这并不意味着你就是root。</p><p>缺少root密码是一个故意的功能启动菜单中的“Ubuntu高级选项”允许您从“root shell提示符”执行一些特定的与root相关的任务。这就是为什么您可以通过此方法重置 Ubuntu 密码。</p><p>如果你想让你的系统更安全，你可以加密磁盘（以保存你的数据）或在 Ubuntu 中为 root 用户设置密码。</p><h2 id="额外提示：处理更改密码后可能出现的密钥环问题-5"><a href="#额外提示：处理更改密码后可能出现的密钥环问题-5" class="headerlink" title="额外提示：处理更改密码后可能出现的密钥环问题"></a>额外提示：处理更改密码后可能出现的密钥环问题</h2><p>Ubuntu 中有一个密钥环功能，用于保持密码锁定和安全。</p><p>当您重置忘记的密码时，密钥环保持解锁状态，您可能会看到类似这样的错误消息。</p><h1 id="如何在-2-分钟内重置忘记的-Ubuntu-密码-6"><a href="#如何在-2-分钟内重置忘记的-Ubuntu-密码-6" class="headerlink" title="如何在 2 分钟内重置忘记的 Ubuntu 密码"></a>如何在 2 分钟内重置忘记的 Ubuntu 密码</h1><hr><p><strong>如果您忘记了 Ubuntu 上的用户密码，请不要担心。您可以非常轻松地重置 Ubuntu 密码。本指南介绍了在 Ubuntu 上更改 root 密码的简单方法。该方法应该也适用于其他Linux发行版。</strong></p><p>忘记了 Ubuntu 登录密码？它发生了。</p><p>如果您已经有一段时间没有使用 Ubuntu，那么很自然地不记得密码。好消息是您不需要因此而重新安装整个操作系统。您可以轻松恢复 Ubuntu 密码。</p><p>这里提到的方法适用于在 VMware、双启动或单安装中重置 Ubuntu 密码。您所需要的只是一点耐心并运行几个命令。您将在几分钟内重置 root 密码。</p><p>**在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 上使用 Linux？**对于 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 来说有点不同。您可以按照此处在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 中重置 Linux 密码的步骤进行操作。</p><h2 id="从恢复模式重置-Ubuntu-密码-6"><a href="#从恢复模式重置-Ubuntu-密码-6" class="headerlink" title="从恢复模式重置 Ubuntu 密码"></a>从恢复模式重置 Ubuntu 密码</h2><p>如果您更喜欢观看视频而不是阅读文字，我还制作了本教程的视频。不要忘记订阅我们的 YouTube 频道以获取更多 Linux 教程视频。</p><h3 id="第-1-步：启动进入恢复模式-6"><a href="#第-1-步：启动进入恢复模式-6" class="headerlink" title="第 1 步：启动进入恢复模式"></a>第 1 步：启动进入恢复模式</h3><p>打开计算机。转到<strong>grub 菜单</strong>。一般来说，它会自动出现 - 如果没有，则<strong>按住 Shift 键</strong>或<strong>按 Esc 键</strong>直到出现启动菜单。</p><p>如果您使用的是 Oracle VirtualBox 或 VMware，当 Oracle 或 VMware 徽标出现时，您必须<strong>按住 Shift 键</strong>。</p><p>在 grub 菜单中，选择“Ubuntu 的高级选项”：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/new-grub-menu-ubuntu.png" alt="img"></p><p>在这里，您将看到进入恢复模式的选项：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/boot-into-recovery-mode-ubuntu.jpg" alt="img"></p><p>它将带您进入黑屏，并快速显示几行输出。在这里等待几秒钟。</p><h3 id="第-2-步：转到-root-shell-提示符-6"><a href="#第-2-步：转到-root-shell-提示符-6" class="headerlink" title="第 2 步：转到 root shell 提示符"></a>第 2 步：转到 root shell 提示符</h3><p>现在您将看到不同的恢复模式选项。这里您需要选择“<strong>Root – Drop to root shell提示</strong>”。只需按 Enter 键即可选择此选项。就像下图这样：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/drop-to-root-prompt-1.png" alt="img"></p><p>您会看到，当您选择 root shell 提示选项时，底部会出现一个输入命令的选项。这是您的 root shell 提示符，您将在此处使用命令来重置密码。</p><h3 id="步骤-3：重新挂载具有写权限的-root-6"><a href="#步骤-3：重新挂载具有写权限的-root-6" class="headerlink" title="步骤 3：重新挂载具有写权限的 root"></a>步骤 3：重新挂载具有写权限的 root</h3><p>您需要具有根分区的写入权限。默认情况下，它具有只读访问权限。</p><p>使用以下命令以写访问权限重新安装它：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><h3 id="第-4-步：重置用户名或密码-6"><a href="#第-4-步：重置用户名或密码-6" class="headerlink" title="第 4 步：重置用户名或密码"></a>第 4 步：重置用户名或密码</h3><p>在这里，您将获得 root 访问权限。使用以下命令列出所有可用的用户：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home</span><br></pre></td></tr></table></figure><p>根据此命令，选择您要重置或（例如）破解密码的“<strong>用户名</strong>”。现在，使用以下命令重置所选“<strong>用户名</strong>”的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>它提示输入新密码。输入新密码两次。</p><blockquote><p>*<strong>请注意，当您开始输入密码时，屏幕上不会显示任何内容。这是完全正常的*</strong>，实际上是 Linux 系统中的一个安全功能。只需盲目输入密码并按 Enter 键即可。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="keyword">new</span> UNIX password:</span><br><span class="line">Retype <span class="keyword">new</span> UNIX password:</span><br></pre></td></tr></table></figure><p>瞧！就这样吧。您刚刚成功重置了密码。现在退出 root shell 提示符：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>退出后，您将返回恢复模式菜单。此处选择正常启动选项。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/recovery-mode-menu-ubuntu.png" alt="img"></p><p>将会出现有关图形模式兼容性的警告。不用担心。完全重新启动将解决与此相关的任何问题。</p><p>您现在应该可以使用新密码登录。</p><h3 id="可能的故障排除：-6"><a href="#可能的故障排除：-6" class="headerlink" title="可能的故障排除："></a>可能的故障排除：</h3><p>输入新密码时，系统可能会提示您<strong>身份验证令牌操作错误</strong>，如下所示：</p><p>passwd 用户名 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：身份验证令牌操作错误 passwd：密码未更改</p><p>出现此错误的原因是文件系统仅以读访问权限挂载。按以下方式更改访问权限并重新挂载文件系统：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><p>现在再次尝试重置密码。现在应该可以了。</p><p>正如您所看到的，即使您忘记了 Ubuntu 密码，更改它也非常容易。几乎不需要几分钟。</p><h2 id="重置-Ubuntu-密码的替代方法-6"><a href="#重置-Ubuntu-密码的替代方法-6" class="headerlink" title="重置 Ubuntu 密码的替代方法"></a>重置 Ubuntu 密码的替代方法</h2><p>如果由于某种原因您难以进入 root shell 并更改密码，您可以尝试这些步骤。</p><h3 id="步骤1-6"><a href="#步骤1-6" class="headerlink" title="步骤1"></a>步骤1</h3><p>重新启动计算机。按住 Shift 键调出 grub 屏幕（如果它没有自动出现）。在 grub 提示符处<strong>按 E</strong> 编辑 grub 屏幕。</p><h3 id="第2步-6"><a href="#第2步-6" class="headerlink" title="第2步"></a>第2步</h3><p>找到以 linux 开头的行，将 ro 更改为 rw 并在该行末尾附加 init&#x3D;&#x2F;bin&#x2F;bash 。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/editing-grub-to-fix-nvidia-issue.jpg" alt="img"></p><h3 id="步骤3-6"><a href="#步骤3-6" class="headerlink" title="步骤3"></a>步骤3</h3><p>按 ctrl-x 保存更改并启动。</p><p>现在，您将使用读写权限启动 Linux 内核，并且不再进入图形用户界面，而是使用 bash shell。</p><p>换句话说，您的系统将启动到无密码 root shell。</p><h3 id="步骤4-6"><a href="#步骤4-6" class="headerlink" title="步骤4"></a>步骤4</h3><p>使用您的用户名输入 passwd 命令。如果您不知道用户名，请使用 <em>ls &#x2F;home</em> 命令进行检查（如方法 1 中所述）。</p><p>设置您的新密码。</p><p>设置新密码后，退出终端。只需在终端中输入 <strong>reboot</strong> 或使用 shutdown 命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><p>您的密码现在应该更改。</p><h2 id="如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-6"><a href="#如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-6" class="headerlink" title="如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？"></a>如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？</h2><p>这是一个公平的问题。 Linux 相对于 Windows 的主要优势之一是其安全性。但如果“任何人”都可以重置密码，为什么 Ubuntu 或其他 Linux 发行版可以被认为是安全的呢？</p><p>让我在这里解释一些事情。主要的安全风险是有人通过互联网从远程位置侵入您的帐户。这并没有发生在这里。</p><p>如果任何人能够物理访问您的计算机，那么您计算机中的数据就已经面临风险。除非整个磁盘都经过加密，否则任何人都可以使用实时 USB“窃取”您的数据，甚至无需进入您安装的操作系统。</p><p>默认情况下，Ubuntu 没有 root 密码，并且 root 帐户被锁定。您在安装 Ubuntu 时设置的用户帐户包含为具有 sudo 权限的管理员。但这并不意味着你就是root。</p><p>缺少root密码是一个故意的功能启动菜单中的“Ubuntu高级选项”允许您从“root shell提示符”执行一些特定的与root相关的任务。这就是为什么您可以通过此方法重置 Ubuntu 密码。</p><p>如果你想让你的系统更安全，你可以加密磁盘（以保存你的数据）或在 Ubuntu 中为 root 用户设置密码。</p><h2 id="额外提示：处理更改密码后可能出现的密钥环问题-6"><a href="#额外提示：处理更改密码后可能出现的密钥环问题-6" class="headerlink" title="额外提示：处理更改密码后可能出现的密钥环问题"></a>额外提示：处理更改密码后可能出现的密钥环问题</h2><p>Ubuntu 中有一个密钥环功能，用于保持密码锁定和安全。</p><p>当您重置忘记的密码时，密钥环保持解锁状态，您可能会看到类似这样的错误消息。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/enter-password-to-unlock-your-login-keyring-ubuntu.jpg" alt="img"></p><p>打开“密码和密钥”应用程序，然后在此处删除登录密码。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/delete-keyring-ubuntu.jpg" alt="img"></p><p>当您尝试在 Ubuntu 中再次使用 Google Chrome 时，它会要求您创建一个新的密钥环。使用新的登录密码作为密钥环密码。</p><p>我希望我已经清楚地说明了如何在 Ubuntu 中重置忘记的密码。</p><p><a href="https://cn.linux-console.net/?p=19579">如何在 2 分钟内重置忘记的 Ubuntu 密码 (linux-console.net)</a></p><p>打开“密码和密钥”应用程序，然后在此处删除登录密码。</p><h1 id="如何在-2-分钟内重置忘记的-Ubuntu-密码-7"><a href="#如何在-2-分钟内重置忘记的-Ubuntu-密码-7" class="headerlink" title="如何在 2 分钟内重置忘记的 Ubuntu 密码"></a>如何在 2 分钟内重置忘记的 Ubuntu 密码</h1><hr><p><strong>如果您忘记了 Ubuntu 上的用户密码，请不要担心。您可以非常轻松地重置 Ubuntu 密码。本指南介绍了在 Ubuntu 上更改 root 密码的简单方法。该方法应该也适用于其他Linux发行版。</strong></p><p>忘记了 Ubuntu 登录密码？它发生了。</p><p>如果您已经有一段时间没有使用 Ubuntu，那么很自然地不记得密码。好消息是您不需要因此而重新安装整个操作系统。您可以轻松恢复 Ubuntu 密码。</p><p>这里提到的方法适用于在 VMware、双启动或单安装中重置 Ubuntu 密码。您所需要的只是一点耐心并运行几个命令。您将在几分钟内重置 root 密码。</p><p>**在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 上使用 Linux？**对于 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 来说有点不同。您可以按照此处在 <a href="https://cn.a-d.site/?cat=linux">WSL</a> 中重置 Linux 密码的步骤进行操作。</p><h2 id="从恢复模式重置-Ubuntu-密码-7"><a href="#从恢复模式重置-Ubuntu-密码-7" class="headerlink" title="从恢复模式重置 Ubuntu 密码"></a>从恢复模式重置 Ubuntu 密码</h2><p>如果您更喜欢观看视频而不是阅读文字，我还制作了本教程的视频。不要忘记订阅我们的 YouTube 频道以获取更多 Linux 教程视频。</p><h3 id="第-1-步：启动进入恢复模式-7"><a href="#第-1-步：启动进入恢复模式-7" class="headerlink" title="第 1 步：启动进入恢复模式"></a>第 1 步：启动进入恢复模式</h3><p>打开计算机。转到<strong>grub 菜单</strong>。一般来说，它会自动出现 - 如果没有，则<strong>按住 Shift 键</strong>或<strong>按 Esc 键</strong>直到出现启动菜单。</p><p>如果您使用的是 Oracle VirtualBox 或 VMware，当 Oracle 或 VMware 徽标出现时，您必须<strong>按住 Shift 键</strong>。</p><p>在 grub 菜单中，选择“Ubuntu 的高级选项”：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/new-grub-menu-ubuntu.png" alt="img"></p><p>在这里，您将看到进入恢复模式的选项：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/boot-into-recovery-mode-ubuntu.jpg" alt="img"></p><p>它将带您进入黑屏，并快速显示几行输出。在这里等待几秒钟。</p><h3 id="第-2-步：转到-root-shell-提示符-7"><a href="#第-2-步：转到-root-shell-提示符-7" class="headerlink" title="第 2 步：转到 root shell 提示符"></a>第 2 步：转到 root shell 提示符</h3><p>现在您将看到不同的恢复模式选项。这里您需要选择“<strong>Root – Drop to root shell提示</strong>”。只需按 Enter 键即可选择此选项。就像下图这样：</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/drop-to-root-prompt-1.png" alt="img"></p><p>您会看到，当您选择 root shell 提示选项时，底部会出现一个输入命令的选项。这是您的 root shell 提示符，您将在此处使用命令来重置密码。</p><h3 id="步骤-3：重新挂载具有写权限的-root-7"><a href="#步骤-3：重新挂载具有写权限的-root-7" class="headerlink" title="步骤 3：重新挂载具有写权限的 root"></a>步骤 3：重新挂载具有写权限的 root</h3><p>您需要具有根分区的写入权限。默认情况下，它具有只读访问权限。</p><p>使用以下命令以写访问权限重新安装它：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><h3 id="第-4-步：重置用户名或密码-7"><a href="#第-4-步：重置用户名或密码-7" class="headerlink" title="第 4 步：重置用户名或密码"></a>第 4 步：重置用户名或密码</h3><p>在这里，您将获得 root 访问权限。使用以下命令列出所有可用的用户：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home</span><br></pre></td></tr></table></figure><p>根据此命令，选择您要重置或（例如）破解密码的“<strong>用户名</strong>”。现在，使用以下命令重置所选“<strong>用户名</strong>”的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>它提示输入新密码。输入新密码两次。</p><blockquote><p>*<strong>请注意，当您开始输入密码时，屏幕上不会显示任何内容。这是完全正常的*</strong>，实际上是 Linux 系统中的一个安全功能。只需盲目输入密码并按 Enter 键即可。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="keyword">new</span> UNIX password:</span><br><span class="line">Retype <span class="keyword">new</span> UNIX password:</span><br></pre></td></tr></table></figure><p>瞧！就这样吧。您刚刚成功重置了密码。现在退出 root shell 提示符：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>退出后，您将返回恢复模式菜单。此处选择正常启动选项。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/recovery-mode-menu-ubuntu.png" alt="img"></p><p>将会出现有关图形模式兼容性的警告。不用担心。完全重新启动将解决与此相关的任何问题。</p><p>您现在应该可以使用新密码登录。</p><h3 id="可能的故障排除：-7"><a href="#可能的故障排除：-7" class="headerlink" title="可能的故障排除："></a>可能的故障排除：</h3><p>输入新密码时，系统可能会提示您<strong>身份验证令牌操作错误</strong>，如下所示：</p><p>passwd 用户名 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：身份验证令牌操作错误 passwd：密码未更改</p><p>出现此错误的原因是文件系统仅以读访问权限挂载。按以下方式更改访问权限并重新挂载文件系统：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mount</span> <span class="literal">-rw</span> <span class="literal">-o</span> remount /</span><br></pre></td></tr></table></figure><p>现在再次尝试重置密码。现在应该可以了。</p><p>正如您所看到的，即使您忘记了 Ubuntu 密码，更改它也非常容易。几乎不需要几分钟。</p><h2 id="重置-Ubuntu-密码的替代方法-7"><a href="#重置-Ubuntu-密码的替代方法-7" class="headerlink" title="重置 Ubuntu 密码的替代方法"></a>重置 Ubuntu 密码的替代方法</h2><p>如果由于某种原因您难以进入 root shell 并更改密码，您可以尝试这些步骤。</p><h3 id="步骤1-7"><a href="#步骤1-7" class="headerlink" title="步骤1"></a>步骤1</h3><p>重新启动计算机。按住 Shift 键调出 grub 屏幕（如果它没有自动出现）。在 grub 提示符处<strong>按 E</strong> 编辑 grub 屏幕。</p><h3 id="第2步-7"><a href="#第2步-7" class="headerlink" title="第2步"></a>第2步</h3><p>找到以 linux 开头的行，将 ro 更改为 rw 并在该行末尾附加 init&#x3D;&#x2F;bin&#x2F;bash 。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/editing-grub-to-fix-nvidia-issue.jpg" alt="img"></p><h3 id="步骤3-7"><a href="#步骤3-7" class="headerlink" title="步骤3"></a>步骤3</h3><p>按 ctrl-x 保存更改并启动。</p><p>现在，您将使用读写权限启动 Linux 内核，并且不再进入图形用户界面，而是使用 bash shell。</p><p>换句话说，您的系统将启动到无密码 root shell。</p><h3 id="步骤4-7"><a href="#步骤4-7" class="headerlink" title="步骤4"></a>步骤4</h3><p>使用您的用户名输入 passwd 命令。如果您不知道用户名，请使用 <em>ls &#x2F;home</em> 命令进行检查（如方法 1 中所述）。</p><p>设置您的新密码。</p><p>设置新密码后，退出终端。只需在终端中输入 <strong>reboot</strong> 或使用 shutdown 命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><p>您的密码现在应该更改。</p><h2 id="如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-7"><a href="#如果重置-Ubuntu-密码这么简单，这不是一个安全风险吗？-7" class="headerlink" title="如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？"></a>如果重置 Ubuntu 密码这么简单，这不是一个安全风险吗？</h2><p>这是一个公平的问题。 Linux 相对于 Windows 的主要优势之一是其安全性。但如果“任何人”都可以重置密码，为什么 Ubuntu 或其他 Linux 发行版可以被认为是安全的呢？</p><p>让我在这里解释一些事情。主要的安全风险是有人通过互联网从远程位置侵入您的帐户。这并没有发生在这里。</p><p>如果任何人能够物理访问您的计算机，那么您计算机中的数据就已经面临风险。除非整个磁盘都经过加密，否则任何人都可以使用实时 USB“窃取”您的数据，甚至无需进入您安装的操作系统。</p><p>默认情况下，Ubuntu 没有 root 密码，并且 root 帐户被锁定。您在安装 Ubuntu 时设置的用户帐户包含为具有 sudo 权限的管理员。但这并不意味着你就是root。</p><p>缺少root密码是一个故意的功能启动菜单中的“Ubuntu高级选项”允许您从“root shell提示符”执行一些特定的与root相关的任务。这就是为什么您可以通过此方法重置 Ubuntu 密码。</p><p>如果你想让你的系统更安全，你可以加密磁盘（以保存你的数据）或在 Ubuntu 中为 root 用户设置密码。</p><h2 id="额外提示：处理更改密码后可能出现的密钥环问题-7"><a href="#额外提示：处理更改密码后可能出现的密钥环问题-7" class="headerlink" title="额外提示：处理更改密码后可能出现的密钥环问题"></a>额外提示：处理更改密码后可能出现的密钥环问题</h2><p>Ubuntu 中有一个密钥环功能，用于保持密码锁定和安全。</p><p>当您重置忘记的密码时，密钥环保持解锁状态，您可能会看到类似这样的错误消息。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/enter-password-to-unlock-your-login-keyring-ubuntu.jpg" alt="img"></p><p>打开“密码和密钥”应用程序，然后在此处删除登录密码。</p><p><img src="https://cn.linux-console.net/common-images/how-to-hack-ubuntu-password/delete-keyring-ubuntu.jpg" alt="img"></p><p>当您尝试在 Ubuntu 中再次使用 Google Chrome 时，它会要求您创建一个新的密钥环。使用新的登录密码作为密钥环密码。</p><p>我希望我已经清楚地说明了如何在 Ubuntu 中重置忘记的密码。</p><p><a href="https://cn.linux-console.net/?p=19579">如何在 2 分钟内重置忘记的 Ubuntu 密码 (linux-console.net)</a></p><p>当您尝试在 Ubuntu 中再次使用 Google Chrome 时，它会要求您创建一个新的密钥环。使用新的登录密码作为密钥环密码。</p><p>我希望我已经清楚地说明了如何在 Ubuntu 中重置忘记的密码。</p><p><a href="https://cn.linux-console.net/?p=19579">如何在 2 分钟内重置忘记的 Ubuntu 密码 (linux-console.net)</a></p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/Linux-%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%81/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/Linux-%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%81/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h1 id="如何在-2-分钟内重置忘记的-Ubuntu-密码"><a href="#如何在-2-分钟内重置忘记的-Ubuntu-密码" class="headerlink" title="如何在 2 分钟内重置忘记的 Ubuntu 密码"></a>如何在 2 分钟内重置忘记的 Ubuntu 密码</h1><hr>
<p><strong>如果您忘记了 Ubuntu 上的用户密码，请不要担心。您可以非常轻松地重置 Ubuntu 密码。本指南介绍了在 Ubuntu 上更改 root 密码的简单方法。该方法应该也适用于其他Linux发行版。</strong></p>
<p>忘记了 Ubuntu]]>
    </summary>
    <title>重置密码</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直对音声这块没什么涉猎，之前虽然有看过一些相关的视频，但是自己没上过手的东西，又怎么能够说知晓了呢。正好，乘闲暇无事，对未知领域进行一番探索。</p><h2 id="VOICEVOX"><a href="#VOICEVOX" class="headerlink" title="VOICEVOX"></a>VOICEVOX</h2><p><strong>VOICEVOX</strong>是由ヒホ（ヒロシバ）基于深度学习技术开发的开源、免费的文字朗读软件。</p><h3 id="软件简述"><a href="#软件简述" class="headerlink" title="软件简述"></a>软件简述</h3><p>VOICEVOX自称“免费使用的中等品质文字朗读软件”（無料で使える中品質なテキスト読み上げソフトウェア），有着以下特点：</p><ol><li>商业或非商业都能免费使用（具体参照各个角色的使用规约）；</li><li>在所有电脑平台都可以使用（Windows、Mac、Linux）；</li><li>可以对语调（intonation）等做详细调整。</li></ol><p>除此之外，软件本体开源（包括编辑器UI、引擎、内核），其他开发者可以按照开源条例使用、开发新的软件或者内嵌至其他软件。</p><p>官方简称为「ボイボ」。</p><p>VoiceVox是voicepeak的姊妹TTS软件，同样可以商用、非商用，但属于免费语音合成软件，目前声库已经增加到10个，对于同人视觉小说游戏开发是一场及时雨。</p><p>虽然修音不如voicepeak，但是就免费开源而言已经很不错了，项目地址在<a href="https://link.zhihu.com/?target=https://github.com/VOICEVOX/voicevox">GitHub - VOICEVOX&#x2F;voicevox: 無料で使える中品質なテキスト読み上げソフトウェア、VOICEVOXのエディター</a> 。大小约1.9GB。</p><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>一直对音声这块没什么涉猎，之前虽然有看过一些相关的视频，但是自己没上过手的东西，又怎么能够说知晓了呢。正好，乘闲暇无事，对未知领域进行一番探索。</p><h2 id="VOICEVOX-1"><a href="#VOICEVOX-1" class="headerlink" title="VOICEVOX"></a>VOICEVOX</h2><p><strong>VOICEVOX</strong>是由ヒホ（ヒロシバ）基于深度学习技术开发的开源、免费的文字朗读软件。</p><h3 id="软件简述-1"><a href="#软件简述-1" class="headerlink" title="软件简述"></a>软件简述</h3><p>VOICEVOX自称“免费使用的中等品质文字朗读软件”（無料で使える中品質なテキスト読み上げソフトウェア），有着以下特点：</p><ol><li>商业或非商业都能免费使用（具体参照各个角色的使用规约）；</li><li>在所有电脑平台都可以使用（Windows、Mac、Linux）；</li><li>可以对语调（intonation）等做详细调整。</li></ol><p>除此之外，软件本体开源（包括编辑器UI、引擎、内核），其他开发者可以按照开源条例使用、开发新的软件或者内嵌至其他软件。</p><p>官方简称为「ボイボ」。</p><p>VoiceVox是voicepeak的姊妹TTS软件，同样可以商用、非商用，但属于免费语音合成软件，目前声库已经增加到10个，对于同人视觉小说游戏开发是一场及时雨。</p><p>虽然修音不如voicepeak，但是就免费开源而言已经很不错了，项目地址在<a href="https://link.zhihu.com/?target=https://github.com/VOICEVOX/voicevox">GitHub - VOICEVOX&#x2F;voicevox: 無料で使える中品質なテキスト読み上げソフトウェア、VOICEVOXのエディター</a> 。大小约1.9GB。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/v2-f2f845d9993a50f03622c8f3bad37a92_720w.webp" alt="img"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mzh.moegirl.org.cn/VOICEVOX">VOICEVOX - 萌娘百科 万物皆可萌的百科全书 (moegirl.org.cn)</a></p><h2 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mzh.moegirl.org.cn/VOICEVOX">VOICEVOX - 萌娘百科 万物皆可萌的百科全书 (moegirl.org.cn)</a></p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/%E4%BA%8C%E6%AC%A1%E5%85%83-VoiceVox/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/%E4%BA%8C%E6%AC%A1%E5%85%83-VoiceVox/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直对音声这块没什么涉猎，之前虽然有看过一些相关的视频，但是自己没上过手的东西，又怎么能够说知晓了呢。正好，乘闲暇无事，对未知领域进行一番探索。</p>
<h2 id="VOICEVOX"><a href="#VOICEVOX" class="headerlink"]]>
    </summary>
    <title>VoiceVox</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><table><thead><tr><th>资源ID</th><th>c4cf1aece35c43b19c396665cbfb0935</th></tr></thead><tbody><tr><td>资源名称</td><td>我的轻量</td></tr><tr><td>资源类型</td><td>轻量应用服务器-实例</td></tr><tr><td>资源组</td><td>-</td></tr><tr><td>地域</td><td>新加坡</td></tr><tr><td>创建时间</td><td>2023年11月3日 15:16:42</td></tr><tr><td>IP地址</td><td>172.17.59.55, 47.236.110.159</td></tr><tr><td>标签</td><td>-</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>资源配置信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Running&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;InstanceId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c4cf1aece35c43b19c396665cbfb0935&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;PlanId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;swas.s2.c2m1s40b30t1.un&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;CreateTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-11-03T07:16:42Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;DdosStatus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;normal&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;BusinessStatus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Normal&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;InstanceName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我的轻量&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;PublicIpAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;47.236.110.159&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;InnerIpAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.59.55&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ExpiredTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-11-03T16:00:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ImageId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;87987f90ac2943c1b23f4c46cc80839c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;PaymentType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PrePaid&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;RegionId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ap-southeast-1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8-config/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8-config/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h3 id="基础信息"><a href="#基础信息" class="headerlink"]]>
    </summary>
    <title>Config</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装"><a href="#1-环境安装" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-1"><a href="#1-环境安装-1" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透"><a href="#2-安装cpolar内网穿透" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透"><a href="#3-内网穿透" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址"><a href="#4-固定http地址" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名"><a href="#5-配置二级子域名" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-2"><a href="#1-环境安装-2" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-1"><a href="#2-安装cpolar内网穿透-1" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-1"><a href="#3-内网穿透-1" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-1"><a href="#4-固定http地址-1" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-1"><a href="#5-配置二级子域名-1" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-1"><a href="#后续-1" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-3"><a href="#1-环境安装-3" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-2"><a href="#2-安装cpolar内网穿透-2" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-2"><a href="#3-内网穿透-2" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-2"><a href="#4-固定http地址-2" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-2"><a href="#5-配置二级子域名-2" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-2"><a href="#后续-2" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><h3 id="2-安装cpolar内网穿透-3"><a href="#2-安装cpolar内网穿透-3" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><h3 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-4"><a href="#1-环境安装-4" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-4"><a href="#2-安装cpolar内网穿透-4" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-3"><a href="#3-内网穿透-3" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-3"><a href="#4-固定http地址-3" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-3"><a href="#5-配置二级子域名-3" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-3"><a href="#后续-3" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><h3 id="前言-5"><a href="#前言-5" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-5"><a href="#1-环境安装-5" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-5"><a href="#2-安装cpolar内网穿透-5" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-4"><a href="#3-内网穿透-4" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-4"><a href="#4-固定http地址-4" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-4"><a href="#5-配置二级子域名-4" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-4"><a href="#后续-4" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><h3 id="前言-6"><a href="#前言-6" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-6"><a href="#1-环境安装-6" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-6"><a href="#2-安装cpolar内网穿透-6" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-5"><a href="#3-内网穿透-5" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-5"><a href="#4-固定http地址-5" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-5"><a href="#5-配置二级子域名-5" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-5"><a href="#后续-5" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><h3 id="前言-7"><a href="#前言-7" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-7"><a href="#1-环境安装-7" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-7"><a href="#2-安装cpolar内网穿透-7" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-6"><a href="#3-内网穿透-6" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-6"><a href="#4-固定http地址-6" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-6"><a href="#5-配置二级子域名-6" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-6"><a href="#后续-6" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><h3 id="3-内网穿透-7"><a href="#3-内网穿透-7" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><h3 id="前言-8"><a href="#前言-8" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-8"><a href="#1-环境安装-8" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-8"><a href="#2-安装cpolar内网穿透-8" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-8"><a href="#3-内网穿透-8" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-7"><a href="#4-固定http地址-7" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-7"><a href="#5-配置二级子域名-7" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-7"><a href="#后续-7" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><h3 id="前言-9"><a href="#前言-9" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-9"><a href="#1-环境安装-9" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-9"><a href="#2-安装cpolar内网穿透-9" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-9"><a href="#3-内网穿透-9" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-8"><a href="#4-固定http地址-8" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-8"><a href="#5-配置二级子域名-8" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-8"><a href="#后续-8" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><h3 id="前言-10"><a href="#前言-10" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-10"><a href="#1-环境安装-10" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-10"><a href="#2-安装cpolar内网穿透-10" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-10"><a href="#3-内网穿透-10" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-9"><a href="#4-固定http地址-9" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-9"><a href="#5-配置二级子域名-9" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-9"><a href="#后续-9" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><p>这个时候我们可以看到站点创建成功</p><h3 id="前言-11"><a href="#前言-11" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-11"><a href="#1-环境安装-11" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-11"><a href="#2-安装cpolar内网穿透-11" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-11"><a href="#3-内网穿透-11" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-10"><a href="#4-固定http地址-10" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-10"><a href="#5-配置二级子域名-10" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-10"><a href="#后续-10" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><h3 id="前言-12"><a href="#前言-12" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-12"><a href="#1-环境安装-12" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-12"><a href="#2-安装cpolar内网穿透-12" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-12"><a href="#3-内网穿透-12" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-11"><a href="#4-固定http地址-11" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-11"><a href="#5-配置二级子域名-11" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-11"><a href="#后续-11" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><h3 id="4-固定http地址-12"><a href="#4-固定http地址-12" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><h3 id="前言-13"><a href="#前言-13" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-13"><a href="#1-环境安装-13" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-13"><a href="#2-安装cpolar内网穿透-13" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-13"><a href="#3-内网穿透-13" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-13"><a href="#4-固定http地址-13" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-12"><a href="#5-配置二级子域名-12" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-12"><a href="#后续-12" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><h3 id="前言-14"><a href="#前言-14" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-14"><a href="#1-环境安装-14" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-14"><a href="#2-安装cpolar内网穿透-14" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-14"><a href="#3-内网穿透-14" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-14"><a href="#4-固定http地址-14" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-13"><a href="#5-配置二级子域名-13" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-13"><a href="#后续-13" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><h3 id="5-配置二级子域名-14"><a href="#5-配置二级子域名-14" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><h3 id="前言-15"><a href="#前言-15" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-15"><a href="#1-环境安装-15" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-15"><a href="#2-安装cpolar内网穿透-15" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-15"><a href="#3-内网穿透-15" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-15"><a href="#4-固定http地址-15" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-15"><a href="#5-配置二级子域名-15" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-14"><a href="#后续-14" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><h3 id="前言-16"><a href="#前言-16" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-16"><a href="#1-环境安装-16" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-16"><a href="#2-安装cpolar内网穿透-16" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-16"><a href="#3-内网穿透-16" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-16"><a href="#4-固定http地址-16" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-16"><a href="#5-配置二级子域名-16" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-15"><a href="#后续-15" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><h3 id="前言-17"><a href="#前言-17" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-17"><a href="#1-环境安装-17" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-17"><a href="#2-安装cpolar内网穿透-17" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-17"><a href="#3-内网穿透-17" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-17"><a href="#4-固定http地址-17" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-17"><a href="#5-配置二级子域名-17" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-16"><a href="#后续-16" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><p>然后我们打开宝塔面板,找到站点,点击设置</p><h3 id="前言-18"><a href="#前言-18" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-18"><a href="#1-环境安装-18" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-18"><a href="#2-安装cpolar内网穿透-18" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-18"><a href="#3-内网穿透-18" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-18"><a href="#4-固定http地址-18" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-18"><a href="#5-配置二级子域名-18" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-17"><a href="#后续-17" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><p>添加一个我们固定的公网地址域名</p><h3 id="前言-19"><a href="#前言-19" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-19"><a href="#1-环境安装-19" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-19"><a href="#2-安装cpolar内网穿透-19" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-19"><a href="#3-内网穿透-19" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-19"><a href="#4-固定http地址-19" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-19"><a href="#5-配置二级子域名-19" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-18"><a href="#后续-18" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><p>然后把之前创建的随机地址删除</p><h3 id="前言-20"><a href="#前言-20" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-20"><a href="#1-环境安装-20" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-20"><a href="#2-安装cpolar内网穿透-20" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-20"><a href="#3-内网穿透-20" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-20"><a href="#4-固定http地址-20" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-20"><a href="#5-配置二级子域名-20" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-19"><a href="#后续-19" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><h3 id="前言-21"><a href="#前言-21" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>、FTP等，通过Web端轻松管理服务器。</p><p>以下教程，我们将演示使用宝塔面板快速简单搭建本地web网站，并做内网穿透，实现不在同个局域网下的用户也可以访问到本地web站点，无需<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>，也不用设置路由器。</p><h3 id="1-环境安装-21"><a href="#1-环境安装-21" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h3><p>安装apache服务器,在宝塔面板中我们点击网站,然后会提示安装apache服务器。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/bbff18195cb87904aac4bdb2596b7f44.png" alt="image-20230307143843485"></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/151ebbebdfff4a106a9e8ab15f256273.png" alt="image-20230307155129355"></p><p>然后等待安装完成即可,安装完成在左边消息列表会提示</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/86f327aff984e56f62086d0c2d4f20a4.png" alt="image-20230307155221216"></p><h3 id="2-安装cpolar内网穿透-21"><a href="#2-安装cpolar内网穿透-21" class="headerlink" title="2. 安装cpolar内网穿透"></a>2. 安装cpolar内网穿透</h3><blockquote><p> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cpolar.com/&source=article&objectId=2337730">https://www.cpolar.com/</a> </p></blockquote><ul><li>打开宝塔终端命令窗口,使用cpolar一件安装脚本:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="attr">https</span>:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/242b75d2e65b085619dee64ca57b5007.png" alt="image-20230303183721806"></p><ul><li>token认证</li></ul><p>登录cpolar官网,点击左侧的<code>验证</code>，查看自己的认证token，之后将token贴在命令行里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/085c96875d0ced7713a5b8f45f57a1cb.png" alt="20230111103532"></p><ul><li>向系统添加服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure><ul><li>启动cpolar服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><ul><li>开放9200端口</li></ul><p>在宝塔面板中选择安全.然后开放9200端口</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/e3f2d366a85316014dcf8e1ed70e797f.png" alt="image-20230303184430176"></p><ul><li>登录cpolar web UI 管理界面</li></ul><p>然后局域网ip访问9200端口即可出现cpolar管理界面，输入cpolar邮箱账号进行登陆</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/55a1eee790aa10ff25c39207681dafcd.png" alt="image-20230303184618711"></p><h3 id="3-内网穿透-21"><a href="#3-内网穿透-21" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h3><p>登录cpolar web UI管理界面后，我们创建一个http隧道，指向80端口,因为apache服务默认是80端口</p><ul><li>隧道名称：可自定义，注意不要重复</li><li>协议：http</li><li>本地地址：80</li><li>端口类型：随机域名</li><li>地区：China vip</li></ul><p>点击<code>创建</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/ccfb43d324c0d8199730fd4e3e0d10ed.png" alt="image-20230307161358154"></p><p>创建成功后我们打开在线隧道列表复制创建的公网地址</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/b575b43f6f998041ebeed60bdb34f16b.png" alt="image-20230307161716775"></p><p>然后我们打开宝塔面板,点击网站,选择添加站点,把复制的公网地址粘贴到域名的参数框,然后点击提交</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/6f20811dd43647cad1236d2e8e1e875e.png" alt="image-20230307162110990"></p><p>这个时候我们可以看到站点创建成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/6ce1fe268297d5e5101b44d4862cfc9d.png" alt="image-20230307162248903"></p><p>然后我们再使用复制的公网地址,打开浏览器访问,出现欢迎页表示成功</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/7e6eba1092281171140be29389b1eddf.png" alt="image-20230307163357047"></p><h3 id="4-固定http地址-21"><a href="#4-固定http地址-21" class="headerlink" title="4. 固定http地址"></a>4. 固定http地址</h3><p>由于刚刚创建隧道使用的是随机临时地址，该地址会在24小时内发生变化，为了长期远程访问，我们接下来将这个公网地址配置为固定的。</p><blockquote><p> 需升级至基础套餐或以上才支持配置二级子域名 </p></blockquote><p>登录cpolar官网后台，点击左侧仪表盘的<code>预留</code>，找到<code>保留二级子域名</code>，为http隧道保留一个二级子域名。</p><ul><li><em>地区：选择服务器地区</em></li><li><em>名称：填写您想要保留的二级子域名（可自定义）</em></li><li><em>描述：即备注，可自定义填写</em></li></ul><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/1ca2488f1909e325f929cc6b80c117a6.png" alt="image-20230307164936590"></p><p>本例保留一个名称为<code>mywebsitegame</code>的二级子域名。子域名保留成功后，我们将子域名复制下来，接下来需要将其配置到隧道中去。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/e332484341c2eb766c0268e974f61b0d.png" alt="image-20230307165346945"></p><h3 id="5-配置二级子域名-21"><a href="#5-配置二级子域名-21" class="headerlink" title="5. 配置二级子域名"></a>5. 配置二级子域名</h3><p>登录cpolar web ui管理界面。点击左侧仪表盘的<code>隧道管理</code>——<code>隧道列表</code>，找到需要配置二级子域名的隧道（本例中为apache website隧道），点击右侧的<code>编辑</code></p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/4b30ec2ade5fc0c448ab927eb6ac5864.png" alt="image-20230307165440111"></p><p>修改隧道信息，将二级子域名配置到隧道中：</p><ul><li><em>域名类型：改为选择<code>二级子域名</code></em></li><li><em>Sub Domain：填写我们刚刚所保留的二级子域名（本例为<code>mywebsitegame</code>）</em></li></ul><p>修改完成后，点击<code>更新</code></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/140721fc7f7d4e0f7b93014ecbc55679.png" alt="image-20230307165524932"></p><p>隧道更新成功后，点击左侧仪表盘的<code>状态</code>——<code>在线隧道列表</code>，可以看到隧道的公网地址，已经更新为二级子域名了，将公网地址复制下来。</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/a5872f56222ed3609b3a5860b56539ea.png" alt="image-20230307165845253"></p><p>然后我们打开宝塔面板,找到站点,点击设置</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/671aebf527cf7b19c48ef49ca6e75b29.png" alt="image-20230307170712990"></p><p>添加一个我们固定的公网地址域名</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/22de66f7ecc95d48d079694f250b830d.png" alt="image-20230307170900973"></p><p>然后把之前创建的随机地址删除</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/53cf4d8386a128b542e40f0ced879e66.png" alt="image-20230307170948787"></p><p>然后我们打开浏览器,使用固定的公网地址进行访问,以上我们就配置好了站点远程访问</p><p><img src="https://raw.githubusercontent.com/h1s97x/picture/main/Doc/9d77064ba2531a51effbf0bef350e8a6.png" alt="image-20230307172031135"></p><h3 id="后续-20"><a href="#后续-20" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p><h3 id="后续-21"><a href="#后续-21" class="headerlink" title="后续"></a>后续</h3><p>说说体验：</p><p>首先是这是一个确实可行的方案，之前试过好几个结果都是有问题。</p><p>但是免费只能用随机地址，一天一换还是很讨厌的。</p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8-cpolar/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8-cpolar/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>宝塔面板作为简单好用的<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>运维管理面板，它支持Linux&#x2F;Windows系统，我们可用它来一键配置LAMP&#x2F;LNMP环境、网站、<a]]>
    </summary>
    <title>Cpolar</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h2 id="frp-内网穿透"><a href="#frp-内网穿透" class="headerlink" title="frp 内网穿透"></a>frp 内网穿透</h2><p><a href="https://zhuanlan.zhihu.com/p/682732358">2024最新宝塔服务器做内网穿透教程，亲测可用 - 知乎 (zhihu.com)</a></p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8-FRP/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8-FRP/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h2 id="frp-内网穿透"><a href="#frp-内网穿透" class="headerlink" title="frp 内网穿透"></a>frp 内网穿透</h2><p><a href="https://zhuanlan.zhihu.com/p/682732358">2024最新宝塔服务器做内网穿透教程，亲测可用 - 知乎]]>
    </summary>
    <title>FRP</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<p><a href="https://www.cnblogs.com/LMIx/p/10789410.html">windows 10 防火墙设置规则：允许特定ip端口 - _STAyy - 博客园 (cnblogs.com)</a></p><p>尝试失败。</p><p>校园网的ip出入限制很麻烦，去年买主机、十月买服务器的时候都试过在同一局域网下互相连接，结果都失败了。</p><p>今年一月考完试再次试了试，这次插了根网线把两台主机连起来，结果可以互相连通了。之后就没再管。</p><p>4月初，也就是最近又有了需求，再次尝试结果失败了，插了网线又成了。第二天再试又不行了。WTM</p><p>耗时耗力结果却不尽人意。</p><p>权且放弃</p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8-%E9%98%B2%E7%81%AB%E5%A2%99/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8-%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<p><a href="https://www.cnblogs.com/LMIx/p/10789410.html">windows 10 防火墙设置规则：允许特定ip端口 - _STAyy - 博客园]]>
    </summary>
    <title>防火墙</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<p><a href="https://www.bt.cn/bbs/thread-19376-1-1.html">宝塔Linux面板安装教程 - 2024年1月3日更新 - 8.0.5正式版 - Linux面板 - 宝塔面板论坛 (bt.cn)</a></p><p>官网下载：<a href="https://www.bt.cn/new/download.html">宝塔面板下载，免费全能的服务器运维软件 (bt.cn)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Complete!</span><br><span class="line">Created symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service → /usr/lib/systemd/system/firewalld.service.</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/firewalld.service → /usr/lib/systemd/system/firewalld.service.</span><br><span class="line">success</span><br><span class="line">==================================================================</span><br><span class="line">Congratulations! Installed successfully!</span><br><span class="line">========================面板账户登录信息==========================</span><br><span class="line"></span><br><span class="line"> 外网面板地址: https://47.236.110.159:41617/8f739bf3</span><br><span class="line"> 内网面板地址: https://172.17.59.55:41617/8f739bf3</span><br><span class="line"> username: sievawp1</span><br><span class="line"> password: a1a8537a</span><br><span class="line"> </span><br><span class="line">=========================打开面板前请看===========================</span><br><span class="line"></span><br><span class="line"> 【云服务器】请在安全组放行 41617 端口</span><br><span class="line"> 因默认启用自签证书https加密访问，浏览器将提示不安全</span><br><span class="line"> 点击【高级】-【继续访问】或【接受风险并继续】访问</span><br><span class="line"> 教程：https://www.bt.cn/bbs/thread-117246-1-1.html</span><br><span class="line"></span><br><span class="line">==================================================================</span><br><span class="line"></span><br><span class="line">宝塔面板交流QQ群：435590797</span><br><span class="line"></span><br><span class="line">==================================================================</span><br></pre></td></tr></table></figure>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<p><a href="https://www.bt.cn/bbs/thread-19376-1-1.html">宝塔Linux面板安装教程 - 2024年1月3日更新 - 8.0.5正式版 - Linux面板 - 宝塔面板论坛 (bt.cn)</a></p>
<p>官网下载：<a href="https://www.bt.cn/new/download.html">宝塔面板下载，免费全能的服务器运维软件 (bt.cn)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span]]>
    </summary>
    <title>宝塔面板</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h3 id="站点"><a href="#站点" class="headerlink" title="站点"></a>站点</h3><p>Wiki：</p><p><a href="https://zh.minecraft.wiki/">中文 Minecraft Wiki</a></p><p><a href="https://minecraft.fandom.com/zh/wiki/Minecraft_Wiki">中文Minecraft Wiki - 最详细的我的世界百科 (fandom.com)</a></p><p><a href="https://www.minecraftzw.com/">我的世界中文站 - 国内知名Minecraft中文主题网站 (minecraftzw.com)</a></p><p><a href="https://www.mc-bbs.vip/">Minecraft(我的世界)中文论坛——Minecraft中文站,我的世界中文论坛,我的世界论坛 - (mc-bbs.vip)</a></p>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5-Minecraft/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5-Minecraft/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h3 id="站点"><a href="#站点" class="headerlink" title="站点"></a>站点</h3><p>Wiki：</p>
<p><a href="https://zh.minecraft.wiki/">中文 Minecraft Wiki</a></p>
<p><a href="https://minecraft.fandom.com/zh/wiki/Minecraft_Wiki">中文Minecraft Wiki - 最详细的我的世界百科 (fandom.com)</a></p>
<p><a]]>
    </summary>
    <title>Minecraft</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
  <entry>
    <author>
      <name>H1S97X</name>
    </author>
    <content>
      <![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 <strong>进程</strong>：每一个应用程序&#x2F;游戏启动，都会产生至少一个进程Process，在任务管理器里可以看到进程名称和进程PID。</p><p>2、 句柄：英文HANDLE，一个整数值。数据的地址需要变动，变动以后就需要有人来记录管理变动，就好像户籍管理一样，因此系统用句柄来记载数据地址的变更。肉眼看到的一个个文件夹，窗口，按钮，图标，应用程序能够通过句柄访问相应的对象的信息</p><p>3、 数据类型：游戏中的血量、蓝、生命值，我们将他们称之为变量，变量包含了变量名称和数据类型，那么它的名字就是”血量、生命值”等等，而它的数据类型决定了数值以何种方式存储到计算机的内存中，想要找到自身需要的变量，如果可以确定这个变量的数据类型或者有根据的推测来缩小变量的数据类型范围，那么对于快速定位该变量是具有帮助性的。以下是几种常见的变量类型：</p><p>整数型：游戏中比如血量、法力可能用到这种类型。</p><p>字节型：根据不同的编辑器，1个整形占用N个字节(N&gt;1)，一般很早之前出产的GBA游戏为了节省开销会用到这种类型。</p><p>浮点型：带有小数点的数字，如果金币或者伤害值带有小数点，那很可能是这种数据类型保存的。</p><p>文本型：比如世界喊话，人物命名，一般采用文本型保存这类数据。</p><p>4、 **钩子：**钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程序以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。</p><p>外挂现在大体上来讲分为三种，分别是模拟按键，WPE封包和内存挂</p><ul><li>模拟键盘的，鼠标的，这种就叫做按键模拟，也叫脚本精灵</li><li>修改数据包的，这种就叫做WPE封包外挂，这种外挂相对而言比较稳定，但是对于技术要求难度也比较高，因为修改WPE封包，你需要知道和了解加密解密算法等等一系列的知识</li><li>修改本地内存的，这种相对而言比较常见，市场上面比较常见的也是这种游戏外挂，相对而言技术要求也不是太高，资料也比较齐全，比较大众</li></ul><p>修改服务器内存的比较少见，技术太高一般人没有办法入手</p><p><strong>基本流程</strong></p><ol><li><strong>找到游戏进程</strong></li><li><strong>然后找到游戏窗口的句柄</strong></li><li><strong>找到存储变量的内存地址</strong></li><li><strong>利用编程语言建立工具修改变量的数值</strong></li></ol><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>CE</p><p>WPE</p><p>OD</p><h3 id="内存挂"><a href="#内存挂" class="headerlink" title="内存挂"></a>内存挂</h3><p>其实，制作内存挂也不是很难，步骤就这么几步</p><ul><li>找游戏数据内存地址，偏移地址</li><li>修改内存地址的值，达到外挂的目的</li><li>用编程语言写出一个程序，使得外挂方便于携带传输，同时也方便于下次玩游戏直接使用</li></ul><p>其实第三步主要是方便使用，方便贩卖等等，很多时候对于一个高手而言，根本不需要写出来，记录下内存地址，偏移地址以后，下次上游戏直接工具里面修改就是了。但是如果经常玩某个游戏，可以写出来，用不着每次玩游戏都去修改。（Cheat engine）</p><h5 id="内存基址和物理地址"><a href="#内存基址和物理地址" class="headerlink" title="内存基址和物理地址"></a>内存基址和物理地址</h5><p>物理地址 动态，每次启动应用程序附加到内存时的位置是不同的，但是基址是不变的。</p><p>物理地址 &#x3D; 一级偏移地址 + 偏移地址<br>一级偏移地址 &#x3D; 二级偏移地址 + 偏移地址<br>二级偏移地址 &#x3D; 三级偏移地址 + 偏移地址<br>三级偏移地址 &#x3D; 游戏技能基址 + 偏移地址</p><blockquote><p>在CE工具中，绿色代表静态地址，红色代表上一次操作改变的地址，黑色代表动态地址但上一次操作没有改变。而要找的基址就是静态基址。</p></blockquote><p>模块：pywin32 ctypes</p><p>请认准窗口名称：Plants vs. Zombies 1.2.0.1073 RELEASE</p><p><strong>以下均为16进制</strong><br>基址: 007794f8<br>阳光：+868+5578 （两次偏移）<br>金钱： +950+50 （两次偏移）</p><p>实战——植物大战僵尸PVZ</p><p>进入游戏，查找阳光数值 -&gt; 变动后再次查找，直到剩下一个</p><blockquote><p>有时会发现有两个数值的情况，这个时候去检查一下每个地址的操作码执行情况，一般数值修改就是add和mov指令</p></blockquote><p>找到这个地址后，用快捷键F6或者右键选中“找出是什么修改了这个地址”，回到游戏让数值发生变动（例如拾取阳光，放置植物等），就可以看到有操作码执行了。</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 <strong>进程</strong>：每一个应用程序&#x2F;游戏启动，都会产生至少一个进程Process，在任务管理器里可以看到进程名称和进程PID。</p><p>2、 句柄：英文HANDLE，一个整数值。数据的地址需要变动，变动以后就需要有人来记录管理变动，就好像户籍管理一样，因此系统用句柄来记载数据地址的变更。肉眼看到的一个个文件夹，窗口，按钮，图标，应用程序能够通过句柄访问相应的对象的信息</p><p>3、 数据类型：游戏中的血量、蓝、生命值，我们将他们称之为变量，变量包含了变量名称和数据类型，那么它的名字就是”血量、生命值”等等，而它的数据类型决定了数值以何种方式存储到计算机的内存中，想要找到自身需要的变量，如果可以确定这个变量的数据类型或者有根据的推测来缩小变量的数据类型范围，那么对于快速定位该变量是具有帮助性的。以下是几种常见的变量类型：</p><p>整数型：游戏中比如血量、法力可能用到这种类型。</p><p>字节型：根据不同的编辑器，1个整形占用N个字节(N&gt;1)，一般很早之前出产的GBA游戏为了节省开销会用到这种类型。</p><p>浮点型：带有小数点的数字，如果金币或者伤害值带有小数点，那很可能是这种数据类型保存的。</p><p>文本型：比如世界喊话，人物命名，一般采用文本型保存这类数据。</p><p>4、 **钩子：**钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程序以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。</p><p>外挂现在大体上来讲分为三种，分别是模拟按键，WPE封包和内存挂</p><ul><li>模拟键盘的，鼠标的，这种就叫做按键模拟，也叫脚本精灵</li><li>修改数据包的，这种就叫做WPE封包外挂，这种外挂相对而言比较稳定，但是对于技术要求难度也比较高，因为修改WPE封包，你需要知道和了解加密解密算法等等一系列的知识</li><li>修改本地内存的，这种相对而言比较常见，市场上面比较常见的也是这种游戏外挂，相对而言技术要求也不是太高，资料也比较齐全，比较大众</li></ul><p>修改服务器内存的比较少见，技术太高一般人没有办法入手</p><p><strong>基本流程</strong></p><ol><li><strong>找到游戏进程</strong></li><li><strong>然后找到游戏窗口的句柄</strong></li><li><strong>找到存储变量的内存地址</strong></li><li><strong>利用编程语言建立工具修改变量的数值</strong></li></ol><h3 id="软件-1"><a href="#软件-1" class="headerlink" title="软件"></a>软件</h3><p>CE</p><p>WPE</p><p>OD</p><h3 id="内存挂-1"><a href="#内存挂-1" class="headerlink" title="内存挂"></a>内存挂</h3><p>其实，制作内存挂也不是很难，步骤就这么几步</p><ul><li>找游戏数据内存地址，偏移地址</li><li>修改内存地址的值，达到外挂的目的</li><li>用编程语言写出一个程序，使得外挂方便于携带传输，同时也方便于下次玩游戏直接使用</li></ul><p>其实第三步主要是方便使用，方便贩卖等等，很多时候对于一个高手而言，根本不需要写出来，记录下内存地址，偏移地址以后，下次上游戏直接工具里面修改就是了。但是如果经常玩某个游戏，可以写出来，用不着每次玩游戏都去修改。（Cheat engine）</p><h5 id="内存基址和物理地址-1"><a href="#内存基址和物理地址-1" class="headerlink" title="内存基址和物理地址"></a>内存基址和物理地址</h5><p>物理地址 动态，每次启动应用程序附加到内存时的位置是不同的，但是基址是不变的。</p><p>物理地址 &#x3D; 一级偏移地址 + 偏移地址<br>一级偏移地址 &#x3D; 二级偏移地址 + 偏移地址<br>二级偏移地址 &#x3D; 三级偏移地址 + 偏移地址<br>三级偏移地址 &#x3D; 游戏技能基址 + 偏移地址</p><blockquote><p>在CE工具中，绿色代表静态地址，红色代表上一次操作改变的地址，黑色代表动态地址但上一次操作没有改变。而要找的基址就是静态基址。</p></blockquote><p>模块：pywin32 ctypes</p><p>请认准窗口名称：Plants vs. Zombies 1.2.0.1073 RELEASE</p><p><strong>以下均为16进制</strong><br>基址: 007794f8<br>阳光：+868+5578 （两次偏移）<br>金钱： +950+50 （两次偏移）</p><p>实战——植物大战僵尸PVZ</p><p>进入游戏，查找阳光数值 -&gt; 变动后再次查找，直到剩下一个</p><blockquote><p>有时会发现有两个数值的情况，这个时候去检查一下每个地址的操作码执行情况，一般数值修改就是add和mov指令</p></blockquote><p>找到这个地址后，用快捷键F6或者右键选中“找出是什么修改了这个地址”，回到游戏让数值发生变动（例如拾取阳光，放置植物等），就可以看到有操作码执行了。</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426233834591.png" alt="image-20240426233834591"></p><ul><li>首先分析一下<code>mov [edi+00005578],esi</code>这条指令，我们在详细信息中看见，寄存器<code>esi</code>中的代码是<code>0000039D</code>这个值换算成十进制刚好是<code>925</code>，发现什么了吗，对了，这个<code>925</code>就是当前的阳光值。这条指令<code>mov mov [edi+00005578],esi</code>就是把寄存器<code>esi</code>的<code>925</code>的值放入<code>edi+00005578</code>这个地址中去，这个地址是谁呢？这个地址就是刚刚找出来的物理地址，刚好满足前面的公式：<code>物理地址 = 阳光基址地址 + 偏移地址</code></li><li>接下看看<code>add [eax+00005578],ecx</code>这条指令，<code>add</code>指令是相加的意思，前面的<code>mov</code>是赋值或者移动的意思，这条代码的意思就是，把<code>ecx</code>寄存器中的值加入<code>[eax+00005578]</code>这个地址中的值当中去，再看看寄存器<code>eax</code>的地址是多少？刚好又是<code>23560070</code>这个指针数值，那么，我们就可以确定一个事情，那就是<code>23560070</code>这个指针数值，肯定是上一级的地址的指针数值，那么上一级要么是基址，要么还是一个偏移地址，这个需要进一步来确认</li><li>把<code>23560070</code>这个指针数值，再次放到CE中搜索一波，看看这个值对应的地址是多少，看看出来的是一个动态地址还是静态地址（在CE中，黑色的地址表示动态地址，绿色的表示静态地址），这里这个值是十六进制的，所以在搜索的时候，需要勾选搜索框前面的hex，这里填好以后点击新的扫描,首次扫描如图所示：</li></ul><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235454287.png" alt="image-20240426235454287"></p><p>这里搜索出来的值有很多，要怎么确认呢？</p><p>多次点击再次扫描以后发现不管怎么点击都剩下来了52个结果，然后看了一下这些结果中并没有绿色的静态地址，说明至少有二级偏移。其他地址开头几位都比较相似，唯独有几个地址比较特殊，这可能就是我们需要的地址了</p><p>百度了一波，结果所说的是这种开头比较像的是数组，也就是说，遇到这种，基本都不是我们需要的地址，直接放弃，把这两个特殊的拉进下边的地址列表，开始分析，双击地址这一栏，在出来的更改地址窗口中复制下这个地址，然后再勾选指针选项，在出来的内容框中填写入刚刚复制的地址，在上面的内容框中写入刚刚找到的00005560这个偏移地址，得到的结果刚好是阳光的物理地址，最后的阳光值也正好和当前的阳光值一样，并且，这两个地址都是一样的，而且都是动态地址</p><p>如上图所示，这两个地址加上偏移地址都可以得到阳光物理地址，右键-找出是什么访问了这个地址，也就是快捷键的F5</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235347682.png" alt="image-20240426235347682"></p><p>进去以后也是和前面一样出来一个窗口，但是这两个窗口里面的内容就不一样了，第一个地址028BBA80在窗口中会出现内容，但是第二个地址0956BD3C在出现的窗口里面是一片空白，所以，这两个地址中，028BBA80才是我们要找的真正的一级偏移地址，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426234356042.png" alt="image-20240426234356042"></p><p>如上第二幅图所示，找到了真正的一级偏移地址<code>028BBA80</code>后，访问这个地址的窗口中看这些代码指令，通过对比，发现这些代码都指向同一个指针数值<code>028BBA80</code>且都有偏移地址<code>00000868</code>，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235649647.png" alt="image-20240426235649647"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000346546.png" alt="image-20240427000346546"></p><p>有四个怎么办？试一试</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000413321.png" alt="image-20240427000413321"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000451679.png" alt="image-20240427000451679"></p><p>对了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import win32gui</span><br><span class="line">import win32process</span><br><span class="line"></span><br><span class="line"># 窗口句柄</span><br><span class="line">window_handle = win32gui.FindWindow(MainWindow, &quot;Plants vs. Zombies&quot;)</span><br><span class="line"></span><br><span class="line">win32process.GetWindowThreadProcessId(window_handle)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427001003309.png" alt="image-20240427001003309"></p><p>CD修改：</p><blockquote><p>rule：</p><p>当植物处于可使用状态时，内存值为1</p><p>当植物处于CD状态时，内存值为0</p><p>植物种植后，内存值由0开始增加，这个增加的过程就是CD，当内存值到达一定数值后，就会自动归零，此时CD结束</p></blockquote><ul><li>首先分析一下<code>mov [edi+00005578],esi</code>这条指令，我们在详细信息中看见，寄存器<code>esi</code>中的代码是<code>0000039D</code>这个值换算成十进制刚好是<code>925</code>，发现什么了吗，对了，这个<code>925</code>就是当前的阳光值。这条指令<code>mov mov [edi+00005578],esi</code>就是把寄存器<code>esi</code>的<code>925</code>的值放入<code>edi+00005578</code>这个地址中去，这个地址是谁呢？这个地址就是刚刚找出来的物理地址，刚好满足前面的公式：<code>物理地址 = 阳光基址地址 + 偏移地址</code></li><li>接下看看<code>add [eax+00005578],ecx</code>这条指令，<code>add</code>指令是相加的意思，前面的<code>mov</code>是赋值或者移动的意思，这条代码的意思就是，把<code>ecx</code>寄存器中的值加入<code>[eax+00005578]</code>这个地址中的值当中去，再看看寄存器<code>eax</code>的地址是多少？刚好又是<code>23560070</code>这个指针数值，那么，我们就可以确定一个事情，那就是<code>23560070</code>这个指针数值，肯定是上一级的地址的指针数值，那么上一级要么是基址，要么还是一个偏移地址，这个需要进一步来确认</li><li>把<code>23560070</code>这个指针数值，再次放到CE中搜索一波，看看这个值对应的地址是多少，看看出来的是一个动态地址还是静态地址（在CE中，黑色的地址表示动态地址，绿色的表示静态地址），这里这个值是十六进制的，所以在搜索的时候，需要勾选搜索框前面的hex，这里填好以后点击新的扫描,首次扫描如图所示：</li></ul><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 <strong>进程</strong>：每一个应用程序&#x2F;游戏启动，都会产生至少一个进程Process，在任务管理器里可以看到进程名称和进程PID。</p><p>2、 句柄：英文HANDLE，一个整数值。数据的地址需要变动，变动以后就需要有人来记录管理变动，就好像户籍管理一样，因此系统用句柄来记载数据地址的变更。肉眼看到的一个个文件夹，窗口，按钮，图标，应用程序能够通过句柄访问相应的对象的信息</p><p>3、 数据类型：游戏中的血量、蓝、生命值，我们将他们称之为变量，变量包含了变量名称和数据类型，那么它的名字就是”血量、生命值”等等，而它的数据类型决定了数值以何种方式存储到计算机的内存中，想要找到自身需要的变量，如果可以确定这个变量的数据类型或者有根据的推测来缩小变量的数据类型范围，那么对于快速定位该变量是具有帮助性的。以下是几种常见的变量类型：</p><p>整数型：游戏中比如血量、法力可能用到这种类型。</p><p>字节型：根据不同的编辑器，1个整形占用N个字节(N&gt;1)，一般很早之前出产的GBA游戏为了节省开销会用到这种类型。</p><p>浮点型：带有小数点的数字，如果金币或者伤害值带有小数点，那很可能是这种数据类型保存的。</p><p>文本型：比如世界喊话，人物命名，一般采用文本型保存这类数据。</p><p>4、 **钩子：**钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程序以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。</p><p>外挂现在大体上来讲分为三种，分别是模拟按键，WPE封包和内存挂</p><ul><li>模拟键盘的，鼠标的，这种就叫做按键模拟，也叫脚本精灵</li><li>修改数据包的，这种就叫做WPE封包外挂，这种外挂相对而言比较稳定，但是对于技术要求难度也比较高，因为修改WPE封包，你需要知道和了解加密解密算法等等一系列的知识</li><li>修改本地内存的，这种相对而言比较常见，市场上面比较常见的也是这种游戏外挂，相对而言技术要求也不是太高，资料也比较齐全，比较大众</li></ul><p>修改服务器内存的比较少见，技术太高一般人没有办法入手</p><p><strong>基本流程</strong></p><ol><li><strong>找到游戏进程</strong></li><li><strong>然后找到游戏窗口的句柄</strong></li><li><strong>找到存储变量的内存地址</strong></li><li><strong>利用编程语言建立工具修改变量的数值</strong></li></ol><h3 id="软件-2"><a href="#软件-2" class="headerlink" title="软件"></a>软件</h3><p>CE</p><p>WPE</p><p>OD</p><h3 id="内存挂-2"><a href="#内存挂-2" class="headerlink" title="内存挂"></a>内存挂</h3><p>其实，制作内存挂也不是很难，步骤就这么几步</p><ul><li>找游戏数据内存地址，偏移地址</li><li>修改内存地址的值，达到外挂的目的</li><li>用编程语言写出一个程序，使得外挂方便于携带传输，同时也方便于下次玩游戏直接使用</li></ul><p>其实第三步主要是方便使用，方便贩卖等等，很多时候对于一个高手而言，根本不需要写出来，记录下内存地址，偏移地址以后，下次上游戏直接工具里面修改就是了。但是如果经常玩某个游戏，可以写出来，用不着每次玩游戏都去修改。（Cheat engine）</p><h5 id="内存基址和物理地址-2"><a href="#内存基址和物理地址-2" class="headerlink" title="内存基址和物理地址"></a>内存基址和物理地址</h5><p>物理地址 动态，每次启动应用程序附加到内存时的位置是不同的，但是基址是不变的。</p><p>物理地址 &#x3D; 一级偏移地址 + 偏移地址<br>一级偏移地址 &#x3D; 二级偏移地址 + 偏移地址<br>二级偏移地址 &#x3D; 三级偏移地址 + 偏移地址<br>三级偏移地址 &#x3D; 游戏技能基址 + 偏移地址</p><blockquote><p>在CE工具中，绿色代表静态地址，红色代表上一次操作改变的地址，黑色代表动态地址但上一次操作没有改变。而要找的基址就是静态基址。</p></blockquote><p>模块：pywin32 ctypes</p><p>请认准窗口名称：Plants vs. Zombies 1.2.0.1073 RELEASE</p><p><strong>以下均为16进制</strong><br>基址: 007794f8<br>阳光：+868+5578 （两次偏移）<br>金钱： +950+50 （两次偏移）</p><p>实战——植物大战僵尸PVZ</p><p>进入游戏，查找阳光数值 -&gt; 变动后再次查找，直到剩下一个</p><blockquote><p>有时会发现有两个数值的情况，这个时候去检查一下每个地址的操作码执行情况，一般数值修改就是add和mov指令</p></blockquote><p>找到这个地址后，用快捷键F6或者右键选中“找出是什么修改了这个地址”，回到游戏让数值发生变动（例如拾取阳光，放置植物等），就可以看到有操作码执行了。</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426233834591.png" alt="image-20240426233834591"></p><ul><li>首先分析一下<code>mov [edi+00005578],esi</code>这条指令，我们在详细信息中看见，寄存器<code>esi</code>中的代码是<code>0000039D</code>这个值换算成十进制刚好是<code>925</code>，发现什么了吗，对了，这个<code>925</code>就是当前的阳光值。这条指令<code>mov mov [edi+00005578],esi</code>就是把寄存器<code>esi</code>的<code>925</code>的值放入<code>edi+00005578</code>这个地址中去，这个地址是谁呢？这个地址就是刚刚找出来的物理地址，刚好满足前面的公式：<code>物理地址 = 阳光基址地址 + 偏移地址</code></li><li>接下看看<code>add [eax+00005578],ecx</code>这条指令，<code>add</code>指令是相加的意思，前面的<code>mov</code>是赋值或者移动的意思，这条代码的意思就是，把<code>ecx</code>寄存器中的值加入<code>[eax+00005578]</code>这个地址中的值当中去，再看看寄存器<code>eax</code>的地址是多少？刚好又是<code>23560070</code>这个指针数值，那么，我们就可以确定一个事情，那就是<code>23560070</code>这个指针数值，肯定是上一级的地址的指针数值，那么上一级要么是基址，要么还是一个偏移地址，这个需要进一步来确认</li><li>把<code>23560070</code>这个指针数值，再次放到CE中搜索一波，看看这个值对应的地址是多少，看看出来的是一个动态地址还是静态地址（在CE中，黑色的地址表示动态地址，绿色的表示静态地址），这里这个值是十六进制的，所以在搜索的时候，需要勾选搜索框前面的hex，这里填好以后点击新的扫描,首次扫描如图所示：</li></ul><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235454287.png" alt="image-20240426235454287"></p><p>这里搜索出来的值有很多，要怎么确认呢？</p><p>多次点击再次扫描以后发现不管怎么点击都剩下来了52个结果，然后看了一下这些结果中并没有绿色的静态地址，说明至少有二级偏移。其他地址开头几位都比较相似，唯独有几个地址比较特殊，这可能就是我们需要的地址了</p><p>百度了一波，结果所说的是这种开头比较像的是数组，也就是说，遇到这种，基本都不是我们需要的地址，直接放弃，把这两个特殊的拉进下边的地址列表，开始分析，双击地址这一栏，在出来的更改地址窗口中复制下这个地址，然后再勾选指针选项，在出来的内容框中填写入刚刚复制的地址，在上面的内容框中写入刚刚找到的00005560这个偏移地址，得到的结果刚好是阳光的物理地址，最后的阳光值也正好和当前的阳光值一样，并且，这两个地址都是一样的，而且都是动态地址</p><p>如上图所示，这两个地址加上偏移地址都可以得到阳光物理地址，右键-找出是什么访问了这个地址，也就是快捷键的F5</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235347682.png" alt="image-20240426235347682"></p><p>进去以后也是和前面一样出来一个窗口，但是这两个窗口里面的内容就不一样了，第一个地址028BBA80在窗口中会出现内容，但是第二个地址0956BD3C在出现的窗口里面是一片空白，所以，这两个地址中，028BBA80才是我们要找的真正的一级偏移地址，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426234356042.png" alt="image-20240426234356042"></p><p>如上第二幅图所示，找到了真正的一级偏移地址<code>028BBA80</code>后，访问这个地址的窗口中看这些代码指令，通过对比，发现这些代码都指向同一个指针数值<code>028BBA80</code>且都有偏移地址<code>00000868</code>，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235649647.png" alt="image-20240426235649647"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000346546.png" alt="image-20240427000346546"></p><p>有四个怎么办？试一试</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000413321.png" alt="image-20240427000413321"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000451679.png" alt="image-20240427000451679"></p><p>对了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import win32gui</span><br><span class="line">import win32process</span><br><span class="line"></span><br><span class="line"># 窗口句柄</span><br><span class="line">window_handle = win32gui.FindWindow(MainWindow, &quot;Plants vs. Zombies&quot;)</span><br><span class="line"></span><br><span class="line">win32process.GetWindowThreadProcessId(window_handle)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427001003309.png" alt="image-20240427001003309"></p><p>CD修改：</p><blockquote><p>rule：</p><p>当植物处于可使用状态时，内存值为1</p><p>当植物处于CD状态时，内存值为0</p><p>植物种植后，内存值由0开始增加，这个增加的过程就是CD，当内存值到达一定数值后，就会自动归零，此时CD结束</p></blockquote><p>这里搜索出来的值有很多，要怎么确认呢？</p><p>多次点击再次扫描以后发现不管怎么点击都剩下来了52个结果，然后看了一下这些结果中并没有绿色的静态地址，说明至少有二级偏移。其他地址开头几位都比较相似，唯独有几个地址比较特殊，这可能就是我们需要的地址了</p><p>百度了一波，结果所说的是这种开头比较像的是数组，也就是说，遇到这种，基本都不是我们需要的地址，直接放弃，把这两个特殊的拉进下边的地址列表，开始分析，双击地址这一栏，在出来的更改地址窗口中复制下这个地址，然后再勾选指针选项，在出来的内容框中填写入刚刚复制的地址，在上面的内容框中写入刚刚找到的00005560这个偏移地址，得到的结果刚好是阳光的物理地址，最后的阳光值也正好和当前的阳光值一样，并且，这两个地址都是一样的，而且都是动态地址</p><p>如上图所示，这两个地址加上偏移地址都可以得到阳光物理地址，右键-找出是什么访问了这个地址，也就是快捷键的F5</p><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 <strong>进程</strong>：每一个应用程序&#x2F;游戏启动，都会产生至少一个进程Process，在任务管理器里可以看到进程名称和进程PID。</p><p>2、 句柄：英文HANDLE，一个整数值。数据的地址需要变动，变动以后就需要有人来记录管理变动，就好像户籍管理一样，因此系统用句柄来记载数据地址的变更。肉眼看到的一个个文件夹，窗口，按钮，图标，应用程序能够通过句柄访问相应的对象的信息</p><p>3、 数据类型：游戏中的血量、蓝、生命值，我们将他们称之为变量，变量包含了变量名称和数据类型，那么它的名字就是”血量、生命值”等等，而它的数据类型决定了数值以何种方式存储到计算机的内存中，想要找到自身需要的变量，如果可以确定这个变量的数据类型或者有根据的推测来缩小变量的数据类型范围，那么对于快速定位该变量是具有帮助性的。以下是几种常见的变量类型：</p><p>整数型：游戏中比如血量、法力可能用到这种类型。</p><p>字节型：根据不同的编辑器，1个整形占用N个字节(N&gt;1)，一般很早之前出产的GBA游戏为了节省开销会用到这种类型。</p><p>浮点型：带有小数点的数字，如果金币或者伤害值带有小数点，那很可能是这种数据类型保存的。</p><p>文本型：比如世界喊话，人物命名，一般采用文本型保存这类数据。</p><p>4、 **钩子：**钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程序以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。</p><p>外挂现在大体上来讲分为三种，分别是模拟按键，WPE封包和内存挂</p><ul><li>模拟键盘的，鼠标的，这种就叫做按键模拟，也叫脚本精灵</li><li>修改数据包的，这种就叫做WPE封包外挂，这种外挂相对而言比较稳定，但是对于技术要求难度也比较高，因为修改WPE封包，你需要知道和了解加密解密算法等等一系列的知识</li><li>修改本地内存的，这种相对而言比较常见，市场上面比较常见的也是这种游戏外挂，相对而言技术要求也不是太高，资料也比较齐全，比较大众</li></ul><p>修改服务器内存的比较少见，技术太高一般人没有办法入手</p><p><strong>基本流程</strong></p><ol><li><strong>找到游戏进程</strong></li><li><strong>然后找到游戏窗口的句柄</strong></li><li><strong>找到存储变量的内存地址</strong></li><li><strong>利用编程语言建立工具修改变量的数值</strong></li></ol><h3 id="软件-3"><a href="#软件-3" class="headerlink" title="软件"></a>软件</h3><p>CE</p><p>WPE</p><p>OD</p><h3 id="内存挂-3"><a href="#内存挂-3" class="headerlink" title="内存挂"></a>内存挂</h3><p>其实，制作内存挂也不是很难，步骤就这么几步</p><ul><li>找游戏数据内存地址，偏移地址</li><li>修改内存地址的值，达到外挂的目的</li><li>用编程语言写出一个程序，使得外挂方便于携带传输，同时也方便于下次玩游戏直接使用</li></ul><p>其实第三步主要是方便使用，方便贩卖等等，很多时候对于一个高手而言，根本不需要写出来，记录下内存地址，偏移地址以后，下次上游戏直接工具里面修改就是了。但是如果经常玩某个游戏，可以写出来，用不着每次玩游戏都去修改。（Cheat engine）</p><h5 id="内存基址和物理地址-3"><a href="#内存基址和物理地址-3" class="headerlink" title="内存基址和物理地址"></a>内存基址和物理地址</h5><p>物理地址 动态，每次启动应用程序附加到内存时的位置是不同的，但是基址是不变的。</p><p>物理地址 &#x3D; 一级偏移地址 + 偏移地址<br>一级偏移地址 &#x3D; 二级偏移地址 + 偏移地址<br>二级偏移地址 &#x3D; 三级偏移地址 + 偏移地址<br>三级偏移地址 &#x3D; 游戏技能基址 + 偏移地址</p><blockquote><p>在CE工具中，绿色代表静态地址，红色代表上一次操作改变的地址，黑色代表动态地址但上一次操作没有改变。而要找的基址就是静态基址。</p></blockquote><p>模块：pywin32 ctypes</p><p>请认准窗口名称：Plants vs. Zombies 1.2.0.1073 RELEASE</p><p><strong>以下均为16进制</strong><br>基址: 007794f8<br>阳光：+868+5578 （两次偏移）<br>金钱： +950+50 （两次偏移）</p><p>实战——植物大战僵尸PVZ</p><p>进入游戏，查找阳光数值 -&gt; 变动后再次查找，直到剩下一个</p><blockquote><p>有时会发现有两个数值的情况，这个时候去检查一下每个地址的操作码执行情况，一般数值修改就是add和mov指令</p></blockquote><p>找到这个地址后，用快捷键F6或者右键选中“找出是什么修改了这个地址”，回到游戏让数值发生变动（例如拾取阳光，放置植物等），就可以看到有操作码执行了。</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426233834591.png" alt="image-20240426233834591"></p><ul><li>首先分析一下<code>mov [edi+00005578],esi</code>这条指令，我们在详细信息中看见，寄存器<code>esi</code>中的代码是<code>0000039D</code>这个值换算成十进制刚好是<code>925</code>，发现什么了吗，对了，这个<code>925</code>就是当前的阳光值。这条指令<code>mov mov [edi+00005578],esi</code>就是把寄存器<code>esi</code>的<code>925</code>的值放入<code>edi+00005578</code>这个地址中去，这个地址是谁呢？这个地址就是刚刚找出来的物理地址，刚好满足前面的公式：<code>物理地址 = 阳光基址地址 + 偏移地址</code></li><li>接下看看<code>add [eax+00005578],ecx</code>这条指令，<code>add</code>指令是相加的意思，前面的<code>mov</code>是赋值或者移动的意思，这条代码的意思就是，把<code>ecx</code>寄存器中的值加入<code>[eax+00005578]</code>这个地址中的值当中去，再看看寄存器<code>eax</code>的地址是多少？刚好又是<code>23560070</code>这个指针数值，那么，我们就可以确定一个事情，那就是<code>23560070</code>这个指针数值，肯定是上一级的地址的指针数值，那么上一级要么是基址，要么还是一个偏移地址，这个需要进一步来确认</li><li>把<code>23560070</code>这个指针数值，再次放到CE中搜索一波，看看这个值对应的地址是多少，看看出来的是一个动态地址还是静态地址（在CE中，黑色的地址表示动态地址，绿色的表示静态地址），这里这个值是十六进制的，所以在搜索的时候，需要勾选搜索框前面的hex，这里填好以后点击新的扫描,首次扫描如图所示：</li></ul><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235454287.png" alt="image-20240426235454287"></p><p>这里搜索出来的值有很多，要怎么确认呢？</p><p>多次点击再次扫描以后发现不管怎么点击都剩下来了52个结果，然后看了一下这些结果中并没有绿色的静态地址，说明至少有二级偏移。其他地址开头几位都比较相似，唯独有几个地址比较特殊，这可能就是我们需要的地址了</p><p>百度了一波，结果所说的是这种开头比较像的是数组，也就是说，遇到这种，基本都不是我们需要的地址，直接放弃，把这两个特殊的拉进下边的地址列表，开始分析，双击地址这一栏，在出来的更改地址窗口中复制下这个地址，然后再勾选指针选项，在出来的内容框中填写入刚刚复制的地址，在上面的内容框中写入刚刚找到的00005560这个偏移地址，得到的结果刚好是阳光的物理地址，最后的阳光值也正好和当前的阳光值一样，并且，这两个地址都是一样的，而且都是动态地址</p><p>如上图所示，这两个地址加上偏移地址都可以得到阳光物理地址，右键-找出是什么访问了这个地址，也就是快捷键的F5</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235347682.png" alt="image-20240426235347682"></p><p>进去以后也是和前面一样出来一个窗口，但是这两个窗口里面的内容就不一样了，第一个地址028BBA80在窗口中会出现内容，但是第二个地址0956BD3C在出现的窗口里面是一片空白，所以，这两个地址中，028BBA80才是我们要找的真正的一级偏移地址，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426234356042.png" alt="image-20240426234356042"></p><p>如上第二幅图所示，找到了真正的一级偏移地址<code>028BBA80</code>后，访问这个地址的窗口中看这些代码指令，通过对比，发现这些代码都指向同一个指针数值<code>028BBA80</code>且都有偏移地址<code>00000868</code>，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235649647.png" alt="image-20240426235649647"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000346546.png" alt="image-20240427000346546"></p><p>有四个怎么办？试一试</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000413321.png" alt="image-20240427000413321"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000451679.png" alt="image-20240427000451679"></p><p>对了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import win32gui</span><br><span class="line">import win32process</span><br><span class="line"></span><br><span class="line"># 窗口句柄</span><br><span class="line">window_handle = win32gui.FindWindow(MainWindow, &quot;Plants vs. Zombies&quot;)</span><br><span class="line"></span><br><span class="line">win32process.GetWindowThreadProcessId(window_handle)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427001003309.png" alt="image-20240427001003309"></p><p>CD修改：</p><blockquote><p>rule：</p><p>当植物处于可使用状态时，内存值为1</p><p>当植物处于CD状态时，内存值为0</p><p>植物种植后，内存值由0开始增加，这个增加的过程就是CD，当内存值到达一定数值后，就会自动归零，此时CD结束</p></blockquote><p>进去以后也是和前面一样出来一个窗口，但是这两个窗口里面的内容就不一样了，第一个地址028BBA80在窗口中会出现内容，但是第二个地址0956BD3C在出现的窗口里面是一片空白，所以，这两个地址中，028BBA80才是我们要找的真正的一级偏移地址，如图所示：</p><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 <strong>进程</strong>：每一个应用程序&#x2F;游戏启动，都会产生至少一个进程Process，在任务管理器里可以看到进程名称和进程PID。</p><p>2、 句柄：英文HANDLE，一个整数值。数据的地址需要变动，变动以后就需要有人来记录管理变动，就好像户籍管理一样，因此系统用句柄来记载数据地址的变更。肉眼看到的一个个文件夹，窗口，按钮，图标，应用程序能够通过句柄访问相应的对象的信息</p><p>3、 数据类型：游戏中的血量、蓝、生命值，我们将他们称之为变量，变量包含了变量名称和数据类型，那么它的名字就是”血量、生命值”等等，而它的数据类型决定了数值以何种方式存储到计算机的内存中，想要找到自身需要的变量，如果可以确定这个变量的数据类型或者有根据的推测来缩小变量的数据类型范围，那么对于快速定位该变量是具有帮助性的。以下是几种常见的变量类型：</p><p>整数型：游戏中比如血量、法力可能用到这种类型。</p><p>字节型：根据不同的编辑器，1个整形占用N个字节(N&gt;1)，一般很早之前出产的GBA游戏为了节省开销会用到这种类型。</p><p>浮点型：带有小数点的数字，如果金币或者伤害值带有小数点，那很可能是这种数据类型保存的。</p><p>文本型：比如世界喊话，人物命名，一般采用文本型保存这类数据。</p><p>4、 **钩子：**钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程序以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。</p><p>外挂现在大体上来讲分为三种，分别是模拟按键，WPE封包和内存挂</p><ul><li>模拟键盘的，鼠标的，这种就叫做按键模拟，也叫脚本精灵</li><li>修改数据包的，这种就叫做WPE封包外挂，这种外挂相对而言比较稳定，但是对于技术要求难度也比较高，因为修改WPE封包，你需要知道和了解加密解密算法等等一系列的知识</li><li>修改本地内存的，这种相对而言比较常见，市场上面比较常见的也是这种游戏外挂，相对而言技术要求也不是太高，资料也比较齐全，比较大众</li></ul><p>修改服务器内存的比较少见，技术太高一般人没有办法入手</p><p><strong>基本流程</strong></p><ol><li><strong>找到游戏进程</strong></li><li><strong>然后找到游戏窗口的句柄</strong></li><li><strong>找到存储变量的内存地址</strong></li><li><strong>利用编程语言建立工具修改变量的数值</strong></li></ol><h3 id="软件-4"><a href="#软件-4" class="headerlink" title="软件"></a>软件</h3><p>CE</p><p>WPE</p><p>OD</p><h3 id="内存挂-4"><a href="#内存挂-4" class="headerlink" title="内存挂"></a>内存挂</h3><p>其实，制作内存挂也不是很难，步骤就这么几步</p><ul><li>找游戏数据内存地址，偏移地址</li><li>修改内存地址的值，达到外挂的目的</li><li>用编程语言写出一个程序，使得外挂方便于携带传输，同时也方便于下次玩游戏直接使用</li></ul><p>其实第三步主要是方便使用，方便贩卖等等，很多时候对于一个高手而言，根本不需要写出来，记录下内存地址，偏移地址以后，下次上游戏直接工具里面修改就是了。但是如果经常玩某个游戏，可以写出来，用不着每次玩游戏都去修改。（Cheat engine）</p><h5 id="内存基址和物理地址-4"><a href="#内存基址和物理地址-4" class="headerlink" title="内存基址和物理地址"></a>内存基址和物理地址</h5><p>物理地址 动态，每次启动应用程序附加到内存时的位置是不同的，但是基址是不变的。</p><p>物理地址 &#x3D; 一级偏移地址 + 偏移地址<br>一级偏移地址 &#x3D; 二级偏移地址 + 偏移地址<br>二级偏移地址 &#x3D; 三级偏移地址 + 偏移地址<br>三级偏移地址 &#x3D; 游戏技能基址 + 偏移地址</p><blockquote><p>在CE工具中，绿色代表静态地址，红色代表上一次操作改变的地址，黑色代表动态地址但上一次操作没有改变。而要找的基址就是静态基址。</p></blockquote><p>模块：pywin32 ctypes</p><p>请认准窗口名称：Plants vs. Zombies 1.2.0.1073 RELEASE</p><p><strong>以下均为16进制</strong><br>基址: 007794f8<br>阳光：+868+5578 （两次偏移）<br>金钱： +950+50 （两次偏移）</p><p>实战——植物大战僵尸PVZ</p><p>进入游戏，查找阳光数值 -&gt; 变动后再次查找，直到剩下一个</p><blockquote><p>有时会发现有两个数值的情况，这个时候去检查一下每个地址的操作码执行情况，一般数值修改就是add和mov指令</p></blockquote><p>找到这个地址后，用快捷键F6或者右键选中“找出是什么修改了这个地址”，回到游戏让数值发生变动（例如拾取阳光，放置植物等），就可以看到有操作码执行了。</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426233834591.png" alt="image-20240426233834591"></p><ul><li>首先分析一下<code>mov [edi+00005578],esi</code>这条指令，我们在详细信息中看见，寄存器<code>esi</code>中的代码是<code>0000039D</code>这个值换算成十进制刚好是<code>925</code>，发现什么了吗，对了，这个<code>925</code>就是当前的阳光值。这条指令<code>mov mov [edi+00005578],esi</code>就是把寄存器<code>esi</code>的<code>925</code>的值放入<code>edi+00005578</code>这个地址中去，这个地址是谁呢？这个地址就是刚刚找出来的物理地址，刚好满足前面的公式：<code>物理地址 = 阳光基址地址 + 偏移地址</code></li><li>接下看看<code>add [eax+00005578],ecx</code>这条指令，<code>add</code>指令是相加的意思，前面的<code>mov</code>是赋值或者移动的意思，这条代码的意思就是，把<code>ecx</code>寄存器中的值加入<code>[eax+00005578]</code>这个地址中的值当中去，再看看寄存器<code>eax</code>的地址是多少？刚好又是<code>23560070</code>这个指针数值，那么，我们就可以确定一个事情，那就是<code>23560070</code>这个指针数值，肯定是上一级的地址的指针数值，那么上一级要么是基址，要么还是一个偏移地址，这个需要进一步来确认</li><li>把<code>23560070</code>这个指针数值，再次放到CE中搜索一波，看看这个值对应的地址是多少，看看出来的是一个动态地址还是静态地址（在CE中，黑色的地址表示动态地址，绿色的表示静态地址），这里这个值是十六进制的，所以在搜索的时候，需要勾选搜索框前面的hex，这里填好以后点击新的扫描,首次扫描如图所示：</li></ul><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235454287.png" alt="image-20240426235454287"></p><p>这里搜索出来的值有很多，要怎么确认呢？</p><p>多次点击再次扫描以后发现不管怎么点击都剩下来了52个结果，然后看了一下这些结果中并没有绿色的静态地址，说明至少有二级偏移。其他地址开头几位都比较相似，唯独有几个地址比较特殊，这可能就是我们需要的地址了</p><p>百度了一波，结果所说的是这种开头比较像的是数组，也就是说，遇到这种，基本都不是我们需要的地址，直接放弃，把这两个特殊的拉进下边的地址列表，开始分析，双击地址这一栏，在出来的更改地址窗口中复制下这个地址，然后再勾选指针选项，在出来的内容框中填写入刚刚复制的地址，在上面的内容框中写入刚刚找到的00005560这个偏移地址，得到的结果刚好是阳光的物理地址，最后的阳光值也正好和当前的阳光值一样，并且，这两个地址都是一样的，而且都是动态地址</p><p>如上图所示，这两个地址加上偏移地址都可以得到阳光物理地址，右键-找出是什么访问了这个地址，也就是快捷键的F5</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235347682.png" alt="image-20240426235347682"></p><p>进去以后也是和前面一样出来一个窗口，但是这两个窗口里面的内容就不一样了，第一个地址028BBA80在窗口中会出现内容，但是第二个地址0956BD3C在出现的窗口里面是一片空白，所以，这两个地址中，028BBA80才是我们要找的真正的一级偏移地址，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426234356042.png" alt="image-20240426234356042"></p><p>如上第二幅图所示，找到了真正的一级偏移地址<code>028BBA80</code>后，访问这个地址的窗口中看这些代码指令，通过对比，发现这些代码都指向同一个指针数值<code>028BBA80</code>且都有偏移地址<code>00000868</code>，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235649647.png" alt="image-20240426235649647"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000346546.png" alt="image-20240427000346546"></p><p>有四个怎么办？试一试</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000413321.png" alt="image-20240427000413321"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000451679.png" alt="image-20240427000451679"></p><p>对了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import win32gui</span><br><span class="line">import win32process</span><br><span class="line"></span><br><span class="line"># 窗口句柄</span><br><span class="line">window_handle = win32gui.FindWindow(MainWindow, &quot;Plants vs. Zombies&quot;)</span><br><span class="line"></span><br><span class="line">win32process.GetWindowThreadProcessId(window_handle)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427001003309.png" alt="image-20240427001003309"></p><p>CD修改：</p><blockquote><p>rule：</p><p>当植物处于可使用状态时，内存值为1</p><p>当植物处于CD状态时，内存值为0</p><p>植物种植后，内存值由0开始增加，这个增加的过程就是CD，当内存值到达一定数值后，就会自动归零，此时CD结束</p></blockquote><p>如上第二幅图所示，找到了真正的一级偏移地址<code>028BBA80</code>后，访问这个地址的窗口中看这些代码指令，通过对比，发现这些代码都指向同一个指针数值<code>028BBA80</code>且都有偏移地址<code>00000868</code>，如图所示：</p><h3 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 <strong>进程</strong>：每一个应用程序&#x2F;游戏启动，都会产生至少一个进程Process，在任务管理器里可以看到进程名称和进程PID。</p><p>2、 句柄：英文HANDLE，一个整数值。数据的地址需要变动，变动以后就需要有人来记录管理变动，就好像户籍管理一样，因此系统用句柄来记载数据地址的变更。肉眼看到的一个个文件夹，窗口，按钮，图标，应用程序能够通过句柄访问相应的对象的信息</p><p>3、 数据类型：游戏中的血量、蓝、生命值，我们将他们称之为变量，变量包含了变量名称和数据类型，那么它的名字就是”血量、生命值”等等，而它的数据类型决定了数值以何种方式存储到计算机的内存中，想要找到自身需要的变量，如果可以确定这个变量的数据类型或者有根据的推测来缩小变量的数据类型范围，那么对于快速定位该变量是具有帮助性的。以下是几种常见的变量类型：</p><p>整数型：游戏中比如血量、法力可能用到这种类型。</p><p>字节型：根据不同的编辑器，1个整形占用N个字节(N&gt;1)，一般很早之前出产的GBA游戏为了节省开销会用到这种类型。</p><p>浮点型：带有小数点的数字，如果金币或者伤害值带有小数点，那很可能是这种数据类型保存的。</p><p>文本型：比如世界喊话，人物命名，一般采用文本型保存这类数据。</p><p>4、 **钩子：**钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程序以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。</p><p>外挂现在大体上来讲分为三种，分别是模拟按键，WPE封包和内存挂</p><ul><li>模拟键盘的，鼠标的，这种就叫做按键模拟，也叫脚本精灵</li><li>修改数据包的，这种就叫做WPE封包外挂，这种外挂相对而言比较稳定，但是对于技术要求难度也比较高，因为修改WPE封包，你需要知道和了解加密解密算法等等一系列的知识</li><li>修改本地内存的，这种相对而言比较常见，市场上面比较常见的也是这种游戏外挂，相对而言技术要求也不是太高，资料也比较齐全，比较大众</li></ul><p>修改服务器内存的比较少见，技术太高一般人没有办法入手</p><p><strong>基本流程</strong></p><ol><li><strong>找到游戏进程</strong></li><li><strong>然后找到游戏窗口的句柄</strong></li><li><strong>找到存储变量的内存地址</strong></li><li><strong>利用编程语言建立工具修改变量的数值</strong></li></ol><h3 id="软件-5"><a href="#软件-5" class="headerlink" title="软件"></a>软件</h3><p>CE</p><p>WPE</p><p>OD</p><h3 id="内存挂-5"><a href="#内存挂-5" class="headerlink" title="内存挂"></a>内存挂</h3><p>其实，制作内存挂也不是很难，步骤就这么几步</p><ul><li>找游戏数据内存地址，偏移地址</li><li>修改内存地址的值，达到外挂的目的</li><li>用编程语言写出一个程序，使得外挂方便于携带传输，同时也方便于下次玩游戏直接使用</li></ul><p>其实第三步主要是方便使用，方便贩卖等等，很多时候对于一个高手而言，根本不需要写出来，记录下内存地址，偏移地址以后，下次上游戏直接工具里面修改就是了。但是如果经常玩某个游戏，可以写出来，用不着每次玩游戏都去修改。（Cheat engine）</p><h5 id="内存基址和物理地址-5"><a href="#内存基址和物理地址-5" class="headerlink" title="内存基址和物理地址"></a>内存基址和物理地址</h5><p>物理地址 动态，每次启动应用程序附加到内存时的位置是不同的，但是基址是不变的。</p><p>物理地址 &#x3D; 一级偏移地址 + 偏移地址<br>一级偏移地址 &#x3D; 二级偏移地址 + 偏移地址<br>二级偏移地址 &#x3D; 三级偏移地址 + 偏移地址<br>三级偏移地址 &#x3D; 游戏技能基址 + 偏移地址</p><blockquote><p>在CE工具中，绿色代表静态地址，红色代表上一次操作改变的地址，黑色代表动态地址但上一次操作没有改变。而要找的基址就是静态基址。</p></blockquote><p>模块：pywin32 ctypes</p><p>请认准窗口名称：Plants vs. Zombies 1.2.0.1073 RELEASE</p><p><strong>以下均为16进制</strong><br>基址: 007794f8<br>阳光：+868+5578 （两次偏移）<br>金钱： +950+50 （两次偏移）</p><p>实战——植物大战僵尸PVZ</p><p>进入游戏，查找阳光数值 -&gt; 变动后再次查找，直到剩下一个</p><blockquote><p>有时会发现有两个数值的情况，这个时候去检查一下每个地址的操作码执行情况，一般数值修改就是add和mov指令</p></blockquote><p>找到这个地址后，用快捷键F6或者右键选中“找出是什么修改了这个地址”，回到游戏让数值发生变动（例如拾取阳光，放置植物等），就可以看到有操作码执行了。</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426233834591.png" alt="image-20240426233834591"></p><ul><li>首先分析一下<code>mov [edi+00005578],esi</code>这条指令，我们在详细信息中看见，寄存器<code>esi</code>中的代码是<code>0000039D</code>这个值换算成十进制刚好是<code>925</code>，发现什么了吗，对了，这个<code>925</code>就是当前的阳光值。这条指令<code>mov mov [edi+00005578],esi</code>就是把寄存器<code>esi</code>的<code>925</code>的值放入<code>edi+00005578</code>这个地址中去，这个地址是谁呢？这个地址就是刚刚找出来的物理地址，刚好满足前面的公式：<code>物理地址 = 阳光基址地址 + 偏移地址</code></li><li>接下看看<code>add [eax+00005578],ecx</code>这条指令，<code>add</code>指令是相加的意思，前面的<code>mov</code>是赋值或者移动的意思，这条代码的意思就是，把<code>ecx</code>寄存器中的值加入<code>[eax+00005578]</code>这个地址中的值当中去，再看看寄存器<code>eax</code>的地址是多少？刚好又是<code>23560070</code>这个指针数值，那么，我们就可以确定一个事情，那就是<code>23560070</code>这个指针数值，肯定是上一级的地址的指针数值，那么上一级要么是基址，要么还是一个偏移地址，这个需要进一步来确认</li><li>把<code>23560070</code>这个指针数值，再次放到CE中搜索一波，看看这个值对应的地址是多少，看看出来的是一个动态地址还是静态地址（在CE中，黑色的地址表示动态地址，绿色的表示静态地址），这里这个值是十六进制的，所以在搜索的时候，需要勾选搜索框前面的hex，这里填好以后点击新的扫描,首次扫描如图所示：</li></ul><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235454287.png" alt="image-20240426235454287"></p><p>这里搜索出来的值有很多，要怎么确认呢？</p><p>多次点击再次扫描以后发现不管怎么点击都剩下来了52个结果，然后看了一下这些结果中并没有绿色的静态地址，说明至少有二级偏移。其他地址开头几位都比较相似，唯独有几个地址比较特殊，这可能就是我们需要的地址了</p><p>百度了一波，结果所说的是这种开头比较像的是数组，也就是说，遇到这种，基本都不是我们需要的地址，直接放弃，把这两个特殊的拉进下边的地址列表，开始分析，双击地址这一栏，在出来的更改地址窗口中复制下这个地址，然后再勾选指针选项，在出来的内容框中填写入刚刚复制的地址，在上面的内容框中写入刚刚找到的00005560这个偏移地址，得到的结果刚好是阳光的物理地址，最后的阳光值也正好和当前的阳光值一样，并且，这两个地址都是一样的，而且都是动态地址</p><p>如上图所示，这两个地址加上偏移地址都可以得到阳光物理地址，右键-找出是什么访问了这个地址，也就是快捷键的F5</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235347682.png" alt="image-20240426235347682"></p><p>进去以后也是和前面一样出来一个窗口，但是这两个窗口里面的内容就不一样了，第一个地址028BBA80在窗口中会出现内容，但是第二个地址0956BD3C在出现的窗口里面是一片空白，所以，这两个地址中，028BBA80才是我们要找的真正的一级偏移地址，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426234356042.png" alt="image-20240426234356042"></p><p>如上第二幅图所示，找到了真正的一级偏移地址<code>028BBA80</code>后，访问这个地址的窗口中看这些代码指令，通过对比，发现这些代码都指向同一个指针数值<code>028BBA80</code>且都有偏移地址<code>00000868</code>，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235649647.png" alt="image-20240426235649647"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000346546.png" alt="image-20240427000346546"></p><p>有四个怎么办？试一试</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000413321.png" alt="image-20240427000413321"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000451679.png" alt="image-20240427000451679"></p><p>对了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import win32gui</span><br><span class="line">import win32process</span><br><span class="line"></span><br><span class="line"># 窗口句柄</span><br><span class="line">window_handle = win32gui.FindWindow(MainWindow, &quot;Plants vs. Zombies&quot;)</span><br><span class="line"></span><br><span class="line">win32process.GetWindowThreadProcessId(window_handle)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427001003309.png" alt="image-20240427001003309"></p><p>CD修改：</p><blockquote><p>rule：</p><p>当植物处于可使用状态时，内存值为1</p><p>当植物处于CD状态时，内存值为0</p><p>植物种植后，内存值由0开始增加，这个增加的过程就是CD，当内存值到达一定数值后，就会自动归零，此时CD结束</p></blockquote><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 <strong>进程</strong>：每一个应用程序&#x2F;游戏启动，都会产生至少一个进程Process，在任务管理器里可以看到进程名称和进程PID。</p><p>2、 句柄：英文HANDLE，一个整数值。数据的地址需要变动，变动以后就需要有人来记录管理变动，就好像户籍管理一样，因此系统用句柄来记载数据地址的变更。肉眼看到的一个个文件夹，窗口，按钮，图标，应用程序能够通过句柄访问相应的对象的信息</p><p>3、 数据类型：游戏中的血量、蓝、生命值，我们将他们称之为变量，变量包含了变量名称和数据类型，那么它的名字就是”血量、生命值”等等，而它的数据类型决定了数值以何种方式存储到计算机的内存中，想要找到自身需要的变量，如果可以确定这个变量的数据类型或者有根据的推测来缩小变量的数据类型范围，那么对于快速定位该变量是具有帮助性的。以下是几种常见的变量类型：</p><p>整数型：游戏中比如血量、法力可能用到这种类型。</p><p>字节型：根据不同的编辑器，1个整形占用N个字节(N&gt;1)，一般很早之前出产的GBA游戏为了节省开销会用到这种类型。</p><p>浮点型：带有小数点的数字，如果金币或者伤害值带有小数点，那很可能是这种数据类型保存的。</p><p>文本型：比如世界喊话，人物命名，一般采用文本型保存这类数据。</p><p>4、 **钩子：**钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程序以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。</p><p>外挂现在大体上来讲分为三种，分别是模拟按键，WPE封包和内存挂</p><ul><li>模拟键盘的，鼠标的，这种就叫做按键模拟，也叫脚本精灵</li><li>修改数据包的，这种就叫做WPE封包外挂，这种外挂相对而言比较稳定，但是对于技术要求难度也比较高，因为修改WPE封包，你需要知道和了解加密解密算法等等一系列的知识</li><li>修改本地内存的，这种相对而言比较常见，市场上面比较常见的也是这种游戏外挂，相对而言技术要求也不是太高，资料也比较齐全，比较大众</li></ul><p>修改服务器内存的比较少见，技术太高一般人没有办法入手</p><p><strong>基本流程</strong></p><ol><li><strong>找到游戏进程</strong></li><li><strong>然后找到游戏窗口的句柄</strong></li><li><strong>找到存储变量的内存地址</strong></li><li><strong>利用编程语言建立工具修改变量的数值</strong></li></ol><h3 id="软件-6"><a href="#软件-6" class="headerlink" title="软件"></a>软件</h3><p>CE</p><p>WPE</p><p>OD</p><h3 id="内存挂-6"><a href="#内存挂-6" class="headerlink" title="内存挂"></a>内存挂</h3><p>其实，制作内存挂也不是很难，步骤就这么几步</p><ul><li>找游戏数据内存地址，偏移地址</li><li>修改内存地址的值，达到外挂的目的</li><li>用编程语言写出一个程序，使得外挂方便于携带传输，同时也方便于下次玩游戏直接使用</li></ul><p>其实第三步主要是方便使用，方便贩卖等等，很多时候对于一个高手而言，根本不需要写出来，记录下内存地址，偏移地址以后，下次上游戏直接工具里面修改就是了。但是如果经常玩某个游戏，可以写出来，用不着每次玩游戏都去修改。（Cheat engine）</p><h5 id="内存基址和物理地址-6"><a href="#内存基址和物理地址-6" class="headerlink" title="内存基址和物理地址"></a>内存基址和物理地址</h5><p>物理地址 动态，每次启动应用程序附加到内存时的位置是不同的，但是基址是不变的。</p><p>物理地址 &#x3D; 一级偏移地址 + 偏移地址<br>一级偏移地址 &#x3D; 二级偏移地址 + 偏移地址<br>二级偏移地址 &#x3D; 三级偏移地址 + 偏移地址<br>三级偏移地址 &#x3D; 游戏技能基址 + 偏移地址</p><blockquote><p>在CE工具中，绿色代表静态地址，红色代表上一次操作改变的地址，黑色代表动态地址但上一次操作没有改变。而要找的基址就是静态基址。</p></blockquote><p>模块：pywin32 ctypes</p><p>请认准窗口名称：Plants vs. Zombies 1.2.0.1073 RELEASE</p><p><strong>以下均为16进制</strong><br>基址: 007794f8<br>阳光：+868+5578 （两次偏移）<br>金钱： +950+50 （两次偏移）</p><p>实战——植物大战僵尸PVZ</p><p>进入游戏，查找阳光数值 -&gt; 变动后再次查找，直到剩下一个</p><blockquote><p>有时会发现有两个数值的情况，这个时候去检查一下每个地址的操作码执行情况，一般数值修改就是add和mov指令</p></blockquote><p>找到这个地址后，用快捷键F6或者右键选中“找出是什么修改了这个地址”，回到游戏让数值发生变动（例如拾取阳光，放置植物等），就可以看到有操作码执行了。</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426233834591.png" alt="image-20240426233834591"></p><ul><li>首先分析一下<code>mov [edi+00005578],esi</code>这条指令，我们在详细信息中看见，寄存器<code>esi</code>中的代码是<code>0000039D</code>这个值换算成十进制刚好是<code>925</code>，发现什么了吗，对了，这个<code>925</code>就是当前的阳光值。这条指令<code>mov mov [edi+00005578],esi</code>就是把寄存器<code>esi</code>的<code>925</code>的值放入<code>edi+00005578</code>这个地址中去，这个地址是谁呢？这个地址就是刚刚找出来的物理地址，刚好满足前面的公式：<code>物理地址 = 阳光基址地址 + 偏移地址</code></li><li>接下看看<code>add [eax+00005578],ecx</code>这条指令，<code>add</code>指令是相加的意思，前面的<code>mov</code>是赋值或者移动的意思，这条代码的意思就是，把<code>ecx</code>寄存器中的值加入<code>[eax+00005578]</code>这个地址中的值当中去，再看看寄存器<code>eax</code>的地址是多少？刚好又是<code>23560070</code>这个指针数值，那么，我们就可以确定一个事情，那就是<code>23560070</code>这个指针数值，肯定是上一级的地址的指针数值，那么上一级要么是基址，要么还是一个偏移地址，这个需要进一步来确认</li><li>把<code>23560070</code>这个指针数值，再次放到CE中搜索一波，看看这个值对应的地址是多少，看看出来的是一个动态地址还是静态地址（在CE中，黑色的地址表示动态地址，绿色的表示静态地址），这里这个值是十六进制的，所以在搜索的时候，需要勾选搜索框前面的hex，这里填好以后点击新的扫描,首次扫描如图所示：</li></ul><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235454287.png" alt="image-20240426235454287"></p><p>这里搜索出来的值有很多，要怎么确认呢？</p><p>多次点击再次扫描以后发现不管怎么点击都剩下来了52个结果，然后看了一下这些结果中并没有绿色的静态地址，说明至少有二级偏移。其他地址开头几位都比较相似，唯独有几个地址比较特殊，这可能就是我们需要的地址了</p><p>百度了一波，结果所说的是这种开头比较像的是数组，也就是说，遇到这种，基本都不是我们需要的地址，直接放弃，把这两个特殊的拉进下边的地址列表，开始分析，双击地址这一栏，在出来的更改地址窗口中复制下这个地址，然后再勾选指针选项，在出来的内容框中填写入刚刚复制的地址，在上面的内容框中写入刚刚找到的00005560这个偏移地址，得到的结果刚好是阳光的物理地址，最后的阳光值也正好和当前的阳光值一样，并且，这两个地址都是一样的，而且都是动态地址</p><p>如上图所示，这两个地址加上偏移地址都可以得到阳光物理地址，右键-找出是什么访问了这个地址，也就是快捷键的F5</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235347682.png" alt="image-20240426235347682"></p><p>进去以后也是和前面一样出来一个窗口，但是这两个窗口里面的内容就不一样了，第一个地址028BBA80在窗口中会出现内容，但是第二个地址0956BD3C在出现的窗口里面是一片空白，所以，这两个地址中，028BBA80才是我们要找的真正的一级偏移地址，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426234356042.png" alt="image-20240426234356042"></p><p>如上第二幅图所示，找到了真正的一级偏移地址<code>028BBA80</code>后，访问这个地址的窗口中看这些代码指令，通过对比，发现这些代码都指向同一个指针数值<code>028BBA80</code>且都有偏移地址<code>00000868</code>，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235649647.png" alt="image-20240426235649647"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000346546.png" alt="image-20240427000346546"></p><p>有四个怎么办？试一试</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000413321.png" alt="image-20240427000413321"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000451679.png" alt="image-20240427000451679"></p><p>对了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import win32gui</span><br><span class="line">import win32process</span><br><span class="line"></span><br><span class="line"># 窗口句柄</span><br><span class="line">window_handle = win32gui.FindWindow(MainWindow, &quot;Plants vs. Zombies&quot;)</span><br><span class="line"></span><br><span class="line">win32process.GetWindowThreadProcessId(window_handle)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427001003309.png" alt="image-20240427001003309"></p><p>CD修改：</p><blockquote><p>rule：</p><p>当植物处于可使用状态时，内存值为1</p><p>当植物处于CD状态时，内存值为0</p><p>植物种植后，内存值由0开始增加，这个增加的过程就是CD，当内存值到达一定数值后，就会自动归零，此时CD结束</p></blockquote><p>有四个怎么办？试一试</p><h3 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 <strong>进程</strong>：每一个应用程序&#x2F;游戏启动，都会产生至少一个进程Process，在任务管理器里可以看到进程名称和进程PID。</p><p>2、 句柄：英文HANDLE，一个整数值。数据的地址需要变动，变动以后就需要有人来记录管理变动，就好像户籍管理一样，因此系统用句柄来记载数据地址的变更。肉眼看到的一个个文件夹，窗口，按钮，图标，应用程序能够通过句柄访问相应的对象的信息</p><p>3、 数据类型：游戏中的血量、蓝、生命值，我们将他们称之为变量，变量包含了变量名称和数据类型，那么它的名字就是”血量、生命值”等等，而它的数据类型决定了数值以何种方式存储到计算机的内存中，想要找到自身需要的变量，如果可以确定这个变量的数据类型或者有根据的推测来缩小变量的数据类型范围，那么对于快速定位该变量是具有帮助性的。以下是几种常见的变量类型：</p><p>整数型：游戏中比如血量、法力可能用到这种类型。</p><p>字节型：根据不同的编辑器，1个整形占用N个字节(N&gt;1)，一般很早之前出产的GBA游戏为了节省开销会用到这种类型。</p><p>浮点型：带有小数点的数字，如果金币或者伤害值带有小数点，那很可能是这种数据类型保存的。</p><p>文本型：比如世界喊话，人物命名，一般采用文本型保存这类数据。</p><p>4、 **钩子：**钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程序以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。</p><p>外挂现在大体上来讲分为三种，分别是模拟按键，WPE封包和内存挂</p><ul><li>模拟键盘的，鼠标的，这种就叫做按键模拟，也叫脚本精灵</li><li>修改数据包的，这种就叫做WPE封包外挂，这种外挂相对而言比较稳定，但是对于技术要求难度也比较高，因为修改WPE封包，你需要知道和了解加密解密算法等等一系列的知识</li><li>修改本地内存的，这种相对而言比较常见，市场上面比较常见的也是这种游戏外挂，相对而言技术要求也不是太高，资料也比较齐全，比较大众</li></ul><p>修改服务器内存的比较少见，技术太高一般人没有办法入手</p><p><strong>基本流程</strong></p><ol><li><strong>找到游戏进程</strong></li><li><strong>然后找到游戏窗口的句柄</strong></li><li><strong>找到存储变量的内存地址</strong></li><li><strong>利用编程语言建立工具修改变量的数值</strong></li></ol><h3 id="软件-7"><a href="#软件-7" class="headerlink" title="软件"></a>软件</h3><p>CE</p><p>WPE</p><p>OD</p><h3 id="内存挂-7"><a href="#内存挂-7" class="headerlink" title="内存挂"></a>内存挂</h3><p>其实，制作内存挂也不是很难，步骤就这么几步</p><ul><li>找游戏数据内存地址，偏移地址</li><li>修改内存地址的值，达到外挂的目的</li><li>用编程语言写出一个程序，使得外挂方便于携带传输，同时也方便于下次玩游戏直接使用</li></ul><p>其实第三步主要是方便使用，方便贩卖等等，很多时候对于一个高手而言，根本不需要写出来，记录下内存地址，偏移地址以后，下次上游戏直接工具里面修改就是了。但是如果经常玩某个游戏，可以写出来，用不着每次玩游戏都去修改。（Cheat engine）</p><h5 id="内存基址和物理地址-7"><a href="#内存基址和物理地址-7" class="headerlink" title="内存基址和物理地址"></a>内存基址和物理地址</h5><p>物理地址 动态，每次启动应用程序附加到内存时的位置是不同的，但是基址是不变的。</p><p>物理地址 &#x3D; 一级偏移地址 + 偏移地址<br>一级偏移地址 &#x3D; 二级偏移地址 + 偏移地址<br>二级偏移地址 &#x3D; 三级偏移地址 + 偏移地址<br>三级偏移地址 &#x3D; 游戏技能基址 + 偏移地址</p><blockquote><p>在CE工具中，绿色代表静态地址，红色代表上一次操作改变的地址，黑色代表动态地址但上一次操作没有改变。而要找的基址就是静态基址。</p></blockquote><p>模块：pywin32 ctypes</p><p>请认准窗口名称：Plants vs. Zombies 1.2.0.1073 RELEASE</p><p><strong>以下均为16进制</strong><br>基址: 007794f8<br>阳光：+868+5578 （两次偏移）<br>金钱： +950+50 （两次偏移）</p><p>实战——植物大战僵尸PVZ</p><p>进入游戏，查找阳光数值 -&gt; 变动后再次查找，直到剩下一个</p><blockquote><p>有时会发现有两个数值的情况，这个时候去检查一下每个地址的操作码执行情况，一般数值修改就是add和mov指令</p></blockquote><p>找到这个地址后，用快捷键F6或者右键选中“找出是什么修改了这个地址”，回到游戏让数值发生变动（例如拾取阳光，放置植物等），就可以看到有操作码执行了。</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426233834591.png" alt="image-20240426233834591"></p><ul><li>首先分析一下<code>mov [edi+00005578],esi</code>这条指令，我们在详细信息中看见，寄存器<code>esi</code>中的代码是<code>0000039D</code>这个值换算成十进制刚好是<code>925</code>，发现什么了吗，对了，这个<code>925</code>就是当前的阳光值。这条指令<code>mov mov [edi+00005578],esi</code>就是把寄存器<code>esi</code>的<code>925</code>的值放入<code>edi+00005578</code>这个地址中去，这个地址是谁呢？这个地址就是刚刚找出来的物理地址，刚好满足前面的公式：<code>物理地址 = 阳光基址地址 + 偏移地址</code></li><li>接下看看<code>add [eax+00005578],ecx</code>这条指令，<code>add</code>指令是相加的意思，前面的<code>mov</code>是赋值或者移动的意思，这条代码的意思就是，把<code>ecx</code>寄存器中的值加入<code>[eax+00005578]</code>这个地址中的值当中去，再看看寄存器<code>eax</code>的地址是多少？刚好又是<code>23560070</code>这个指针数值，那么，我们就可以确定一个事情，那就是<code>23560070</code>这个指针数值，肯定是上一级的地址的指针数值，那么上一级要么是基址，要么还是一个偏移地址，这个需要进一步来确认</li><li>把<code>23560070</code>这个指针数值，再次放到CE中搜索一波，看看这个值对应的地址是多少，看看出来的是一个动态地址还是静态地址（在CE中，黑色的地址表示动态地址，绿色的表示静态地址），这里这个值是十六进制的，所以在搜索的时候，需要勾选搜索框前面的hex，这里填好以后点击新的扫描,首次扫描如图所示：</li></ul><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235454287.png" alt="image-20240426235454287"></p><p>这里搜索出来的值有很多，要怎么确认呢？</p><p>多次点击再次扫描以后发现不管怎么点击都剩下来了52个结果，然后看了一下这些结果中并没有绿色的静态地址，说明至少有二级偏移。其他地址开头几位都比较相似，唯独有几个地址比较特殊，这可能就是我们需要的地址了</p><p>百度了一波，结果所说的是这种开头比较像的是数组，也就是说，遇到这种，基本都不是我们需要的地址，直接放弃，把这两个特殊的拉进下边的地址列表，开始分析，双击地址这一栏，在出来的更改地址窗口中复制下这个地址，然后再勾选指针选项，在出来的内容框中填写入刚刚复制的地址，在上面的内容框中写入刚刚找到的00005560这个偏移地址，得到的结果刚好是阳光的物理地址，最后的阳光值也正好和当前的阳光值一样，并且，这两个地址都是一样的，而且都是动态地址</p><p>如上图所示，这两个地址加上偏移地址都可以得到阳光物理地址，右键-找出是什么访问了这个地址，也就是快捷键的F5</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235347682.png" alt="image-20240426235347682"></p><p>进去以后也是和前面一样出来一个窗口，但是这两个窗口里面的内容就不一样了，第一个地址028BBA80在窗口中会出现内容，但是第二个地址0956BD3C在出现的窗口里面是一片空白，所以，这两个地址中，028BBA80才是我们要找的真正的一级偏移地址，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426234356042.png" alt="image-20240426234356042"></p><p>如上第二幅图所示，找到了真正的一级偏移地址<code>028BBA80</code>后，访问这个地址的窗口中看这些代码指令，通过对比，发现这些代码都指向同一个指针数值<code>028BBA80</code>且都有偏移地址<code>00000868</code>，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235649647.png" alt="image-20240426235649647"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000346546.png" alt="image-20240427000346546"></p><p>有四个怎么办？试一试</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000413321.png" alt="image-20240427000413321"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000451679.png" alt="image-20240427000451679"></p><p>对了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import win32gui</span><br><span class="line">import win32process</span><br><span class="line"></span><br><span class="line"># 窗口句柄</span><br><span class="line">window_handle = win32gui.FindWindow(MainWindow, &quot;Plants vs. Zombies&quot;)</span><br><span class="line"></span><br><span class="line">win32process.GetWindowThreadProcessId(window_handle)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427001003309.png" alt="image-20240427001003309"></p><p>CD修改：</p><blockquote><p>rule：</p><p>当植物处于可使用状态时，内存值为1</p><p>当植物处于CD状态时，内存值为0</p><p>植物种植后，内存值由0开始增加，这个增加的过程就是CD，当内存值到达一定数值后，就会自动归零，此时CD结束</p></blockquote><h3 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 <strong>进程</strong>：每一个应用程序&#x2F;游戏启动，都会产生至少一个进程Process，在任务管理器里可以看到进程名称和进程PID。</p><p>2、 句柄：英文HANDLE，一个整数值。数据的地址需要变动，变动以后就需要有人来记录管理变动，就好像户籍管理一样，因此系统用句柄来记载数据地址的变更。肉眼看到的一个个文件夹，窗口，按钮，图标，应用程序能够通过句柄访问相应的对象的信息</p><p>3、 数据类型：游戏中的血量、蓝、生命值，我们将他们称之为变量，变量包含了变量名称和数据类型，那么它的名字就是”血量、生命值”等等，而它的数据类型决定了数值以何种方式存储到计算机的内存中，想要找到自身需要的变量，如果可以确定这个变量的数据类型或者有根据的推测来缩小变量的数据类型范围，那么对于快速定位该变量是具有帮助性的。以下是几种常见的变量类型：</p><p>整数型：游戏中比如血量、法力可能用到这种类型。</p><p>字节型：根据不同的编辑器，1个整形占用N个字节(N&gt;1)，一般很早之前出产的GBA游戏为了节省开销会用到这种类型。</p><p>浮点型：带有小数点的数字，如果金币或者伤害值带有小数点，那很可能是这种数据类型保存的。</p><p>文本型：比如世界喊话，人物命名，一般采用文本型保存这类数据。</p><p>4、 **钩子：**钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程序以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。</p><p>外挂现在大体上来讲分为三种，分别是模拟按键，WPE封包和内存挂</p><ul><li>模拟键盘的，鼠标的，这种就叫做按键模拟，也叫脚本精灵</li><li>修改数据包的，这种就叫做WPE封包外挂，这种外挂相对而言比较稳定，但是对于技术要求难度也比较高，因为修改WPE封包，你需要知道和了解加密解密算法等等一系列的知识</li><li>修改本地内存的，这种相对而言比较常见，市场上面比较常见的也是这种游戏外挂，相对而言技术要求也不是太高，资料也比较齐全，比较大众</li></ul><p>修改服务器内存的比较少见，技术太高一般人没有办法入手</p><p><strong>基本流程</strong></p><ol><li><strong>找到游戏进程</strong></li><li><strong>然后找到游戏窗口的句柄</strong></li><li><strong>找到存储变量的内存地址</strong></li><li><strong>利用编程语言建立工具修改变量的数值</strong></li></ol><h3 id="软件-8"><a href="#软件-8" class="headerlink" title="软件"></a>软件</h3><p>CE</p><p>WPE</p><p>OD</p><h3 id="内存挂-8"><a href="#内存挂-8" class="headerlink" title="内存挂"></a>内存挂</h3><p>其实，制作内存挂也不是很难，步骤就这么几步</p><ul><li>找游戏数据内存地址，偏移地址</li><li>修改内存地址的值，达到外挂的目的</li><li>用编程语言写出一个程序，使得外挂方便于携带传输，同时也方便于下次玩游戏直接使用</li></ul><p>其实第三步主要是方便使用，方便贩卖等等，很多时候对于一个高手而言，根本不需要写出来，记录下内存地址，偏移地址以后，下次上游戏直接工具里面修改就是了。但是如果经常玩某个游戏，可以写出来，用不着每次玩游戏都去修改。（Cheat engine）</p><h5 id="内存基址和物理地址-8"><a href="#内存基址和物理地址-8" class="headerlink" title="内存基址和物理地址"></a>内存基址和物理地址</h5><p>物理地址 动态，每次启动应用程序附加到内存时的位置是不同的，但是基址是不变的。</p><p>物理地址 &#x3D; 一级偏移地址 + 偏移地址<br>一级偏移地址 &#x3D; 二级偏移地址 + 偏移地址<br>二级偏移地址 &#x3D; 三级偏移地址 + 偏移地址<br>三级偏移地址 &#x3D; 游戏技能基址 + 偏移地址</p><blockquote><p>在CE工具中，绿色代表静态地址，红色代表上一次操作改变的地址，黑色代表动态地址但上一次操作没有改变。而要找的基址就是静态基址。</p></blockquote><p>模块：pywin32 ctypes</p><p>请认准窗口名称：Plants vs. Zombies 1.2.0.1073 RELEASE</p><p><strong>以下均为16进制</strong><br>基址: 007794f8<br>阳光：+868+5578 （两次偏移）<br>金钱： +950+50 （两次偏移）</p><p>实战——植物大战僵尸PVZ</p><p>进入游戏，查找阳光数值 -&gt; 变动后再次查找，直到剩下一个</p><blockquote><p>有时会发现有两个数值的情况，这个时候去检查一下每个地址的操作码执行情况，一般数值修改就是add和mov指令</p></blockquote><p>找到这个地址后，用快捷键F6或者右键选中“找出是什么修改了这个地址”，回到游戏让数值发生变动（例如拾取阳光，放置植物等），就可以看到有操作码执行了。</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426233834591.png" alt="image-20240426233834591"></p><ul><li>首先分析一下<code>mov [edi+00005578],esi</code>这条指令，我们在详细信息中看见，寄存器<code>esi</code>中的代码是<code>0000039D</code>这个值换算成十进制刚好是<code>925</code>，发现什么了吗，对了，这个<code>925</code>就是当前的阳光值。这条指令<code>mov mov [edi+00005578],esi</code>就是把寄存器<code>esi</code>的<code>925</code>的值放入<code>edi+00005578</code>这个地址中去，这个地址是谁呢？这个地址就是刚刚找出来的物理地址，刚好满足前面的公式：<code>物理地址 = 阳光基址地址 + 偏移地址</code></li><li>接下看看<code>add [eax+00005578],ecx</code>这条指令，<code>add</code>指令是相加的意思，前面的<code>mov</code>是赋值或者移动的意思，这条代码的意思就是，把<code>ecx</code>寄存器中的值加入<code>[eax+00005578]</code>这个地址中的值当中去，再看看寄存器<code>eax</code>的地址是多少？刚好又是<code>23560070</code>这个指针数值，那么，我们就可以确定一个事情，那就是<code>23560070</code>这个指针数值，肯定是上一级的地址的指针数值，那么上一级要么是基址，要么还是一个偏移地址，这个需要进一步来确认</li><li>把<code>23560070</code>这个指针数值，再次放到CE中搜索一波，看看这个值对应的地址是多少，看看出来的是一个动态地址还是静态地址（在CE中，黑色的地址表示动态地址，绿色的表示静态地址），这里这个值是十六进制的，所以在搜索的时候，需要勾选搜索框前面的hex，这里填好以后点击新的扫描,首次扫描如图所示：</li></ul><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235454287.png" alt="image-20240426235454287"></p><p>这里搜索出来的值有很多，要怎么确认呢？</p><p>多次点击再次扫描以后发现不管怎么点击都剩下来了52个结果，然后看了一下这些结果中并没有绿色的静态地址，说明至少有二级偏移。其他地址开头几位都比较相似，唯独有几个地址比较特殊，这可能就是我们需要的地址了</p><p>百度了一波，结果所说的是这种开头比较像的是数组，也就是说，遇到这种，基本都不是我们需要的地址，直接放弃，把这两个特殊的拉进下边的地址列表，开始分析，双击地址这一栏，在出来的更改地址窗口中复制下这个地址，然后再勾选指针选项，在出来的内容框中填写入刚刚复制的地址，在上面的内容框中写入刚刚找到的00005560这个偏移地址，得到的结果刚好是阳光的物理地址，最后的阳光值也正好和当前的阳光值一样，并且，这两个地址都是一样的，而且都是动态地址</p><p>如上图所示，这两个地址加上偏移地址都可以得到阳光物理地址，右键-找出是什么访问了这个地址，也就是快捷键的F5</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235347682.png" alt="image-20240426235347682"></p><p>进去以后也是和前面一样出来一个窗口，但是这两个窗口里面的内容就不一样了，第一个地址028BBA80在窗口中会出现内容，但是第二个地址0956BD3C在出现的窗口里面是一片空白，所以，这两个地址中，028BBA80才是我们要找的真正的一级偏移地址，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426234356042.png" alt="image-20240426234356042"></p><p>如上第二幅图所示，找到了真正的一级偏移地址<code>028BBA80</code>后，访问这个地址的窗口中看这些代码指令，通过对比，发现这些代码都指向同一个指针数值<code>028BBA80</code>且都有偏移地址<code>00000868</code>，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235649647.png" alt="image-20240426235649647"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000346546.png" alt="image-20240427000346546"></p><p>有四个怎么办？试一试</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000413321.png" alt="image-20240427000413321"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000451679.png" alt="image-20240427000451679"></p><p>对了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import win32gui</span><br><span class="line">import win32process</span><br><span class="line"></span><br><span class="line"># 窗口句柄</span><br><span class="line">window_handle = win32gui.FindWindow(MainWindow, &quot;Plants vs. Zombies&quot;)</span><br><span class="line"></span><br><span class="line">win32process.GetWindowThreadProcessId(window_handle)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427001003309.png" alt="image-20240427001003309"></p><p>CD修改：</p><blockquote><p>rule：</p><p>当植物处于可使用状态时，内存值为1</p><p>当植物处于CD状态时，内存值为0</p><p>植物种植后，内存值由0开始增加，这个增加的过程就是CD，当内存值到达一定数值后，就会自动归零，此时CD结束</p></blockquote><p>对了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import win32gui</span><br><span class="line">import win32process</span><br><span class="line"></span><br><span class="line"># 窗口句柄</span><br><span class="line">window_handle = win32gui.FindWindow(MainWindow, &quot;Plants vs. Zombies&quot;)</span><br><span class="line"></span><br><span class="line">win32process.GetWindowThreadProcessId(window_handle)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基本概念-9"><a href="#基本概念-9" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 <strong>进程</strong>：每一个应用程序&#x2F;游戏启动，都会产生至少一个进程Process，在任务管理器里可以看到进程名称和进程PID。</p><p>2、 句柄：英文HANDLE，一个整数值。数据的地址需要变动，变动以后就需要有人来记录管理变动，就好像户籍管理一样，因此系统用句柄来记载数据地址的变更。肉眼看到的一个个文件夹，窗口，按钮，图标，应用程序能够通过句柄访问相应的对象的信息</p><p>3、 数据类型：游戏中的血量、蓝、生命值，我们将他们称之为变量，变量包含了变量名称和数据类型，那么它的名字就是”血量、生命值”等等，而它的数据类型决定了数值以何种方式存储到计算机的内存中，想要找到自身需要的变量，如果可以确定这个变量的数据类型或者有根据的推测来缩小变量的数据类型范围，那么对于快速定位该变量是具有帮助性的。以下是几种常见的变量类型：</p><p>整数型：游戏中比如血量、法力可能用到这种类型。</p><p>字节型：根据不同的编辑器，1个整形占用N个字节(N&gt;1)，一般很早之前出产的GBA游戏为了节省开销会用到这种类型。</p><p>浮点型：带有小数点的数字，如果金币或者伤害值带有小数点，那很可能是这种数据类型保存的。</p><p>文本型：比如世界喊话，人物命名，一般采用文本型保存这类数据。</p><p>4、 **钩子：**钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程序以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。</p><p>外挂现在大体上来讲分为三种，分别是模拟按键，WPE封包和内存挂</p><ul><li>模拟键盘的，鼠标的，这种就叫做按键模拟，也叫脚本精灵</li><li>修改数据包的，这种就叫做WPE封包外挂，这种外挂相对而言比较稳定，但是对于技术要求难度也比较高，因为修改WPE封包，你需要知道和了解加密解密算法等等一系列的知识</li><li>修改本地内存的，这种相对而言比较常见，市场上面比较常见的也是这种游戏外挂，相对而言技术要求也不是太高，资料也比较齐全，比较大众</li></ul><p>修改服务器内存的比较少见，技术太高一般人没有办法入手</p><p><strong>基本流程</strong></p><ol><li><strong>找到游戏进程</strong></li><li><strong>然后找到游戏窗口的句柄</strong></li><li><strong>找到存储变量的内存地址</strong></li><li><strong>利用编程语言建立工具修改变量的数值</strong></li></ol><h3 id="软件-9"><a href="#软件-9" class="headerlink" title="软件"></a>软件</h3><p>CE</p><p>WPE</p><p>OD</p><h3 id="内存挂-9"><a href="#内存挂-9" class="headerlink" title="内存挂"></a>内存挂</h3><p>其实，制作内存挂也不是很难，步骤就这么几步</p><ul><li>找游戏数据内存地址，偏移地址</li><li>修改内存地址的值，达到外挂的目的</li><li>用编程语言写出一个程序，使得外挂方便于携带传输，同时也方便于下次玩游戏直接使用</li></ul><p>其实第三步主要是方便使用，方便贩卖等等，很多时候对于一个高手而言，根本不需要写出来，记录下内存地址，偏移地址以后，下次上游戏直接工具里面修改就是了。但是如果经常玩某个游戏，可以写出来，用不着每次玩游戏都去修改。（Cheat engine）</p><h5 id="内存基址和物理地址-9"><a href="#内存基址和物理地址-9" class="headerlink" title="内存基址和物理地址"></a>内存基址和物理地址</h5><p>物理地址 动态，每次启动应用程序附加到内存时的位置是不同的，但是基址是不变的。</p><p>物理地址 &#x3D; 一级偏移地址 + 偏移地址<br>一级偏移地址 &#x3D; 二级偏移地址 + 偏移地址<br>二级偏移地址 &#x3D; 三级偏移地址 + 偏移地址<br>三级偏移地址 &#x3D; 游戏技能基址 + 偏移地址</p><blockquote><p>在CE工具中，绿色代表静态地址，红色代表上一次操作改变的地址，黑色代表动态地址但上一次操作没有改变。而要找的基址就是静态基址。</p></blockquote><p>模块：pywin32 ctypes</p><p>请认准窗口名称：Plants vs. Zombies 1.2.0.1073 RELEASE</p><p><strong>以下均为16进制</strong><br>基址: 007794f8<br>阳光：+868+5578 （两次偏移）<br>金钱： +950+50 （两次偏移）</p><p>实战——植物大战僵尸PVZ</p><p>进入游戏，查找阳光数值 -&gt; 变动后再次查找，直到剩下一个</p><blockquote><p>有时会发现有两个数值的情况，这个时候去检查一下每个地址的操作码执行情况，一般数值修改就是add和mov指令</p></blockquote><p>找到这个地址后，用快捷键F6或者右键选中“找出是什么修改了这个地址”，回到游戏让数值发生变动（例如拾取阳光，放置植物等），就可以看到有操作码执行了。</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426233834591.png" alt="image-20240426233834591"></p><ul><li>首先分析一下<code>mov [edi+00005578],esi</code>这条指令，我们在详细信息中看见，寄存器<code>esi</code>中的代码是<code>0000039D</code>这个值换算成十进制刚好是<code>925</code>，发现什么了吗，对了，这个<code>925</code>就是当前的阳光值。这条指令<code>mov mov [edi+00005578],esi</code>就是把寄存器<code>esi</code>的<code>925</code>的值放入<code>edi+00005578</code>这个地址中去，这个地址是谁呢？这个地址就是刚刚找出来的物理地址，刚好满足前面的公式：<code>物理地址 = 阳光基址地址 + 偏移地址</code></li><li>接下看看<code>add [eax+00005578],ecx</code>这条指令，<code>add</code>指令是相加的意思，前面的<code>mov</code>是赋值或者移动的意思，这条代码的意思就是，把<code>ecx</code>寄存器中的值加入<code>[eax+00005578]</code>这个地址中的值当中去，再看看寄存器<code>eax</code>的地址是多少？刚好又是<code>23560070</code>这个指针数值，那么，我们就可以确定一个事情，那就是<code>23560070</code>这个指针数值，肯定是上一级的地址的指针数值，那么上一级要么是基址，要么还是一个偏移地址，这个需要进一步来确认</li><li>把<code>23560070</code>这个指针数值，再次放到CE中搜索一波，看看这个值对应的地址是多少，看看出来的是一个动态地址还是静态地址（在CE中，黑色的地址表示动态地址，绿色的表示静态地址），这里这个值是十六进制的，所以在搜索的时候，需要勾选搜索框前面的hex，这里填好以后点击新的扫描,首次扫描如图所示：</li></ul><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235454287.png" alt="image-20240426235454287"></p><p>这里搜索出来的值有很多，要怎么确认呢？</p><p>多次点击再次扫描以后发现不管怎么点击都剩下来了52个结果，然后看了一下这些结果中并没有绿色的静态地址，说明至少有二级偏移。其他地址开头几位都比较相似，唯独有几个地址比较特殊，这可能就是我们需要的地址了</p><p>百度了一波，结果所说的是这种开头比较像的是数组，也就是说，遇到这种，基本都不是我们需要的地址，直接放弃，把这两个特殊的拉进下边的地址列表，开始分析，双击地址这一栏，在出来的更改地址窗口中复制下这个地址，然后再勾选指针选项，在出来的内容框中填写入刚刚复制的地址，在上面的内容框中写入刚刚找到的00005560这个偏移地址，得到的结果刚好是阳光的物理地址，最后的阳光值也正好和当前的阳光值一样，并且，这两个地址都是一样的，而且都是动态地址</p><p>如上图所示，这两个地址加上偏移地址都可以得到阳光物理地址，右键-找出是什么访问了这个地址，也就是快捷键的F5</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235347682.png" alt="image-20240426235347682"></p><p>进去以后也是和前面一样出来一个窗口，但是这两个窗口里面的内容就不一样了，第一个地址028BBA80在窗口中会出现内容，但是第二个地址0956BD3C在出现的窗口里面是一片空白，所以，这两个地址中，028BBA80才是我们要找的真正的一级偏移地址，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426234356042.png" alt="image-20240426234356042"></p><p>如上第二幅图所示，找到了真正的一级偏移地址<code>028BBA80</code>后，访问这个地址的窗口中看这些代码指令，通过对比，发现这些代码都指向同一个指针数值<code>028BBA80</code>且都有偏移地址<code>00000868</code>，如图所示：</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240426235649647.png" alt="image-20240426235649647"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000346546.png" alt="image-20240427000346546"></p><p>有四个怎么办？试一试</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000413321.png" alt="image-20240427000413321"></p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427000451679.png" alt="image-20240427000451679"></p><p>对了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import win32gui</span><br><span class="line">import win32process</span><br><span class="line"></span><br><span class="line"># 窗口句柄</span><br><span class="line">window_handle = win32gui.FindWindow(MainWindow, &quot;Plants vs. Zombies&quot;)</span><br><span class="line"></span><br><span class="line">win32process.GetWindowThreadProcessId(window_handle)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20240427001003309.png" alt="image-20240427001003309"></p><p>CD修改：</p><blockquote><p>rule：</p><p>当植物处于可使用状态时，内存值为1</p><p>当植物处于CD状态时，内存值为0</p><p>植物种植后，内存值由0开始增加，这个增加的过程就是CD，当内存值到达一定数值后，就会自动归零，此时CD结束</p></blockquote><p>CD修改：</p><blockquote><p>rule：</p><p>当植物处于可使用状态时，内存值为1</p><p>当植物处于CD状态时，内存值为0</p><p>植物种植后，内存值由0开始增加，这个增加的过程就是CD，当内存值到达一定数值后，就会自动归零，此时CD结束</p></blockquote>]]>
    </content>
    <id>https://h1s97x.github.io/blog/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5-%E5%A4%96%E6%8C%82%E5%BC%80%E5%8F%91/</id>
    <link href="https://h1s97x.github.io/blog/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5-%E5%A4%96%E6%8C%82%E5%BC%80%E5%8F%91/"/>
    <published>2025-12-27T15:46:11.000Z</published>
    <summary>
      <![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 <strong>进程</strong>：每一个应用程序&#x2F;游戏启动，都会产生至少一个进程Process，在任务管理器里可以看到进程名称和进程PID。</p>
<p>2、 句柄：英文HANDLE，一个整数值。数据的地址需要变动，变动以后就需要有人来记录管理变动，就好像户籍管理一样，因此系统用句柄来记载数据地址的变更。肉眼看到的一个个文件夹，窗口，按钮，图标，应用程序能够通过句柄访问相应的对象的信息</p>
<p>3、]]>
    </summary>
    <title>外挂开发</title>
    <updated>2025-12-27T15:46:11.000Z</updated>
  </entry>
</feed>
