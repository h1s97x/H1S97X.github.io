<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-02T08:26:01.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>近来的苦恼</title>
    <link href="http://example.com/2023/11/02/%E8%BF%91%E6%9D%A5%E7%9A%84%E8%8B%A6%E6%81%BC/"/>
    <id>http://example.com/2023/11/02/%E8%BF%91%E6%9D%A5%E7%9A%84%E8%8B%A6%E6%81%BC/</id>
    <published>2023-11-02T08:26:01.000Z</published>
    <updated>2023-11-02T08:26:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近的烦心事不可谓不多，写这篇也是临时起意，将这些事情记录下来，也是给自己这大学两年多以来的经历进行总结教训。</p><p>总说大学大学，大不了自学。听起来很对，但真要到身体力行，则深感道阻且长，学习上的事，从小学以来基本都是老师讲，我听，我记，我做，不断重复然后形成知识体系，于我，上课听懂多少基本就是我学了多少；但到了大学，老师讲的东西，要么听不懂，要么听懂一部分，剩下就茫然了，尝试看书，有时会有很好的发现，可一旦落笔，则又瞬间什么又不懂了。我不知道怎么做，我不知道怎么学，我不知道怎么问，我不知道怎么解决。</p><p>大二转了专业，到了软院，数据结构瞬间打回原形，大一学的只有一节课相关，但本身上课就稀里糊涂，而且还不是一个版本，数据结构用C++编程，只学了一点C，连PPT的示例代码都看不懂，更别说自己写了。于是重新走上老路，上课不听去自学C++ Prime plus，但这本书将近千页，平时还有别的课程，没时间一次看完，一次看一点的方式完全行不通。这就是第一个烦心事。</p><p>接下来说说最近的，认识实习，原定第八周，推迟到了第九周，也就是本周，这周也马上过去了，明天也有web课程设计的考试，可项目又停滞了一个多月，当了团队的leader，一开始三番五次向其他成员说明，让他们要报告自己的进展，好安排任务，但是，他们完全没有团队意识，而我又很忙，9月底还找了一份实习的工作，已经做了一个多月了，该怎么办？第十四周就要提交了，本周末肯定要抓紧完成初步的项目，但还有别的任务，别的实验课，别的考试，我该怎么办？这就是第二个烦心事。</p><p>认识实习这几天，学校的安排给我感觉很差劲，先是把我们班级拆成两个组，并到其他组里去，然后和我同组的另一个班，计划变更也不说明，也不能按时抵达（有时是我们班其他人），联系的时候还联系不上，不提前站队查人，导致上车后等半天，虽然这些都是小事，但给我的感受就是很不好受，行政管理低下导致的问题。这些其实都不是什么重点，重点是即将结束的大学生活，课程设计、实验、毕业设计、考研还是找工作？考研自然毫不必问，可问题是方向还有能力，就目前而言，我有很多想做的事情，可这些需要时间，还有指导！大学以来，很少在学习上有过指点，坑是自己踩的，活是自己干的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近的烦心事不可谓不多，写这篇也是临时起意，将这些事情记录下来，也是给自己这大学两年多以来的经历进行总结教训。&lt;/p&gt;
&lt;p&gt;总说大学大学，大不了自学。听起来很对，但真要到身体力行，则深感道阻且长，学习上的事，从小学以来基本都是老师讲，我听，我记，我做，不断重复然后形成知识</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/24/net-attack&amp;defence-doc/bof-password/"/>
    <id>http://example.com/2023/10/24/net-attack&amp;defence-doc/bof-password/</id>
    <published>2023-10-24T03:36:42.819Z</published>
    <updated>2023-10-24T03:36:33.333Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/24/net-attack&amp;defence-doc/x-windows/"/>
    <id>http://example.com/2023/10/24/net-attack&amp;defence-doc/x-windows/</id>
    <published>2023-10-24T03:35:43.113Z</published>
    <updated>2023-10-24T00:59:56.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="X-windows"><a href="#X-windows" class="headerlink" title="X-windows"></a>X-windows</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p> X Windows 是 UNIX 和所有类 UNIX （包括Linux）操作系统的标准图形接口，有时也称为X Windows、X Window 或者 X。由于它是在 W 窗口系统之后开发成功的，故称为 X 系统。X Window 系统可以在许多系统上运行，具有可移植性、对彩色处理的多样性，以及在网络上操作的透明性等特点，使得 X 成为一个工业标准。因此，严格来说，X Window 系统并不是一个软件，而是一个协议（protocal），定义了一个系统成品必须具备的功能。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.bilibili.com/read/cv8087543/">【Linux图形环境】何为X Windows系统（图形环境）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;X-windows&quot;&gt;&lt;a href=&quot;#X-windows&quot; class=&quot;headerlink&quot; title=&quot;X-windows&quot;&gt;&lt;/a&gt;X-windows&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/23/web-doc/vue-%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/"/>
    <id>http://example.com/2023/10/23/web-doc/vue-%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/</id>
    <published>2023-10-23T03:27:58.434Z</published>
    <updated>2023-10-24T03:18:58.630Z</updated>
    
    <content type="html"><![CDATA[<h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p><code>暗黑模式/白天模式</code>的主题切换功能</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/7134594122391748615">前端主题切换方案 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;想法&quot;&gt;&lt;a href=&quot;#想法&quot; class=&quot;headerlink&quot; title=&quot;想法&quot;&gt;&lt;/a&gt;想法&lt;/h3&gt;&lt;p&gt;&lt;code&gt;暗黑模式/白天模式&lt;/code&gt;的主题切换功能&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;hea</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/23/web-doc/vue-markdown/"/>
    <id>http://example.com/2023/10/23/web-doc/vue-markdown/</id>
    <published>2023-10-23T03:02:44.369Z</published>
    <updated>2023-10-23T03:27:39.306Z</updated>
    
    <content type="html"><![CDATA[<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>首先需要使用npm引入三个包</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i markdown-loader html-loader marked --save</span><br></pre></td></tr></table></figure><p>说明：<code>markdown-loader</code>、<code>html- loader</code>是为了让<code>vue</code>能够解析<code>md</code>格式的文件，读取出来，然后使用<code>marked</code>将读取出来的数据转换成<code>html</code>格式渲染到页面上。使用<code>marked</code>是为了使用更方便。</p><p>下一步准备引入 *.md 文件，但是引入之前还需要做一个规则配置，如果没有配置的话会报无法解析“#”的错误。配置好后就可以引入md文件了。</p><h4 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h4><p>在vue.config.js里进行配置,<strong>如果使用的是 vue-cli 3 以上版本则在vue.config.js中配置</strong></p><p>webpack.base.conf.js 配置：在 module &gt; rules 中添加一条规则</p><figure class="highlight javascript"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        <span class="comment">// 配置读取 *.md 文件的规则</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.md$/</span>,</span><br><span class="line">             <span class="attr">use</span>: [</span><br><span class="line">                &#123; <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">loader</span>: <span class="string">&#x27;markdown-loader&#x27;</span>, <span class="attr">options</span>: &#123;&#125; &#125;</span><br><span class="line">             ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vue.config.js 配置：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        // 配置读取 *.md 文件的规则</span><br><span class="line">        &#123;</span><br><span class="line">          test: /\.md$/,</span><br><span class="line">          use: [</span><br><span class="line">            &#123; loader: &quot;html-loader&quot; &#125;,</span><br><span class="line">            &#123; loader: &quot;markdown-loader&quot;, options: &#123;&#125; &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="页面引入和渲染"><a href="#页面引入和渲染" class="headerlink" title="页面引入和渲染"></a>页面引入和渲染</h4><p>在需要使用的地方，引入 marked，再将 md 文档交给它来解析，获得到解析后的 HTML 格式内容，再将解析后的内容渲染到页面上</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;文档&lt;/div&gt;</span><br><span class="line">    &lt;div v-html=&quot;articalContent&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">​</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const marked = require(&quot;marked&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      articalContent: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.$axios.get(&quot;/articles/test.md&quot;).then(res =&gt; &#123;</span><br><span class="line">        const htmlMD = marked(res.data);</span><br><span class="line">​</span><br><span class="line">        this.articalContent = htmlMD;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这时，md格式的数据就被解析成了html格式的数据，我们只需要将html格式的数据渲染上去就行了。</p><h4 id="MD样式未渲染"><a href="#MD样式未渲染" class="headerlink" title="MD样式未渲染"></a>MD样式未渲染</h4><p>到现在为止，只是将文档正确解析并显示到了页面上，但是没有任何样式，我们可以再给渲染的内容加上样式，比如使用 github 的样式：</p><p>这时候就需要我们下载另外一个依赖</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install github-markdown-css</span><br></pre></td></tr></table></figure><p>然后在main.js中将md文件的样式引入</p><figure class="highlight arduino"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;github-markdown-css&#x27;</span>;</span><br></pre></td></tr></table></figure><p>最后给页面的div盒子加上样式的class</p><figure class="highlight css"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> v-<span class="selector-tag">html</span>=&quot;md&quot; class=&quot;markdown-<span class="selector-tag">body</span>&quot; &gt;</span><br><span class="line"> </span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p>注：可能页面有些不一样因为样式不同</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/weixin_44702572/article/details/107321909">Vue解析 markdown 文件_vue 解析markdown-CSDN博客</a></p><p><a href="https://juejin.cn/post/7034048009000189960">vue引入并解析md文件 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;依赖&quot;&gt;&lt;a href=&quot;#依赖&quot; class=&quot;headerlink&quot; title=&quot;依赖&quot;&gt;&lt;/a&gt;依赖&lt;/h4&gt;&lt;p&gt;首先需要使用npm引入三个包&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;input class=&quot;b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/23/assets/markdownhere/"/>
    <id>http://example.com/2023/10/23/assets/markdownhere/</id>
    <published>2023-10-23T02:31:49.970Z</published>
    <updated>2023-10-23T02:36:14.051Z</updated>
    
    <content type="html"><![CDATA[/*markdown here 的全局配置*/.markdown-here-wrapper {    font-size: 16px;    line-height: 1.8em;    /*em指的是相对单位，当前对象内字体的尺寸，默认浏览器16px*/    /*http://www.w3school.com.cn/cssref/css_units.asp*/    letter-spacing: 0.1em;  }    pre, code {       /*,逗号连接是并集选择器*/    font-size: 14px;    font-family: Roboto, 'Courier New', Consolas, Inconsolata, Courier, monospace;    margin: auto 5px;  }    /*设置pre 和code的整体属性，pre可以把div中的/r/n保存下来显示，而code则用浏览器的方式渲染*/  code {    white-space: pre-wrap;    border-radius: 2px;    display: inline;  }  /*display 的属性为指定元素框的类型*/  /*margin： 0为默认值，auto为浏览器自动计算的外边距，外边距属性*/  /*border-radius: div元素的圆角框*/  /*write-space:如何处理元素内空白行，回车or忽略,nowrap不换行，pre-wrap换行*/  /*http://www.w3school.com.cn/cssref/pr_text_white-space.asp*/      pre {      /*pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。*/    font-size: 15px;    line-height: 1.4em;    display: block; !important;  /*在ie6以上的浏览器中，设置优先级，覆盖预先设置的属性 !important*/  }    pre code {  /*空格连接是后代选择器，外层在前内层在后； >连接是子元素选择器*/    white-space: pre;    overflow: auto;   /*内容益处元素框时候的行为*/    border-radius: 3px;    padding: 1px 1px;    display: block !important;  }    /*各种选择器：https://blog.csdn.net/m0_38070602/article/details/69950795*/  /*pre code 的解释：http://www.cnblogs.com/lizonghui/archive/2012/09/18/2692355.html*/  strong, b{      /*strong表示强调，用<b>粗体显示，也可以自定义自己的强调方式*/    color: #BF360C;  }    em, i {      /*em表示强调，用<i>标签斜体显示，也可以自定义自己的强调方式*/    color: #009688;  }    hr {       /*水平线分割---*/    border: 1px solid #BF360C;    margin: 1.5em auto;  }    p {      /*段落选择器*/    margin: 1.5em 5px !important;    /*颜色*/    /*color:#d6a841;*/       /*字体*/    font-family:'微软雅黑';    /*字号*/    font-size:15px;    /*行间距，可用百分比，数值倍数，像素设置，还包括text-indent缩进、letter-spacing字间距、*/    line-height:100%  2  100px;    /*段间距，一般用margin属性调整*/    margin-bottom:20px;    /*页边距用padding属性调整*/  }    /*表格和*/  table, pre, dl, blockquote, q, ul, ol {    margin: 10px 5px;    /*并集选择器：表格、预格式化、定义列表、块引用、短引用、无序列表、有序列表*/  }    ul, ol {      /*无序、有序列表*/    padding-left: 15px;  }    li {      /* 定义列表中的项目*/    margin: 10px;  }    li p {      /*li列表元素中的后代选择器，包含选择器，应用于li中的p*/    margin: 10px 0 !important;  }    ul ul, ul ol, ol ul, ol ol {        /*各个后代选择器一起添加属性*/    margin: 0;    padding-left: 10px;  }    ul {    list-style-type: circle;  }  /*无序列表的前缀，circle,square,好多种,同样有序列表ol也可以设置不同的标记*/  /*http://www.w3school.com.cn/cssref/pr_list-style-type.asp*/    dl {    padding: 0;  }    dl dt {    font-size: 1em;    font-weight: bold;      /*加粗  意大利斜体*/    font-style: italic;  }    dl dd {    margin: 0 0 10px;    padding: 0 10px;  }  /*各种表格的包含选择器定义，用空格连接*/      blockquote, q {    border-left: 2px solid #009688;    padding: 0 10px;      /*上右下左的排序，可输入四个值*/    color: #777;    quotes: none;    margin-left: 1em;  }  /*块引用和短引用的样式*/    blockquote::before, blockquote::after, q::before, q::after {    content: none;  }  /*before 和after属于css伪元素，:before在元素之前插入相应。：after在之后插入*/  /*伪元素用::，伪类用：参考ref。。https://blog.csdn.net/qq_25292481/article/details/52577320*/      /*--------同时设置六级标题的属性，其中！important用于指定优先级>ie6--------------*/  h1, h2, h3, h4, h5, h6 {    margin: 20px 0 10px;    padding: 0;    font-style: bold !important;    color: #009688 !important;    text-align: center !important;    margin: 1.5em 5px !important;    padding: 0.5em 1em !important;  }    h1 {    font-size: 24px !important;    border-bottom: 1px solid #ddd !important;  }    h2 {    font-size: 20px !important;    border-bottom: 1px solid #B3B3B3 !important;  }    h3 {    font-size: 18px;  }    h4 {    font-size: 16px;    /*可以针对自己的标题做出个性化设置*/    color:#d6a841   /*16进制颜色*/    font-style: bold /*加粗？倾斜*/    /*---------各种居中方式---------*/    margin: 0, auto;        /*块级元素居中*/    text-align: center;    /*行内居中*/    justify-content: center;  /*对齐*/    vertical-align: middle;  /*垂直居中*/    /*ref:   https://www.jianshu.com/p/61c431fd924a*/    }    /*-------------表格元素的设置-----------------*/  table {    padding: 0;    border-collapse: collapse;  /*合并边框属性*/    border-spacing: 0;      font-size: 1em;    font: inherit;    border: 0;    margin: 0 auto;  }    tbody {    margin: 0;    padding: 0;    border: 0;  }    table tr {    border: 0;    border-top: 1px solid #CCC;    background-color: white;    margin: 0;    padding: 0;  }    table tr:nth-child(2n) {    background-color: #F8F8F8;  }    table tr th, table tr td {    font-size: 16px;    border: 1px solid #CCC;    margin: 0;    padding: 5px 10px;  }    table tr th {  /*表格。tableraw，tableheader*/    font-weight: bold;    color: #eee;    border: 1px solid #009688;    background-color: #009688;  }      /* ----------  可根据markdown的实现自己的**个性化**标记 */  @strong-char: "**";  /*可以将着重符号替换为自己的个性化符号*/  strong:before, strong:after {      content: @strong-char;      display: inline;  }  @em-char: "*";     em:before, em:after {      content: @em-char;      display: inline;  }    ]]></content>
    
    
      
      
    <summary type="html">/*markdown here 的全局配置*/
.markdown-here-wrapper {
    font-size: 16px;
    line-height: 1.8em;
    /*em指的是相对单位，当前对象内字体的尺寸，默认浏览器16px*/
    /*h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Web前端框架</title>
    <link href="http://example.com/2023/10/19/Web%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2023/10/19/Web%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</id>
    <published>2023-10-19T13:18:02.000Z</published>
    <updated>2023-10-19T13:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue 的核心功能是声明式渲染：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应该是什么样子的。当状态改变时，HTML 会自动更新。</p><h3 id="plugin-插件"><a href="#plugin-插件" class="headerlink" title="plugin 插件"></a>plugin 插件</h3><p><a href="https://juejin.cn/post/6966106927990308872">Volar - vue终极开发神器！ - 掘金 (juejin.cn)</a></p><p><a href="https://cn.vitejs.dev/config/">配置 Vite | Vite 官方中文文档 (vitejs.dev)</a></p><p>能在改变时触发更新的状态被认为是响应式的(AJAX)。在 Vue 中，响应式状态被保存在组件中。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">  // 组件选项</span><br><span class="line">  // 此处声明一些响应式状态</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello World!&#x27;,</span><br><span class="line">      // 复合属性用对象表示 &#x27;x.x_value&#x27;</span><br><span class="line">      counter: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Count is: &#123;&#123; counter.count &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>message 属性可以在模板中使用。下面展示了我们如何使用双花括号法，根据 message 的值来渲染动态文本。</p><p>在 Vue 中，mustache 语法 (即双大括号) 只能用于文本插值。为了给 attribute 绑定一个动态值，需要使用 <code>v-bind</code> 指令：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line">// 简写写法</span><br></pre></td></tr></table></figure><p>指令是由 v- 开头的一种特殊 attribute。它们是 Vue 模板语法的一部分。和文本插值类似，指令的值是可以访问组件状态的 JavaScript 表达式。<br>冒号后面的部分 (:id) 是指令的“参数”。此处，元素的 id <code>attribute</code> 将与组件状态里的 <code>dynamicId</code> 属性保持同步。<br><strong>v-bind绑定属性变量dynamicId，属性变量的值才是实际的class</strong></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      titleClass: &#x27;title&#x27; //titleClass是属性变量，title是属性值</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 :class=&quot;titleClass&quot;&gt;&#123;&#123;titleClass&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">// 跟属性值相同</span><br><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/torchstar/p/11799394.html">vue中v-on支持的事件总结</a><br>我们可以使用 <code>v-on</code> 指令监听 DOM 事件：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">// 简写写法</span><br><span class="line">&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>此处，increment 引用了一个使用 methods 选项声明的函数</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 组件选项 方法体</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      // 更新组件状态</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><strong>表单绑定</strong><br>我们可以同时使用 v-bind 和 v-on 来在表单的输入元素上创建双向绑定：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input :value=&quot;text&quot; @input=&quot;onInput&quot;&gt;</span><br></pre></td></tr></table></figure><p>这里，我们使用 v-bind:value 将 text 属性绑定到 <code>&lt;input&gt;</code> 元素的 value 属性上。每当用户在 <code>&lt;input&gt;</code> 元素中输入时，浏览器都会触发 input 事件并调用 onInput 方法。在这个方法中，我们更新组件状态的 text 属性。</p><p>为了简化双向绑定，Vue 提供了一个 <code>v-model</code> 指令，它实际上是上述操作的语法糖：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;text&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      text: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onInput(e) &#123;</span><br><span class="line">      this.text = e.target.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input :value=&quot;text&quot; @input=&quot;onInput&quot; placeholder=&quot;Type here&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>试着在文本框里输入——你会看到 <code>&lt;p&gt;</code> 里的文本也随着你的输入更新了。</p><p>我们可以使用 <code>v-if</code> 指令来有条件地渲染元素：<br>这个 <code>&lt;h1&gt;</code> 标签只会在 awesome 的值为真值 (Truthy) 时渲染。若 awesome 更改为假值 (Falsy)，它将被从 DOM 中移除。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p><strong>列表渲染</strong><br>我们可以使用 <code>v-for</code> 指令来渲染一个基于源数组的列表：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>这里的 todo 是一个局部变量，表示当前正在迭代的数组元素。它只能在 v-for 所绑定的元素上或是其内部访问，就像函数的作用域一样。</p><p>注意，我们还给每个 todo 对象设置了唯一的 id，并且将它作为特殊的 key attribute 绑定到每个 <code>&lt;li&gt;</code>。key 使得 Vue 能够精确的移动每个 <code>&lt;li&gt;</code>，以匹配对应的对象在数组中的位置。这个 key attribute 也是 Vue 为了性能而做的一个必要的优化。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 给每个 todo 对象一个唯一的 id</span><br><span class="line">let id = 0</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      newTodo: &#x27;&#x27;,</span><br><span class="line">      todos: [</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn HTML&#x27; &#125;,</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn JavaScript&#x27; &#125;,</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn Vue&#x27; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodo() &#123;</span><br><span class="line">      this.todos.push(&#123; id: id++, text: this.newTodo &#125;)</span><br><span class="line">      this.newTodo = &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeTodo(todo) &#123;</span><br><span class="line">      this.todos = this.todos.filter((t) =&gt; t !== todo)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;form @submit.prevent=&quot;addTodo&quot;&gt;</span><br><span class="line">    &lt;input v-model=&quot;newTodo&quot;&gt;</span><br><span class="line">    &lt;button&gt;Add Todo&lt;/button&gt;    </span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">      &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>(t) &#x3D;&gt; t !&#x3D;&#x3D; todo 可以转变成以下形式</p><p>function(t){<br>    return t!&#x3D;&#x3D;todo<br>}</p><p>介绍一个新概念：计算属性。我们可以使用 computed 选项声明一个响应式的属性，它的值由其他属性计算而来：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: &#123;</span><br><span class="line">    filteredTodos() &#123;</span><br><span class="line">      // 根据 `this.hideCompleted` 返回过滤后的 todo 项目</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">let id = 0</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      newTodo: &#x27;&#x27;,</span><br><span class="line">      hideCompleted: false,</span><br><span class="line">      todos: [</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn HTML&#x27;, done: true &#125;,</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn JavaScript&#x27;, done: true &#125;,</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn Vue&#x27;, done: false &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    filteredTodos() &#123;</span><br><span class="line">      return this.hideCompleted</span><br><span class="line">        ? this.todos.filter((t) =&gt; !t.done)</span><br><span class="line">        : this.todos</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodo() &#123;</span><br><span class="line">      this.todos.push(&#123; id: id++, text: this.newTodo, done: false &#125;)</span><br><span class="line">      this.newTodo = &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeTodo(todo) &#123;</span><br><span class="line">      this.todos = this.todos.filter((t) =&gt; t !== todo)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;form @submit.prevent=&quot;addTodo&quot;&gt;</span><br><span class="line">    &lt;input v-model=&quot;newTodo&quot;&gt;</span><br><span class="line">    &lt;button&gt;Add Todo&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;todo in filteredTodos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;</span><br><span class="line">      &lt;span :class=&quot;&#123; done: todo.done &#125;&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;button @click=&quot;hideCompleted = !hideCompleted&quot;&gt;</span><br><span class="line">    &#123;&#123; hideCompleted ? &#x27;Show all&#x27; : &#x27;Hide completed&#x27; &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.done &#123;</span><br><span class="line">  text-decoration: line-through;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>怎么实现的隐藏？</p><p>手动操作 DOM。</p><p>这时我们需要使用模板引用——也就是指向模板中一个 DOM 元素的 ref。我们需要通过这个特殊的 ref attribute 来实现模板引用：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p ref=&quot;pElementRef&quot;&gt;hello&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>此元素将作为 this.$refs.pElementRef 暴露在 this.$refs 上。然而，你只能在组件挂载之后访问它。</p><p>要在挂载之后执行代码，我们可以使用 mounted 选项：<br>这被称为生命周期钩子——它允许我们注册一个在组件的特定生命周期调用的回调函数。还有一些其他的钩子如 created 和 updated。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 此时组件已经挂载。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.$refs.pElementRef.textContent = &#x27;mounted!&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p ref=&quot;pElementRef&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>侦听器<br>有时我们需要响应性地执行一些“副作用”——例如，当一个数字改变时将其输出到控制台。我们可以通过侦听器来实现它：<br>一个比在控制台输出更加实际的例子是当 ID 改变时抓取新的数据。在下边的例子中就是这样一个组件。该组件被挂载时，会从模拟 API 中抓取 todo 数据，同时还有一个按钮可以改变要抓取的 todo 的 ID。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      todoId: 1,</span><br><span class="line">      todoData: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async fetchData() &#123;</span><br><span class="line">      this.todoData = null</span><br><span class="line">      const res = await fetch(</span><br><span class="line">        `https://jsonplaceholder.typicode.com/todos/$&#123;this.todoId&#125;`</span><br><span class="line">      )</span><br><span class="line">      this.todoData = await res.json()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.fetchData()</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    todoId() &#123;</span><br><span class="line">      this.fetchData()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;Todo id: &#123;&#123; todoId &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button @click=&quot;todoId++&quot;&gt;Fetch next todo&lt;/button&gt;</span><br><span class="line">  &lt;p v-if=&quot;!todoData&quot;&gt;Loading...&lt;/p&gt;</span><br><span class="line">  &lt;pre v-else&gt;&#123;&#123; todoData &#125;&#125;&lt;/pre&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>组件<br>目前为止，我们只使用了单个组件。真正的 Vue 应用往往是由嵌套组件创建的。</p><p>父组件可以在模板中渲染另一个组件作为子组件。要使用子组件，我们需要先导入它：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要使用 components 选项注册组件。这里我们使用对象属性的简写形式在 ChildComp 键下注册 ChildComp 组件。</p><p>然后我们就可以在模板中使用组件，就像这样：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComp /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;Child component&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>Props<br>子组件可以通过 props 从父组件接受动态数据。首先，需要声明它所接受的 props：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在子组件中</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦声明，msg prop 就会暴露在 this 上，并可以在子组件的模板中使用。</p><p>父组件可以像声明 HTML attributes 一样传递 props。若要传递动态值，也可以使用 v-bind 语法：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComp :msg=&quot;greeting&quot; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      greeting: &#x27;Hello from parent&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp :msg=&quot;greeting&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123; msg || &#x27;No props passed yet&#x27; &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>Emits<br>除了接收 props，子组件还可以向父组件触发事件：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  // 声明触发的事件</span><br><span class="line">  emits: [&#x27;response&#x27;],</span><br><span class="line">  created() &#123;</span><br><span class="line">    // 带参数触发</span><br><span class="line">    this.$emit(&#x27;response&#x27;, &#x27;hello from child&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.$emit() 的第一个参数是事件的名称。其他所有参数都将传递给事件监听器。</p><p>父组件可以使用 v-on 监听子组件触发的事件——这里的处理函数接收了子组件触发事件时的额外参数并将它赋值给了本地状态：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp @response=&quot;(msg) =&gt; childMsg = msg&quot; /&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; childMsg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>插槽<br>除了通过 props 传递数据外，父组件还可以通过插槽 (slots) 将模板片段传递给子组件：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComp&gt;</span><br><span class="line">  This is some slot content!</span><br><span class="line">&lt;/ChildComp&gt;</span><br></pre></td></tr></table></figure><p>在子组件中，可以使用 <slot> 元素作为插槽出口 (slot outlet) 渲染父组件中的插槽内容 (slot content)：<br><slot> 插口中的内容将被当作“默认”内容：它会在父组件没有传递任何插槽内容时显示</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在子组件的模板中 --&gt;</span><br><span class="line">&lt;slot&gt;Fallback content&lt;/slot&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;from parent&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/ChildComp&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;slot&gt;Fallback content&lt;/slot&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;script setup&gt;</code> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。当同时使用 SFC 与组合式 API 时该语法是默认推荐。相比于普通的 <code>&lt;script&gt;</code> 语法，它具有更多优势：<br>里面的代码会被编译成组件 setup() 函数的内容。这意味着与普通的 <script> 只在组件被首次引入的时候执行一次不同，<script setup> 中的代码会在每次组件实例被创建的时候执行。</p><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h2&gt;&lt;p&gt;Vue 的核心功能是声明式渲染：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络防范</title>
    <link href="http://example.com/2023/10/19/%E7%BD%91%E7%BB%9C%E9%98%B2%E8%8C%83/"/>
    <id>http://example.com/2023/10/19/%E7%BD%91%E7%BB%9C%E9%98%B2%E8%8C%83/</id>
    <published>2023-10-19T03:31:30.000Z</published>
    <updated>2023-10-19T03:31:30.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>CE修改器入门</title>
    <link href="http://example.com/2023/10/19/CE%E4%BF%AE%E6%94%B9%E5%99%A8%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2023/10/19/CE%E4%BF%AE%E6%94%B9%E5%99%A8%E5%85%A5%E9%97%A8/</id>
    <published>2023-10-19T00:53:08.000Z</published>
    <updated>2023-10-19T00:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新手教程"><a href="#新手教程" class="headerlink" title="新手教程"></a>新手教程</h2><p><a href="https://cheatengine.org/">cheat engine 官网</a></p><p>附加<code>Tutorial-i386.exe进程</code>后,我们点击教程的下一步按钮，接着继续第二关，第二关的作用还是很简单的，主要目的是遍历出我们想要的动态数据，比如角色的生命，人物的魔法等，都会用到精确扫描，可以说这一关是既简单又实用的东西，也是今后制作中最常用的环节，接着我们看下<code>Tutorial-i386.exe程序</code>对这一关通关流程的描述:</p><blockquote><p>步骤 2: 精确值扫描 (密码&#x3D;090453)</p><p>现在你已经在 Cheat Engine 中打开了训练程序，为我们下一步的练习做好了准备。<br>本窗口的左下方显示的”健康:XXX”，在你每次点击”打我”按钮时，它的值便会减少。<br>要进入下一关，你必须找到这个数值并把它改成 1000 。<br>很多方法都可以找到这个数值的位置，但我将告诉你一个最简单的方法，”精确数值”扫描：</p></blockquote><p>上面的简单描述的意思就是,需要将100这个数值修改为1000则本关就算通过，看下面具体的步骤</p><p>1.首先游戏规则是每次我们点击<code>打我</code>按钮则健康值则会减一,我们首先搜索这个<code>100</code>看能不能找到些什么.</p><p><img src="/img/CE/CE-simple-scan-1.png"></p><p>现在开始搜索精确数值 <code>100</code>  数值中<code>输入100</code> 点击 <code>首次扫描</code> 按钮</p><p><img src="/img/CE/CE-simple-scan-2.png"></p><p>默认情况下一般游戏就是4字节，这里不需要改动<code>扫描类型和数值类型</code>，默认就好了.</p><p>这次扫描我们得到 35 个结果，里面肯定有我们要找的那个血值，不过好像太多了,没关系继续往下看.</p><p><img src="/img/CE/CE-simple-scan-3.png"></p><p>关键一步：为了找到更加精确的数据，我们回到 Tutorial 点击 <code>打我</code> 按钮，此时血值已有变化了：</p><p><img src="/img/CE/CE-simple-scan-4.png"></p><p>我们再输入 <code>95</code> 点击 <code>再次扫描</code> 按钮 结果只剩1个（这就是我们要找的），我们双击此地址将其添加到地址栏：</p><p><img src="/img/CE/CE-simple-scan-5.png"></p><p>此时地址栏里面只有1个结果了，这个就是我们要找的内存地址，双击将其加入到地址栏</p><p><img src="/img/CE/CE-simple-scan-6.png"></p><p>在数值95上面双击，并修改把 95 改成 1000 点击<code>确定</code>按钮,此时通关.</p><p><img src="/img/CE/CE-simple-scan-7.png"></p><p>此时回到Tutorial-i386.exe程序，会发现教程的 <code>下一步</code> 按钮变成可用,再次点击打我按钮，数值变大了，继续点击下一步进入第三关…</p><p><img src="/img/CE/CE-simple-scan-8.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新手教程&quot;&gt;&lt;a href=&quot;#新手教程&quot; class=&quot;headerlink&quot; title=&quot;新手教程&quot;&gt;&lt;/a&gt;新手教程&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://cheatengine.org/&quot;&gt;cheat engine 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>外挂分析与实现</title>
    <link href="http://example.com/2023/10/19/%E5%A4%96%E6%8C%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/10/19/%E5%A4%96%E6%8C%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-10-19T00:39:59.000Z</published>
    <updated>2023-10-19T00:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PVZ辅助"><a href="#PVZ辅助" class="headerlink" title="PVZ辅助"></a>PVZ辅助</h2><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/tree/main">PlantsVsZombies-Cheat: 植物大战僵尸逆向分析与辅助开发系列教程(github.com)</a></p><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><h4 id="OnlyDbg使用"><a href="#OnlyDbg使用" class="headerlink" title="OnlyDbg使用"></a>OnlyDbg使用</h4><p><a href="https://www.bilibili.com/video/BV1cE411f7sE/?p=6&spm_id_from=pageDriver&vd_source=206a091077ff783d662b49e64cc9589d">06.常用断点之硬件断点原理解析_哔哩哔哩_bilibili</a></p><p><a href="https://www.cnblogs.com/xueyoo/articles/4938538.html">OllyDBG完美教程(超强入门级) - xueyoo - 博客园 (cnblogs.com)</a></p><p><strong>OllyDBG界面认识</strong><br><img src="/img/Network-attack/OB-desktop.png"></p><ul><li><p>反汇编窗口：显示被调试程序的反汇编代码。用鼠标左键点击注释标签可以切换注释显示的方式。如果需要修改代码，直接在这里在修改，比如“使用NOP填充”。</p></li><li><p>寄存器窗口：显示当前所选线程的CPU寄存器内容。点击标签寄存器(FPU)可以切换显示寄存器的方式。</p></li><li><p>信息窗口：显示反汇编窗口中当前选中的第一条命令的参数及一些跳转目标地址、字串等（一般动态加密解密字串等会在此出现）。</p></li><li><p>数据窗口：显示内存或文件的内容。直接点击ASCII数据可以切换编码显示方式。</p></li><li><p>堆栈窗口：显示当前线程的堆栈数据。比如程序初始化的一些常量、变量之类的数据。</p></li><li><p>菜单窗口：一些常用调试命令以及操作。一般把鼠标移到菜单窗口的某按钮后，界面最左下角会出现一些命令提示，比如单步步入（F7），单步步过F8，运行程序（F9）等。</p></li><li><p>命令行窗口：用来下断点等相关命令。</p></li></ul><p><strong>调试方法</strong></p><p><img src="/img/Network-attack/debug-shortcut-key.png"></p><p>F2：设置断点。只要在光标定位的位置（上图中灰色条）按F2键即可，再按一次F2键则会删除断点。（相当于 SoftICE 中的 F9）<br>F8：单步跳过。每按一次这个键执行一条反汇编窗口中的一条指令，遇到 CALL 等子程序不进入其代码。（相当于 SoftICE 中的 F10）<br>F7：单步步入。功能同单步步过(F8)类似，区别是遇到 CALL 等子程序时会进入其中，进入后首先会停留在子程序的第一条指令上。（相当于 SoftICE 中的 F8）<br>F4：运行到选定位置。作用就是直接运行到光标所在位置处暂停。（相当于 SoftICE 中的 F7）<br>F9：运行。按下这个键如果没有设置相应断点的话，被调试的程序将直接开始运行。（相当于 SoftICE 中的 F5）<br>CTR + F9：执行到返回。此命令在执行到一个 ret (返回指令)指令时暂停，常用于从系统领空返回到我们调试的程序领空。（相当于 SoftICE 中的 F12）<br>ALT + F9：执行到用户代码。可用于从系统领空快速返回到我们调试的程序领空。（相当于 SoftICE 中的 F11） </p><p><strong>常用断点</strong></p><p><a href="https://www.cnblogs.com/LyShark/p/13071792.html">Windows 下的常用调试API断点 - lyshark - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq1084283172/article/details/47733849">OD调试程序常用断点大全_od 创建进程 断点-CSDN博客</a></p><p>[<a href="https://cloud.tencent.com/developer/article/1910265">系统安全] 二十四.逆向分析之OD调试INT3断点、反调试、硬件断点与内存断点-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><strong>汇编指令</strong></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cmp a,b 比较a与b</span><br><span class="line"></span><br><span class="line">mov a,b 把b的值送给a</span><br><span class="line"></span><br><span class="line">ret 返回主程序</span><br><span class="line"></span><br><span class="line">nop 无作用,英文“no operation”的简写，意思是“do nothing”(机器码90)</span><br><span class="line">(解释:ultraedit打开编辑exe文件时你看到90,等同于汇编语句nop)</span><br><span class="line"></span><br><span class="line">call 调用子程序</span><br><span class="line"></span><br><span class="line">je 或jz 若相等则跳(机器码74 或0F84)</span><br><span class="line"></span><br><span class="line">jne或jnz 若不相等则跳(机器码75或0F85)</span><br><span class="line"></span><br><span class="line">jmp 无条件跳(机器码EB)</span><br><span class="line"></span><br><span class="line">jb 若小于则跳</span><br><span class="line"></span><br><span class="line">ja 无符-若大于则跳</span><br><span class="line"></span><br><span class="line">jg 有符-若大于则跳</span><br><span class="line"></span><br><span class="line">jge 若大于等于则跳</span><br><span class="line"></span><br><span class="line">jl 若小于则跳</span><br><span class="line"></span><br><span class="line">jle 若小于等于则跳</span><br><span class="line"></span><br><span class="line">pop 出栈</span><br><span class="line"></span><br><span class="line">push 压栈</span><br></pre></td></tr></table></figure><p>1.E语言在OD里面的入口特征（OEP）<br>E语言的入口其实和VC++基本差不多，所以 在OD里面Ctrl+B 输入 FF 25<br>​2.E语言的按钮事件<br>FF 55 FC 5F 5E，这个就是E语言的按钮在OD中的特征码，搜索它就直接可以找到按钮事件在OD的Call的位置<br>3.E语言常用断点</p><ul><li>MessageBoxA  消息框断点</li><li>ShellExecuteA&#x2F;W   WinExec    弹网页</li><li>CreateProcessA&#x2F;W  创建进程</li><li>ExitProcess       退出进程</li></ul><h4 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h4><p><a href="https://www.52pojie.cn/thread-1646466-1-1.html">练习笔记之手撕常见压缩壳 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.52pojie.cn/thread-1641368-1-1.html">关于压缩壳脱壳步骤详解！看这一篇足够。 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.cnblogs.com/hongren/p/12633232.html">ESP定律脱壳——NsPack3.x脱壳 - 红刃 - 博客园 (cnblogs.com)</a><br><a href="https://www.52pojie.cn/thread-941671-1-1.html">手脱NsPack 壳，新手看看</a><br>什么是壳：<br>壳是一种概念上的东西，人们为了保护软件不会被轻易的修改或者反编译，希望软件能够获得一种保护，能如同乌龟壳保护乌龟一般，能有一个东西保护自己，于是壳就出现了。<br>关于壳的作用：<br>壳的初始作用是保护软件，但后来发展的方向不一就出现了各种各样的壳，大致有压缩壳、加密壳、VM 壳的分类。压缩壳故名思意，主要作用是用于压缩方面，可以有效的减小软件的大小；加密壳，其主要作用是保护软件；VM 壳是一种很特殊的壳，它利用了虚拟机技术，可以很有效的保护指定地址代码，但很大的牺牲了效率，所以一般只在关键代码处使用。</p><p><strong>ESP定律法 （80%的压缩壳可脱）</strong><br>ESP 定律法是脱壳的利器，是应用频率最高的脱壳方法之一。ESP 定律的原理在于程序中堆栈平衡的合理利用。由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器内容压栈，如使用 pushad，在解压结束后，会将之前的寄存器值出栈，如使用 popad。因此在寄存器出栈时，往往程序代码被自动恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的 OEP 位置。</p><p>具体操作步骤：pushad开头，F8一次以后，8个寄存器只有ESP是红色时候，就可以使用该定律。<br>右键ESP 选择数据窗口跟随，数据窗口下硬件访问断点，F9运行，此时已经接近OEP。<br><img src="/img/Network-attack/pvz-shell.png"></p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>可以看到这个辅助的功能有很多，接下来就跟我一起解密这些按钮在点击后发生了什么。</p><blockquote><p>之前分析的时候一直没开游戏只对辅助od，结果破壳破了好久也没成功，但就算破壳也无法直接获取到源码，只能看汇编，破解还是要在游戏中去进行，辅助修改游戏的内存，只要对写内存操作打断点就可以观察具体的修改。踩了这样一个坑，希望引以为戒。</p></blockquote><p><img src="/img/Network-attack/PVZ-analysis-1.png"></p><h4 id="阳光修改"><a href="#阳光修改" class="headerlink" title="阳光修改"></a>阳光修改</h4><p>1.首先我们找出阳光的动态地址，找到之后我们双击这个地址，将其加入到地址列表中，阳光的查找技巧相信你已经能够掌握了，这里就不再罗嗦了。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718105016029-754750877.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718105016029-754750877.png" alt="img"></a></p><p>2.接着我们选择最下方的地址列表，然后按下<code>F6键</code>，也就是下一个硬件写入断点，然后回到游戏等待阳光出现并点击阳光，此时CE会出现以下代码，我们只需要记下<code>00430A11</code>这个内存地址，然后直接关闭CE吧，短期内用不到了。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718105234187-230098721.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718105234187-230098721.png" alt="img"></a></p><p>3.打开OD，然后我们直接附加植物大战僵尸的游戏进程，点击<code>文件</code>然后点击<code>附加</code>选择植物大战僵尸进程就好。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110121994-224028383.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110121994-224028383.png" alt="img"></a></p><p>4.附加完成后，我们的游戏会被OD暂停运行，此时我们直接按下<code>F12</code>让游戏正常的运行，默认情况下会停在系统领空，我们直接按下<code>Ctrl + G</code>输入<code>00401000</code>来到程序领空。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110558599-2081305956.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110558599-2081305956.png" alt="img"></a></p><p>5.接着我们按下<code>Ctrl + G</code>输入<code>00430A11</code>跳转到刚才找到的代码位置，过去以后直接<code>F2</code>下一个断点</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110754502-1706128416.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110754502-1706128416.png" alt="img"></a></p><p>6.紧接着我们回到游戏，然后等待阳光的出现，当阳光出现后我们点击阳光，OD会自动断在00430A11的位置，其中ecx就是要增加的阳光数。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718111426062-1841073246.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718111426062-1841073246.png" alt="img"></a></p><p>上图并没有CALL调用，应该是在外部，我们直接回朔到上一层<code>Ctrl+F9</code>执行到返回，<code>F8</code>直接出CALL.</p><p>7.我们在JNZ和CALL的两处位置下断点，然后运行程序，当我们点击阳光时会断在JNZ的位置，如果把JNZ用NOP填充的话，会发现当我们再次点击阳光的时候阳光会迅速的被回收没有了动画。</p><p>也就是说，JNZ如果成立的话则会有回收阳光的动画，当不成立的时候则会执行<code>call 004309d0</code>显然这就是回收阳光的关键CALL，但我们可猜测，再回收阳光的时候一定会判断是否回收，所以回收的判断应该在上一层。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718111754966-828351196.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718111754966-828351196.png" alt="img"></a></p><p>8.首先我们回到游戏，等待出现阳光然后点击阳光，OD会断下，断下后我们取消这两处的断点，然后跟着OD单步<code>F8</code>向下走，直接出这个CALL，出CALL后会看到如下代码，我们直接下三个断点。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718112814057-159772692.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718112814057-159772692.png" alt="img"></a></p><p>9.下好断点，回到游戏等待阳光下落我们回收，此时OD会断下，我们运行OD发现会一直被断在<code>0043158F</code>只要阳光没有收回就会一直断下，此处的跳转并没有实现，因为我们没有去点击阳光，这里可以得出如果点击了阳光JNZ则会跳转成立，否则不成立等待用户点击回收阳光。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718113135132-2026175107.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718113135132-2026175107.png" alt="img"></a></p><p>10.我们取消所有的断点，然后尝试把JNZ跳转改成JMP无条件跳转，让其只要一出现阳光就自动的触发回收的CALL试试。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718113425831-2135275106.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718113425831-2135275106.png" alt="img"></a></p><p>改完以后我们回到游戏，会发现只要阳光出现了会被立即回收。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718130615227-2143845712.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718130615227-2143845712.png" alt="img"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PVZ辅助&quot;&gt;&lt;a href=&quot;#PVZ辅助&quot; class=&quot;headerlink&quot; title=&quot;PVZ辅助&quot;&gt;&lt;/a&gt;PVZ辅助&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/follow-the-vine-to-get-to-the-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>外挂分析与实现</title>
    <link href="http://example.com/2023/10/19/net-attack&amp;defence-doc/%E5%A4%96%E6%8C%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/10/19/net-attack&amp;defence-doc/%E5%A4%96%E6%8C%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-10-19T00:39:59.000Z</published>
    <updated>2023-10-19T00:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PVZ辅助"><a href="#PVZ辅助" class="headerlink" title="PVZ辅助"></a>PVZ辅助</h2><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/tree/main">PlantsVsZombies-Cheat: 植物大战僵尸逆向分析与辅助开发系列教程(github.com)</a></p><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><h4 id="OnlyDbg使用"><a href="#OnlyDbg使用" class="headerlink" title="OnlyDbg使用"></a>OnlyDbg使用</h4><p><a href="https://www.bilibili.com/video/BV1cE411f7sE/?p=6&spm_id_from=pageDriver&vd_source=206a091077ff783d662b49e64cc9589d">06.常用断点之硬件断点原理解析_哔哩哔哩_bilibili</a></p><p><a href="https://www.cnblogs.com/xueyoo/articles/4938538.html">OllyDBG完美教程(超强入门级) - xueyoo - 博客园 (cnblogs.com)</a></p><p><strong>OllyDBG界面认识</strong><br><img src="/img/Network-attack/OB-desktop.png"></p><ul><li><p>反汇编窗口：显示被调试程序的反汇编代码。用鼠标左键点击注释标签可以切换注释显示的方式。如果需要修改代码，直接在这里在修改，比如“使用NOP填充”。</p></li><li><p>寄存器窗口：显示当前所选线程的CPU寄存器内容。点击标签寄存器(FPU)可以切换显示寄存器的方式。</p></li><li><p>信息窗口：显示反汇编窗口中当前选中的第一条命令的参数及一些跳转目标地址、字串等（一般动态加密解密字串等会在此出现）。</p></li><li><p>数据窗口：显示内存或文件的内容。直接点击ASCII数据可以切换编码显示方式。</p></li><li><p>堆栈窗口：显示当前线程的堆栈数据。比如程序初始化的一些常量、变量之类的数据。</p></li><li><p>菜单窗口：一些常用调试命令以及操作。一般把鼠标移到菜单窗口的某按钮后，界面最左下角会出现一些命令提示，比如单步步入（F7），单步步过F8，运行程序（F9）等。</p></li><li><p>命令行窗口：用来下断点等相关命令。</p></li></ul><p><strong>调试方法</strong></p><p><img src="/img/Network-attack/debug-shortcut-key.png"></p><p>F2：设置断点。只要在光标定位的位置（上图中灰色条）按F2键即可，再按一次F2键则会删除断点。（相当于 SoftICE 中的 F9）<br>F8：单步跳过。每按一次这个键执行一条反汇编窗口中的一条指令，遇到 CALL 等子程序不进入其代码。（相当于 SoftICE 中的 F10）<br>F7：单步步入。功能同单步步过(F8)类似，区别是遇到 CALL 等子程序时会进入其中，进入后首先会停留在子程序的第一条指令上。（相当于 SoftICE 中的 F8）<br>F4：运行到选定位置。作用就是直接运行到光标所在位置处暂停。（相当于 SoftICE 中的 F7）<br>F9：运行。按下这个键如果没有设置相应断点的话，被调试的程序将直接开始运行。（相当于 SoftICE 中的 F5）<br>CTR + F9：执行到返回。此命令在执行到一个 ret (返回指令)指令时暂停，常用于从系统领空返回到我们调试的程序领空。（相当于 SoftICE 中的 F12）<br>ALT + F9：执行到用户代码。可用于从系统领空快速返回到我们调试的程序领空。（相当于 SoftICE 中的 F11） </p><p><strong>常用断点</strong></p><p><a href="https://www.cnblogs.com/LyShark/p/13071792.html">Windows 下的常用调试API断点 - lyshark - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq1084283172/article/details/47733849">OD调试程序常用断点大全_od 创建进程 断点-CSDN博客</a></p><p>[<a href="https://cloud.tencent.com/developer/article/1910265">系统安全] 二十四.逆向分析之OD调试INT3断点、反调试、硬件断点与内存断点-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><strong>汇编指令</strong></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cmp a,b 比较a与b</span><br><span class="line"></span><br><span class="line">mov a,b 把b的值送给a</span><br><span class="line"></span><br><span class="line">ret 返回主程序</span><br><span class="line"></span><br><span class="line">nop 无作用,英文“no operation”的简写，意思是“do nothing”(机器码90)</span><br><span class="line">(解释:ultraedit打开编辑exe文件时你看到90,等同于汇编语句nop)</span><br><span class="line"></span><br><span class="line">call 调用子程序</span><br><span class="line"></span><br><span class="line">je 或jz 若相等则跳(机器码74 或0F84)</span><br><span class="line"></span><br><span class="line">jne或jnz 若不相等则跳(机器码75或0F85)</span><br><span class="line"></span><br><span class="line">jmp 无条件跳(机器码EB)</span><br><span class="line"></span><br><span class="line">jb 若小于则跳</span><br><span class="line"></span><br><span class="line">ja 无符-若大于则跳</span><br><span class="line"></span><br><span class="line">jg 有符-若大于则跳</span><br><span class="line"></span><br><span class="line">jge 若大于等于则跳</span><br><span class="line"></span><br><span class="line">jl 若小于则跳</span><br><span class="line"></span><br><span class="line">jle 若小于等于则跳</span><br><span class="line"></span><br><span class="line">pop 出栈</span><br><span class="line"></span><br><span class="line">push 压栈</span><br></pre></td></tr></table></figure><p>1.E语言在OD里面的入口特征（OEP）<br>E语言的入口其实和VC++基本差不多，所以 在OD里面Ctrl+B 输入 FF 25<br>​2.E语言的按钮事件<br>FF 55 FC 5F 5E，这个就是E语言的按钮在OD中的特征码，搜索它就直接可以找到按钮事件在OD的Call的位置<br>3.E语言常用断点</p><ul><li>MessageBoxA  消息框断点</li><li>ShellExecuteA&#x2F;W   WinExec    弹网页</li><li>CreateProcessA&#x2F;W  创建进程</li><li>ExitProcess       退出进程</li></ul><h4 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h4><p><a href="https://www.52pojie.cn/thread-1646466-1-1.html">练习笔记之手撕常见压缩壳 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.52pojie.cn/thread-1641368-1-1.html">关于压缩壳脱壳步骤详解！看这一篇足够。 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.cnblogs.com/hongren/p/12633232.html">ESP定律脱壳——NsPack3.x脱壳 - 红刃 - 博客园 (cnblogs.com)</a><br><a href="https://www.52pojie.cn/thread-941671-1-1.html">手脱NsPack 壳，新手看看</a><br>什么是壳：<br>壳是一种概念上的东西，人们为了保护软件不会被轻易的修改或者反编译，希望软件能够获得一种保护，能如同乌龟壳保护乌龟一般，能有一个东西保护自己，于是壳就出现了。<br>关于壳的作用：<br>壳的初始作用是保护软件，但后来发展的方向不一就出现了各种各样的壳，大致有压缩壳、加密壳、VM 壳的分类。压缩壳故名思意，主要作用是用于压缩方面，可以有效的减小软件的大小；加密壳，其主要作用是保护软件；VM 壳是一种很特殊的壳，它利用了虚拟机技术，可以很有效的保护指定地址代码，但很大的牺牲了效率，所以一般只在关键代码处使用。</p><p><strong>ESP定律法 （80%的压缩壳可脱）</strong><br>ESP 定律法是脱壳的利器，是应用频率最高的脱壳方法之一。ESP 定律的原理在于程序中堆栈平衡的合理利用。由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器内容压栈，如使用 pushad，在解压结束后，会将之前的寄存器值出栈，如使用 popad。因此在寄存器出栈时，往往程序代码被自动恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的 OEP 位置。</p><p>具体操作步骤：pushad开头，F8一次以后，8个寄存器只有ESP是红色时候，就可以使用该定律。<br>右键ESP 选择数据窗口跟随，数据窗口下硬件访问断点，F9运行，此时已经接近OEP。<br><img src="/img/Network-attack/pvz-shell.png"></p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>可以看到这个辅助的功能有很多，接下来就跟我一起解密这些按钮在点击后发生了什么。</p><blockquote><p>之前分析的时候一直没开游戏只对辅助od，结果破壳破了好久也没成功，但就算破壳也无法直接获取到源码，只能看汇编，破解还是要在游戏中去进行，辅助修改游戏的内存，只要对写内存操作打断点就可以观察具体的修改。踩了这样一个坑，希望引以为戒。</p></blockquote><p><img src="/img/Network-attack/PVZ-analysis-1.png"></p><h4 id="阳光修改"><a href="#阳光修改" class="headerlink" title="阳光修改"></a>阳光修改</h4><p>1.首先我们找出阳光的动态地址，找到之后我们双击这个地址，将其加入到地址列表中，阳光的查找技巧相信你已经能够掌握了，这里就不再罗嗦了。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718105016029-754750877.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718105016029-754750877.png" alt="img"></a></p><p>2.接着我们选择最下方的地址列表，然后按下<code>F6键</code>，也就是下一个硬件写入断点，然后回到游戏等待阳光出现并点击阳光，此时CE会出现以下代码，我们只需要记下<code>00430A11</code>这个内存地址，然后直接关闭CE吧，短期内用不到了。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718105234187-230098721.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718105234187-230098721.png" alt="img"></a></p><p>3.打开OD，然后我们直接附加植物大战僵尸的游戏进程，点击<code>文件</code>然后点击<code>附加</code>选择植物大战僵尸进程就好。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110121994-224028383.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110121994-224028383.png" alt="img"></a></p><p>4.附加完成后，我们的游戏会被OD暂停运行，此时我们直接按下<code>F12</code>让游戏正常的运行，默认情况下会停在系统领空，我们直接按下<code>Ctrl + G</code>输入<code>00401000</code>来到程序领空。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110558599-2081305956.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110558599-2081305956.png" alt="img"></a></p><p>5.接着我们按下<code>Ctrl + G</code>输入<code>00430A11</code>跳转到刚才找到的代码位置，过去以后直接<code>F2</code>下一个断点</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110754502-1706128416.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110754502-1706128416.png" alt="img"></a></p><p>6.紧接着我们回到游戏，然后等待阳光的出现，当阳光出现后我们点击阳光，OD会自动断在00430A11的位置，其中ecx就是要增加的阳光数。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718111426062-1841073246.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718111426062-1841073246.png" alt="img"></a></p><p>上图并没有CALL调用，应该是在外部，我们直接回朔到上一层<code>Ctrl+F9</code>执行到返回，<code>F8</code>直接出CALL.</p><p>7.我们在JNZ和CALL的两处位置下断点，然后运行程序，当我们点击阳光时会断在JNZ的位置，如果把JNZ用NOP填充的话，会发现当我们再次点击阳光的时候阳光会迅速的被回收没有了动画。</p><p>也就是说，JNZ如果成立的话则会有回收阳光的动画，当不成立的时候则会执行<code>call 004309d0</code>显然这就是回收阳光的关键CALL，但我们可猜测，再回收阳光的时候一定会判断是否回收，所以回收的判断应该在上一层。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718111754966-828351196.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718111754966-828351196.png" alt="img"></a></p><p>8.首先我们回到游戏，等待出现阳光然后点击阳光，OD会断下，断下后我们取消这两处的断点，然后跟着OD单步<code>F8</code>向下走，直接出这个CALL，出CALL后会看到如下代码，我们直接下三个断点。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718112814057-159772692.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718112814057-159772692.png" alt="img"></a></p><p>9.下好断点，回到游戏等待阳光下落我们回收，此时OD会断下，我们运行OD发现会一直被断在<code>0043158F</code>只要阳光没有收回就会一直断下，此处的跳转并没有实现，因为我们没有去点击阳光，这里可以得出如果点击了阳光JNZ则会跳转成立，否则不成立等待用户点击回收阳光。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718113135132-2026175107.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718113135132-2026175107.png" alt="img"></a></p><p>10.我们取消所有的断点，然后尝试把JNZ跳转改成JMP无条件跳转，让其只要一出现阳光就自动的触发回收的CALL试试。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718113425831-2135275106.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718113425831-2135275106.png" alt="img"></a></p><p>改完以后我们回到游戏，会发现只要阳光出现了会被立即回收。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718130615227-2143845712.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718130615227-2143845712.png" alt="img"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PVZ辅助&quot;&gt;&lt;a href=&quot;#PVZ辅助&quot; class=&quot;headerlink&quot; title=&quot;PVZ辅助&quot;&gt;&lt;/a&gt;PVZ辅助&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/follow-the-vine-to-get-to-the-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络攻防实验</title>
    <link href="http://example.com/2023/10/18/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2023/10/18/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-10-18T09:26:59.000Z</published>
    <updated>2023-10-18T09:26:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络扫描"><a href="#网络扫描" class="headerlink" title="网络扫描"></a>网络扫描</h3><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 7</span><br><span class="line">连接本机7号端口</span><br><span class="line">netstat -na | more</span><br><span class="line">查看本机提供的服务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ls /bin /usr/bin |wc</span><br><span class="line">linux 命令查看</span><br></pre></td></tr></table></figure><p>telnet service:</p><p>控制面板——程序——启动或关闭windows功能——勾上telnet client</p><p>简单TCP&#x2F;IP service：</p><p>控制面板——程序——启动或关闭windows功能——勾上 simple TCP&#x2F;IP service</p><p> (1)Echo<br>   RFC862 端口 7<br>   回显在该服务器端口上接收到的任何消息中的数据。<br>   作为网络调试和监视工具可能非常有用。<br> (2)Discard<br>   RFC863 端口 9<br>   放弃该端口上接收到的所有消息，而不响应或确认。<br>   在网络设置和配置过程中，可以用作空端口来接收和路由 TCP&#x2F;IP 测试消息，或者在某些情况下，程序可将其用作为消息放弃函数。<br> (3)Character Generator<br>   RFC864 端口 19<br>   所发送数据包含一组 95 个可打印的 ASCII 字符。<br>   作为测试或解决行打印机问题的调试工具非常有用。<br> (4)Quote of the Day<br>   RFC865 端口 17<br>   在消息中以一行或多行文本的形式返回报价。<br>   报价从以下文件中随机提取：%SYSTEMROOT%\System32\Drivers\Etc\Quotes。<br>   示例报价文件会与简单的 TCP&#x2F;IP 服务一起安装。如果该文件丢失，则报价服务会失败。<br> (5)Daytime<br>   RFC867 端口 13<br>   返回包含星期几、月、天、年、当前时间（以 hh:mm:ss 格式表示）和时区信息的消息。<br>   某些程序可能会将该服务的输出用于调试或监视系统时钟时间中或不同主机上的变化。</p><p><strong>ntop</strong>服务</p><p>nmap script 漏洞 heartbleed </p><p>TCP keep-alive 删除死连接</p><p><a href="https://cloud.tencent.com/developer/article/2104021">心脏出血（Heartbleed）漏洞浅析、复现-腾讯云开发者社区-腾讯云 (tencent.com)</a> </p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">telnet 211.87.227.229 4433    </span><br><span class="line">git服务器</span><br><span class="line">127.28.11.31</span><br><span class="line">靶机服务器</span><br></pre></td></tr></table></figure><h2 id="FAKE-WIFI实验"><a href="#FAKE-WIFI实验" class="headerlink" title="FAKE-WIFI实验"></a>FAKE-WIFI实验</h2><p>无线网卡还在路上~</p><p>2023.10.23 更新<br>1.1. 建立wifi热点<br>使用一个usb无线网卡，可以建立一个WIFI热点。</p><p>安装驱动：<a href="https://wkqd.lanzouu.com/s/wkqd">https://wkqd.lanzouu.com/s/wkqd</a></p><blockquote><p>目前状况：第一步就卡住了，网卡不支持承载网络。</p><p>看了几个贴子，给出的方法包括但不限于：1.更新驱动。2.开启“移动热点”功能，新的网卡驱动不再支持使用托管网络，而这也是许多教程要求使用旧版本驱动的原因。3.[在 Windows 中设置无线网络 - Microsoft 支持](<a href="https://support.microsoft.com/zh-cn/windows/%E5%9C%A8-windows-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C-97914e31-3aa4-406d-cef6-f1629e2c3721#:~:text=%E5%9C%A8Windows">https://support.microsoft.com/zh-cn/windows/在-windows-中设置无线网络-97914e31-3aa4-406d-cef6-f1629e2c3721#:~:text=在Windows</a> 10 中 ，选择 “开始”，然后选择”设置&gt; Internet %26”&gt;”状态&gt;”网络和共享中心”。,在Windows 11 中，选择”开始”，键入”控制面板”，然后选择”控制面板”&gt;”网络和 Internet&gt;”网络和共享中心”。 选择“设置新的连接或网络”。 选择“设置新网络”，然后选择“下一步”。 该向导将指导你创建网络名称和安全密钥。)</p><p>未能解决问题，可能是网卡本身就不支持，白折腾半天，问商家也不回消息，踩坑(T_T)</p></blockquote><p>Windows&#x2F;CMD中，配合两行命令(管理员权限)：<br>netsh wlan set hostednetwork mode&#x3D;allow<br>netsh wlan set hostednetwork mode&#x3D;allow ssid&#x3D;fake1 key&#x3D;12345678<br>netsh wlan start hostednetwork<br>如此设置后，手机即可通过该热点“fake1”上网了。<br>其他有用的命令：<br>netsh wlan stop hostednetwork  # 停止<br>NETSH WLAN show drivers  #显示参数等</p><p><img src="/img/Network-attack/fake-wifi-1.png"></p><p>1.2. 加入dns欺骗</p><h2 id="课程项目1：网络攻防安全扫描集成平台"><a href="#课程项目1：网络攻防安全扫描集成平台" class="headerlink" title="课程项目1：网络攻防安全扫描集成平台"></a>课程项目1：网络攻防安全扫描集成平台</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.   介绍"></a>1.   介绍</h3><p>进行网络安全扫描，和对文件系统进行杀毒扫描一样，杀毒扫描需要病毒特征库，网络安全扫描需要漏洞攻击库，而且这些库都在各自更新，除了可以自由使用的版本，有的还有昂贵的商业版本。因此，仅用一款扫描工具是不够的，要尽量多找不同的工具、使用不同来源的漏洞攻击库。因此，需要建立一个综合各种扫描工具、支持多种漏洞攻击库的集成系统，服务于生产，也可以服务教学需求。</p><h3 id="2-扫描工具"><a href="#2-扫描工具" class="headerlink" title="2.   扫描工具"></a>2.   扫描工具</h3><p>根据不同的目的、功能、用途，网络安全方面的扫描器可以分为很多种。</p><p>下面是几款漏洞扫描软件的介绍、试用以及实测结果，包括nmap、nessus、Metasploit、OpenVAS、W3AF等。</p><h4 id="I-Nmap-org"><a href="#I-Nmap-org" class="headerlink" title="I. Nmap.org"></a>I. <a href="https://nmap.org/">Nmap.org</a></h4><p><a href="https://blog.csdn.net/m0_46588765/article/details/107417808">nmap扫描与tcpdump抓包工具_nmap是抓包工具的吗-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_43510203/article/details/107596158">Nmap端口扫描+Nmap脚本扫描漏洞（学习笔记）_nmap漏洞扫描分析脚本文件-CSDN博客</a></p><p><a href="https://www.cnblogs.com/rtnb/p/15595210.html">tcpdump抓包与nmap扫描 - 不会跳舞的胖子 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/day0713/article/details/123171655">网络攻防技术——端口扫描_2)对本机(关闭防火墙)的开放端口和非开放端口完成半连接、ack、fin、null、xmas、_啦啦啦啦啦啦啦噜噜的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_51459513/article/details/117263932">网络攻防之网络扫描_unicornscan_程序猿cxy的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/smli_ng/article/details/105964486">nmap详细参数 -CSDN博客</a></p><p>Nmap是开放开源的，比较小巧，用法简单而直接，尤其适合对大IP范围内的主机进行初步扫描以确定重点攻击目标，因此是入侵者最常用的前期预扫描工具。<a href="http://nmap.org/">http://nmap.org/</a> </p><p>端口扫描是<a href="https://so.csdn.net/so/search?q=Nmap&spm=1001.2101.3001.7020">Nmap</a>最基本最核心的功能，用于确定目标主机的TCP&#x2F;UDP端口的开放情况。 默认情况下，Nmap会扫描<strong>1000</strong>个最有可能开放的TCP端口。</p><p>利用nmap能测试和发现：</p><ul><li>目标主机（IP）是否开机，安装了什么操作系统，有哪些端口开着，是什么服务，哪种服务程序，什么版本；</li><li>能规避防火墙的防护规则，能根据脚本自动、批量的扫描有哪些漏洞；</li></ul><p>Nmap具体功能：端口扫描，协议扫描，漏洞扫描，绕过防护，漏洞利用等。</p><h5 id="nmap测试"><a href="#nmap测试" class="headerlink" title="nmap测试"></a>nmap测试</h5><p>nmap的基本用法:</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 【扫描类型】 【选项】 【扫描目标…】</span><br></pre></td></tr></table></figure><p>常用的扫描类型：</p><ul><li>-sS ：TCP，SYN扫描(半开) 半开扫描意思就是，客户端向服务器请求连接，当服务器给与回应时，客户端又不响应服务器。这就是典型的DDOS攻击</li><li>-sT ： TCP连接扫描(全开) 全开扫描表示执行完三次握手</li><li>-sU ： UDP扫描</li><li>-sP： ICMP扫描</li><li>-A ：目标系统全面分析</li></ul><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 默认TCP扫描</span><br><span class="line">$ nmap 10.27.214.21</span><br><span class="line">Starting Nmap 7.94 ( https://nmap.org ) at 2023-10-18 11:52 EDT</span><br><span class="line">Nmap scan report for 10.27.214.21</span><br><span class="line">Host is up (0.0096s latency).</span><br><span class="line">Not shown: 993 filtered tcp ports (no-response)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">25/tcp   open  smtp</span><br><span class="line">110/tcp  open  pop3</span><br><span class="line">135/tcp  open  msrpc</span><br><span class="line">139/tcp  open  netbios-ssn</span><br><span class="line">445/tcp  open  microsoft-ds</span><br><span class="line">912/tcp  open  apex-mesh</span><br><span class="line">3306/tcp open  mysql</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#扫描本机开了什么端口，默认TCP扫描</span><br><span class="line">$ nmap 127.0.0.1   </span><br><span class="line">Starting Nmap 7.94 ( https://nmap.org ) at 2023-10-18 12:03 EDT</span><br><span class="line">Nmap scan report for localhost (127.0.0.1)</span><br><span class="line">Host is up (0.000025s latency).</span><br><span class="line">All 1000 scanned ports on localhost (127.0.0.1) are in ignored states.</span><br><span class="line">Not shown: 1000 closed tcp ports (reset)                     </span><br></pre></td></tr></table></figure><ul><li><p><input disabled="" type="checkbox"> 为什么扫描结果不一致？</p></li><li><p><input disabled="" type="checkbox"> ipconfig的结果</p></li><li><p><input disabled="" type="checkbox"> eth0</p></li></ul><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**抓取指定协议的数据包**</span><br><span class="line">#另外打开一个虚拟机ping host50主机</span><br><span class="line">$ ping -c 1 192.168.4.50</span><br><span class="line">PING 192.168.4.50 (192.168.4.50) 56(84) bytes of data.</span><br><span class="line"> </span><br><span class="line">--- 192.168.4.50 ping statistics ---</span><br><span class="line">1 packets transmitted, 0 received, 100% packet loss, time 0ms</span><br><span class="line"></span><br><span class="line">#这时host 50主机就可以抓到相应的ping包</span><br><span class="line">#抓取经过eth0上的数据包</span><br><span class="line">$ tcpdump  -i eth0 icmp</span><br><span class="line">tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">12:13:19.839665 IP 192.168.122.129 &gt; 192.168.4.50: ICMP echo request, id 53883, seq 1, length 64</span><br><span class="line"></span><br><span class="line">#node2为源地址，host50为目标地址</span><br><span class="line">IP [host50] &gt; [node2]: ICMP echo [request], id [7227], seq [1], length [64]</span><br></pre></td></tr></table></figure><p><img src="/img/Network-attack/tcpdump-use-1.png"></p><p>Nmap端口扫描<br>端口状态：</p><p>1、Open：端口开启，有程序监听此端口</p><p>2、Closed：端口关闭，数据能到达主机，但是没有程序监听此端口</p><p>3、Filtered：数据未能到达主机</p><p>4、Unfiltered：数据能到达主机，但是Nmap无法判断端口开启还是关闭</p><p>5、Open | filtered：端口没返回值，主要出现在UDP，IP，FIN，NULL和Xmas扫描</p><p>6、Closed | filtered：只出现在IP ID idle 扫描</p><p>单个扫描：nmap xxx.xxx.xxx.xxx</p><p>多个扫描：nmap 192.168.1.1 192.168.1.2</p><p>网段扫描：nmap 192.168.2.1-192.168.2.100</p><p>导入扫描：nmap -iL [LIST.TXT]</p><p><strong>nmap的扫描脚本</strong></p><p>nmap提供了大量不同种类的脚本，方便不同的用途。按照不同的主题分类主要有：</p><p>  auth: 负责处理鉴权证书（绕开鉴权）的脚本<br>  broadcast: 在局域网内探查更多服务开启状况，如dhcp&#x2F;dns&#x2F;sqlserver等服务<br>  brute: 提供暴力破解方式，针对常见的应用如http&#x2F;snmp等<br>  default:  使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力<br>  discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等<br>  dos: 用于进行拒绝服务攻击<br>  exploit: 利用已知的漏洞入侵系统<br>  external: 利用第三方的数据库或资源，例如进行whois解析<br>  fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞<br>  intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS&#x2F;IPS的记录或屏蔽<br>  malware: 探测目标机是否感染了病毒、开启了后门等信息<br>  safe: 此类与intrusive相反，属于安全性脚本<br>  version: 负责增强服务与版本扫描（Version Detection）功能的脚本<br>  vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067  </p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#默认脚本扫描，主要搜索各种应用服务的信息，收集后，可再针对具体服务进行攻击</span><br><span class="line">nmap --script=default 192.168.88.131</span><br><span class="line"></span><br><span class="line">#检查是否存在常见漏洞</span><br><span class="line">nmap --script=vuln 192.168.1.104</span><br><span class="line"></span><br><span class="line">#提供暴力破解的方式，可对数据库、smb、snmp等进行简单密码的暴力猜解</span><br><span class="line">nmap --script=brute 192.168.88.131</span><br><span class="line"></span><br><span class="line">#利用FTP指定脚本对目标特定FTP协议进行密码爆破</span><br><span class="line">nmap --script=ftp-brute.nse 192.168.88.131</span><br><span class="line"></span><br><span class="line">#利用第三方的数据库或资源，例如进行whoise解析</span><br><span class="line">nmap --script=external 192.168.88.131</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="nmap脚本"><a href="#nmap脚本" class="headerlink" title="nmap脚本"></a>nmap脚本</h5><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat ping.sh </span><br><span class="line">#!/bin/bash</span><br><span class="line">yum -y install nmap &gt; /dev/null</span><br><span class="line">read -p &quot;输入整个网段例如104.233.105.0/24：&quot; ip</span><br><span class="line">nmap -n -sP $ip  &gt; /root/ping.test  # -n表示不做主机名解析</span><br><span class="line">num=$(cat /root/ping.test | tail -1 | awk &#x27;&#123;print $3&#125;&#x27;)</span><br><span class="line">setup=$(cat /root/ping.test | tail -1 | awk &#x27;&#123;print $6&#125;&#x27;)</span><br><span class="line">echo &quot;扫描到$num个IP&quot;</span><br><span class="line">echo &quot;有$setup个可以通信&quot;</span><br><span class="line">rm -rf /root/ping.test</span><br></pre></td></tr></table></figure><h5 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h5><p><strong>ipconfig</strong> </p><blockquote><p>ipconfig &#x2F;all：显示本机TCP&#x2F;IP配置的详细信息；<br>ipconfig &#x2F;release：DHCP客户端手工释放IP地址；<br>ipconfig &#x2F;renew：DHCP客户端手工向服务器刷新请求；<br>ipconfig &#x2F;flushdns：清除本地DNS缓存内容；<br>ipconfig &#x2F;displaydns：显示本地DNS内容；<br>ipconfig &#x2F;registerdns：DNS客户端手工向服务器进行注册；<br>ipconfig &#x2F;showclassid：显示网络适配器的DHCP类别信息；<br>ipconfig &#x2F;setclassid：设置网络适配器的DHCP类别。<br>ipconfig &#x2F;renew “Local Area Connection”：更新“本地连接”适配器的由 DHCP 分配 IP 地址的配置<br>ipconfig &#x2F;showclassid Local*：显示名称以 Local 开头的所有适配器的 DHCP 类别 ID<br>ipconfig &#x2F;setclassid “Local Area Connection” TEST：将“本地连接”适配器的 DHCP 类别 ID 设置为 TEST</p></blockquote><figure class="highlight bash"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示所有当前的 TCP/IP 网络配置值，并刷新动态主机配置协议 (DHCP) 和域名系统 (DNS) 设置。 在没有参数的情况下使用时，ipconfig 会显示 Internet 协议版本 4 (IPv4) 和 IPv6 地址、子网掩码以及所有适配器的默认网关。</span></span><br><span class="line">&gt; ipconfig </span><br><span class="line">无线局域网适配器 WLAN:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::8aa0:535b:4042:fe90%8</span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : 10.27.214.21</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : 255.255.192.0</span><br><span class="line">   默认网关. . . . . . . . . . . . . : 10.27.255.254</span><br></pre></td></tr></table></figure><p><strong>tcpdump</strong></p><p><strong>语法：</strong></p><figure class="highlight text"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tcpdump [ -AdDefIJKlLnNOpqRStuUvxX ] [ -B buffer_size ] [ -c count ]</span><br><span class="line">               [ -C file_size ] [ -G rotate_seconds ] [ -F file ]</span><br><span class="line">               [ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M secret ]</span><br><span class="line">               [ -Q|-P in|out|inout ]</span><br><span class="line">               [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]</span><br><span class="line">               [ -W filecount ]</span><br><span class="line">               [ -E spi@ipaddr algo:secret,...  ]</span><br><span class="line">               [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ]</span><br><span class="line">               [ expression ]</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><p>-c 在收到指定的数量的分组后，tcpdump就会停止<br>-i 指定监听的网络接口<br>-r 从指定的文件中读取包(这些包一般通过-w选项产生)。<br>-w 直接将分组写入文件中，而不是不分析并打印出来。</p><p><strong>过滤条件：</strong><br>类型：host、net、port、portange<br>方向：src、dst<br>协议：tcp、dup、ip、wlan、arp…<br>多条件组合：and、or、not…</p><p><strong>示例：</strong></p><figure class="highlight text"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 无参数：抓取所有网络包，并在`terminal`中显示抓取的结果，将包以十六进制的形式显示。</span><br><span class="line">tcpdump</span><br></pre></td></tr></table></figure><figure class="highlight text"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 抓取所有的经过`eth0`网卡的网络包</span><br><span class="line">tcpdump -i eth0 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 想要截获所有192.168.1.100的主机收到的和发出的所有的数据包：</span><br><span class="line">tcpdump host 192.168.1.100</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 抓取经过 eth0 网卡的源 ip 是 192.168.1.100 数据包，src参数表示源。</span><br><span class="line">tcpdump -i eth0 -vnn src host 192.168.1.100</span><br><span class="line"></span><br><span class="line"># 抓取经过 eth0 网卡目的 ip 是 192.168.1.100 数据包，dst参数表示目的。</span><br><span class="line">tcpdump -i eth0 -vnn dst host 192.168.1.100</span><br></pre></td></tr></table></figure><h4 id="II-vuls"><a href="#II-vuls" class="headerlink" title="II. vuls"></a>II. vuls</h4><p><a href="https://github.com/future-architect/vuls">vuls - github</a></p><h4 id="III．legion"><a href="#III．legion" class="headerlink" title="III．legion"></a>III．legion</h4><p><strong>介绍</strong><br><a href="https://govanguard.com/legion">legoin 官网</a><br><a href="https://github.com/GoVanguard/legion">GitHub项目地址</a><br>Legion是SECFORCE的Sparta的分支，是一个开源，易于使用，超扩展和半自动化的网络渗透测试框架，针对发现，侦察和利用漏洞的信息系统。 Legion由GoVanguard开发和维护。</p><h5 id="legoin-测试"><a href="#legoin-测试" class="headerlink" title="legoin 测试"></a>legoin 测试</h5><p><strong>安装与使用</strong><br>kali取消了自带的Sparta而是改为legion，kali下的安装会方便的多；除此之外也可以尝试docker安装。kali终端直接输入legion即可启动。</p><p>填写的目标可为ip、可为网段、也可为域。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.0/24</span><br><span class="line">10.10.10.10-20</span><br><span class="line">1.2.3.4</span><br><span class="line">bing.com</span><br></pre></td></tr></table></figure><p><img src="/img/Network-attack/legoin-use-1.png"></p><h3 id="3-Docker打包"><a href="#3-Docker打包" class="headerlink" title="3.Docker打包"></a>3.Docker打包</h3><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html">Go 语言</a> 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络扫描&quot;&gt;&lt;a href=&quot;#网络扫描&quot; class=&quot;headerlink&quot; title=&quot;网络扫描&quot;&gt;&lt;/a&gt;网络扫描&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;input class=&quot;btn-copy&quot; type=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CTF - 网络安全夺旗赛</title>
    <link href="http://example.com/2023/10/18/CTF-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%BA%E6%97%97%E8%B5%9B/"/>
    <id>http://example.com/2023/10/18/CTF-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%BA%E6%97%97%E8%B5%9B/</id>
    <published>2023-10-17T16:11:10.000Z</published>
    <updated>2023-10-17T16:11:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><p><a href="https://zhuanlan.zhihu.com/p/631613398">2023最全CTF入门指南（建议收藏） - 知乎 (zhihu.com)</a></p><p>CTF在线练习场:<br><a href="https://zhuanlan.zhihu.com/p/407953508">https://zhuanlan.zhihu.com/p/407953508</a></p><p>【1】萌新_密码1<br>密文：<br>53316C6B5A6A42684D3256695A44566A4E47526A4D5459774C5556375A6D49324D32566C4D4449354F4749345A6A526B4F48303D<br>提交格式：KEY{XXXXXXXXXXXXXX}</p><p><strong>[WriteUp]</strong><br>hex-&gt;字符串-&gt;base64解密-&gt;栅栏解密<br>分析题目，密文看起来符合16进制特征，所以先尝试Hex decode 得到</p><blockquote><p>S1lkZjBhM2ViZDVjNGRjMTYwLUV7ZmI2M2VlMDI5OGI4ZjRkOH0&#x3D;</p></blockquote><p>有点像Base64加密特征，我们尝试Base64 decode发现</p><blockquote><p>KYdf0a3ebd5c4dc160-E{fb63ee0298b8f4d8}</p></blockquote><p>然后再使用对方提供的tool工具箱中的<em>栅栏密码加解密1.10</em>解码,将数据填进去，发现栏数只有两个选择：2和19。</p><p>我们从2栏开始解密得</p><blockquote><p>KEY{dffb06a33eeeb0d259c84bd8cf146d08-} 符合提交格式</p></blockquote><p>再试试19栏</p><blockquote><p>Kd03b54c6-{b3e28848Yfaedcd10Ef6e09bfd}</p></blockquote><p>【3】萌新_密码2<br>出题人已累，随便敲了几下键盘。。。 rdcvbg 2qase3 6tghu7</p><p><strong>[WriteUp]</strong><br>观察这三组字符串在键盘上的排列，能够发现规律这三组每一组都围绕着一个字符，得到flag{fwy}<br>【4】萌新 密码3<br>题目名称：我想吃培根<br>题目描述： – — .-. … . ..–.- .. … ..–.- -.-. — — .-.. ..–.- -… ..- - ..–.- -… .- -.-. — -. ..–.- .. … ..–.- -.-. — — .-.. . .-. ..–.- – – -.. -.. – -.. – -.. – – – -.. -.. -.. &#x2F;– -.. – -.. -.. –&#x2F; – – – – – &#x2F;– -.. -.. – -.. – &#x2F;– -.. -.. –<br>格式：flag{***********}<br><strong>[WriteUp]</strong><br>解题思路</p><p>首先题目中最先出现的是 – — .-. … . .，这样的内容，判断为摩斯电码</p><p>通过对摩斯电码进行解密，获得:</p><blockquote><p>MORSE_IS_COOL_BUT_BACON_IS_COOLER_MMDDMDMDMMMDDDMDMDDMMMMMMMDDMDMMDDM</p></blockquote><p>结合题目中出现的培根，可以了解到存在培根密码这样的一种加密方式。即将a-z，加密成AB两种组合，类似与二进制。</p><p>这里摘出MMDDMDMDMMMDDDMDMDDMMMMMMMDDMDMMDDM，将其转换成AB</p><p>AABBABABAAABBBABABBAAAAAAABBABAABBA ，对其进行培根解码可得</p><p>GUOWANG<br>【4】萌新 密码4<br>QW8obWdIWF5FKUFSQW5URihKXWZAJmx0OzYiLg&#x3D;&#x3D;<br>提示：比base64还大的base<br><strong>[WriteUp]</strong></p><p>密文一看就是base系列，而且提示里面也说明了base64，那么从base64解码看看得到如下：</p><blockquote><p>Ao(mgHX^E)ARAnTF(J]f@&lt;6”.</p></blockquote><p>这个显然不是flag，仍然需要解，那么比base64大的就是base85了</p><p>利用base85在线工具解除一下</p><p>发现一个很有意思的状况</p><blockquote><p><a href="http://www.atoolbox.net/Tool.php?Id=934">http://www.atoolbox.net/Tool.php?Id=934</a> 这个得出flag{base_base_b</p></blockquote><blockquote><p><a href="https://ctf.bugku.com/tool/base85">https://ctf.bugku.com/tool/base85</a> 这个显示Server Error</p></blockquote><blockquote><p><a href="https://try8.cn/tool/code/base85">https://try8.cn/tool/code/base85</a> 这个显示乱码�����fg���%��g�</p></blockquote><blockquote><p><a href="http://www.hiencode.com/base85.html">http://www.hiencode.com/base85.html</a> 这个显示解码失败</p></blockquote><blockquote><p><a href="https://gongjumi.com/encrypt/ascii85">https://gongjumi.com/encrypt/ascii85</a> 这个显示flag{base_base_b&#96;�LlAa（用RWA解码，其他解码标准要么没反应，要么乱码）</p></blockquote><blockquote><p><a href="https://www.rfctools.com/base85-decoder/">https://www.rfctools.com/base85-decoder/</a> 这个显示flag{base_base_b&#96;獿lAa</p></blockquote><p>总之我查到的base85解码网站，解码出来的状况千奇百怪，可能解码时用的编号标准是不一样的？所以查到最后，我用第一个的flag{base_base_b，来推测一下，看看后面是不是base，结果被我试出来了，但还是感觉一头雾水，于是又看了别人的WP，又从百度和谷歌找了很多资料，下面说一下对这道题的想法</p><p>说是Ao(mgHX^E)ARAnTF(J]f@&lt;6”.里面的【&lt;】是一个HTML字符实体，表示小于号【&lt;】，为什么不直接用&lt;来表示呢，因为如果直接用&lt;游览器会误以为这是一个HTML标签,而不是小于号。</p><p>于是我尝试将从base64解出来的字符串放到一个TXT文件并把它转换成HTML格式，通过游览器打开后，它显示了一个正确的可完整的被base85解码出来的字符串。</p><p>Ao(mgHX^E)ARAnTF(J]f@&lt;6”.</p><p>尝试放到上面的列出的各项base85解码网站，很神奇的是有些依然乱码，但大部分是可被正确解码出来的，我想可能是因为字符集用的不一样吧？</p><p>flag{base_base_base}</p><p>【5】萌新 密码5<br>小明心爱的图片在压缩包中，可是小明夜深人静的时候，孤枕难眠，想打开图片排遣寂寞，可是忘记了密码了，小米依稀记得9位的密码都是数字，前3位是372，你能帮助小明吗？</p><p>格式：flag{372XXXXXX}<br><strong>[WriteUp]</strong></p><p>已知总位数是9，同时已知全为数字，且前三位已经给出，暴力破解在十万-百万层级，时间不会很长，使用作者提供的工具，在攻击类型栏里选择掩码，并在暴力范围选项中只选择所有数字，在掩码框中写入“372??????”，进行破解即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CTF&quot;&gt;&lt;a href=&quot;#CTF&quot; class=&quot;headerlink&quot; title=&quot;CTF&quot;&gt;&lt;/a&gt;CTF&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/631613398&quot;&gt;2023最全CTF入门指南（建议收</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux实验</title>
    <link href="http://example.com/2023/10/17/linux%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2023/10/17/linux%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-10-17T04:51:37.000Z</published>
    <updated>2023-10-17T04:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实验一：Linux的基本操作和常见命令的使用"><a href="#实验一：Linux的基本操作和常见命令的使用" class="headerlink" title="实验一：Linux的基本操作和常见命令的使用"></a>实验一：Linux的基本操作和常见命令的使用</h3><p><strong>实验内容</strong>：</p><p>一. 基本命令</p><blockquote><p>__ 1. 显示系统当前时间.<br>__ 2. 显示2003年的日历.<br>__ 3. 分别显示1999年1月份和99年1月份的日历. 1999年的和99年的是否是一个?<br>__ 4. 列出系统中所有登陆用户.<br>__ 5. 显示你的登陆名.<br>__ 6. 显示你的用户信息.<br>__ 7. 清屏.<br>__ 8. 显示字符串’Out to lunch’.<br>__ 9. 使用wall命令进行系统广播:Good Evening everyone!<br>__ 10.使用一个命令屏蔽所有消息.这个命令对所有用户都起作用吗?</p></blockquote><p>二.  Man 手册</p><blockquote><p>__ 11. 使用man手册察看ls命令如何使用.<br>__ 12. 试着解释一下ls命令的man手册有几部分组成?每一部分是用来说明什么的?<br>__ 13. 在man手册中试着移动光标:<br>       到下一页<br>       到前一页<br>       向下移动一行<br>__ 14.退出man手册.</p></blockquote><p>__ 1. 显示系统当前时间：使用date命令。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br><span class="line">Tue Oct 17 12:55:18 AM EDT 2023</span><br></pre></td></tr></table></figure><p>__ 2. 显示2003年的日历：使用cal命令。</p><p><strong>cal</strong> <strong>和 ncal</strong></p><p>你可以使用 cal 命令显示整个月份。没有参数时，cal 显示当前月份，默认情况下，通过反转前景色和背景颜色来突出显示当天。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ cal 2003</span><br><span class="line"></span><br><span class="line">       April                  May                   June          </span><br><span class="line">Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  </span><br><span class="line">       1  2  3  4  5               1  2  3   1  2  3  4  5  6  7  </span><br><span class="line"> 6  7  8  9 10 11 12   4  5  6  7  8  9 10   8  9 10 11 12 13 14  </span><br><span class="line">13 14 15 16 17 18 19  11 12 13 14 15 16 17  15 16 17 18 19 20 21  </span><br><span class="line">20 21 22 23 24 25 26  18 19 20 21 22 23 24  22 23 24 25 26 27 28  </span><br><span class="line">27 28 29 30           25 26 27 28 29 30 31  29 30                 </span><br><span class="line">                                                                  </span><br><span class="line"></span><br><span class="line">        July                 August              September        </span><br><span class="line">Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  </span><br><span class="line">       1  2  3  4  5                  1  2      1  2  3  4  5  6  </span><br><span class="line"> 6  7  8  9 10 11 12   3  4  5  6  7  8  9   7  8  9 10 11 12 13  </span><br><span class="line">13 14 15 16 17 18 19  10 11 12 13 14 15 16  14 15 16 17 18 19 20  </span><br><span class="line">20 21 22 23 24 25 26  17 18 19 20 21 22 23  21 22 23 24 25 26 27  </span><br><span class="line">27 28 29 30 31        24 25 26 27 28 29 30  28 29 30              </span><br><span class="line">                      31                                          </span><br><span class="line"></span><br><span class="line">      October               November              December        </span><br><span class="line">Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  </span><br><span class="line">          1  2  3  4                     1      1  2  3  4  5  6  </span><br><span class="line"> 5  6  7  8  9 10 11   2  3  4  5  6  7  8   7  8  9 10 11 12 13  </span><br><span class="line">12 13 14 15 16 17 18   9 10 11 12 13 14 15  14 15 16 17 18 19 20  </span><br><span class="line">19 20 21 22 23 24 25  16 17 18 19 20 21 22  21 22 23 24 25 26 27  </span><br><span class="line">26 27 28 29 30 31     23 24 25 26 27 28 29  28 29 30 31           </span><br><span class="line">                      30                                          </span><br><span class="line">                                                      </span><br></pre></td></tr></table></figure><p>__ 3. 分别显示1999年1月份和99年1月份的日历，并判断它们是否相同。</p><p>你也可以使用 <code>cal</code> 命令显示一整年。请记住，你需要输入年份的四位数字。如果你输入 <code>cal 18</code>，你将获得公元 18 年的历年，而不是 2018 年。</p><p>要指定年份和月份，使用 <code>-d</code> 选项，如下所示：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cal -d 1949-03</span><br></pre></td></tr></table></figure><p>__ 4. 列出系统中所有登录用户：使用who命令。</p><p>Linux who命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p><p>使用权限：所有使用者都可使用。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//显示当前登录系统的用户</span><br><span class="line">$ who</span><br><span class="line">kali     tty7         2023-10-13 02:24 (:0)</span><br></pre></td></tr></table></figure><p>__ 5.显示你的登录名：使用finger命令。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finger [options] user[@address]</span><br></pre></td></tr></table></figure><p>Linux finger命令可以让使用者查询一些其他使用者的资料。会列出来的资料有：</p><p>· Login Name</p><p>· User Name</p><p>· Home directory</p><p>· Shell</p><p>· Login status</p><p>· mail status</p><p>· .plan</p><p>· .project</p><p>· .forward</p> <figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ finger </span><br><span class="line">Login     Name       Tty      Idle  Login Time   Office     Office Phone</span><br><span class="line">kali                 tty7       3d  Oct 13 02:24 (:0)</span><br><span class="line">                                                            </span><br></pre></td></tr></table></figure><p>__ 6.显示你用户信息：使用finger命令。</p><p>参数： -l 　多行显示。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//显示用户信息</span><br><span class="line">$ finger -l</span><br><span class="line">Login: kali                             Name: </span><br><span class="line">Directory: /home/kali                   Shell: /usr/bin/zsh</span><br><span class="line">On since Fri Oct 13 02:24 (EDT) on tty7 from :0</span><br><span class="line">   3 days 22 hours idle</span><br><span class="line">No mail.</span><br><span class="line">No Plan.           </span><br></pre></td></tr></table></figure><p>__ 7.清屏：使用clear命令</p><p>__ 8.显示字符串’Out to lunch’：使用echo命令。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;Out to lunch&quot;</span><br><span class="line">Out to lunch</span><br></pre></td></tr></table></figure><p>__ 9.使用wall命令进行系统广播：发送消息’Good Evening!’。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wall &#x27;Good Evening!&#x27;</span><br></pre></td></tr></table></figure><p>__ 10.使用一个命令屏蔽所有消息：使用mesg命令。这个命令对所有用户都起作用。</p><p>Linux mesg命令用于设置终端机的写入权限。</p><p>将mesg设置y时，其他用户可利用write指令将信息直接显示在您的屏幕上。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mesg [ny]</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>n 不允许其他用户将信息直接显示在你的屏幕上。</li><li>y 允许其他用户将信息直接显示在你的屏幕上。</li></ul><p>二. Man 手册</p><p>__ 11.使用man手册查看ls命令的使用方法。</p><p>__ 12.解释ls命令的man手册组成部分以及每部分的说明内容。</p><p>__ 13.在man手册中移动光标：翻页、上一页、向下滚动一行。</p><p>__ 14.退出man手册：使用q键退出。</p><p><img src="/img/experiment/linux-man.png"></p><h3 id="实验二：文件系统"><a href="#实验二：文件系统" class="headerlink" title="实验二：文件系统"></a>实验二：文件系统</h3><p>实验内容：</p><p>一.  对目录的操作</p><blockquote><p>__ 1. 检查你当前所在的目录，该目录是 __________.<br>    <code>pwd</code><br>__ 2. 改变当前目录到根目录(&#x2F;).<br>      <code>cd /</code><br>__ 3. 验证是否在根目录，分别用简单列表和长列表的方式列出目录中的文件.<br>    <code>ls</code><br>__ 4. 列出当前目录中的所有文件，列出当前目录及其子目录中的所有文件.<br>      注意: 该命令会有大量的输出. 要停止的话,可以用 <Ctrl> +c来中止.<br>      <code>ls -R</code><br>__ 5. 返回到你的主目录，列出该目录的内容包括隐藏文件.<br>    <code>cd ~</code><br>    <code>ls -a</code><br>__ 6. 在你的主目录里创建一个名为mydir的目录. 然后, 发出命令分别显示你的主目录<br>      和~&#x2F;mydir目录的长列表. (不显示目录下的内容.) 每一个目录的大小是多少?<br>      mkdir mydir<br>      ls -l ~<br>      ls -l mydir<br>__ 7. 分别用绝对路径和相对路径两种方式转到mydir目录. 创建两个名为myfile1和myfile2的文件.<br>    cd ~&#x2F;mydir<br>    touch myfile1 myfile2<br>__ 8. 用长列表形式显示mydir目录的内容. 长列表列出的各栏分别显示了什么信息?文件myfile1和myfile2的大小是多少?<br>    ls -l<br>   长列表的各栏显示的信息分别是文件的权限、硬链接数、所有者、所属组、文件大小、最后修改时间、文件名。<br>   文件的大小显示在第5列。<br>__ 9. 返回到你的主目录然后使用 ls -R 命令来显示你的目录树. 解释显示出来的信息。<br>__ 10. 试着用rmdir删除mydir目录. 能行吗?为什么?<br>    rmdir mydir<br>不可以，因为mydir目录不为空，rmdir只能删除空目录。<br>__ 12. 进入mydir目录删除该目录中的2个文件. 然后返回到你的主目录并且删除掉mydir目录.<br>    cd mydir<br>    rm myfile1 myfile2<br>    cd ..<br>    rmdir mydir<br>__ 13. 用一条rm命令可否实现12题中的要求？如何实现？解释rm命令的作用。<br>是可以的，可以使用以下命令实现：<br>    rm -r mydir<br>rm命令是用来删除文件和目录的，-r选项表示递归删除目录及其下的所有文件和子目录。</p></blockquote><p>二.  对文件的操作</p><blockquote><p>__ 14. 分别用cat,more和less命令查看 &#x2F;etc&#x2F;passwd 文件的内容。&#x2F;etc&#x2F;passwd 文件包含了能使用该系统的所有授权的用户的一个列表.<br>       这三个命令显示的方式有什么不同？用more命令查看时，验证以下按键的功能：<br>       f键或<Space>: 进入下一屏。<br>       b键: 在文本中前移<br>       <Enter>: 向下移动一行<br>       q键或&lt;Ctrl+C&gt;:退出。<br>__ 15. 复制&#x2F;etc&#x2F;passwd 文件到你的主目录, 并将其重命名为usersfile.用一条命令实现。如果用两条命令实现呢？<br>__ 16. 用wc命令统计文件userfile的字符数、行数和单词数. 解释显示出的各栏对应的内容。如果只统计行数呢？<br>__ 17. 分别创建userfile的一个硬链接文件userfile-hard和一个字符链接文件userfile-soft。考虑userfile-hard和userfile-soft的异同点。<br>       之后删除userfile文件，查看一下userfile-hard和userfile-soft的内容并解释结果的不同之处。<br>__ 18. 用whereis搜索命令passwd所在的路径。用locate命令搜索文件名中带有aa字段的文件。 whereis和locate命令的区别是什么？</p></blockquote><p>三.  对文件和目录的递归操作</p><blockquote><p>__ 19. 创建一个sub1目录, 在sub1中再创建一个 sub2 目录. 用一条命令来实现.<br>__ 20. 转到 sub2 目录, 创建一个文件 myfile.<br>__ 21. 返回到你的主目录. 复制整个 sub1目录树到tree1. 分别递归显示目录sub1和tree1里的所有文件.<br>__ 22. 现在你有了2个目录树, sub1和tree1. 把目录树tree1 移到sub1子目录中.<br>__ 23. 列出你的主目录的内容. 递归显示sub1目录中的所有文件和目录.</p><ol><li>创建一个sub1目录，在sub1中再创建一个sub2目录，用一条命令来实现：<br>mkdir -p sub1&#x2F;sub2</li><li>转到sub2目录，创建一个文件myfile：<br>cd sub1&#x2F;sub2<br>touch myfile</li><li>返回到你的主目录复制整个sub1目录树到tree1，分别递归显示目录sub和tree1里的所有文件：<br>cd ~<br>cp -R sub1 tree1<br>ls -R sub1<br>ls -R tree</li><li>现在你有了个目录树，sub1和tree1。把目录树tree1移动到sub1子目录中：<br>mv tree1 sub1</li><li>列出你的主目录的内容，递归显示sub1目录中的所有文件和目录：<br>ls -R ~<br>ls -R sub1</li></ol><p>请注意，上述命令假设当前目录是主目录（~）。如果不是，请先切换到主目录再执行命令。</p></blockquote><p>四.  创建用户帐号</p><blockquote><p>为了完整地演示权限, 我们需要创建一些附加的用户, tux1和tux2, 它们都是penguins 组的成员.<br>__ 1. 切换到tty3(按Ctrl+Alt+F3键),用 root帐号登录.<br>__ 2. 执行下列一系列命令:</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># groupadd penguins</span><br><span class="line"></span><br><span class="line"># useradd -m -g penguins -c &quot;Tux the Penguin (1)&quot; tux1</span><br><span class="line"></span><br><span class="line"># useradd -m -g penguins -c &quot;Tux the Penguin (2)&quot; tux2</span><br><span class="line"></span><br><span class="line"># passwd tux1</span><br><span class="line"></span><br><span class="line">New password: penguin1</span><br><span class="line">Retype new password: penguin1</span><br><span class="line"></span><br><span class="line"># passwd tux2</span><br><span class="line"></span><br><span class="line">New password: penguin2</span><br><span class="line">Retype new password: penguin2</span><br></pre></td></tr></table></figure><p>__ 3. 切换到tty1(按Ctrl+Alt+F1键), 用tux1帐号登录, 密码是penguin1, 然后再切换到 tty2(按Ctrl+Alt+F2键),<br>        用tux2帐号登录, 密码是penguin2.</p></blockquote><p> 五.  文件和目录的权限</p><blockquote><p>__ 24. 切换到tty1(按Ctrl+Alt+F1键), 你是以 tux1帐号登录的, 查看你的主目录的权限.<br>__ 25. 切换到tty2, 你是以 tux2帐号登录的. 试着改变到tux1的主目录, 或者显示tux1主<br>           目录的内容. 能行吗?为什么?<br>__ 26. 切换到tty1. 改变tux1主目录的权限以使其他用户能够有读(read)和执行(execute)的权限.<br>           然后再以tux2帐号试着进入tux1的主目录. 现在能行吗?<br>__ 27. 作为用户tux2, 试着创建和删除tux1的主目录里的文件. 能否成功?<br>__ 28. 再次切换到tty1. 创建一个bin目录,复制文件&#x2F;bin&#x2F;ls 到此目录,并且重命名为my_ls.<br>__ 29. 设置my_ls的权限为rw-r—–, 然后分别以tux1和tux2登录试着运行它. 能否运行? 为什么?<br>__ 30. 重新设置my_ls的权限为rwxr-xr-x, 然后再次分别以tux1和tux2登录试着运行它. 现在能否运行?<br>__ 31. 试着运行 my_ls , 分别以tux1 , tux2, 和你自己的帐号 , 权限分别为 rw——-, rw-rw—-,<br>           rwx——, rwx–x— 和 rwx–x–x . 对于tux1, 运行my_ls所需要的最小权限是什么?<br>           对于tux2呢? 对于你自己的帐号呢?</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;实验一：Linux的基本操作和常见命令的使用&quot;&gt;&lt;a href=&quot;#实验一：Linux的基本操作和常见命令的使用&quot; class=&quot;headerlink&quot; title=&quot;实验一：Linux的基本操作和常见命令的使用&quot;&gt;&lt;/a&gt;实验一：Linux的基本操作和常见命令的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>python密码学实验</title>
    <link href="http://example.com/2023/10/17/python%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2023/10/17/python%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-10-17T02:17:02.000Z</published>
    <updated>2023-10-17T02:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="课程实验"><a href="#课程实验" class="headerlink" title="课程实验"></a>课程实验</h2><h3 id="实验一：凯撒密码与仿射密码"><a href="#实验一：凯撒密码与仿射密码" class="headerlink" title="实验一：凯撒密码与仿射密码"></a>实验一：凯撒密码与仿射密码</h3><h4 id="caesar密码python实现"><a href="#caesar密码python实现" class="headerlink" title="caesar密码python实现"></a>caesar密码python实现</h4><p><a href="https://www.w3schools.cn/cryptography_with_python/cryptography_with_python_affine_cipher.html">Python 密码学教程 - w3schools</a></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def caesar_encrypt(k):</span><br><span class="line">    message = input(&#x27;请输入需要加密的字符串：&#x27;)</span><br><span class="line">    ciphertext = &#x27;&#x27;</span><br><span class="line">    for i in message:</span><br><span class="line">        ciphertext += (chr(ord(i) + k)) # 将明文汉字转换为对应ASCLL数值或Unicode数值（ord函数），然后在此数值上+3，再将该值返回汉字（chr函数）</span><br><span class="line">    print(ciphertext)</span><br><span class="line">def caesar_decrypt(k):</span><br><span class="line">    message = input(&#x27;请输入需要解密的字符串：&#x27;)</span><br><span class="line">    plaintext = &#x27;&#x27;</span><br><span class="line">    for i in message:</span><br><span class="line">        plaintext += (chr(ord(i) - k)) # 将明文汉字转换为对应ASCLL数值或Unicode数值（ord函数），然后在此数值上-3，再将该值返回汉字（chr函数）</span><br><span class="line">    print(plaintext)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    k = 3</span><br><span class="line">    caesar_encrypt(k)</span><br><span class="line">    caesar_decrypt(k)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def caesar_encrypt(key,text = &#x27;abcxyzABCXYZ&#x27;):</span><br><span class="line">    ciphertext = &#x27;&#x27;</span><br><span class="line">    for i in range(len(text)):</span><br><span class="line">        char = text[i]</span><br><span class="line">        if (char.isupper()):</span><br><span class="line">            ciphertext += chr((ord(char) + key - ord(&#x27;a&#x27;)) % 26 + ord(&#x27;a&#x27;))</span><br><span class="line">        else:</span><br><span class="line">            ciphertext += chr((ord(char) + key - ord(&#x27;A&#x27;)) % 26 + ord(&#x27;A&#x27;))</span><br><span class="line">    return ciphertext</span><br><span class="line">def caesar_decrypt(key,text = &#x27;abcxyzABCXYZ&#x27;):</span><br><span class="line">    key = -key</span><br><span class="line">    plaintext = &#x27;&#x27;</span><br><span class="line">    for i in range(len(text)):</span><br><span class="line">        char = text[i]</span><br><span class="line">        if (char.isupper()):</span><br><span class="line">            plaintext += chr((ord(char) + key - ord(&#x27;a&#x27;)) % 26 + ord(&#x27;a&#x27;))</span><br><span class="line">        else:</span><br><span class="line">            plaintext += chr((ord(char) + key - ord(&#x27;A&#x27;)) % 26 + ord(&#x27;A&#x27;))</span><br><span class="line">    return plaintext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    k = 3</span><br><span class="line">    # text = input(&quot;请输入需要加密的字符串：&quot;)</span><br><span class="line">    print(caesar_encrypt(k))</span><br><span class="line">    print(caesar_decrypt(k))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def caesar_encrypt(mode, message, key):</span><br><span class="line">    if mode[0] == &#x27;d&#x27;:</span><br><span class="line">        key = -key</span><br><span class="line">    ciphertext = &#x27;&#x27;</span><br><span class="line">    for symbol in message:</span><br><span class="line">        if symbol.isalpha():</span><br><span class="line">          num = ord(symbol)+key</span><br><span class="line">          if symbol.isupper():  # 所有密文字母是大写</span><br><span class="line">              if num &gt; ord(&#x27;Z&#x27;):</span><br><span class="line">                  num -= 26</span><br><span class="line">              elif num &lt; ord(&#x27;A&#x27;):</span><br><span class="line">                  num += 26</span><br><span class="line">          elif symbol.islower():</span><br><span class="line">              if num &gt; ord(&#x27;z&#x27;):</span><br><span class="line">                  num -= 26</span><br><span class="line">              elif num &lt; ord(&#x27;a&#x27;):</span><br><span class="line">                  num += 26</span><br><span class="line">        ciphertext += chr(num)</span><br><span class="line">        else:</span><br><span class="line">            ciphertext += symbol</span><br><span class="line">    return ciphertext</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    key = int(input(&quot;请输入偏移量：&quot;)) % 26</span><br><span class="line">    message = input(&#x27;请输入需要加密的字符串：&#x27;)</span><br><span class="line">    mode = input(&#x27;请输入加密或解密(e/d)：&#x27;)</span><br><span class="line">    print(&quot;加密或解密后的结果为：&quot;, caesar_encrypt(mode, message, key))</span><br></pre></td></tr></table></figure><p>暴力破解</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def caesar_decrypt(message):</span><br><span class="line">    LETTERS = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span><br><span class="line">    letters = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">    for key in range(26):</span><br><span class="line">        translated = &#x27;&#x27;</span><br><span class="line">        for symbol in message:</span><br><span class="line">            if symbol in LETTERS:</span><br><span class="line">                num = LETTERS.find(symbol)</span><br><span class="line">                num = num - key</span><br><span class="line">                if num &lt; 0:</span><br><span class="line">                    num = num + len(LETTERS)</span><br><span class="line">                translated = translated + LETTERS[num]</span><br><span class="line">            elif symbol in letters:</span><br><span class="line">                num = letters.find(symbol)</span><br><span class="line">                num = num - key</span><br><span class="line">                if num &lt; 0:</span><br><span class="line">                    num = num + len(letters)</span><br><span class="line">                translated = translated + letters[num]</span><br><span class="line">            else:</span><br><span class="line">                translated = translated + symbol</span><br><span class="line">        print(&#x27;Hacking key #%s: %s&#x27; % (key, translated))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h4><p><a href="https://www.cnblogs.com/clwsec/p/10198428.html">仿射密码Python实现</a><br>仿射密码是一种替换密码。它是利用加密函数一个字母对一个字母的加密。</p><p>加密函数是E(x)&#x3D; (ax + b) (mod m)，其中，a和m互质，m是字符集的大小。<br>（例如，26即是以26个字母作为编码，当m是26时，a必须是1，3，5，7，9，11，15，17，19，21，23，25其中之一）</p><p>解密函数为D(x) &#x3D; a<sup>-1</sup>(x - b) (mod m)，其中a<sup>-1</sup>是a在Zm群的乘法逆元。</p><blockquote><p><strong>乘法逆元</strong><br>群G中任意一个元素a，都在G中有唯一的逆元a’，具有性质aa’ &#x3D; a’a &#x3D; e，其中e为群的单位元。</p></blockquote><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">仿射密码</span><br><span class="line">(a,b)</span><br><span class="line">m = 26，字符集为小写字母</span><br><span class="line">加密函数是E(x)= (ax + b) (mod m)</span><br><span class="line">解密函数为D(x) = (a^-1)(x - b) (mod m)，其中a^-1是a的乘法逆元</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">#通过一个简单的遍历得到a的乘法逆元，也可以通过gmpy2库中的invert函数实现</span><br><span class="line">def get_inverse(a):</span><br><span class="line">    for i in range(1,27):</span><br><span class="line">        if a*i%26==1:</span><br><span class="line">            return i</span><br><span class="line"></span><br><span class="line">#加密</span><br><span class="line">def encipher(a, b, p):</span><br><span class="line">    c=[]</span><br><span class="line">    for i in p:</span><br><span class="line">        temp=((ord(i)-97)*a+b)%26+97</span><br><span class="line">        c.append(chr(temp))</span><br><span class="line">    print(&#x27;&#x27;.join(c))</span><br><span class="line"></span><br><span class="line">#解密</span><br><span class="line">def decipher(a, b, c):</span><br><span class="line">    a_inv = get_inverse(a)</span><br><span class="line">    p=[]</span><br><span class="line">    for i in c:</span><br><span class="line">        temp=(((ord(i)-97)-b)*a_inv)%26+97</span><br><span class="line">        p.append(chr(temp))</span><br><span class="line">    print(&#x27;&#x27;.join(p))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    a = 11</span><br><span class="line">    b = 6</span><br><span class="line">    message = &#x27;sorcery&#x27;</span><br><span class="line">    encipher(a,b,message)</span><br><span class="line">    #decipher(a,b,message)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">仿射密码</span><br><span class="line">m = 52</span><br><span class="line">字符集为小写和大写字母</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">import string</span><br><span class="line">def encrypt(k1,k2,message):</span><br><span class="line">    dic = string.ascii_letters</span><br><span class="line">    c = []</span><br><span class="line">    for i in message:</span><br><span class="line">        if i.islower():</span><br><span class="line">            num = ord(i)-ord(&#x27;a&#x27;)</span><br><span class="line">            c.append(dic[(num*k1+k2)%52])</span><br><span class="line">        elif i.isupper():</span><br><span class="line">            num = ord(i)-ord(&#x27;A&#x27;)+26</span><br><span class="line">            c.append(dic[(num*k1+k2)%52])</span><br><span class="line">        else:</span><br><span class="line">            c.append(i)</span><br><span class="line">    print(&#x27;&#x27;.join(c))</span><br><span class="line"></span><br><span class="line">def decrypt(k1,k2,message):</span><br><span class="line">    for i in range(52):</span><br><span class="line">        if k1*i%52==1:</span><br><span class="line">            inv = i</span><br><span class="line">            break</span><br><span class="line">    dic = string.ascii_letters</span><br><span class="line">    m = []</span><br><span class="line">    for i in message:</span><br><span class="line">        if i.islower():</span><br><span class="line">            num = ord(i)-ord(&#x27;a&#x27;)</span><br><span class="line">            m.append(dic[inv*(num-k2)%52])</span><br><span class="line">        elif i.isupper():</span><br><span class="line">            num = ord(i)-ord(&#x27;A&#x27;)+26</span><br><span class="line">            m.append(dic[inv*(num-k2)%52])</span><br><span class="line">        else:</span><br><span class="line">            m.append(i)</span><br><span class="line">    print(&#x27;&#x27;.join(m))</span><br><span class="line"></span><br><span class="line">message = &#x27;gVEXGT iDIT&#x27; #待加密或解密的消息</span><br><span class="line">a = 5 # key的范围0~51之间</span><br><span class="line">b = 29 # key的范围0~51之间</span><br><span class="line"># encrypt(a,b,message)</span><br><span class="line">decrypt(a,b,message)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Affine(object):</span><br><span class="line">    DIE = 128</span><br><span class="line">    KEY = (7, 3, 55)</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def encryptChar(self, char):</span><br><span class="line">        K1, K2, kI = self.KEY</span><br><span class="line">        return chr((K1 * ord(char) + K2) % self.DIE)</span><br><span class="line"></span><br><span class="line">    def encrypt(self, string):</span><br><span class="line">        return &quot;&quot;.join(map(self.encryptChar, string))</span><br><span class="line"></span><br><span class="line">    def decryptChar(self, char):</span><br><span class="line">        K1, K2, KI = self.KEY</span><br><span class="line">        return chr(KI * (ord(char) - K2) % self.DIE)</span><br><span class="line"></span><br><span class="line">    def decrypt(self, string):</span><br><span class="line">        return &quot;&quot;.join(map(self.decryptChar, string))</span><br><span class="line"></span><br><span class="line">affine = Affine()</span><br><span class="line">print(affine.encrypt(&#x27;Affine Cipher&#x27;))</span><br><span class="line">print(affine.decrypt(&#x27;*18?FMT&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实验二：哈希函数"><a href="#实验二：哈希函数" class="headerlink" title="实验二：哈希函数"></a>实验二：哈希函数</h3><p>1、编程实现生成空字符串、‘Alice’、‘Bob’的md5、sha256的哈希值；</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">def hash_md5():</span><br><span class="line">    alice = hashlib.md5(b&quot;Alice&quot;)</span><br><span class="line">    bob = hashlib.md5(b&quot;Bob&quot;)</span><br><span class="line">    print(&#x27;&quot;Alice&quot; md5:&#x27; + alice.hexdigest())</span><br><span class="line">    print(&#x27;&quot;Bob&quot; md5:&#x27; + bob.hexdigest())</span><br><span class="line"></span><br><span class="line">def hash_sha256():</span><br><span class="line">    alice = hashlib.sha256(b&quot;Alice&quot;)</span><br><span class="line">    bob = hashlib.sha256(b&quot;Bob&quot;)</span><br><span class="line">    print(&#x27;&quot;Alice&quot; sha256:&#x27; + alice.hexdigest())</span><br><span class="line">    print(&#x27;&quot;Bob&quot; sha256:&#x27; + bob.hexdigest())</span><br></pre></td></tr></table></figure><p>2、编程实现生成自己名字的哈希值，注意编码的转换；</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def myhash(str = &quot;Yangjiaqing&quot;):</span><br><span class="line">    res = hashlib.md5(str.encode(encoding=&quot;utf-8&quot;))</span><br><span class="line">    print(str + &quot; md5: &quot; + res.hexdigest())</span><br></pre></td></tr></table></figure><p>3、编写体现哈希雪崩的代码，哈希值用二进制表示； 参考Listing2-5 代码；<br><a href="https://huaweicloud.csdn.net/63807e39dacf622b8df88c1c.html#:~:text=%23%20%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%20%23%20author%3Amarxycj%20%23%20date%3A2021-10-29%20from%20hashlib,%27__main__%27%20%3A%20md5_value%20%3D%20input%20%28%29%20brute_md5%20%28md5_value%29">Python 哈希函数与消息认证实验</a><br><a href="https://www.wolfram.com/language/12/cryptography/demonstrate-the-avalanche-effect-of-a-hash-function.html.zh">展示散列函数的雪崩效应</a></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def cmpcount(str1, str2):</span><br><span class="line">    count = 0</span><br><span class="line">    for i in range(0, len(str1)):</span><br><span class="line">        if str1[i] != str2[i]:</span><br><span class="line">            count += 1</span><br><span class="line">    return count</span><br><span class="line"></span><br><span class="line">def avalanche(str1 = &#x27;bob&#x27;, str2 = &#x27;aob&#x27;):</span><br><span class="line">    bin1 = str1.encode(&#x27;utf-8&#x27;)</span><br><span class="line">    bin2 = str2.encode(&#x27;utf-8&#x27;)</span><br><span class="line">    hexstring1 = hashlib.md5(bin1).hexdigest()</span><br><span class="line">    binstring1 = &#x27;&#123;:08b&#125;&#x27;.format(int(hexstring1, 16))</span><br><span class="line">    # binstring1 = bin(int(hexstring1, 16))</span><br><span class="line">    hexstring2 = hashlib.md5(bin2).hexdigest()</span><br><span class="line">    binstring2 = &#x27;&#123;:08b&#125;&#x27;.format(int(hexstring2, 16))</span><br><span class="line">    # binstring2 = bin(int(hexstring2, 16))</span><br><span class="line">    print(int(hexstring1, 16))</span><br><span class="line">    print(int(hexstring2, 16))</span><br><span class="line">    print(str1 + &quot; md5:&quot; + binstring1)</span><br><span class="line">    print(str2 + &quot; md5:&quot; + binstring2)</span><br><span class="line">    print(&quot;两个哈希值不同的位数：&quot; + str(cmpcount(binstring1, binstring2)))</span><br></pre></td></tr></table></figure><p>4、利用scrypt密钥派生函数，实现口令加盐，生成更加安全的密钥（口令）；<br><a href="https://deepinout.com/python/python-qa/169_python_creating_a_salt_in_python.html#:~:text=Python%203.6%2B%20%E7%9A%84%20secrets%20%E6%A8%A1%E5%9D%97%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E7%A7%8D%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E3%80%82%20%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BD%BF%E7%94%A8%20secrets%20%E6%A8%A1%E5%9D%97%E7%94%9F%E6%88%90%E7%9B%90%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A,16%20salt%20%3D%20secrets.token_hex%28salt_length%29%20print%28salt%29%20%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E5%B0%86%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E9%95%BF%E5%BA%A6%E4%B8%BA%2016%20%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E7%9B%90%E3%80%82">创建一个 Python 盐</a><br>Scrypt介绍<br>Scrypt 是一个强大的密钥派生函数，其通过内存密集的计算方式来抵抗 GPU、ASIC、FPGA 这类密码破解硬件的攻击。</p><p>Scrypt 接收多个输入参数，进行计算后输出密钥：</p><p>key &#x3D; Scrypt(password, salt, N, r, p, derived-key-len)<br>其中的参数被称为” Scrypt 配置参数”，说明如下：</p><blockquote><p>N - 迭代次数，将影响 CPU 和内存用量，例：16384 、2048 ；<br>r - 块大小，将影响 CPU 和内存用量，例：8 ；<br>p - 并行因数 （并行运行的线程数，将影响 CPU 和内存用量），通常为 1 ；<br>password - 输入的密码（推荐至少为 8 - 10 个字符）；<br>salt - 安全产生的随机字节序列（最小为 64 位，推荐 128 位）；<br>derived-key-len - 输出的密钥要有多少字节长，例如 32 （256 位）<br>Scrypt 的输出密钥长度可以是 128 位到 512 位，但是通常为 256 位。</p></blockquote><p>Salt 用使用 secrets 模块生成，也可以用os.urandom()随机生成</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def hash_password(password = b&#x27;p@$Sw0rD~7&#x27;):</span><br><span class="line">    salt_length = 16</span><br><span class="line">    salt = secrets.token_bytes(salt_length)</span><br><span class="line">    key = pyscrypt.hash(password, salt, 2048, 8, 1, 32)</span><br><span class="line">    return key.hex()</span><br></pre></td></tr></table></figure><p>5、实现区块链中的工作量证明编程，通过设置不同的难度，体会生成符合要求哈希值需要时间长短的不同；<br><a href="https://zhuanlan.zhihu.com/p/29903461">从零开始构建一个区块链（二）： 工作量证明</a><br><a href="https://blog.csdn.net/xiaobing1994/article/details/87967693">使用python实现简版区块链-工作量证明</a><br><a href="https://github.com/xiaobing94/pysimpleblockchain/tree/part2">区块链的简单实现 - github</a></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import hashlib</span><br><span class="line">class NonceNotFoundError(Exception):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def encode(str, code=&#x27;utf-8&#x27;):</span><br><span class="line">    return str.encode(code)</span><br><span class="line"></span><br><span class="line">def decode(bytes, code=&#x27;utf-8&#x27;):</span><br><span class="line">    return bytes.decode(code)</span><br><span class="line"></span><br><span class="line">def sum256_hex(*args):</span><br><span class="line">    m = hashlib.sha256()</span><br><span class="line">    for arg in args:</span><br><span class="line">        if isinstance(arg, str):</span><br><span class="line">            m.update(arg.encode())</span><br><span class="line">        else:</span><br><span class="line">            m.update(arg)</span><br><span class="line">    return m.hexdigest()</span><br><span class="line"></span><br><span class="line">def sum256_byte(*args):</span><br><span class="line">    m = hashlib.sha256()</span><br><span class="line">    for arg in args:</span><br><span class="line">        if isinstance(arg, str):</span><br><span class="line">            m.update(arg.encode())</span><br><span class="line">        else:</span><br><span class="line">            m.update(arg)</span><br><span class="line">    return m.digest()</span><br><span class="line"></span><br><span class="line">class ProofOfWork(object):</span><br><span class="line">    _N_BITS = 20</span><br><span class="line">    MAX_BITS = 256</span><br><span class="line">    MAX_SIZE = sys.maxsize</span><br><span class="line">    def __init__(self, n_bits=_N_BITS):</span><br><span class="line">        self._n_bits = n_bits</span><br><span class="line">        self._target_bits = 1 &lt;&lt; (self.MAX_BITS - n_bits)</span><br><span class="line">    def _prepare_data(self, nonce):</span><br><span class="line">        data_lst = [str(nonce)]</span><br><span class="line">        return encode(&#x27;&#x27;.join(data_lst))</span><br><span class="line">    def run(self):</span><br><span class="line">        nonce = 0</span><br><span class="line">        found = False</span><br><span class="line">        hash_hex = None</span><br><span class="line">        print(&#x27;Mining a new block&#x27;)</span><br><span class="line">        while nonce &lt; self.MAX_SIZE:</span><br><span class="line">            data = self._prepare_data(nonce)</span><br><span class="line">            hash_hex = sum256_hex(data)</span><br><span class="line">            hash_val = int(hash_hex, 16)</span><br><span class="line">            sys.stdout.write(&quot;try nonce == %d hash_hex == %s \r&quot; % (nonce, hash_hex))</span><br><span class="line">            if (hash_val &lt; self._target_bits):</span><br><span class="line">                found = True</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            nonce += 1</span><br><span class="line">        if found: </span><br><span class="line">            print(&#x27;Found nonce == %d&#x27; % nonce)</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;Not Found nonce&#x27;)</span><br><span class="line">            raise NonceNotFoundError(&#x27;nonce not found&#x27;)</span><br><span class="line">        return nonce, hash_hex</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    bc = ProofOfWork()</span><br><span class="line">    bc.run()</span><br></pre></td></tr></table></figure><h3 id="实验三：实现对称加密编程"><a href="#实验三：实现对称加密编程" class="headerlink" title="实验三：实现对称加密编程"></a>实验三：实现对称加密编程</h3><p><a href="https://zhuanlan.zhihu.com/p/364772865">分组密码的五大工作模式</a></p><p><a href="https://zhuanlan.zhihu.com/p/23276413">使用cryptography进行AES的cbc模式加密 - 知乎 (zhihu.com)</a></p><p><a href="https://github.com/istommao/cryptokit/tree/main">istommao&#x2F;cryptokit: cryptokit is a cryptography kit (github.com)</a></p><p>4、练习3-12 手工CBC:编程应用AES的ECB模式实现CBC模式</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def ecbTocbc(self, data):</span><br><span class="line">    if not isinstance(data, bytes):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    cipher = Cipher(algorithms.AES(self.aes_key),</span><br><span class="line">                    modes.ECB(),</span><br><span class="line">                    backend=default_backend())</span><br><span class="line">    dataList = []</span><br><span class="line">    cipherText = []</span><br><span class="line">    padded_data = self.pkcs7_padding(data)</span><br><span class="line">    binary_data = bin((int(padded_data.hex(), 16)))[2:]</span><br><span class="line">    while len(binary_data) / 128 &gt;= 0:</span><br><span class="line">        if len(binary_data) / 128 == 0 &amp; len(binary_data) % 128 == 0:</span><br><span class="line">            break</span><br><span class="line">        elif len(binary_data) / 128 == 0 &amp; len(binary_data) % 128 != 0:</span><br><span class="line">            dataList.append(binary_data[0:])</span><br><span class="line">            dataList.remove()</span><br><span class="line">        else:</span><br><span class="line">            dataList.append(binary_data[0:128])</span><br><span class="line">            binary_data = binary_data[128:]</span><br><span class="line"></span><br><span class="line">    c = &quot;&#123;:08b&#125;&quot;.format(int(self.aes_iv.hex(), 16))</span><br><span class="line">    for i in dataList:</span><br><span class="line">        ci = cipher.encryptor().update(bytes(i^c))</span><br><span class="line">        cipherText.append(ci)</span><br><span class="line">        c = ci.decode()</span><br><span class="line">        print(c)</span><br><span class="line">    m = &#x27;&#x27;.join([c.hex() for c in cipherText])</span><br><span class="line">    return m</span><br></pre></td></tr></table></figure><p>5、练习3-13 简单CTR模式：编程应用AES的ECB模式实现CTR模式</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def ecbToctr(self, data):</span><br><span class="line">    if not isinstance(data, bytes):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    iv = self.aes_iv</span><br><span class="line">    cipher = Cipher(algorithms.AES(self.aes_key),</span><br><span class="line">                    modes.ECB(),</span><br><span class="line">                    backend=default_backend())</span><br><span class="line"></span><br><span class="line">    dataList = []</span><br><span class="line">    cipherText = []</span><br><span class="line">    padded_data = self.pkcs7_padding(data)</span><br><span class="line">    binary_data = &quot;&#123;:08b&#125;&quot;.format(int(padded_data.hex(), 16)) + &#x27;0&#x27;</span><br><span class="line">    while len(binary_data) / 128 &gt;= 0:</span><br><span class="line">        if len(binary_data) / 128 == 0 &amp; len(binary_data) % 128 == 0:</span><br><span class="line">            break</span><br><span class="line">        elif len(binary_data) / 128 == 0 &amp; len(binary_data) % 128 != 0:</span><br><span class="line">            dataList.append(binary_data[0:])</span><br><span class="line">            dataList.remove()</span><br><span class="line">        else:</span><br><span class="line">            dataList.append(binary_data[0:128])</span><br><span class="line">            binary_data = binary_data[128:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for i in dataList:</span><br><span class="line">        ci = cipher.encryptor().update(iv) ^ i.encode()</span><br><span class="line">        iv += 1</span><br><span class="line">        cipherText.append(ci)</span><br><span class="line">        print(ci)</span><br><span class="line">    m = &#x27;&#x27;.join(cipherText)</span><br><span class="line">    return m</span><br></pre></td></tr></table></figure><h3 id="实验四：实现非对称加密编程"><a href="#实验四：实现非对称加密编程" class="headerlink" title="实验四：实现非对称加密编程"></a>实验四：实现非对称加密编程</h3><p><a href="https://cloud.tencent.com/developer/article/2186122">非对称密钥沉思系列（1）：RSA专题之PKCSv1.5填充模式下的选择性密文攻击概述-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;课程实验&quot;&gt;&lt;a href=&quot;#课程实验&quot; class=&quot;headerlink&quot; title=&quot;课程实验&quot;&gt;&lt;/a&gt;课程实验&lt;/h2&gt;&lt;h3 id=&quot;实验一：凯撒密码与仿射密码&quot;&gt;&lt;a href=&quot;#实验一：凯撒密码与仿射密码&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络病毒测试</title>
    <link href="http://example.com/2023/10/16/%E7%BD%91%E7%BB%9C%E7%97%85%E6%AF%92%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2023/10/16/%E7%BD%91%E7%BB%9C%E7%97%85%E6%AF%92%E6%B5%8B%E8%AF%95/</id>
    <published>2023-10-16T02:44:53.000Z</published>
    <updated>2023-10-16T02:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Wannacry"><a href="#Wannacry" class="headerlink" title="Wannacry"></a>Wannacry</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://www.cloudflare-cn.com/learning/security/ransomware/wannacry-ransomware/">什么是 WannaCry 勒索软件攻击？</a></p><p>WannaCry 通过使用名为“EternalBlue”的漏洞利用进行传播。EternalBlue 仅适用于较旧的、未打补丁的 Microsoft Windows 版本，但运行此类版本的机器数量足以让 WannaCry 迅速传播开来。</p><p>*<em>勒索软件是一种恶意软件，它通过<a href="https://www.cloudflare.com/learning/ssl/what-is-encryption/">加密</a>锁住文件和数据，并索取赎金。</em></p><p>WannaCry 包含一个不寻常的函数：在执行之前，它将查询<a href="https://www.cloudflare.com/learning/dns/glossary/what-is-a-domain-name/">域</a> iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com。这个网站并不存在。</p><p>在 Hutchins 注册了这个域之后，WannaCry 的副本继续传播，但他们停止了执行。从本质上讲，一旦 WannaCry 开始收到来自 iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com 的响应，它就会自行关闭。<br><img src="/img/Network-attack/wanncry-analysis-1.png"></p><h4 id="为什么这能阻止攻击？"><a href="#为什么这能阻止攻击？" class="headerlink" title="为什么这能阻止攻击？"></a>为什么这能阻止攻击？</h4><p>虽然不能确定 WannaCry 作者的动机，但据推测，WannaCry 中包含了这种域名查询功能的目的是让赎金软件能够检查它是否在沙盒内。</p><p>沙盒是一种反恶意软件工具。它是一个<a href="https://www.cloudflare.com/learning/cloud/what-is-a-virtual-machine/">虚拟机</a>，与所有其他系统和网络分开运行。它提供了一个安全的环境来执行不受信任的文件，看看它们是做什么的。</p><p>沙盒实际上没有连接到互联网。但沙盒的目的是尽可能地模仿真实的计算机，因此它们可能会对恶意软件针对特定域的查询产生一个虚假的响应。因此，恶意软件检查其是否在沙盒内的一种方法是向一个假的域名发送查询。如果它得到一个“真实的”响应（由沙盒生成），它可以认为自己是在沙盒中，并关闭自己，这样沙盒就不会检测到它是恶意的。</p><p>然而，如果恶意软件将其测试查询发送到一个硬编码的域名，那么如果有人注册了这个域名，它就会被欺骗，以为自己始终在沙盒中。这可能是 WannaCry 发生的情况：世界各地的 WannaCry 副本被欺骗，认为它们在沙盒内，并关闭自己。（从恶意软件作者的角度来看，一个更好的设计是查询一个每次都不同的随机域名，这样一来，从沙盒外的域名得到回应的几率就接近零了）。</p><h3 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h3><p>国庆假期结束后的第一节网络攻防课，老师安排测试wannacry病毒的任务。</p><h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><p>由于病毒具有破坏性，因此在本地直接运行是极其危险的行为，一旦控制不慎，不仅自己电脑的数据要被破坏和丢失，甚至可能导致电脑成为肉鸡，去攻击其他联网设备。<br>为了安全考虑，首先需要准备好病毒运行的环境。</p><ul><li>支持虚拟化技术的电脑</li><li>VMware Workstation Pro 软件</li><li>操作系统安装包</li><li>计算机病毒样本</li></ul><h4 id="虚拟机环境配置"><a href="#虚拟机环境配置" class="headerlink" title="虚拟机环境配置"></a>虚拟机环境配置</h4><p>系统：Windows XP<br>安装教程：<br><a href="https://blog.csdn.net/IronmanJay/article/details/129965817">VMware虚拟机之WindowsXP系统超详细下载安装与使用教程</a><br><a href="https://next.itellyou.cn/Original/">itellyou官网 - 系统镜像下载</a></p><p>这个教程非常详细，而且每一步都有图片，即使小白也能轻松使用。</p><h4 id="本地文件如何与虚拟机交互"><a href="#本地文件如何与虚拟机交互" class="headerlink" title="本地文件如何与虚拟机交互"></a>本地文件如何与虚拟机交互</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>因为VMware自带有工具Vmware Tools，能够直接实现主机和虚拟机之间的文件共享，同时支持自由拖拽文件进行上传和下载，因此最简单且好用的办法就是在虚拟机安装Vmware Tools。</p><p>附上官方文档：<a href="https://docs.vmware.com/cn/VMware-Tools/11.2.5/vmware-tools-user-guide.pdf">VMware Tools 用户指南 - VMware Tools 11.2.5</a></p><blockquote><p>说明：由于上一步安装虚拟机后，我的XP虚拟机自动安装了Vmware Tools（所以显示重新安装vmware tool），因此以下内容并未具体尝试，可能以下安装步骤中会出现一些报错或bug，请酌情查看。</p><p><img src="/img/Network-attack/VMtool-download.png"></p></blockquote><p>具体步骤如下：</p><p><strong>windows：</strong></p><p><a href="https://docs.vmware.com/cn/VMware-Tools/12.3.0/com.vmware.vsphere.vmwaretools.doc/GUID-391BE4BF-89A9-4DC3-85E7-3D45F5124BC7.html">在 Windows 上手动安装 VMware Tools</a></p><p>[如何在Windows操作系统安装VMwareTools_VMware服务-阿里云帮助中心 (aliyun.com)](<a href="https://help.aliyun.com/document_detail/412878.html#:~:text=%E5%AE%89%E8%A3%85VMware">https://help.aliyun.com/document_detail/412878.html#:~:text=安装VMware</a> Tools（Windows操作系统） 1 Windows操作系统安装完成后，VMware vSphere控制台会提示“该虚拟机上未安装VMware Tools” 2 鼠标右击虚拟机，选择,。 7 选择 安装 ，开始安装。 8 正在安装，如下图所示。 更多项目)</p><p><strong>linux：</strong></p><p>打开linux虚拟机，在VMware菜单栏里点击虚拟机选项，找到安装VMware tools选项。</p><p>对linux系统的tool安装需要控制台执行，下面附上代码：</p><figure class="highlight bash"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 解压下载的安装包</span><br><span class="line">tar -zxvf [文件名]</span><br><span class="line">//进入解压完成的文件夹</span><br><span class="line"><span class="built_in">cd</span> [wen<span class="string">&#x27;jian&#x27;</span>ji]</span><br><span class="line">//查看文件夹下的文件</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">//执行文件夹下的可执行文件。</span><br><span class="line">sudo ./vmware-install.pl</span><br></pre></td></tr></table></figure><p>完成以上步骤后重启系统。</p><h5 id="方法二：（以下内容只是对该博客的简略，并非原创）"><a href="#方法二：（以下内容只是对该博客的简略，并非原创）" class="headerlink" title="方法二：（以下内容只是对该博客的简略，并非原创）"></a>方法二：（以下内容只是对该博客的简略，并非原创）</h5><p><a href="https://blog.csdn.net/qq_41486333/article/details/115259771?ops_request_misc=%7B%22request_id%22:%22169733009516800222810780%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169733009516800222810780&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-115259771-null-null.142%5Ev96%5Epc_search_result_base1&utm_term=vmware%E6%80%8E%E4%B9%88%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%99%A4%E4%BA%86vmwaretool&spm=1018.2226.3001.4187">将本机文件复制到安装的虚拟机系统中的两种方法_vmware怎么将本地文件下载到虚拟机除了vmwaretool_灼_灼的博客-CSDN博客</a></p><p>进入虚拟机设置，选择硬盘，再点击映射</p><p><img src="/img/Network-attack/VMware-interact-1.png"></p><p>在打开的映射虚拟磁盘，选择要复制到虚拟机里的哪个盘，记得取消勾选“以只读模式打开文件”，然后点击确定。</p><p><img src="/img/Network-attack/VMware-interact-2.png"></p><p>点击本地资源管理器，选择已经映射的盘</p><p><img src="/img/Network-attack/VMware-interact-3.png"></p><p>如果没有出现需要格式化弹窗，就可以直接把文件复制到映射盘中了，然后在虚拟机里，对应的你刚才选中的虚拟机里的磁盘就可以看到复制的文件了。</p><blockquote><p><strong>注意</strong>：要是有提示格式化，然后有文件较为重要，建议不要格式化</p></blockquote><p><img src="/img/Network-attack/VMware-interact-4.png"></p><p>复制完文件记得断开连接</p><p><img src="/img/Network-attack/VMware-interact-5.png"></p><h4 id="隔离措施"><a href="#隔离措施" class="headerlink" title="隔离措施"></a>隔离措施</h4><blockquote><p><strong>做好隔离措施。此步骤非常重要！！！</strong></p><p><strong>注意：为了安全起见，强烈建议拔掉插在电脑上的U盘。</strong></p></blockquote><p>打开虚拟机操作系统上的网络与共享中心，单击已经连接因特网的本地连接，在弹出的对话框中单击“禁用“按钮。</p><p><img src="/img/Network-attack/virus-analysis-4.jpg"></p><p>点击VMware Workstation Pro软件上方的虚拟机菜单，选择设置，单击设置窗口左侧的网络适配器，之后在网络适配器设置的设备状态栏内将两个勾去掉。</p><p><img src="/img/Network-attack/virus-analysis-2.jpg" alt="如何安全地做电脑病毒实验？"></p><p>单击上方的“选项”选项卡，在左侧列表框内确认共享文件夹已禁用。设置完后单击确定按钮。</p><p><img src="/img/Network-attack/virus-analysis-3.jpg" alt="如何安全地做电脑病毒实验？"></p><p><strong>拍摄快照</strong>。为了防止病毒发作导致虚拟机系统崩溃后恢复麻烦，建议在运行病毒程序前拍摄快照，如图所示。该步骤需要几分钟时间，注意观察虚拟机软件的左下角。</p><p><img src="/img/Network-attack/virus-analysis-1.jpg" alt="如何安全地做电脑病毒实验？"></p><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p><strong>针对病毒特性，设好模型。</strong>比如：如果要运行勒索病毒，则需在虚拟机桌面上象征新地放置几个文本文件，观察中毒前后文件内容变化。</p><p><img src="/img/Network-attack/virus-analysis-5.jpg"></p><p><strong>在确认做好隔离措施后（特别是检查是否已经断网），在虚拟机上把病毒样本压缩包解压缩并小心运行病毒程序。</strong></p><p><strong>观察实验效果。</strong>如：我们刚刚放置的文件已经被加密而乱码；桌面变了；弹出勒索对话框。如图。</p><p><img src="/img/Network-attack/virus-analysis-6.jpg"></p><p><img src="/img/Network-attack/virus-analysis-7.jpg"></p><blockquote><p>病毒似乎并不能把已经运行的程序强制关闭，但这些打开的源文件已经不在桌面了，因此可以知道病毒并不直接修改内存。应该只是操作硬盘数据。</p></blockquote><p><em><strong>*解毒具体步骤*</strong></em></p><p>打开wannakey-master，阅读readme.txt，由于wannacry会识别后缀名为txt的文件并标记为重要文件进行加密，因此readme的后缀名有可能被改成了其他形式，此时应该改回txt格式，采用记事本打开。</p><p>根据readme.txt中提供的信息，参照自己的windows版本，在bin中选择合适的exe进行运行：</p><p>运行wannakey.exe程序</p><p>多核系统使用wannakey_omp.exe</p><p>运行后会跳出cmd窗口（窗口可能会一闪而过，注意观察），如果显示秘钥已经成功生成(key has been generated)，那么秘钥已经获取成功，此时前往恶意软件窗口，单击解密(decrypt)按钮，在后续的窗口里选择自己要解密的对象点击start，即可进行解密。</p><p>此时下方的目录表中会显示所有被解密了的文件的路径，可以根据路径进行核实和查看。</p><p><strong>恢复。</strong>实验完后，恢复中毒前的状态。依次单击VMware Workstation Pro软件上方的虚拟机菜单-快照-恢复到快照，在弹出的对话框中选择”是“，如图所示。大约半分钟后就虚拟机就恢复到了中毒前的状态。</p><h3 id="病毒逆向"><a href="#病毒逆向" class="headerlink" title="病毒逆向"></a>病毒逆向</h3><p><a href="https://www.52pojie.cn/thread-1573058-1-1.html">病毒分析之WannaCry勒索病毒 - 『病毒分析区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p>[<a href="https://cloud.tencent.com/developer/article/1910271">系统安全] 三十.WannaCry勒索病毒分析 (4)全网“最”详细的蠕虫传播机制解读-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>[<a href="https://cloud.tencent.com/developer/article/1910268">系统安全] 二十七.WannaCry勒索病毒分析 (3)蠕虫传播机制分析及IDA和OD逆向-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>WannaCry利用Windows系统的SMB漏洞获取系统的最高权限，该工具通过恶意代码扫描开放445端口的Windows系统。WannaCry利用永恒之蓝漏洞进行网络端口扫描攻击，目标机器被成功攻陷后会从攻击机下载WannaCry蠕虫进行感染，并作为攻击机再次扫描互联网和局域网的其他机器，形成蠕虫感染大范围超快速扩散。</p><p>WannaCry勒索病毒主要行为是传播和勒索。<br>该病毒分为两个部分：</p><p>（1） 蠕虫部分，利用基于445端口的SMB漏洞MS17-010(永恒之蓝)进行病毒传播，并释放出勒索病毒。</p><p>（2） 勒索病毒部分，加密用户文件索要赎金。释放文件，包括加密器、解密器、说明文件、语言文件等；加密文件；设置桌面背景、窗体信息及付款账号等。</p><h4 id="勒索病毒部分详细分析-（待修改）"><a href="#勒索病毒部分详细分析-（待修改）" class="headerlink" title="勒索病毒部分详细分析 （待修改）"></a><strong>勒索病毒部分详细分析</strong> （待修改）</h4><p><strong>CryptGenKey</strong> 函数生成随机加密<a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">会话密钥</a>或<a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/p-gly">公钥&#x2F;私钥对</a>。密钥或密钥对的句柄在 <em>phKey</em> 中返回。</p><p>勒索主逻辑执行，先会导入一个存放在镜像中的RSA公钥，之后调用CryptGenKey生成一组RSA算法的Session key。之后将这组Key的公钥通过CryptExportKey导出，再写入到00000000.pky文件中。将Session key中的私钥用刚导入RSA公钥进行加密，存放在00000000.eky如下图所示：</p><p><img src="https://pic1.zhimg.com/80/v2-ef633e009eae50dc19f8f253273a2af0_720w.webp" alt="img"></p><p>如果遍历到的文件扩展名在欲加密的文件扩展名列表中，如下图所示：</p><p><img src="https://pic3.zhimg.com/80/v2-25696ad49373393f257bc7826b8654e6_720w.webp" alt="img"></p><p>则会将当前文件路径加入到文件操作列表中，在遍历文件结束后一并进行文件操作。代码如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-ac9efbcc9f670fad48976552489fd4a6_720w.webp" alt="img"></p><p>对于每个需要加密的文件，都会调用CryptGenRadom随机生成AES密钥，之后使用Session Key中的RSA公钥对AES密钥进行加密，存放在加密后的数据文件头中，之后将原始文件数据用该AES密钥进行加密。如下图所示：</p><p><img src="https://pic2.zhimg.com/80/v2-c4ec5a74af2e25e73956450b6fbe793d_720w.webp" alt="img"></p><p>整体加密流程，如下图所示：</p><p><img src="https://pic4.zhimg.com/80/v2-d5d7f398fcf56e76bfff2fc91588259b_720w.webp" alt="img"></p><p>因为病毒是生成加密过的用户文件后再删除原始文件，所以存在通过文件恢复类工具恢复原始未加密文件的可能。但是因为病毒对文件系统的修改操作过于频繁，导致被删除的原始文件数据块被覆盖，致使实际恢复效果有限。且随着系统持续运行，恢复类工具恢复数据的可能性会显著降低。</p><p><strong>Wannakey的恢复</strong></p><p>因为所有文件都是用随机生成的AES</p><p>WannaCry 在加密文件时会将加密密钥存储在内存中，而没有进行及时的清除。WannaKey 利用了这个漏洞，通过扫描内存中的数据，找到并提取出加密文件的解密密钥。</p><p>因此，WannaKey 能够解密 WannaCry 加密的文件，是因为它能够获取到加密文件的解密密钥。通过使用这个解密密钥，WannaKey 可以还原被 WannaCry 加密的文件，使受害者能够恢复其文件的原始状态。</p><h4 id="病毒样本下载"><a href="#病毒样本下载" class="headerlink" title="病毒样本下载"></a>病毒样本下载</h4><p><a href="https://blog.csdn.net/so18635793637/article/details/128781620">计算机病毒样本分享_勒索病毒样本下载-CSDN博客</a></p><blockquote><p><strong>注意：为了安全起见，建议直接在虚拟机上上网搜索、下载，*在做好隔离措施前不要解压缩*。</strong></p></blockquote><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[如何安全地做电脑病毒实验-百度经验 (baidu.com)](<a href="https://jingyan.baidu.com/article/8cdccae9bacc6b705413cdf9.html#:~:text=%E6%81%A2%E5%A4%8D%E3%80%82">https://jingyan.baidu.com/article/8cdccae9bacc6b705413cdf9.html#:~:text=恢复。</a> 实验完后，恢复中毒前的状态。 依次单击VMware,Workstation Pro软件上方的虚拟机菜单-快照-恢复到快照，在弹出的对话框中选择”是“，如图所示。 大约半分钟后就虚拟机就恢复到了中毒前的状态。)</p><p><a href="https://en.wikipedia.org/wiki/WannaCry_ransomware_attack#cite_note-zdnet-xpwannakey-79">WannaCry - wiki</a></p><p><a href="https://www.wired.com/2017/05/wannacry-flaw-help-windows-xp-victims-get-files-back/">Wannakey</a></p><p><a href="https://zhuanlan.zhihu.com/p/26935965">勒索病毒WannaCry深度技术分析—— 详解传播、感染和危害细节</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Wannacry&quot;&gt;&lt;a href=&quot;#Wannacry&quot; class=&quot;headerlink&quot; title=&quot;Wannacry&quot;&gt;&lt;/a&gt;Wannacry&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络病毒测试</title>
    <link href="http://example.com/2023/10/16/net-attack&amp;defence-doc/%E7%BD%91%E7%BB%9C%E7%97%85%E6%AF%92%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2023/10/16/net-attack&amp;defence-doc/%E7%BD%91%E7%BB%9C%E7%97%85%E6%AF%92%E6%B5%8B%E8%AF%95/</id>
    <published>2023-10-16T02:44:53.000Z</published>
    <updated>2023-10-16T02:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Wannacry"><a href="#Wannacry" class="headerlink" title="Wannacry"></a>Wannacry</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://www.cloudflare-cn.com/learning/security/ransomware/wannacry-ransomware/">什么是 WannaCry 勒索软件攻击？</a></p><p>WannaCry 通过使用名为“EternalBlue”的漏洞利用进行传播。EternalBlue 仅适用于较旧的、未打补丁的 Microsoft Windows 版本，但运行此类版本的机器数量足以让 WannaCry 迅速传播开来。</p><p>*<em>勒索软件是一种恶意软件，它通过<a href="https://www.cloudflare.com/learning/ssl/what-is-encryption/">加密</a>锁住文件和数据，并索取赎金。</em></p><p>WannaCry 包含一个不寻常的函数：在执行之前，它将查询<a href="https://www.cloudflare.com/learning/dns/glossary/what-is-a-domain-name/">域</a> iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com。这个网站并不存在。</p><p>在 Hutchins 注册了这个域之后，WannaCry 的副本继续传播，但他们停止了执行。从本质上讲，一旦 WannaCry 开始收到来自 iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com 的响应，它就会自行关闭。<br><img src="/img/Network-attack/wanncry-analysis-1.png">x&#96;</p><h4 id="为什么这能阻止攻击？"><a href="#为什么这能阻止攻击？" class="headerlink" title="为什么这能阻止攻击？"></a>为什么这能阻止攻击？</h4><p>虽然不能确定 WannaCry 作者的动机，但据推测，WannaCry 中包含了这种域名查询功能的目的是让赎金软件能够检查它是否在沙盒内。</p><p>沙盒是一种反恶意软件工具。它是一个<a href="https://www.cloudflare.com/learning/cloud/what-is-a-virtual-machine/">虚拟机</a>，与所有其他系统和网络分开运行。它提供了一个安全的环境来执行不受信任的文件，看看它们是做什么的。</p><p>沙盒实际上没有连接到互联网。但沙盒的目的是尽可能地模仿真实的计算机，因此它们可能会对恶意软件针对特定域的查询产生一个虚假的响应。因此，恶意软件检查其是否在沙盒内的一种方法是向一个假的域名发送查询。如果它得到一个“真实的”响应（由沙盒生成），它可以认为自己是在沙盒中，并关闭自己，这样沙盒就不会检测到它是恶意的。</p><p>然而，如果恶意软件将其测试查询发送到一个硬编码的域名，那么如果有人注册了这个域名，它就会被欺骗，以为自己始终在沙盒中。这可能是 WannaCry 发生的情况：世界各地的 WannaCry 副本被欺骗，认为它们在沙盒内，并关闭自己。（从恶意软件作者的角度来看，一个更好的设计是查询一个每次都不同的随机域名，这样一来，从沙盒外的域名得到回应的几率就接近零了）。</p><h3 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h3><p>国庆假期结束后的第一节网络攻防课，老师安排测试wannacry病毒的任务。</p><h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><p>由于病毒具有破坏性，因此在本地直接运行是极其危险的行为，一旦控制不慎，不仅自己电脑的数据要被破坏和丢失，甚至可能导致电脑成为肉鸡，去攻击其他联网设备。<br>为了安全考虑，首先需要准备好病毒运行的环境。</p><ul><li>支持虚拟化技术的电脑</li><li>VMware Workstation Pro 软件</li><li>操作系统安装包</li><li>计算机病毒样本</li></ul><h4 id="虚拟机环境配置"><a href="#虚拟机环境配置" class="headerlink" title="虚拟机环境配置"></a>虚拟机环境配置</h4><p>系统：Windows XP<br>安装教程：<br><a href="https://blog.csdn.net/IronmanJay/article/details/129965817">VMware虚拟机之WindowsXP系统超详细下载安装与使用教程</a><br><a href="https://next.itellyou.cn/Original/">itellyou官网 - 系统镜像下载</a></p><p>这个教程非常详细，而且每一步都有图片，即使小白也能轻松使用。</p><h4 id="本地文件如何与虚拟机交互"><a href="#本地文件如何与虚拟机交互" class="headerlink" title="本地文件如何与虚拟机交互"></a>本地文件如何与虚拟机交互</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>因为VMware自带有工具Vmware Tools，能够直接实现主机和虚拟机之间的文件共享，同时支持自由拖拽文件进行上传和下载，因此最简单且好用的办法就是在虚拟机安装Vmware Tools。</p><p>附上官方文档：<a href="https://docs.vmware.com/cn/VMware-Tools/11.2.5/vmware-tools-user-guide.pdf">VMware Tools 用户指南 - VMware Tools 11.2.5</a></p><blockquote><p>说明：由于上一步安装虚拟机后，我的XP虚拟机自动安装了Vmware Tools（所以显示重新安装vmware tool），因此以下内容并未具体尝试，可能以下安装步骤中会出现一些报错或bug，请酌情查看。</p><p><img src="/img/Network-attack/VMtool-download.png"></p></blockquote><p>具体步骤如下：</p><p><strong>windows：</strong></p><p><a href="https://docs.vmware.com/cn/VMware-Tools/12.3.0/com.vmware.vsphere.vmwaretools.doc/GUID-391BE4BF-89A9-4DC3-85E7-3D45F5124BC7.html">在 Windows 上手动安装 VMware Tools</a></p><p>[如何在Windows操作系统安装VMwareTools_VMware服务-阿里云帮助中心 (aliyun.com)](<a href="https://help.aliyun.com/document_detail/412878.html#:~:text=%E5%AE%89%E8%A3%85VMware">https://help.aliyun.com/document_detail/412878.html#:~:text=安装VMware</a> Tools（Windows操作系统） 1 Windows操作系统安装完成后，VMware vSphere控制台会提示“该虚拟机上未安装VMware Tools” 2 鼠标右击虚拟机，选择,。 7 选择 安装 ，开始安装。 8 正在安装，如下图所示。 更多项目)</p><p><strong>linux：</strong></p><p>打开linux虚拟机，在VMware菜单栏里点击虚拟机选项，找到安装VMware tools选项。</p><p>对linux系统的tool安装需要控制台执行，下面附上代码：</p><figure class="highlight bash"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 解压下载的安装包</span><br><span class="line">tar -zxvf [文件名]</span><br><span class="line">//进入解压完成的文件夹</span><br><span class="line"><span class="built_in">cd</span> [wen<span class="string">&#x27;jian&#x27;</span>ji]</span><br><span class="line">//查看文件夹下的文件</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">//执行文件夹下的可执行文件。</span><br><span class="line">sudo ./vmware-install.pl</span><br></pre></td></tr></table></figure><p>完成以上步骤后重启系统。</p><h5 id="方法二：（以下内容只是对该博客的简略，并非原创）"><a href="#方法二：（以下内容只是对该博客的简略，并非原创）" class="headerlink" title="方法二：（以下内容只是对该博客的简略，并非原创）"></a>方法二：（以下内容只是对该博客的简略，并非原创）</h5><p><a href="https://blog.csdn.net/qq_41486333/article/details/115259771?ops_request_misc=%7B%22request_id%22:%22169733009516800222810780%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169733009516800222810780&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-115259771-null-null.142%5Ev96%5Epc_search_result_base1&utm_term=vmware%E6%80%8E%E4%B9%88%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%99%A4%E4%BA%86vmwaretool&spm=1018.2226.3001.4187">将本机文件复制到安装的虚拟机系统中的两种方法_vmware怎么将本地文件下载到虚拟机除了vmwaretool_灼_灼的博客-CSDN博客</a></p><p>进入虚拟机设置，选择硬盘，再点击映射</p><p><img src="/img/Network-attack/VMware-interact-1.png"></p><p>在打开的映射虚拟磁盘，选择要复制到虚拟机里的哪个盘，记得取消勾选“以只读模式打开文件”，然后点击确定。</p><p><img src="/img/Network-attack/VMware-interact-2.png"></p><p>点击本地资源管理器，选择已经映射的盘</p><p><img src="/img/Network-attack/VMware-interact-3.png"></p><p>如果没有出现需要格式化弹窗，就可以直接把文件复制到映射盘中了，然后在虚拟机里，对应的你刚才选中的虚拟机里的磁盘就可以看到复制的文件了。</p><blockquote><p><strong>注意</strong>：要是有提示格式化，然后有文件较为重要，建议不要格式化</p></blockquote><p><img src="/img/Network-attack/VMware-interact-4.png"></p><p>复制完文件记得断开连接</p><p><img src="/img/Network-attack/VMware-interact-5.png"></p><h4 id="隔离措施"><a href="#隔离措施" class="headerlink" title="隔离措施"></a>隔离措施</h4><blockquote><p><strong>做好隔离措施。此步骤非常重要！！！</strong></p><p><strong>注意：为了安全起见，强烈建议拔掉插在电脑上的U盘。</strong></p></blockquote><p>打开虚拟机操作系统上的网络与共享中心，单击已经连接因特网的本地连接，在弹出的对话框中单击“禁用“按钮。</p><p><img src="/img/Network-attack/virus-analysis-4.jpg"></p><p>点击VMware Workstation Pro软件上方的虚拟机菜单，选择设置，单击设置窗口左侧的网络适配器，之后在网络适配器设置的设备状态栏内将两个勾去掉。</p><p><img src="/img/Network-attack/virus-analysis-2.jpg" alt="如何安全地做电脑病毒实验？"></p><p>单击上方的“选项”选项卡，在左侧列表框内确认共享文件夹已禁用。设置完后单击确定按钮。</p><p><img src="/img/Network-attack/virus-analysis-3.jpg" alt="如何安全地做电脑病毒实验？"></p><p><strong>拍摄快照</strong>。为了防止病毒发作导致虚拟机系统崩溃后恢复麻烦，建议在运行病毒程序前拍摄快照，如图所示。该步骤需要几分钟时间，注意观察虚拟机软件的左下角。</p><p><img src="/img/Network-attack/virus-analysis-1.jpg" alt="如何安全地做电脑病毒实验？"></p><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p><strong>针对病毒特性，设好模型。</strong>比如：如果要运行勒索病毒，则需在虚拟机桌面上象征新地放置几个文本文件，观察中毒前后文件内容变化。</p><p><img src="/img/Network-attack/virus-analysis-5.jpg"></p><p><strong>在确认做好隔离措施后（特别是检查是否已经断网），在虚拟机上把病毒样本压缩包解压缩并小心运行病毒程序。</strong></p><p><strong>观察实验效果。</strong>如：我们刚刚放置的文件已经被加密而乱码；桌面变了；弹出勒索对话框。如图。</p><p><img src="/img/Network-attack/virus-analysis-6.jpg"></p><p><img src="/img/Network-attack/virus-analysis-7.jpg"></p><blockquote><p>病毒似乎并不能把已经运行的程序强制关闭，但这些打开的源文件已经不在桌面了，因此可以知道病毒并不直接修改内存。应该只是操作硬盘数据。</p></blockquote><p><em><strong>*解毒具体步骤*</strong></em></p><p>打开wannakey-master，阅读readme.txt，由于wannacry会识别后缀名为txt的文件并标记为重要文件进行加密，因此readme的后缀名有可能被改成了其他形式，此时应该改回txt格式，采用记事本打开。</p><p>根据readme.txt中提供的信息，参照自己的windows版本，在bin中选择合适的exe进行运行：</p><p>运行wannakey.exe程序</p><p>多核系统使用wannakey_omp.exe</p><p>运行后会跳出cmd窗口（窗口可能会一闪而过，注意观察），如果显示秘钥已经成功生成(key has been generated)，那么秘钥已经获取成功，此时前往恶意软件窗口，单击解密(decrypt)按钮，在后续的窗口里选择自己要解密的对象点击start，即可进行解密。</p><p>此时下方的目录表中会显示所有被解密了的文件的路径，可以根据路径进行核实和查看。</p><p><strong>恢复。</strong>实验完后，恢复中毒前的状态。依次单击VMware Workstation Pro软件上方的虚拟机菜单-快照-恢复到快照，在弹出的对话框中选择”是“，如图所示。大约半分钟后就虚拟机就恢复到了中毒前的状态。</p><h3 id="病毒逆向"><a href="#病毒逆向" class="headerlink" title="病毒逆向"></a>病毒逆向</h3><p><a href="https://www.52pojie.cn/thread-1573058-1-1.html">病毒分析之WannaCry勒索病毒 - 『病毒分析区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p>[<a href="https://cloud.tencent.com/developer/article/1910271">系统安全] 三十.WannaCry勒索病毒分析 (4)全网“最”详细的蠕虫传播机制解读-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>[<a href="https://cloud.tencent.com/developer/article/1910268">系统安全] 二十七.WannaCry勒索病毒分析 (3)蠕虫传播机制分析及IDA和OD逆向-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>WannaCry利用Windows系统的SMB漏洞获取系统的最高权限，该工具通过恶意代码扫描开放445端口的Windows系统。WannaCry利用永恒之蓝漏洞进行网络端口扫描攻击，目标机器被成功攻陷后会从攻击机下载WannaCry蠕虫进行感染，并作为攻击机再次扫描互联网和局域网的其他机器，形成蠕虫感染大范围超快速扩散。</p><p>WannaCry勒索病毒主要行为是传播和勒索。<br>该病毒分为两个部分：</p><p>（1） 蠕虫部分，利用基于445端口的SMB漏洞MS17-010(永恒之蓝)进行病毒传播，并释放出勒索病毒。</p><p>（2） 勒索病毒部分，加密用户文件索要赎金。释放文件，包括加密器、解密器、说明文件、语言文件等；加密文件；设置桌面背景、窗体信息及付款账号等。</p><h4 id="勒索病毒部分详细分析-（待修改）"><a href="#勒索病毒部分详细分析-（待修改）" class="headerlink" title="勒索病毒部分详细分析 （待修改）"></a><strong>勒索病毒部分详细分析</strong> （待修改）</h4><p><strong>CryptGenKey</strong> 函数生成随机加密<a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">会话密钥</a>或<a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/p-gly">公钥&#x2F;私钥对</a>。密钥或密钥对的句柄在 <em>phKey</em> 中返回。</p><p>勒索主逻辑执行，先会导入一个存放在镜像中的RSA公钥，之后调用CryptGenKey生成一组RSA算法的Session key。之后将这组Key的公钥通过CryptExportKey导出，再写入到00000000.pky文件中。将Session key中的私钥用刚导入RSA公钥进行加密，存放在00000000.eky如下图所示：</p><p><img src="https://pic1.zhimg.com/80/v2-ef633e009eae50dc19f8f253273a2af0_720w.webp" alt="img"></p><p>如果遍历到的文件扩展名在欲加密的文件扩展名列表中，如下图所示：</p><p><img src="https://pic3.zhimg.com/80/v2-25696ad49373393f257bc7826b8654e6_720w.webp" alt="img"></p><p>则会将当前文件路径加入到文件操作列表中，在遍历文件结束后一并进行文件操作。代码如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-ac9efbcc9f670fad48976552489fd4a6_720w.webp" alt="img"></p><p>对于每个需要加密的文件，都会调用CryptGenRadom随机生成AES密钥，之后使用Session Key中的RSA公钥对AES密钥进行加密，存放在加密后的数据文件头中，之后将原始文件数据用该AES密钥进行加密。如下图所示：</p><p><img src="https://pic2.zhimg.com/80/v2-c4ec5a74af2e25e73956450b6fbe793d_720w.webp" alt="img"></p><p>整体加密流程，如下图所示：</p><p><img src="https://pic4.zhimg.com/80/v2-d5d7f398fcf56e76bfff2fc91588259b_720w.webp" alt="img"></p><p>因为病毒是生成加密过的用户文件后再删除原始文件，所以存在通过文件恢复类工具恢复原始未加密文件的可能。但是因为病毒对文件系统的修改操作过于频繁，导致被删除的原始文件数据块被覆盖，致使实际恢复效果有限。且随着系统持续运行，恢复类工具恢复数据的可能性会显著降低。</p><p><strong>Wannakey的恢复</strong></p><p>因为所有文件都是用随机生成的AES</p><p>WannaCry 在加密文件时会将加密密钥存储在内存中，而没有进行及时的清除。WannaKey 利用了这个漏洞，通过扫描内存中的数据，找到并提取出加密文件的解密密钥。</p><p>因此，WannaKey 能够解密 WannaCry 加密的文件，是因为它能够获取到加密文件的解密密钥。通过使用这个解密密钥，WannaKey 可以还原被 WannaCry 加密的文件，使受害者能够恢复其文件的原始状态。</p><h4 id="病毒样本下载"><a href="#病毒样本下载" class="headerlink" title="病毒样本下载"></a>病毒样本下载</h4><p><a href="https://blog.csdn.net/so18635793637/article/details/128781620">计算机病毒样本分享_勒索病毒样本下载-CSDN博客</a></p><blockquote><p><strong>注意：为了安全起见，建议直接在虚拟机上上网搜索、下载，*在做好隔离措施前不要解压缩*。</strong></p></blockquote><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://jingyan.baidu.com/article/8cdccae9bacc6b705413cdf9.html">如何安全地做电脑病毒实验-百度经验</a> </p><p><a href="https://en.wikipedia.org/wiki/WannaCry_ransomware_attack#cite_note-zdnet-xpwannakey-79">WannaCry - wiki</a></p><p><a href="https://www.wired.com/2017/05/wannacry-flaw-help-windows-xp-victims-get-files-back/">Wannakey</a></p><p><a href="https://zhuanlan.zhihu.com/p/26935965">勒索病毒WannaCry深度技术分析—— 详解传播、感染和危害细节</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Wannacry&quot;&gt;&lt;a href=&quot;#Wannacry&quot; class=&quot;headerlink&quot; title=&quot;Wannacry&quot;&gt;&lt;/a&gt;Wannacry&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UML统一建模语言</title>
    <link href="http://example.com/2023/10/16/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/"/>
    <id>http://example.com/2023/10/16/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</id>
    <published>2023-10-16T02:44:42.000Z</published>
    <updated>2023-10-16T02:44:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UML词汇表和术语"><a href="#UML词汇表和术语" class="headerlink" title="UML词汇表和术语"></a>UML词汇表和术语</h2><ul><li><strong>抽象类</strong>：一个永远不会被实例化的类。这个类的一个实例永远不会存在。</li><li><strong>Actor（演员）</strong>：发起系统参与的事件的对象或人物。</li><li><strong>活动</strong>：活动图中的步骤或行动。表示系统或演员采取的行动。</li><li><strong>活动图</strong>：一个美化的流程图，显示了流程中的步骤和决定以及并行操作，如算法或业务流程。</li><li><strong>聚合</strong>：是另一类的一部分。图中的包含类旁边有一个空心钻石。</li><li><strong>工件</strong>：描述设计过程中某个步骤输出的文档。描述是图形，文字或其他组合。</li><li><strong>关联</strong>：一个模型的两个元素之间的联系。这可能代表代码中的成员变量，或者人员记录与其所代表的人之间的关联，或者两类工作人员之间的关系，或者任何类似的关系。默认情况下，一个关联中的两个元素是相等的，并且通过该关联知道对方。一个协会也可以是一个可导航的协会，这意味着协会的来源端知道目标端，但反之亦然。</li><li><strong>关联类</strong>：表示两个其他类之间的关联信息的类。</li><li><strong>属性</strong>：可用于引用其他对象或保存对象状态信息的对象的特征。</li><li><strong>基类</strong>：定义由子类通过泛化关系继承的属性和操作的类。</li><li><strong>分支</strong>：活动图中的决策点。分支出现多个转变，每个都有一个保护条件。当控制到达分支时，恰好一个保护条件必须为真; 并且控制遵循相应的转换。</li><li><strong>类</strong>：类似对象的类别，全部由相同的属性和操作描述，并且所有的赋值兼容。</li><li><strong>类图</strong>：显示系统类和它们之间的关系。</li><li><strong>分类器</strong> ：具有属性和操作的UML元素。具体来说，Actor，Classes和Interfaces。</li><li><strong>协作</strong>：通信图中两个对象之间的关系，指示消息可以在对象之间来回传递。</li><li><strong>通信图</strong>：显示如何在强调对象角色的同时完成操作的图表。</li><li><strong>组件</strong>：系统中可部署的代码单元。</li><li><strong>组件图</strong>：显示各种组件和接口之间关系的图表。</li><li><strong>概念</strong>：要包含在域模型中的名词或抽象概念。</li><li><strong>构建阶段</strong>：Rational统一过程的第三阶段，在这个阶段中，正在构建的系统中内置了多个功能迭代。这是主要工作完成的地方。</li><li><strong>依赖关系</strong>：指示一个分类器的关系知道另一个分类器的属性和操作，但不直接连接到第二个分类器的任何实例。</li><li><strong>部署图</strong>：显示各种处理器之间关系的图表。</li><li><strong>域</strong>：系统所涉及的宇宙的一部分。</li><li><strong>精化阶段</strong>：Rational统一过程的第二阶段，允许额外的项目计划，包括构建阶段的迭代。</li><li><strong>元素</strong>：出现在模型中的任何项目。</li><li><strong>封装</strong>：对象中的数据是私有的。</li><li><strong>泛化</strong>：指示一个类是另一个类（超类）的子类。一个空心箭头指向超类。</li><li><strong>事件</strong>：在状态图中，这表示导致系统采取行动或切换状态的信号或事件或输入。</li><li><strong>最终状态</strong> ：在状态图或活动图中，这表示图完成的点。</li><li><strong>叉</strong>：活动图中的一个点，多个并行控制线程开始。</li><li><strong>泛化</strong>：继承关系，其中一个子类继承并添加到基类的属性和操作。</li><li><strong>GoF</strong>：四人帮设计模式。</li><li><strong>高凝聚力</strong>：GRASP评估模式，确保课程不是太复杂，做不相关的功能。</li><li><strong>低耦合</strong>：GRASP评估模式，衡量一个类别依赖于另一个类别或与另一个类别相关联。</li><li><strong>启动阶段</strong>：Rational统一过程的第一阶段，处理原始概念化和项目开始阶段。</li><li><strong>继承</strong>：子类继承父类（超类）类的属性或特性。这些属性可以在子类中重写。</li><li><strong>初始状态</strong>：在状态图或活动图中，这表示图开始的点。</li><li><strong>实例</strong>：一个类像模板一样用来创建一个对象。这个对象被称为类的一个实例。可以创建任何数量的该类的实例。</li><li><strong>接口</strong>：定义形成行为契约的属性和操作的分类器。提供者类或组件可以选择实现接口（即实现其属性和操作）。客户端类或组件可以依赖于接口，并因此使用提供者而不提供提供者的真实类别的任何细节。</li><li><strong>迭代</strong>：一个小项目部分，在这个小项目中，一小部分功能被添加到项目中。包括分析，设计和编码的开发循环。</li><li><strong>加入</strong>：活动图中的一个点，多个并行控制线程同步并重新加入。</li><li><strong>成员</strong>：分类器中的属性或操作。</li><li><strong>合并</strong>：活动图中的一个点，不同的控制路径汇集在一起。</li><li><strong>消息</strong>：从一个对象到另一个对象的请求，要求接收消息的对象执行某些操作。这基本上是对接收对象中的方法的调用。</li><li><strong>方法</strong>：对象中的函数或过程。</li><li><strong>模型</strong>：中央UML神器。由各个元素组成的层次结构，以及元素之间的关系。</li><li><strong>多重性</strong>：显示在领域模型中，表示外部概念框，表示与其他对象的分位数的对象数量关系。</li><li><strong>可导航性</strong>：指示关系的哪一端知道另一端。关系可以具有双向可导航性（每一端意识到另一端）或单向导航（一端意识到另一端，但反之亦然）。</li><li><strong>符号</strong>：创建分析和设计方法的图形化文档。</li><li><strong>注意</strong>：文字注释已添加到图表中以更详细地解释图表。</li><li><strong>对象</strong>：对象：在活动图中，从活动接收信息或向活动提供信息的对象。在“协作图”或“序列图”中，参与图中所示场景的对象。通常：给定分类器（Actor，Class或Interface）的一个实例或示例。</li><li><strong>包</strong>：逻辑上应该组合在一起的一组UML元素。</li><li><strong>包图</strong>：所有元素都是包和依赖关系的类图。</li><li><strong>模式</strong>：用于确定交互对象责任分配的解决方案。这是一个成功解决众所周知的常见问题的名称。</li><li><strong>参数</strong>：一个操作的参数。</li><li><strong>多态性</strong>：相同的消息，不同的方法。也用作模式。</li><li><strong>私有</strong>：应用于属性或操作的可见性级别，指示只有包含该成员的分类器的代码才可以访问该成员。</li><li><strong>处理器</strong>：在部署图中，代表可以部署代码的计算机或其他可编程设备。</li><li><strong>受保护</strong>：应用于属性或操作的可见性级别，指示只有包含该成员或其子类的分类器的代码才能访问该成员。</li><li><strong>公开</strong>：应用于属性或操作的可见性级别，指示任何代码都可以访问该成员。</li><li><strong>读取方向箭头</strong>：指示领域模型中关系的方向。</li><li><strong>实现</strong>：表示组件或类提供给定的接口。</li><li><strong>角色</strong>：用于域模型，是关于角色角色的可选描述。</li><li><strong>顺序图</strong>：一个图表，显示随着时间的推移对象的存在，以及随着时间的推移在这些对象之间传递的消息来执行一些行为。状态图图 - 显示所有可能的对象状态的图。</li><li><strong>状态</strong>：在状态图中，这表示系统或子系统的一种状态：它在某个时间点所做的事情，以及其数据的值。</li><li><strong>状态图</strong>：显示系统或子系统的状态，状态之间的转换以及导致转换的事件的图表。</li><li><strong>静态</strong>：一个属性的修饰符，用于指示分类器的所有实例之间共享的属性只有一个副本。“操作”的修饰符，用于指示“操作”独立运行并且不在分类器的一个特定实例上操作。</li><li><strong>刻板印象（Stereotype）</strong>：一个应用于Model元素的修饰符，用于指示它通常不能用UML表示的东西。从本质上讲，定型允许你定义你自己的UML“方言”。</li><li><strong>子类</strong>：继承由子类通过泛化关系定义的属性和操作的类。</li><li><strong>互動區</strong>：活动图的一个元素，指示系统或域的哪些部分执行特定的活动。泳道内的所有活动都由泳道所代表的对象，组件或者演员负责。</li><li><strong>时间拳击</strong>：每次迭代都会有特定目标的时间限制。</li><li><strong>过渡</strong>：在活动图中，表示从一个活动或分支或合并或分叉或连接到另一个的控制流程。在国家图中，代表着一个国家向另一个国家的转变。</li><li><strong>过渡阶段</strong> - Rational 统一过程的最后一个阶段，在这个阶段，用户接受使用新系统和系统的培训，用户可以使用这个阶段。</li><li><strong>统一建模语言（ UML）</strong>：统一建模语言（ UML）利用文本和图形文档，通过在对象之间建立更紧密的关系，来增强软件项目的分析和设计</li><li><strong>用例</strong>：在用例图中，表示系统响应来自Actor的某个请求所采取的操作。</li><li><strong>用例图</strong>：显示参与者和用例之间关系的图表。</li><li><strong>可见性</strong>：对属性或操作的修饰符，指示哪些代码可以访问成员。可见性级别包括公共，受保护和私有。</li><li><strong>工作流程</strong>：一组产生特定结果的活动。</li></ul><h2 id="UML-概述"><a href="#UML-概述" class="headerlink" title="UML - 概述"></a>UML - 概述</h2><p>以下简要地介绍了这 13 个 UML 图表。UML 图表可大致分为结构性图表和行为性图表两种。</p><p><img src="http://lib.uml.com.cn/ebook/UML2.5/images/2019071221.png"></p><p>结构性图表显示了系统在不同抽象层次和实现层次上的静态结构以及它们之间的相互关系。结构性图表中的元素表示系统中具意义的概念，可能包括抽象的、现实的和實作的概念。结构性图表有七种类型：</p><ul><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#class-diagram">类图 (Class Diagram)</a></li><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#component-diagram">组件图 (Component Diagram)</a></li><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#deployment-diagram">部署图 (Deployment Diagram)</a></li><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#object-diagram">对象图 (Object Diagram)</a></li><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#package-diagram">包图 (Package Diagram)</a></li><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#composite-structure-diagram">复合结构图 (Composite Structure Diagram)</a></li><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#profile-diagram">轮廓图 (Profile Diagram)</a></li></ul><p>行为性图表显示了系统中对象的动态行为 ，可用以表达系统随时间的变化。行为性图表有七种类型：</p><ul><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#use-case-diagram">用例图 (Use Case Diagram)</a></li><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#activity-diagram">活动图 (Activity Diagram)</a></li><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#state-machine-diagram">状态机图 (State Machine Diagram)</a></li><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#sequence-diagram">序列图 (Sequence Diagram)</a></li><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#communication-diagram">通訊圖 (Communication Diagram)</a></li><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#interaction-overview-diagram">交互概述图 (Interaction Overview Diagram)</a></li><li><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/#timing-diagram">时序图 (Timing Diagram)</a></li></ul><h3 id="类图-Class-Diagram"><a href="#类图-Class-Diagram" class="headerlink" title="类图 (Class Diagram)"></a>类图 (Class Diagram)</h3><p><a href="https://blog.csdn.net/ibukikonoha/article/details/80643959?utm_source=app&app_version=4.9.1">UML类图总结（浅显易懂实用）-CSDN博客</a></p><h4 id="类的基本表示方式"><a href="#类的基本表示方式" class="headerlink" title="类的基本表示方式"></a>类的基本表示方式</h4><p>在UML类图中，每一个矩形代表一个类。</p><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>类之间的关系有继承关系，实现关系，依赖关系，关联关系，聚合关系，组合关系。</p><p>有三种主要的关系：</p><ol><li>关联 - 代表类型之间的关系（一个人为公司工作，一间公司有多个办事处）。</li><li>继承 - 专为将实例关系图 (ERD) 应用于面向对象设计而设的一种关系。它在面向对象设计中的继承概念互相呼应。”is-a” relationship</li><li>聚合 - 面向对象设计中的一种对象组合的形式，是另一类的一部分。“has-a” relationship</li></ol><p><img src="/img/software-engineering/class-diagram-example.png" alt="类图"></p><h3 id="序列图-Sequence-Diagram"><a href="#序列图-Sequence-Diagram" class="headerlink" title="序列图 (Sequence Diagram)"></a>序列图 (Sequence Diagram)</h3><p><a href="https://blog.csdn.net/fly_zxy/article/details/80911942?utm_source=app&app_version=4.9.1">UML时序图(Sequence Diagram)学习笔记_-CSDN博客</a></p><p><strong>Definition</strong></p><blockquote><p>时序图(Sequence Diagram)，又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</p></blockquote><p><strong>Element</strong></p><p>角色(Actor)</p><blockquote><p>系统角色，可以是人或者其他系统，子系统。以一个小人图标表示。</p></blockquote><p>对象(Object)</p><blockquote><p>对象位于时序图的顶部,以一个矩形表示。对象的命名方式一般有三种：<br>    1 对象名和类名。例如：华为手机:手机、loginServiceObject:LoginService。<br>    2 只显示类名，不显示对象，即为一个匿名类。例如：:手机、:LoginSservice。<br>    3 只显示对象名，不显示类名。例如：华为手机:、loginServiceObject:。</p></blockquote><p>生命线(LifeLine)</p><blockquote><p>时序图中每个对象和底部中心都有一条垂直的虚线，这就是对象的生命线(对象的时间线)。以一条垂直的虚线表。</p></blockquote><p>控制焦点(Activation)</p><blockquote><p>控制焦点代表时序图中在对象时间线上某段时期执行的操作。以一个很窄的矩形表示。</p></blockquote><p>消息(Message)</p><blockquote><p>表现代表对象之间发送的信息。消息分为三种类型。<br>    同步消息(Synchronous Message)<br>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。以一条实线+实心箭头表示。<br>    异步消息(Asynchronous Message)<br>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。以一条实线+大于号表示。<br>    返回消息(Return Message)<br>返回消息表示从过程调用返回。以小于号+虚线表示。</p></blockquote><p>关联消息</p><blockquote><p>表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。以一个半闭合的长方形+下方实心剪头表示。</p></blockquote><p><strong>时序图示例：</strong><br>1，用户输入手机密码<br>2，打开手机<br>3，打开微信扫一扫<br>4，返回微信扫一扫界面<br>5.1 扫描商家收款码<br>5.2 商家生成收款二维码<br>5.3 返回收款二维码<br>5.4 识别商家收款码<br>6，提示用户输入微信支付密码<br>7.1 输入微信支付密码<br>7.2 微信验证用户输入密码正确<br>7.3 向商家汇款</p><p>7.4 汇款成功<br>8，提示用户支付成功<br><img src="/img/software-engineering/UML-sequence-diagram.png"></p><h3 id="状态机图-State-Machine-Diagram"><a href="#状态机图-State-Machine-Diagram" class="headerlink" title="状态机图 (State Machine Diagram)"></a>状态机图 (State Machine Diagram)</h3><p><a href="https://blog.csdn.net/gstrong298/article/details/25166425?utm_source=app&app_version=4.9.1">【学习小记】UML——状态机图_uml状态机图怎么画-CSDN博客</a></p><p><strong>Definition</strong></p><p>UML状态机图同活动图一样，是动态视图的一种。</p><p>UML状态机图描述的是某个对象的状态和感兴趣的事件，以及对象响应该事件的行为。它描述的是“某个对象”，因此，一个状态机图中只能表示一个对象，而不是多个对象。状态图显示了该对象的生命周期，也即，对象经历的事件，对象的转换和对象在这些事件之间的状态。<br><strong>Element</strong></p><p>1、状态</p><p>   UML状态机图中的状态，以圆角方框表示，通常有状态名称，进入&#x2F;退出活动，内部转换，子状态，延迟事件组成（后面介绍）。</p><p>   状态还包括初始状态（由实心黑圆点表示）和终止状态（由实心黑圆点外包一个圆圈表示）。</p><p>2、事件</p><p>   事件包含在转换中.</p><p>3、转换</p><p>   转换涉及的内容包括：源状态、目标状态、触发事件（事件）、监护条件、动作，具体可以参看下图的例子。</p><p>如何绘制状态机图</p><pre><code>  绘制状态机图的基本步骤为：  1、寻找主要状态  2、确定状态间的转换，可借助状态转换分析表  3、细化状态内部的活动和转换        根据需要添加内部转换、进入转换、退出转换以及相关的活动等。  4、用复合状态来展开细节  下面用一个例子来进行绘制过程的演示。</code></pre><h3 id="数据流图-Data-flow-diagrams-DFD"><a href="#数据流图-Data-flow-diagrams-DFD" class="headerlink" title="数据流图 (Data-flow diagrams(DFD))"></a>数据流图 (Data-flow diagrams(DFD))</h3><p><a href="https://blog.csdn.net/I_r_o_n_M_a_n/article/details/121309525">【精选】软件工程 – 数据流图的画法_CodeJiao的博客-CSDN博客</a></p><p><strong>Definition</strong></p><blockquote><p>数据流图(Data Flow Diagram，DFD)是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换。</p></blockquote><p>数据流图的优点：</p><ul><li>在数据流图中没有任何具体的物理元素，它只是描绘信息在软件中流动和被处理的情况。</li><li>因为数据流图是系统逻辑功能的图形表示，即使不是专业的计算机技术人员也容易理解它，所以是分析员与用户之间极好的沟通工具。</li><li>设计数据流图时只需考虑系统必须完成的基本逻辑功能，完全不需考虑怎样具体地实现这些功能，因此，它也是今后进行软件设计很好的出发点。</li><li>数据流图可以在任何抽象层次上被用来表示系统或软件。事实上，数据流图可以被分层次地画，层次越低（在数据流图中1层比0层的层次更等）表现出的信息流细节和功能细节也越多。数据流图既提供了功能建模机制、也提供了信息流建模机制。</li></ul><p><strong>Element</strong></p><p>数据流图有4种基本符号：</p><ul><li>正方形（或立方体）表示数据的源点或终点；</li><li>圆角矩形（或圆形）代表变换数据的处理；</li><li>开口矩形（或两条平行横线）代表数据存储；</li><li>箭头表示数据流，即特定数据的流动方向。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/">什么是统一建模语言（UML）？ (visual-paradigm.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;UML词汇表和术语&quot;&gt;&lt;a href=&quot;#UML词汇表和术语&quot; class=&quot;headerlink&quot; title=&quot;UML词汇表和术语&quot;&gt;&lt;/a&gt;UML词汇表和术语&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抽象类&lt;/strong&gt;：一个永远不会被实例化的类。这个</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/04/assets/web1/"/>
    <id>http://example.com/2023/10/04/assets/web1/</id>
    <published>2023-10-04T12:12:35.194Z</published>
    <updated>2023-10-04T12:12:40.795Z</updated>
    
    <content type="html"><![CDATA[:root{    --theme-skin: #ff5f77;    --theme-skin-matching:#ff91af;    --infor_bar_bgcolor:rgba(255,255,255,0.8);    --style_menu_selection_radius:15px;    --post_list_matching_color:#ffb7c5;    --load_nextpage_svg:url("https://statics.imoeq.com/blog/ball.svg");    --style_menu_radius:10px;    --post-list-thumb: #e8e8e8;    --friend-link-shadow: #e8e8e8;    --friend-link-title: #ffe066;    --comment_area_matching: #ffe066;    --comment_area_shadow: #e8e8e8;    --shuoshuo_background_color1:#8f4ec4;    --shuoshuo_background_color2:#ea00bf;    --inline_code_background_color:#F2F1F1;        --theme-skin-dark:  #b500dd;    --global-font-weight:300;    --theme-dm-background_transparency:0.7;    --exhibition_area_matching_color:#d3212d;    --inline_code_background_color_in_dark_mode:#505050;}.the-feature.from_left_and_right .info,.the-feature.from_left_and_right .info h3{background: rgba(193,193,193,0.4) ;}/*白猫样式Logo*//*非全局色彩管理*/.post-date {    background-color: #ffb7c526;}.center-text{color: rgba(237,78,54,0.43) ;font-size: 84px;}.Ubuntu-font,.center-text{font-family:  ;}.notice i ,.notice {    color: #f47738;}.notice {    border: 1px solid #E6E6E6;}#centerbg{background:#0000;}/*预加载部分*//*深色模式*//*可变项目*//*深色模式控件透明度*/body.dark .header-info,body.dark .header-shuo,body.dark .top-social img{color:#fff;background:rgba(51,51,51,0.75);}body.dark .the-feature.from_left_and_right .info{background-color: rgba(51,51,51,0.75);}body.dark .yya,body.dark input[type=submit] {background-color:rgba(38,38,38,0.75) !important;}/*深色模式自定义颜色*/body.dark .headertop-down svg path {fill: rgba(51,51,51,0.8) !important;transition: all 0.8s ease !important;}/*深色模式图像亮度*/body.dark img,body.dark .highlight-wrap,body.dark iframe,body.dark .entry-content .aplayer,body.dark .post-thumb video{filter:brightness(0.8);}@media (max-width: 1200px){body.dark .site-top .lower nav.navbar ul {background: rgba(255,255,255,0);}}/*字体*/.serif{font-family: !important ;font-size: 15px;}body{font-family: !important;font-size: 15px;}.site-top ul li a,.header-user-name,.header-user-menu a {font-family:Noto Serif SC !important;}.site-title a{font-family: 'ZCOOL QingKe HuangYou';}.site-info,.site-info a{font-family:Noto Serif SC !important;}.skin-menu p{font-family:Noto Serif SC !important;}h1.main-title,h1.fes-title{font-family:Noto Serif SC;}.header-info p, .header-shuo p{font-family:Noto Serif SC !important;font-size: 16px;}.cbp_tmtimeline > li .cbp_tmlabel {font-family:Noto Serif SC !important;}.post-list-thumb .post-title h3{font-size: 18px !important;}.post-meta, .post-meta a{font-size: 12px !important;}.pattern-center h1.cat-title,.pattern-center h1.entry-title {font-size: 40px ;}.pattern-center-sakura h1.cat-title,.pattern-center-sakura h1.entry-title {font-size: 40px !important;}.single-center .single-header h1.entry-title {font-size: 32px ;}/*鼠标*/body{cursor: url(https://statics.imoeq.com/blog/normal.cur), auto;}.headertop-down,#waifu #live2d,.aplayer svg,.aplayer.aplayer-narrow .aplayer-body,.aplayer.aplayer-narrow .aplayer-pic,#emotion-toggle,.emoji-item,.emotion-box,.emotion-item,.on-hover,.tieba-container span,#moblieGoTop,#changskin{cursor: url(https://statics.imoeq.com/blog/No_Disponible.cur), auto;}a,.ins-section .ins-section-header,.font-family-controls button,.menu-list li,.ins-section .ins-search-item,.ins-section .ins-search-item .ins-search-preview{cursor: url(https://statics.imoeq.com/blog/ayuda.cur), auto;}p,.highlight-wrap code,.highlight-wrap,.hljs-ln-code .hljs-ln-line{cursor: url(https://statics.imoeq.com/blog/texto.cur), auto;}a:active{cursor: url(https://statics.imoeq.com/blog/work.cur), alias;}/*背景类*/.comment-respond textarea {background-image: url(); }.search-form.is-visible{background-image: url(https://statics.imoeq.com/blog/iloli.gif);}.site-footer {background-color: rgba(255, 255, 255,0.4); backdrop-filter: blur(10px);  -webkit-backdrop-filter: blur(10px); }.wrapper {background-color: rgba(255, 255, 255,0.4); backdrop-filter: blur(10px);  -webkit-backdrop-filter: blur(10px); }/*首页圆角设置*/.header-info,.header-shuo{border-radius: 50px;grid-row: 1;grid-column: 1;}.focusinfo img{border-radius: 15px;}.focusinfo .header-tou img{border-radius: 100px;}/*标题横线动画*/.single-center header.single-header .toppic-line{position:relative;bottom:0;left:0;display:block;width:100%;height:2px;background-color:#fff;animation:lineWidth 2.5s;animation-fill-mode:forwards;}@keyframes lineWidth{0%{width:0;}100%{width:100%;}}/*标题动画*/.entry-title,.single-center .entry-census a,.entry-census,.post-list p,.p-time,.feature{-moz-animation: fadeInDown 2s;    -webkit-animation:fadeInDown 2s;animation: fadeInDown 2s;}@-moz-keyframes fadeInUp {0% {-moz-transform: translateY(200%);transform: translateY(200%);opacity: 0} 50% {-moz-transform: translateY(200%);transform: translateY(200%);opacity: 0} 100% {-moz-transform: translateY(0%);transform: translateY(0%);opacity: 1}} @-webkit-keyframes fadeInUp {0% {-webkit-transform: translateY(200%);transform: translateY(200%);opacity: 0} 50% {-webkit-transform: translateY(200%);transform: translateY(200%);opacity: 0} 100% {-webkit-transform: translateY(0%);transform: translateY(0%);opacity: 1}} @keyframes fadeInUp {0% {-moz-transform: translateY(200%);-ms-transform: translateY(200%);-webkit-transform: translateY(200%);transform: translateY(200%);opacity: 0} 50% {-moz-transform: translateY(200%);-ms-transform: translateY(200%);-webkit-transform: translateY(200%);transform: translateY(200%);opacity: 0} 100% {-moz-transform: translateY(0%);-ms-transform: translateY(0%);-webkit-transform: translateY(0%);transform: translateY(0%);opacity: 1}}/*首页封面动画*/h1.main-title, h1.fes-title,.the-feature.from_left_and_right .info,.header-info p,.header-info,.header-shuo,.header-shuo p,.focusinfo .header-tou img,.top-social img,.center-text{-moz-animation: fadeInDown  1.16s;    -webkit-animation:fadeInDown  1.16s;animation: fadeInDown  1.16s;}@-moz-keyframes fadeInDown {0% {-moz-transform: translateY(-100%);transform: translateY(-100%);opacity: 0} 50% {-moz-transform: translateY(-100%);transform: translateY(-100%);opacity: 0} 100% {-moz-transform: translateY(0%);transform: translateY(0%);opacity: 1}} @-webkit-keyframes fadeInDown {0% {-webkit-transform: translateY(-100%);transform: translateY(-100%);opacity: 0} 50% {-webkit-transform: translateY(-100%);transform: translateY(-100%);opacity: 0} 100% {-webkit-transform: translateY(0%);transform: translateY(0%);opacity: 1}} @keyframes fadeInDown {0% {-moz-transform: translateY(-100%);-ms-transform: translateY(-100%);-webkit-transform: translateY(-100%);transform: translateY(-100%);opacity: 0} 50% {-moz-transform: translateY(-100%);-ms-transform: translateY(-100%);-webkit-transform: translateY(-100%);transform: translateY(-100%);opacity: 0} 100% {-moz-transform: translateY(0%);-ms-transform: translateY(0%);-webkit-transform: translateY(0%);transform: translateY(0%);opacity: 1}}/*导航菜单动画*//*其他*/.headertop{    border-radius: 0 0 15px 15px;}.author-profile .meta {display:none;}.post-modified-time {display:none;}.post-list-thumb:nth-child(2n) .post-content-wrap {    float: left;    padding-left: 30px;    padding-right: 0;    text-align: right;    margin: 20px 10px 10px 0}.post-list-thumb:nth-child(2n) .post-thumb {    float: left}.post-list-thumb:nth-child(2n) .post-thumb a {    border-radius: 10px 0 0 10px}.pattern-center::after {    display:none;}.pattern-center-blank {    display:none;}.site-header {    width: 100%;    height: 75px;    top: 0;    left: 0;    background: 0 0;    -webkit-transition: all .4s ease;    transition: all .4s ease;    position: fixed;    z-index: 999;    border-radius: 0px;}.header-user-avatar {  margin-top: 22px;}.site-branding {  height: 75px;  line-height: 75px;}.site-title img {  margin-top: 17px;}.site-top .lower {  margin: 15px 0 0 0;}.lower li ul {  top: 46px;  right: -24px;}.header-user-menu {  right: -11px;  top: 44px;}.logolink a {  height: 56px;  line-height: 56px;}.logolink.moe-mashiro a{  line-height: 56px !important;}.searchbox.js-toggle-search{  margin: 17px 0;  margin-left: 15px;}@media (max-width:860px) {.site-header {  height: 60px;}}.cbp_tmtimeline > li:nth-child(odd) .cbp_tmlabel:after {    display: none;}.cbp_tmtimeline > li .cbp_tmlabel:after {    display: none;}.the-feature.from_left_and_right {    position: relative;    border-radius: 15px;    height: 160px;    width: 258px;    margin: 6px 6px 0 6px;}.the-feature img {    height: 160px;    width: 258px;}h1.fes-title,h1.main-title {    text-align: center;}.notice {    background: #fbfbfb50;}body{    background-size:auto;}#video-add{    background-image: url(https://cdn.jsdelivr.net/gh/Fuukei/Sakurairo_Vision@2.6/basic/add.png);}@media (max-width:860px) {  .headertop.filter-dot::before {    background-image: url(https://cdn.jsdelivr.net/gh/Fuukei/Sakurairo_Vision@2.6/basic/grid.png);  }}.headertop.filter-grid::before {  background-image: url(https://cdn.jsdelivr.net/gh/Fuukei/Sakurairo_Vision@2.6/basic/grid.png);}.headertop.filter-dot::before {  background-image: url(https://cdn.jsdelivr.net/gh/Fuukei/Sakurairo_Vision@2.6/basic/dot.gif);}.loadvideo,.video-play {  background-image: url(https://cdn.jsdelivr.net/gh/Fuukei/Sakurairo_Vision@2.6/basic/play.png);}.video-pause {  background-image: url(https://cdn.jsdelivr.net/gh/Fuukei/Sakurairo_Vision@2.6/basic/stop.png);}#loading-comments {background-image: url(https://cdn.jsdelivr.net/gh/Fuukei/Sakurairo_Vision@2.6/load_svg/ball.svg);}#banner_wave_1 {    background: url(https://cdn.jsdelivr.net/gh/Fuukei/Sakurairo_Vision@2.6/basic/wave1.png) repeat-x;}#banner_wave_2 {    background: url(https://cdn.jsdelivr.net/gh/Fuukei/Sakurairo_Vision@2.6/basic/wave2.png) repeat-x;}]]></content>
    
    
      
      
    <summary type="html">:root{
    --theme-skin: #ff5f77;
    --theme-skin-matching:#ff91af;
    --infor_bar_bgcolor:rgba(255,255,255,0.8);
    --style_menu_selecti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/04/assets/alist/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AE%B9%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>http://example.com/2023/10/04/assets/alist/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AE%B9%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81/</id>
    <published>2023-10-04T10:36:42.128Z</published>
    <updated>2023-10-04T10:36:43.495Z</updated>
    
    <content type="html"><![CDATA[自定义内容里面的代码  --- 这一行记得不要加进去哦<!--延迟加载--><!--如果要写自定义内容建议都加到这个延迟加载的范围内--><div id="customize" style="display: none;">    <div><!--音乐播放器-->        <meting-js fixed="true" autoplay="false" theme="#409EFF" list-folded="true" auto="QQ音乐或者网易云的链接"></meting-js>        <br />        <center class="dibu">            <div style=" line-height: 20px;font-size: 9pt;font-weight: bold;">                <span>                    "                    <span style="color: rgb(13, 109, 252); font-weight: bold;" id="hitokoto">                        <a href="#" id="hitokoto_text">                            "人生最大的遗憾,就是在最无能为力的时候遇到一个想要保护一生的人."                        </a>                    </span> "                </span>                <p style="margin-left: 10rem;font-size: 8pt;">                    <small>                        —— Anwen's Cloud                    </small>                </p>            </div>            <div style="font-size: 13px; font-weight: bold;">                <span class="nav-item">                    <a class="nav-link" href="xxxxxxxxxx"                        target="_blank">                        <i class="fab fa-qq" style="color:#409EFF" aria-hidden="true">                        </i>                        QQ |                    </a>                </span>                <span class="nav-item">                    <a class="nav-link" href="mailto:xxxxx@foxmail.com" target="_blank">                        <i class="fa-duotone fa-envelope-open" style="color:#409EFF" aria-hidden="true">                        </i>                        邮箱 |                    </a>                </span>                <span class="nav-item">                    <a class="nav-link" href="xxxxxx" target="_blank">                        <i class="fas fa-edit" style="color:#409EFF" aria-hidden="true">                        </i>                        博客 |                    </a>                </span>                <span class="nav-item">                    <a class="nav-link" href="xxxxxxxx" target="_blank">                        <i class="fas fa-comment-lines" style="color:#409EFF;" aria-hidden="true">                        </i>                        留言 |                    </a>                </span>                <span class="nav-item">                    <a class="nav-link" href="xxxxxxx" target="_blank">                        <i class="fa fa-cloud-download" style="color:#409EFF;" aria-hidden="true">                        </i>                        云盘 |                    </a>                </span>                <!--后台入口-->                <span class="nav-item">                    <a class="nav-link" href="/@manage" target="_blank">                        <i class="fa-solid fa-folder-gear" style="color:#409EFF;" aria-hidden="true">                        </i>                        管理 |                    </a>                </span>                <!--版权，请尊重作者-->                <span class="nav-item">                    <a class="nav-link" href="https://github.com/Xhofe/alist" target="_blank">                        <i class="fa-solid fa-copyright" style="color:#409EFF;" aria-hidden="true">                        </i>                        Alist                    </a>                </span>                <br />            </div>        </center>        <br />        <br />    </div>    <!--一言API-->    <script src="https://v1.hitokoto.cn/?encode=js&select=%23hitokoto" defer></script><!--延迟加载范围到这里结束--></div><!--延迟加载配套使用JS--><script>    let interval = setInterval(() => {        if (document.querySelector(".footer")) {            document.querySelector("#customize").style.display = "";            clearInterval(interval);        }    }, 200);</script><!-- 渐变背景初始化,如果要使用渐变背景把下面的那一行注释去掉即可--><!-- 下面的几行都是渐变的一套,自定义头部内还有一个关联的自定义CSS --><!--<canvas id="canvas-basic"></canvas> --><script src="https://npm.elemecdn.com/granim@2.0.0/dist/granim.min.js"></script><script>var granimInstance = new Granim({    element: '#canvas-basic',    direction: 'left-right',    isPausedWhenNotInView: true,    states : {        "default-state": {            gradients: [                ['#a18cd1', '#fbc2eb'],                 ['#fff1eb', '#ace0f9'],                 ['#d4fc79', '#96e6a1'],                 ['#a1c4fd', '#c2e9fb'],                 ['#a8edea', '#fed6e3'],                 ['#9890e3', '#b1f4cf'],                 ['#a1c4fd', '#c2e9fb'],                 ['#fff1eb', '#ace0f9']                       ]        }    }});</script>]]></content>
    
    
      
      
    <summary type="html">
自定义内容里面的代码  --- 这一行记得不要加进去哦

&lt;!--延迟加载--&gt;
&lt;!--如果要写自定义内容建议都加到这个延迟加载的范围内--&gt;
&lt;div id=&quot;customize&quot; style=&quot;display: none;&quot;&gt;
    &lt;div&gt;
		&lt;!--音乐播放器-</summary>
      
    
    
    
    
  </entry>
  
</feed>
