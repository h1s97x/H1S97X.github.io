<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-24T06:12:05.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件管理</title>
    <link href="http://example.com/2023/12/24/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/12/24/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2023-12-24T06:12:05.000Z</published>
    <updated>2023-12-24T06:12:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相比大家都有过文件太多难以管理的经历，现在各大应用程序都有自己存储文件的习惯，QQ把下载的文件存储在QQ_FileRecv里，微信也按照每个用户与时间管理所有下载的文件。当然这是在windows操作系统下的文件管理。至于IOS系统、Linux系统等系统的文件管理则大不相同，为了改善这些差异所带来的麻烦，如何将这些系统之间的差异填补，就是我们所要考虑的问题了，比如说我有几个文件分散在手机Android系统、ipad IOS系统以及电脑Windows系统和Linux系统，那么有没有方法将它们统一管理呢？对于这种情况我没有什么解决的思路，在网络上也没找到类似的（或许应该有，需要关键词去搜索）如果正向走不动，把思路逆转过来如何？我们为什么要文件管理，不就是图个方便吗，既然如此，那就把所有的文件集中起来，放到服务器，需要的时候再从服务器下载，或者功能再强大一点，实现文件预览，直接在本地预览服务器的文件，就不用搞得文件到处都是了。这种方案我认为可行性很大，而且现有的一些开源软件已经有类似的实现。所需要做的工作就是：1.文件搜集：把散落在各个系统的文件找到并传输到服务器去。</p><p>2.搭建服务器，承载功能。</p><p>3.服务器开发上传和下载的接口。</p><p>那么首先我们先了解各操作系统的文件系统：</p><h2 id="Android系统"><a href="#Android系统" class="headerlink" title="Android系统"></a>Android系统</h2><p><a href="https://zarchiver.online/">ZArchiver APK For Android - Free Download</a></p><h2 id="IOS系统"><a href="#IOS系统" class="headerlink" title="IOS系统"></a>IOS系统</h2><p><a href="https://sspai.com/post/61729#!">是时候认识一下 iPad 的文件管理了 - 少数派 (sspai.com)</a></p><p><a href="https://www.zhihu.com/question/64610035">(9 封私信 &#x2F; 80 条消息) 苹果手机下载的东西都存到哪里了？ - 知乎 (zhihu.com)</a></p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="搭建服务器"><a href="#搭建服务器" class="headerlink" title="搭建服务器"></a>搭建服务器</h3><p>[本地alist网盘如何实现公网域名远程访问？——快解析内网端口映射外网-金万维快解析 (kuaijiexi.com)](<a href="https://www.kuaijiexi.com/helpDetail380.html#:~:text=1.%E5%9C%A8alist%E6%9C%AC%E5%9C%B0%E4%BB%BB%E6%84%8F%E4%B8%BB%E6%9C%BA%E7%94%B5%E8%84%91%E4%B8%8A%EF%BC%8C%E5%AE%89%E8%A3%85%E5%B9%B6%E7%99%BB%E5%BD%95%E5%BF%AB%E8%A7%A3%E6%9E%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%82">https://www.kuaijiexi.com/helpDetail380.html#:~:text=1.在alist本地任意主机电脑上，安装并登录快解析客户端。</a> 快解析版本无忧版、钻石版、旗舰版、星耀版账号均可实现内网穿透。,2.添加映射。 通过这一步添加映射设置，将alist内网访问地址变成域名让外网访问。)</p><p><a href="https://help.aliyun.com/document_detail/39834.html#h2--dns-2">有哪些方法测试域名解析生效_云解析DNS(DNS)-阿里云帮助中心 (aliyun.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/371579941">全网最详细：个人网站如何备案 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机引论</title>
    <link href="http://example.com/2023/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BC%95%E8%AE%BA/"/>
    <id>http://example.com/2023/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BC%95%E8%AE%BA/</id>
    <published>2023-12-24T02:27:38.000Z</published>
    <updated>2023-12-24T02:27:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书"><a href="#主要参考书" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>计算机科学引论（2021英文精编版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://booklibimg.kfzimg.com/data/book_lib_img_v2/isbn/1/4d6b/4d6b280d8a24f68c6e9698f45c83dd5c_0_1_300_300.jpg" alt="计算机科学引论（2021英文精编版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2020-09-01</td><td></td></tr><tr><td>出版社:</td><td>机械工业出版社</td><td></td></tr><tr><td>图书作者:</td><td>[美] 蒂莫西-J.奥利里 著</td><td></td></tr><tr><td>ISBN:</td><td>9787111663782</td><td></td></tr></tbody></table><h3 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h3><p><a href="https://www.cnblogs.com/wxyww/p/15740867.html">计算机科学引论笔记 - wxyww - 博客园 (cnblogs.com)</a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>Unit1 information technology,internet,and you<ul><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#people">PEOPLE</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#software">Software</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#hardware">Hardware</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E6%95%B0%E6%8D%AEdata"><strong>数据（Data）</strong></a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E8%BF%9E%E9%80%9A%E6%80%A7%E5%92%8C%E4%BA%92%E8%81%94%E7%BD%91">连通性和互联网</a></li></ul></li><li>Unit2 The Internet，the Web and Electronic commerce<ul><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#internet-and-web">Internet and web</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#internet-access-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">Internet Access 网络连接</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#web-utilities-%E7%BD%91%E9%A1%B5%E5%B7%A5%E5%85%B7%E5%8C%85">Web Utilities 网页工具包</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#communication-%E7%A4%BE%E4%BA%A4">Communication 社交</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#search-tools-%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7">Search Tools 搜索工具</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#electronic-commerce-%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1">Electronic commerce 电子商务</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E4%BA%91%E8%AE%A1%E7%AE%97cloud-computing">云计算（cloud computing）</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E7%89%A9%E8%81%94%E7%BD%91internet-of-thingsiot">物联网（Internet of Things，IoT）</a></li></ul></li><li>Unit3 Application Software<ul><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#applicationg-software">applicationg software</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F">通用程序</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E4%B8%93%E4%B8%9A%E7%A8%8B%E5%BA%8F">专业程序</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8mobile-apps">移动应用（Mobile APPS）</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E8%BD%AF%E4%BB%B6%E5%A5%97%E4%BB%B6software-suites">软件套件（Software Suites）</a></li></ul></li><li>Unit4 System Software<ul><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Foperating-system">操作系统（operating system）</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mobile-operating-system">移动操作系统 mobile operating system</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E6%A1%8C%E9%9D%A2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">桌面操作系统</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8Futilities">实用程序（Utilities）</a></li></ul></li><li>Unit5 System Unit<ul><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#system-unit-%E7%B3%BB%E7%BB%9F%E5%8D%95%E5%85%83">System Unit 系统单元</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#system-board-%E4%B8%BB%E6%9D%BF">System Board 主板</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#microprocessor-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8">Microprocessor 微处理器</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#memory-%E5%86%85%E5%AD%98">Memory 内存</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#expansion-slots-and-cards%E6%89%A9%E5%B1%95%E6%8F%92%E6%A7%BD%E4%B8%8E%E6%89%A9%E5%B1%95%E5%8D%A1">Expansion Slots and Cards扩展插槽与扩展卡</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#bus-lines-%E6%80%BB%E7%BA%BF">Bus Lines 总线</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#ports-%E7%AB%AF%E5%8F%A3">Ports 端口</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#power-supply-%E7%94%B5%E6%BA%90">power supply 电源</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#%E4%BF%A1%E5%8F%B7%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BC%96%E7%A0%81">信号转换与编码</a></li></ul></li><li>Unit 6 Input and output<ul><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#keyboard-%E9%94%AE%E7%9B%98">Keyboard 键盘</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#pointing-devices%E7%82%B9%E8%AE%BE%E5%A4%87">Pointing devices点设备</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#scanning-devices-%E6%89%AB%E6%8F%8F%E8%AE%BE%E5%A4%87">Scanning Devices 扫描设备</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#image-capturing-devices-%E5%9B%BE%E5%83%8F%E6%8D%95%E8%8E%B7%E8%AE%BE%E5%A4%87">image capturing devices 图像捕获设备</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#audio-input-devices%E9%9F%B3%E9%A2%91%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87">Audio-Input Devices音频输入设备</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#monitors-%E6%98%BE%E7%A4%BA%E5%99%A8">Monitors 显示器</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#printers-%E6%89%93%E5%8D%B0%E6%9C%BA">Printers 打印机</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#audio-and-video-devices%E9%9F%B3%E9%A2%91%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87">Audio and Video Devices音频输出设备</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#combination-input-and-output-devices%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BA%8C%E5%90%88%E4%B8%80%E8%AE%BE%E5%A4%87"><strong>Combination</strong> Input and Output Devices输入输出二合一设备</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#ergonomics-%E4%BA%BA%E4%BD%93%E5%B7%A5%E7%A8%8B%E5%AD%A6">Ergonomics 人体工程学</a></li></ul></li><li>Unit7 Secondary Storage<ul><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#storage-%E5%82%A8%E5%AD%98">Storage 储存</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#solid-stage-storage-%E5%9B%BA%E6%80%81%E5%AD%98%E5%82%A8">Solid Stage Storage 固态存储</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#hard-disks-%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98">Hard Disks 机械硬盘</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#optical-disks-%E5%85%89%E7%9B%98">Optical Disks 光盘</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#cloud-storage%E4%BA%91%E5%AD%98%E5%82%A8">Cloud Storage云存储</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#mass-storage-devices-%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87">Mass Storage Devices 大容量存储设备</a></li></ul></li><li>Unit8 Communication and Networks<ul><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#communication-%E9%80%9A%E4%BF%A1">communication 通信</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#communication-channels-%E4%BF%A1%E9%81%93">communication channels 信道</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#connection-device-%E8%BF%9E%E6%8E%A5%E8%AE%BE%E5%A4%87">Connection device 连接设备</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#data-transmission-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93">Data Transmission 数据传输</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#networks-%E7%BD%91%E7%BB%9C">Networks 网络</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#network-types-%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B">Network Types 网络类型</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#network-architecture-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84">Network Architecture 网络架构</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#organizational-network-%E7%BB%84%E7%BB%87%E7%BD%91%E7%BB%9C">Organizational Network 组织网络</a></li><li><a href="https://www.cnblogs.com/wxyww/p/15740867.html#network-security-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8">Network Security 网络安全</a></li></ul></li></ul><h2 id="Unit1-information-technology-internet-and-you"><a href="#Unit1-information-technology-internet-and-you" class="headerlink" title="Unit1 information technology,internet,and you"></a>Unit1 information technology,internet,and you</h2><p>**个人电脑(personal computer)<strong>是一种</strong>信息系统(information system)**。信息系统包括以下几个部分</p><ul><li><strong>人(people)</strong> 是信息系统中至关重要的一个部分，信息系统的目的是让想你这样的**最终用户(end users)**更高效率</li><li>**程序(procedures)**是使用软件、硬件和数据的时候要遵循的指南。他们通常由计算机专业人员编写。</li><li>**软件(Software or programs)**提供一步一步的指令(instructions)来控制计算机把数据(data)转换成信息(information)</li><li>**硬件(hardware)**由物理设备组成，它由软件控制把数据(data)加工成信息(information)</li><li>**数据(data)<strong>是未加工的信息，包括文本、数字、图片、声音。</strong>信息(information)**是被电脑加工过的数据(data)</li><li>**互联网(internet)**使得计算机可以相互连通并分享信息</li></ul><h3 id="PEOPLE"><a href="#PEOPLE" class="headerlink" title="PEOPLE"></a>PEOPLE</h3><p>人是信息系统里最重要的</p><h3 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h3><p>软件Software包括系统软件和应用软件</p><ul><li><strong>系统软件（System software）</strong>使得应用软件能够与计算机硬件进行交互。包括<strong>操作系统（operating system）</strong>和<strong>实用程序（Utilities）</strong>。操作系统协调资源，提供接口并运行应用程序。包括<strong>嵌入式（embedded）操作系统（RTOS）</strong>，<strong>独立（stand-alone）操作系统</strong>和<strong>网络操作系统（network）</strong>实用程序执行特定的任务来管理电脑资源</li><li><strong>应用软件（Application Software）</strong> 包括<strong>通用应用软件（general-purpose）</strong>，<strong>专用软件（specialized）</strong>和<strong>移动应用软件（mobile application）</strong>通用应用软件被广泛应用于各种职业领域，专业应用软件更多的关注特定学科和职业，移动应用是为移动设备设计的应用</li></ul><h3 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h3><ul><li><p>计算机的种类，<strong>超级计算机（supercomputer）</strong>，<strong>大型计算机（mainframe）</strong>，<strong>中档计算机（服务器）（midrange（server））</strong>，和<strong>个人计算机（personal computer）</strong>是四种计算机类型。个人计算机包括<strong>台式机（desktop）</strong>，<strong>笔记本电脑（laptop）</strong>，<strong>平板电脑（ablet）</strong>，<strong>智能手机（smartphone）</strong>，<strong>可穿戴计算机（wearable）</strong></p></li><li><p>个人电脑硬件，电脑硬件有四种。</p><p>（1）<strong>系统单元（system unit）</strong>包含一些微电子电路，包括<strong>微处理器（microprocessors）</strong>和<strong>存储器（memory）</strong>。<strong>随机存取存储器（Random-access memory，RAM）</strong>用来保存正在被处理的程序和数据。</p><p>（2）输入和输出设备</p><p>（3）<strong>辅助存储器（Secondary storage）</strong>用来保存数据和程序，一般包括<strong>硬盘（hard disk）</strong>，<strong>固态存储（solid-state storage）</strong>，和<strong>光盘（optical discs）</strong>（CD，DVD，Blu-ray）</p><p>（4）<strong>通信设备（Communication devices）</strong>使得计算机之间可以相互通信。<strong>调制解调器（Modems）</strong>可以修改音频、视频、和其他类型的数据使得他们可以在互联网上传输。</p></li></ul><h3 id="数据（Data）"><a href="#数据（Data）" class="headerlink" title="数据（Data）"></a>数据（Data）</h3><p>电脑的文件类型包括：</p><p>（1）<strong>文本文件（Document files）</strong></p><p>（2）<strong>工作表文件（worksheet）</strong></p><p>（3）<strong>数据库文件（Database files）</strong></p><p>（4）<strong>演示文件（Presentation files）</strong></p><h3 id="连通性和互联网"><a href="#连通性和互联网" class="headerlink" title="连通性和互联网"></a>连通性和互联网</h3><p>Internet是世界上最大的电脑互联网，web提供了一个访问互联网上可用资源的接口。</p><ul><li><strong>云计算（cloud computing）</strong> 使用互联网和web网页来讲用户电脑上的一些活动转移到网络上的电脑上</li><li><strong>无限革命（wireless revolution）</strong>改变了我们交流和使用电脑科技的方式，无线设备包括平板设备（tablet），手机和手表</li><li><strong>物联网（Internet of Things，IoT）</strong>是互联网的进一步发展，它使得嵌入（embedded）了电子设备的日常物品可以在网络上接受和发送数据。</li></ul><h2 id="Unit2-The-Internet，the-Web-and-Electronic-commerce"><a href="#Unit2-The-Internet，the-Web-and-Electronic-commerce" class="headerlink" title="Unit2 The Internet，the Web and Electronic commerce"></a>Unit2 The Internet，the Web and Electronic commerce</h2><h3 id="Internet-and-web"><a href="#Internet-and-web" class="headerlink" title="Internet and web"></a>Internet and web</h3><ul><li><p>因特网（internet）于1969年和<strong>阿帕网（arpanet）</strong>一起推出，互联网由实际的物理网络组成</p></li><li><p><strong>万维网（Web）</strong> 于1991年诞生，<strong>the web（world wide web，WWW）</strong>提供一个网络资源的多媒体接口。一共有四代：<strong>Web1.0</strong>（链接现存信息，搜索引擎），<strong>Web2.0</strong>（包括动态内容和社会信息，社会媒体网站）<strong>Web3.0</strong>（深化数据之间的联系）<strong>Web4.0</strong>（链接数据和物理生活的未来产品）</p></li><li><p>常见用途</p><p>（1）交流—最流行的互联网活动</p><p>（2）购物—增长最快的互联网活动</p><p>（3）搜索—寻找图书馆和本地或者本国或者国际新闻</p><p>（4）教育—<strong>电子学习（e-learning）</strong>和网络课程</p><p>（5）网络娱乐—电影，新闻，音乐和视频游戏（video games）</p></li></ul><h3 id="Internet-Access-网络连接"><a href="#Internet-Access-网络连接" class="headerlink" title="Internet Access 网络连接"></a>Internet Access 网络连接</h3><ul><li><p><strong>供应商（Internet service providers）</strong>提供一个连接互联网的途径。连接技术包括<strong>数字用户电路（DSL）</strong>，<strong>电缆调制解调器（cable modems）</strong>，和<strong>无线调制解调（wireless modems）</strong></p></li><li><p><strong>浏览器（Browsers）</strong>提供了对web的访问，相关术语：</p><p>（1）<strong>URLs</strong>—网络资源的地址，有**域名(domain name)<strong>和</strong>协议(protocol)**两个部分,<strong>顶级域名(top-level domain name，TLD)<strong>或者</strong>网络后缀（web suffix）</strong>确定了该网页的类型</p><p>（2）HTML—一些展示王爷的命令语言，<strong>超链接（hyperlinks）</strong></p></li></ul><p>提供<strong>交互式（interactive）动画（animated）</strong>网站的技术包括<strong>JavaScript</strong>（在用户的计算机上执行来引发互动功能），<strong>PHP</strong>（在HTML中执行来触发交互功能和在线表格）<strong>CSS</strong>（控制网页的外观）</p><h3 id="Web-Utilities-网页工具包"><a href="#Web-Utilities-网页工具包" class="headerlink" title="Web Utilities 网页工具包"></a>Web Utilities 网页工具包</h3><p><strong>网页工具包（Web Utilities）</strong>是专门的工具集，使得使用网络和网页更加的便捷和安全。</p><ul><li><p><strong>过滤器（Filters）</strong>被家长和组织用来屏蔽某些网站，并监控互联网和 网络的使用情况</p></li><li><p><strong>文件传输工具（File Transfer Utilities）</strong>可以将文件下载或上传到你的计算机上。有三种类型</p><p>（1）<strong>FTP（File Transfer Protocol）</strong>和<strong>SFTP（secure file tranfer protocol）</strong>使你在网络上高效的传输文件</p><p>（2）<strong>比特流（BitTorrent）</strong>在许多不同的电脑之间分发传输任务</p><p>（3）<strong>基于web的文件传输服务（Web-based file transfer services）</strong>利用web浏览器来上传和下载文件</p></li><li><p><strong>网络安全套件（Internet Security Suite）</strong>是一组实用程序的集合，用来保护隐私和互联网安全。</p></li></ul><h3 id="Communication-社交"><a href="#Communication-社交" class="headerlink" title="Communication 社交"></a>Communication 社交</h3><ul><li><p><strong>社交网络（Social Networking）</strong>。社交网站的功能包括：<strong>配置文件（profiles）</strong>，<strong>页面（pages）</strong>，<strong>群组（groups）</strong>，<strong>好友（friends）</strong>，<strong>新闻（news feeds）</strong>，和<strong>共享设置（share setting）</strong>。两个著名社交网站<strong>领英（linkedin）</strong>和<strong>脸书（facebook）</strong>。</p></li><li><p>博客，微博，播客（Podcasts），和维基</p><p>（1）<strong>博客（blogs）</strong></p><p>（2）<strong>微博（microblogs）</strong>使用短句子，推特每个推文（tweet）允许280个字符，<strong>Ins</strong>主要用于分享图片和视频。</p><p>（3）<strong>播客（Podcasts）</strong>是通过互联网传播的音频节目</p><p>（4）<strong>维基（wiki）</strong>是一个允许访问者使用浏览器添加、编辑或者删除网站内容的网站。**维基百科(wikipedic)**是最受欢迎的维基之一</p></li><li><p><strong>messaging</strong>，除了email外还有两种消息传递系统</p><p>（1）<strong>短信（Text messaging）</strong>也叫做<strong>texting</strong>或者<strong>SMS（short massage service）</strong>。一般不超过160个字符</p><p>（2）<strong>即时消息（Instant messaging，IM）</strong>。支持实时通信</p></li><li><p>E-mail 有两种电子邮件系统</p><p>（1）<strong>基于用户的电子邮件系统（Client-based e-mail system）</strong>使用安装在用户机上的电子邮件客户系统。</p><p>（2）<strong>基于网络的电子邮件系统（Web-base e-mail system）</strong>使用在服务器上的客户端。也被叫做<strong>webmail</strong></p><ul><li>通常的电子邮件有三个基本元素：<strong>头部（header）</strong>包括<strong>地址（address）</strong>，<strong>主题（subject）</strong>，和<strong>附件（attachent）</strong>。<strong>消息内容（message）</strong>和<strong>签名（signature）</strong>。</li><li><strong>垃圾邮件（Spam）</strong>，<strong>垃圾邮件拦截器（Spam bolckers，Spam filters）</strong></li></ul></li></ul><h3 id="Search-Tools-搜索工具"><a href="#Search-Tools-搜索工具" class="headerlink" title="Search Tools 搜索工具"></a>Search Tools 搜索工具</h3><ul><li><strong>搜索服务（search services）</strong>运营网站来帮助你得到你想要的信息。</li><li><strong>爬虫（spiders）</strong>是一种不断的寻找信息并更新数据库的特殊程序</li><li><strong>搜索引擎（search engines）</strong>可以帮助你找到特定的信息。使用关键词和短句来搜索</li><li><strong>专业搜索引擎（search engines）</strong>是一种专注于特定主题网站的搜索引擎</li><li><strong>内容评估（conten evaluation）</strong>，网络信息辨别真伪要注意检查<strong>权威性（authority）</strong>，<strong>准确性（accuracy）</strong>，<strong>客观性（objectivity）</strong>和<strong>时效性（currency）</strong></li></ul><h3 id="Electronic-commerce-电子商务"><a href="#Electronic-commerce-电子商务" class="headerlink" title="Electronic commerce 电子商务"></a>Electronic commerce 电子商务</h3><p><strong>电子商务（Electronic commerce，E-Commerce）</strong>是指通过互联网进行交易。有三种类型</p><ul><li><p>**企业对消费者（business to consumer,B2C)**是增长最快的电子商务类型。涉及向公众或最终用户销售产品或服务。有三种形式</p><p>（1）网上银行(online banking)</p><p>（2）金融交易(financial trading)</p><p>（3）网络购物(shopping)</p></li><li><p><strong>消费者对消费者(consumer to consumer,C2C)</strong></p><p>是最近的趋势。个人向个人出售。以<strong>网络拍卖（Web auctions）</strong>的形式，与传统拍卖类似，不过买卖双方不会见面。</p></li><li><p><strong>企业对企业（business to business，B2B）</strong></p><p>产品和服务从一个企业销售到另一个起义，主要是制造商(manufacturer)之间的关系</p></li></ul><p>电子商务的<strong>安全性（security）</strong>，两个挑战是</p><ul><li>安全保密。两种交易形式是<strong>信用卡（credit cards）</strong>和<strong>数字现金（digital cash）</strong></li><li>便捷性。提供便捷的方式获取信息</li></ul><h3 id="云计算（cloud-computing）"><a href="#云计算（cloud-computing）" class="headerlink" title="云计算（cloud computing）"></a>云计算（cloud computing）</h3><p>使用互联网和web网页来讲用户电脑上的一些活动转移到网络上的电脑上</p><p>使最终用户无需拥有、维护和存储软件程序和数据。</p><p><strong>云计算（cloud computing）</strong>有三个基本组成部分：</p><ul><li><strong>客户（clents）</strong></li><li>网络</li><li><strong>服务提供商（service providers）</strong></li></ul><h3 id="物联网（Internet-of-Things，IoT）"><a href="#物联网（Internet-of-Things，IoT）" class="headerlink" title="物联网（Internet of Things，IoT）"></a>物联网（Internet of Things，IoT）</h3><p>物联网是互联网的进一步发展，它使得嵌入的电子设备的物体可以发送和接收数据。如智能手机，可穿戴设备，甚至咖啡壶。使用web3.0程序将设备与应用程序同步</p><h2 id="Unit3-Application-Software"><a href="#Unit3-Application-Software" class="headerlink" title="Unit3 Application Software"></a>Unit3 Application Software</h2><h3 id="applicationg-software"><a href="#applicationg-software" class="headerlink" title="applicationg software"></a>applicationg software</h3><p>应用程序有三种类型<strong>通用应用（general pupose）</strong>，<strong>专业应用（specialized）</strong>，<strong>移动应用（mobile）</strong></p><p><strong>用户页面（user interface）</strong>也叫<strong>图形用户界面（Graphical User Interface，GUI）</strong>，使用户可以与程序交互。</p><p><strong>图标（icons）</strong>用户可以用鼠标点击图标来完成动作。</p><p><strong>鼠标箭头（pointer）</strong>在屏幕上显示，通过鼠标来操作</p><p>(1)传统的GUI系统含有三个板块</p><ul><li><strong>菜单（Menus）</strong>展示显示在屏幕顶部<strong>菜单栏（menus bar）</strong>中的命令</li><li><strong>工具栏（toolbars）</strong>用来存放一些**按钮(buttons)**用来快捷的完成常用的一些命令。</li><li><strong>对话框（dialog boxes）</strong>提供附加的信息并且请求用户的输入。</li></ul><p>(2) <strong>功能区GUI（Ribbon GUI）</strong>使用户能够更轻松地查找和使用应用程序的所有功能。它包括</p><ul><li><strong>功能区（Ribbon）</strong>将一些菜单和工具栏里的命令放到选项卡集合里</li><li><strong>选项卡（Tabs）</strong>将功能区分成几类，每个选项卡代表<strong>一组（groups）</strong>相关的选项。</li><li><strong>下拉菜单（Contextual tabs）</strong>只有当该选项被选中时才会展示</li><li><strong>预览（Galleries）</strong>使用户可以在选择选项之前预览他的效果</li></ul><p>(3) 大多数应用程序提供</p><ul><li>拼写检查（spell check）</li><li>校准（alignment）</li><li>字体和字体大小（font and font size）</li><li>桌面（tables）</li><li>报告（reports）</li></ul><h3 id="通用程序"><a href="#通用程序" class="headerlink" title="通用程序"></a>通用程序</h3><p>通用程序包括<strong>文本处理器（Word processors）</strong>，<strong>表格（Spreadsheets）</strong>，<strong>演示文档（Presentation programs）</strong>，<strong>数据库管理系统（Database management systems）</strong></p><ul><li><strong>文本处理器（Word processors）</strong> 用于创建<strong>文档（documents）</strong>的最灵活和广泛使用的软件工具之一，PC用户最早使用的软件之一，微软word是最常用的文字处理程序。文字处理程序有：Microsoft word，Apple Pages，Google Docs，OpenOffice Writer</li><li><strong>表格（Spreadsheet Programs）</strong>，组织、分析和绘制数值数据。</li><li><strong>演示文档（Presentation programs）</strong>，创建有趣和专业的演示文档</li><li><strong>数据库管理系统（Database management systems）</strong>，<strong>数据库（database）</strong>是一些相关数据的集合。数据库管理程序也叫<strong>Database Manager</strong>是建立数据库的程序。</li></ul><h3 id="专业程序"><a href="#专业程序" class="headerlink" title="专业程序"></a>专业程序</h3><p>专业程序专注于特定的学科和职业计划。包括<strong>图形处理程序（graphics programs）</strong>和<strong>网页制作工具（authoring programs）</strong>和<strong>电视游戏设计软件</strong>。</p><ul><li><p>图形处理程序是用于图形艺术的专用程序。</p><p>（1）<strong>视频处理器（video editors）</strong></p><p>（2）<strong>图片处理器（image editors，photo editors）</strong></p><p>（3）<strong>插画程序（Illustration Programs）</strong>创造和编辑矢量图</p><p>（4）<strong>页面排版程序（Desktop Publishing Programs，Page Layout Programs）</strong>，混合图片和文字制作出版物。</p></li><li><p>网页制作工具</p><p>（1）<strong>博客（blog）</strong>是在线的日记活评论</p><p>（2）网页制作程序创造常见的网站，编辑页面和HTML。具有<strong>所见即所得的特性（WYSIWYG，what you see is what you get）</strong></p></li><li><p>电视游戏设计软件引导用户完成游戏的设计</p></li></ul><h3 id="移动应用（Mobile-APPS）"><a href="#移动应用（Mobile-APPS）" class="headerlink" title="移动应用（Mobile APPS）"></a>移动应用（Mobile APPS）</h3><p>移动应用是一种平板或者手机上附加（Add-on）的应用程序。</p><p><strong>角色扮演类游戏（role playing game，RPG）</strong></p><p><strong>应用商店（APP stores）</strong>提供移动应用的下载。</p><h3 id="软件套件（Software-Suites）"><a href="#软件套件（Software-Suites）" class="headerlink" title="软件套件（Software Suites）"></a>软件套件（Software Suites）</h3><p>软件套件是一些单个程序的集合，捆绑在一起进行销售有四种。</p><ul><li><strong>办公套件（Office suites，office software suite ，productivity suites ）</strong>通常被用于工作情境。通常包括文档处理程序，表格处理程序，演示文档。</li><li><strong>在线套件（Cloud suites ， online office suites）</strong>是一些存放在互联网服务器上的套件，通过互联网进行访问。优点：轻松协作。缺点：依赖于服务器，所以要及时备份。</li><li><strong>专业套件（Specialized suites ）</strong>专注于专业程序。</li><li><strong>实用套件（Utility suites）</strong>被设计用来使计算更加方便和安全。</li></ul><h2 id="Unit4-System-Software"><a href="#Unit4-System-Software" class="headerlink" title="Unit4 System Software"></a>Unit4 System Software</h2><p><strong>系统软件（System Software ）</strong> 在电脑硬件与用户应用软件之间工作，来实现技术细节。</p><p>有四种类型<strong>操作系统（Operating systems）</strong>，<strong>实用程序（Utilities）</strong>， <strong>设备驱动程序（Device drivers）</strong>， <strong>编译器（Language translators）</strong></p><p>编译器是把程序员写的高级程序语言转化成电脑可以识别的机器语言。</p><h3 id="操作系统（operating-system）"><a href="#操作系统（operating-system）" class="headerlink" title="操作系统（operating system）"></a>操作系统（operating system）</h3><p>操作系统也叫<strong>软件环境（software environment）</strong>或者<strong>软件平台（software platforms）</strong></p><ul><li><p>作用：</p><p>（1）管理资源</p><p>（2）提供用户界面（graphical user interface，GUI）</p><p>（3）运行应用程序，<strong>多任务处理（Multitasking）</strong>，使得计算机可以在应用程序之间快速切换。当前运行的程序成为<strong>前台程序（foreground）</strong>，其他正在运行的程序成为<strong>后台程序（background）</strong></p></li><li><p>特点：</p><p>（1）与应用程序相同的特点：有图标（icons），鼠标指针（pointer），窗口（window），菜单（menus），标签（tabs），对话框（dialog boxes），帮助（help），手势控制（gesture control）。</p><p><strong>手势控制（gesture control）</strong>是指通过手指移动来控制操作的能力：即滑动、捏合。</p><p>（2）独特的特点是可以<strong>启动（boot）</strong>计算机。<strong>热启动（warm boot）</strong>是在计算机已经打开的情况下不关闭计算机，重新启动。<strong>冷启动（cold boot）</strong>是在计算机关闭的情况下启动计算机。</p><p>（3）大多数操作系统将数据和程序存储在<strong>系统文件（system file）</strong>和<strong>文件夹（folders）</strong>中。</p></li><li><p>种类：</p><p>（1）<strong>嵌入式操作系统（embedded OS）</strong>，如智能手机，智能手表，视频游戏系统</p><p>（2）<strong>独立操作系统（Stand-alone OS）</strong>也叫<strong>桌面操作系统（desktop OS）</strong>，控制单一的台式机</p><p>（3）<strong>网络操作系统（Network operating systems ，NOS）</strong>，控制协调联网计算机，操作系统储存在<strong>网络服务器（network server）</strong>上</p></li></ul><h3 id="移动操作系统-mobile-operating-system"><a href="#移动操作系统-mobile-operating-system" class="headerlink" title="移动操作系统 mobile operating system"></a>移动操作系统 mobile operating system</h3><p>没有那么复杂，更适合无线技术。常见的移动操作系统是<strong>安卓（Android）</strong>、<strong>苹果（IOS）</strong>和<strong>微软windows（windows Phone）</strong></p><h3 id="桌面操作系统"><a href="#桌面操作系统" class="headerlink" title="桌面操作系统"></a>桌面操作系统</h3><p>一般用于个人电脑</p><ul><li><p>windows 使用最广泛的桌面操作系统，<strong>windows 10</strong>集成了桌面和移动设备，可以在所有的windows设备上运行。</p></li><li><p><strong>macOS</strong>，专为苹果电脑设计，只能在苹果电脑上运行。功能强大，易于使用</p><p><strong>macOS X</strong>是苹果电脑使用最广泛的操作系统</p><p>最新的两款系统是<strong>macOS high sierra</strong>和<strong>macOS mojave</strong></p></li><li><p>UNIX操作系统，最初用于小型计算机，现在用于网络环境。常用于大型计算机（mainframe computers）和网络服务器。有非常多的版本。</p></li><li><p>LINUX是UNIX的一个扩展。代码开源。谷歌的<strong>chrome OS</strong>就基于linux设计。</p></li><li><p><strong>虚拟化（Virtualization）</strong>通过运行<strong>虚拟化软件（virtualization software）</strong>支持独立运行的多个操作系统。</p><ul><li>每个操作系统称为一个<strong>虚拟机（virtual machine）</strong>。</li><li><strong>主机操作系统（Host operating system）</strong> 是物理机原本的操作系统</li><li><strong>客户机操作系统（Guest operating system）</strong> 是指虚拟机的操作系统</li><li>Parallels就是一个虚拟化软件，可以在macOS X中运行windows</li></ul></li></ul><h3 id="实用程序（Utilities）"><a href="#实用程序（Utilities）" class="headerlink" title="实用程序（Utilities）"></a>实用程序（Utilities）</h3><p>是一种专注于使计算更加便捷的程序。</p><p><strong>操作系统实用程序（Operating System Utilities）</strong></p><ul><li><strong>故障识别程序（Troubleshooting）</strong> 也叫<strong>诊断程序（diagnostic program）</strong>用来识别并纠正问题</li><li><strong>防病毒程序（Antivirus program）</strong>用来保护计算机免受病毒侵害。</li><li><strong>备份程序（Backup program）</strong>创造文件的副本，当源文件损坏的使用后来重建文件</li><li><strong>搜索程序（search program）</strong>提供了一种快捷的方式来搜索或者检查整个计算机系统</li><li><strong>存储管理程序（Storage management program ）</strong>通过列出可以消除的文件或程序来帮助解决存储空间不足的问题</li><li><strong>虚拟助手（Virtual Assistants）</strong>通过文本或者语音接受命令，可以直接与平板，电脑，手机交互</li></ul><p><strong>实用程序套件（Utility Suites）</strong>将多个实用程序组合到一个包里。</p><h2 id="Unit5-System-Unit"><a href="#Unit5-System-Unit" class="headerlink" title="Unit5 System Unit"></a>Unit5 System Unit</h2><h3 id="System-Unit-系统单元"><a href="#System-Unit-系统单元" class="headerlink" title="System Unit 系统单元"></a>System Unit 系统单元</h3><p><strong>系统单元（System Unit）</strong>也叫<strong>系统机箱（System chassis）</strong>是一个容纳大多数组成电脑系统的<strong>电子元件（electronic components）</strong>的容器。</p><p>常见的<strong>个人计算机（personal computers）</strong>类型：</p><ul><li><p>智能手机（Smartphones）也叫手持计算机系统（hand-held computer systems）整个计算机系统都保存在移动设备内部。</p></li><li><p>平板电脑（Tablet）像是一个大号手机</p></li><li><p>笔记本（laptop）装有电子元件，辅助设备和输入设备。也叫做<strong>notebook computer</strong></p><p>（1）<strong>二合一笔记本电脑（Two-in-one laptops）</strong> 可以用作笔记本或者平板电脑</p><p>（2）游戏本（Gaming）有高端显卡和快速处理器</p><p>（3）<strong>超极本（Ultrabook</strong>）或<strong>超便携式笔记本（Ultraportables）</strong>或者<strong>轻薄本（mini notebook）</strong>是一种便携式笔记本，更轻更薄，有更长的续航。</p></li><li><p>台式机（desktop）装有电子元件和外存。系统单元被放置在<strong>塔式单元（tower unit，tower computer）</strong>里。**一体机（all-in-one)**整合了显示器和系统单元。</p></li><li><p><strong>可穿戴设备（wearable）</strong>包含嵌入式电脑。</p></li></ul><p>各种智能设备都有类似的组成：<strong>主板（system boards）</strong>，<strong>微处理器（Microprocessors）</strong>，<strong>内存（Memory）</strong></p><h3 id="System-Board-主板"><a href="#System-Board-主板" class="headerlink" title="System Board 主板"></a>System Board 主板</h3><p><strong>主板（System Board，main board，motherboarrd）</strong>控制整个计算机组件的交流。</p><p>所有的组件都连接到系统主板。</p><p>主板充当数据路径和流量监视器，允许组件之间相互通信。</p><p>系统主板包含许多组件</p><ul><li><strong>插口（Sockets）</strong>芯片的连接点</li><li><strong>芯片（chips，silicon chip,semiconductor,integrated circuit）</strong>包含许多电路，这些电路蚀刻在硅和其他材料层的小晶圆上。芯片安装在载体包上（carrier packages）</li><li><strong>插槽（Slots）</strong>提供特定的元件与电路板的连接点。</li><li><strong>总线（Bus lines）</strong>连接电路板上的线路来支持通信</li></ul><h3 id="Microprocessor-微处理器"><a href="#Microprocessor-微处理器" class="headerlink" title="Microprocessor 微处理器"></a>Microprocessor 微处理器</h3><p><strong>中央处理器（Central Processing Unit，CPU）</strong>位于于<strong>微处理器（microprocessors）</strong>芯片上，有两个组件：<strong>控制单元（control unit）</strong>和<strong>算数逻辑单元（the arithmetic-logic unit，ALU）</strong></p><ul><li><strong>控制单元（control unit）</strong>：告诉计算机如何去执行程序指令</li><li><strong>算数逻辑单元（ALU）</strong>：进行算术运算（Arithmetic operation）和逻辑运算（Logical operation）</li></ul><p>微处理器芯片的指标：<strong>位（word）</strong>是指计算机的位数。8位形成一个自己，32位计算机一次可以访问4个字节，64位一次方位8个字节。算力（clock speed）CPU在一秒内可以获取和处理数据和指令的次数。</p><p><strong>多核处理器（Multicore Processors）</strong>有两个或者更多的独立核心</p><p><strong>并行处理（Parallel Processing）</strong>计算机将任务分为可在每个内核里分别运行。</p><p><strong>专用处理器（Specialty processors，coprocessors）</strong>用来提高特定的计算操作。如<strong>显卡（Graphics Processing Unit ，GPU）</strong></p><h3 id="Memory-内存"><a href="#Memory-内存" class="headerlink" title="Memory 内存"></a>Memory 内存</h3><p>数据、指令和信息的保持区域，有三种。</p><ul><li><p><strong>随机存储设备（Random-Access memory，RAM）</strong>，用来保存CPU正在处理的程序和数据</p><p>断电之后信息会丢失。</p><p>（1）<strong>高速缓存（Cache memory）</strong>对于经常使用的信息放在特定的高速区域，来提高处理性能</p><p>（2）<strong>双列直插式内存模块（dual in-line memory module，DIMM）</strong>，用来扩展内容</p><p>（3）<strong>虚拟内存（Virtual memory）</strong>把程序划分开，分别放在储存器和内存里，使系统可以运行非常大的的程序。</p></li><li><p><strong>只读存储器（Read only Memory，ROM）</strong>，制造商提前把内容烧录进去，用户无法更改。</p><p>用于特殊指令，例如启动计算机，访问内存和处理键盘输入。</p></li><li><p><strong>闪存（Flash Memory）</strong>可以及时更新存储的信息，并且断电的时候信息不会丢失。</p></li></ul><h3 id="Expansion-Slots-and-Cards"><a href="#Expansion-Slots-and-Cards" class="headerlink" title="Expansion Slots and Cards"></a>Expansion Slots and Cards</h3><p><strong>扩展插槽（Expansion slots）</strong>用于插入扩展卡。</p><p>常见的扩展卡：</p><ul><li><strong>显卡（Graphics cards）</strong>，提供高质量的3D图形渲染</li><li><strong>网卡（Network interface cards，NIC）</strong>，使设备可以连接网络。</li><li><strong>无线网卡（Wireless network cards）</strong>使黑背可以连接无线网</li><li>SD卡（用于移动设备的扩展）</li></ul><h3 id="Bus-Lines-总线"><a href="#Bus-Lines-总线" class="headerlink" title="Bus Lines 总线"></a>Bus Lines 总线</h3><p><strong>总线（Bus Lines）</strong>连接主板上各种各样的系统单元。</p><p><strong>总线宽度（Bus width）</strong>表示可以总线可以同时传输的位数。</p><p>总线的架构和设计与计算机的速度和功耗息息相关。</p><p>每台计算机都有两种总线</p><ul><li><p><strong>系统总线（System bus）</strong>连接CPU和内存</p></li><li><p><strong>扩展总线（Expansion bus）</strong>连接CPU和其他系统单元以及主板上的扩展插槽。</p><p>（1）<strong>通用串行总线（Universal Serial Bus，USB）</strong>最常用。</p><p>（2）<strong>FireWire总线，</strong>与USB类似，主要用于连接音频和视频设备。</p><p>（3）<strong>PCI Express（PCIe）</strong>，广泛使用于功能强大的计算机。为每个连接的设备提供一条专用路径。（其他的总线为各个设备共享同一条路径）</p></li></ul><h3 id="Ports-端口"><a href="#Ports-端口" class="headerlink" title="Ports 端口"></a>Ports 端口</h3><p>端口是把外界设备连接到系统单元上的插口，用两种类型：标准端口和专用端口</p><ul><li><p>标准插口（Standard Ports）</p><p>（1）USB将多个设备连接到系统单元</p><p>（2）<strong>以太网（Ethernet）</strong>网络标准，，高速网络端口。使用户可以连接网络</p><p>（3）<strong>高清多媒体接口（High Definition Multimedia Interface，HDMI）</strong>提供高清的音视频</p><p>（4）<strong>雷电接口（Thunderbolt）</strong>提供高速连接，一个端口可以连接七个独立的设备。</p></li><li><p><strong>专用接口（Specialized Ports）</strong></p><p>（1）<strong>迷你显示端口（mini displayPort，MiniDp，mDP）</strong>连接大显示器</p><p>（2）<strong>VGA和DVI</strong>，与模拟信号和数字信号显示器的连接</p><p>（3）<strong>FireWire端口</strong>，连接摄录一体机和储存谁被</p></li></ul><p><strong>电缆（Cables）</strong>用于将设备与端口连接起来</p><h3 id="power-supply-电源"><a href="#power-supply-电源" class="headerlink" title="power supply 电源"></a>power supply 电源</h3><p>电脑需要<strong>直流电（DC）</strong>，</p><p>台式机的系统单元上有一个<strong>电源转换单元（power supply unit）</strong></p><p>笔记本有<strong>交流适配器（AC adapters）</strong></p><p>手机和平板使用内置的交流适配器</p><p>手机还可以使用<strong>无线充电（charging platforms）</strong></p><h3 id="信号转换与编码"><a href="#信号转换与编码" class="headerlink" title="信号转换与编码"></a>信号转换与编码</h3><p>计算机只能识别<strong>数字信号（Digital signals）</strong></p><p><strong>模拟信号（Analog signals）</strong>是连续的由声音创建的。</p><p>计算机处理之前必须把模拟信号转化为数字信号</p><ul><li><p>数字化表示</p><p><strong>二进制（binary system）</strong>系统仅由两种数字组成。一个字节有8位<strong>，十六进制系统（Hexadecimal system，hex）</strong>用十六进制数来表示二进制数。</p></li><li><p>字符编码</p><p>为每个字符分配唯一的编码</p><p>（1）<strong>ASCII</strong>，曾经被用于个人电脑</p><p>（2）<strong>EBCDIC</strong>，曾经被用于大型机</p><p>（3）<strong>Unicode</strong>，16位编码，应用最广泛的标准。</p></li></ul><h2 id="Unit-6-Input-and-output"><a href="#Unit-6-Input-and-output" class="headerlink" title="Unit 6 Input and output"></a>Unit 6 Input and output</h2><p>输入设备用于将人们可以理解的信息转化为计算机可以理解的形式。</p><h3 id="Keyboard-键盘"><a href="#Keyboard-键盘" class="headerlink" title="Keyboard 键盘"></a>Keyboard 键盘</h3><ul><li>传统键盘（Traditional keyboard）</li><li>笔记本电脑键盘（laptop keyboard）用于笔记本电脑</li><li>虚拟键盘（virtual keyboard）用于平板电脑和移动设备上的键盘</li></ul><h3 id="Pointing-devices点设备"><a href="#Pointing-devices点设备" class="headerlink" title="Pointing devices点设备"></a>Pointing devices点设备</h3><p>通过手势或者点按将信息转化为机器可读的输入。提供直观的界面</p><ul><li><p><strong>鼠标（Mouse）</strong>控制<strong>鼠标指针（Mouse pointer）</strong>。有<strong>滚轮按钮（wheel button）</strong>来滚动。<strong>光电鼠标（optical Mouse）</strong>使用最广泛。</p><p>（1）<strong>光电鼠标（optical Mouse）</strong>没有移动部件，发出并感应光线来检测鼠标的移动。可以在任何表面上使用。</p><p>（2）<strong>无线鼠标（cordless mouse，wireless mouse）</strong>利用无线电波或者红外光波传输</p><p>（3）<strong>触摸板（touch pads）</strong>通过手指在触摸板上移动或点击来控制指针。</p></li><li><p><strong>触摸屏（Touch screen）</strong>使用手指或者笔在屏幕上操作。<strong>手写笔（Stylus）</strong>是一种类似笔的设备。在平板电脑上使用。需要使用<strong>手写识别软件识别（handwriting recognition software）</strong>。<strong>多点触控屏（Multi-touch screen）</strong>可以用多个手指触摸。</p></li><li><p><strong>游戏控制器（Gaming Controllers）</strong></p><p>（1）<strong>操纵杆（Joystick）</strong>通过改变压力、速度和方向来控制游戏动作</p><p>（2）<strong>游戏鼠标（Gaming Moouse）</strong> 类似于传统鼠标，具有更高的精度，更快的响应速度，可编程的按钮和更好的人体工程学设计</p><p>（3）<strong>游戏板（Game pads）</strong>可以使用两只手同时握住来操作。</p><p>（4）<strong>运动感应设备（Motion sensing device）</strong>通过用户移动来控制设备。</p></li></ul><h3 id="Scanning-Devices-扫描设备"><a href="#Scanning-Devices-扫描设备" class="headerlink" title="Scanning Devices 扫描设备"></a>Scanning Devices 扫描设备</h3><p><strong>扫描设备（scanning devices）</strong>将扫描的数据转换成系统单元可以出的的形式。</p><ul><li><p><strong>光学扫描仪（optical）</strong>也叫<strong>scanner</strong></p><p>（1）<strong>平板扫描仪（Flatbed）</strong>像是复印机。</p><p>（2）<strong>文档扫描仪（Document）</strong>，可以快速扫描多页文档</p><p>（3）<strong>便携式扫描仪（Portable）</strong>手持设备，可以在图像上滑动，直接接触。</p><p>（4）3D，使用激光相机或者机械臂来记录物体的三维形状</p></li><li><p><strong>读卡设备（Card Readers）</strong>解释存储在借记卡、信用卡和身份证上的编码信息。最常见的是<strong>磁卡读卡器（Magnetic card reader）</strong>，信息储存在卡背面的薄词条上。<strong>芯片卡（chip card）</strong>再信用卡中嵌入微芯片，包含加密数据。</p></li><li><p><strong>条形码阅读器（Bar code readers，bar code canners）</strong>有<strong>手持型（wand reader)<strong>或者</strong>平台型(platform scanner)<strong>。读取商品上面的条码。产品有</strong>通用产品代码（Universal,UPC）</strong>和用于运输的<strong>Maxicode.</strong></p></li><li><p><strong>射频识别（radio frequency identification，RFID）</strong>嵌入在大多数任何东西中的微小芯片都包含电子储存的信息。可以使用位于几码外的阅读器读取。可用于追踪宠物，更新和控制库存，阅读护照</p></li><li><p><strong>字符和标记识别设备（radio frequency identification）</strong>用来识别特殊字符和标记。</p><p>（1）<strong>MICR</strong>，银行用于读取支票和存款单底部的磁性编码字符;数字由阅读器&#x2F;排序器读取</p><p>（2）读取特别预印的字符，读取价格标签</p><p>（3）<strong>OMR</strong>，设备检测标记的存在与否，这在标准化和多项选择题测试评分中很常见。</p></li></ul><h3 id="image-capturing-devices-图像捕获设备"><a href="#image-capturing-devices-图像捕获设备" class="headerlink" title="image capturing devices 图像捕获设备"></a>image capturing devices 图像捕获设备</h3><ul><li><strong>数码相机（Digital cameras）</strong>类似于传统相机，图像以数字的方式记录在磁盘或者相机的内存里。</li><li><strong>网络相机（Webcams）</strong>可以捕获图像并且发送到计算机通过网络 广播，内置于智能手机和平板电脑里。</li></ul><h3 id="Audio-Input-Devices音频输入设备"><a href="#Audio-Input-Devices音频输入设备" class="headerlink" title="Audio-Input Devices音频输入设备"></a>Audio-Input Devices音频输入设备</h3><p>麦克风是最常用的音频输入设备。</p><p><strong>语音识别系统（Voice recognition systems）</strong>，即智能语音助手</p><h3 id="Monitors-显示器"><a href="#Monitors-显示器" class="headerlink" title="Monitors 显示器"></a>Monitors 显示器</h3><p><strong>显示器（Monitor）</strong>也叫<strong>display screen</strong></p><ul><li><p>属性</p><p>（1）<strong>清晰度（Clarity）</strong>所显示图像的质量和清晰度</p><p>（2）<strong>分辨率（Resolution）</strong>最重要的功能之一;图像由一系列点或像素（pixels，picture elements）在显示器上形成</p><p>（3）<strong>像素点间距（Dot pitch）</strong>每个像素之间的距离;大多数较新的显示器的点间距为 0.30 毫米（30&#x2F;100 毫米）或更小</p><p>（4）<strong>对比度（Contrast ratios）</strong>显示器显示颜色的能力</p><p>（5）<strong>尺寸（Size）</strong></p><p>（6）<strong>宽高比例（Aspect ratio）</strong></p></li><li><p><strong>平板显示器（Flat-Panel Monitors）</strong>使用最广泛。运行所需功率少，便携精简。大多数有背光。三种类型：</p><p>（1）<strong>液晶显示器（LCD）</strong>比较老旧</p><p>（2）<strong>发光二极管（LED）</strong>，有更先进的背光</p><p>（3）<strong>有机发光二极管（OLED，产生光的薄层有机化合物）</strong></p></li><li><p><strong>电子阅读器（E-book Readers）</strong></p><p>用来阅读电子书。使用<strong>电子墨水（e-ink）</strong>技术。产生反射光线的图像。如亚马逊的kindle</p></li><li><p>其他显示器</p><p>（1）<strong>数字白板（Digital whiteboards）</strong>可交互的大型触摸屏</p><p>（2）<strong>柔性屏幕（Flexible Screens）</strong>允许设备在弯曲的表面上显示</p><p>（3）<strong>数字投影仪（Digital projector）</strong></p></li></ul><h3 id="Printers-打印机"><a href="#Printers-打印机" class="headerlink" title="Printers 打印机"></a>Printers 打印机</h3><ul><li><p>特点</p><p>（1）<strong>分辨率（Resolution）</strong>，以<strong>每英寸点数（dots-per-inch，dpi）</strong>表示</p><p>（2）<strong>颜色（color）</strong>，彩色打印更贵</p><p>（3）<strong>速度（speed）</strong></p><p>（4）<strong>内存（Memory）</strong>用于储存打印队列</p><p>（5）<strong>双面打印（Duplexprinting）</strong></p></li><li><p><strong>喷墨打印机（Inkjet printer）</strong>将墨水高速喷洒到纸张表面 可靠、安静、价格低廉。</p></li><li><p><strong>激光打印机（Laser printer）</strong>使用激光束来生成图像 比喷墨打印机更快、质量更优、更昂贵。</p></li><li><p>3D打印机，创建三维形状，重复添加一层薄薄的材料，直到创建项目。</p></li><li><p>其他打印机</p><p>（1）<strong>云打印机（Cloud）</strong>连接到互联网，并为网络上的其他人提供打印服务。</p><p>（2）<strong>热敏打印机（Thermal printers）</strong>使用热敏元件在热敏纸、ATM 和气泵上生成图像</p><p>（3）<strong>绘图仪（Plotters）</strong>用于地图，图像，建筑和工程图纸等。</p></li></ul><h3 id="Audio-and-Video-Devices音频输出设备"><a href="#Audio-and-Video-Devices音频输出设备" class="headerlink" title="Audio and Video Devices音频输出设备"></a>Audio and Video Devices音频输出设备</h3><p><strong>扬声器（Sperkers）</strong>和<strong>耳机（headsets）</strong>是使用最广泛的音频输出设备。蓝牙技术（Bluetooth）将扬声器连接到无线声卡。</p><h3 id="Combination-Input-and-Output-Devices输入输出二合一设备"><a href="#Combination-Input-and-Output-Devices输入输出二合一设备" class="headerlink" title="Combination Input and Output Devices输入输出二合一设备"></a><strong>Combination</strong> Input and Output Devices输入输出二合一设备</h3><ul><li><strong>耳麦（Headsets）</strong>结合麦克风和耳机。</li><li><strong>多功能设备（Multifunctional devices，MFD）</strong>结合了扫描仪、打印机、传真机和复印机的功能。</li><li><strong>虚拟现实设备（Virtual reality，VR）</strong>由计算机创造的人造或者模拟显示设备。有<strong>头戴式显示器（Virtual head-mounted displays）和控制器（Controllers）</strong></li><li><strong>无人机（Drones）</strong>也叫<strong>非武装飞行器（unarmed aerial vehicles，UAV）</strong>，从控制器获取输入并将视频和声音发回给用户</li><li><strong>机器人（Robots）</strong>使用摄像头、麦克风和其他传感器作为输入。</li></ul><h3 id="Ergonomics-人体工程学"><a href="#Ergonomics-人体工程学" class="headerlink" title="Ergonomics 人体工程学"></a>Ergonomics 人体工程学</h3><p>使任务更适合用户使用</p><p>可以避免：</p><ul><li><strong>眼睛疲劳（eyestrain）</strong></li><li><strong>背部和颈部疼痛（Back and neck pain）</strong></li><li><strong>重复性劳损（Repetitive strain injury）</strong></li><li><strong>腕管综合征（Carpal tunnel syndrome）</strong>手部神经和肌肉受损</li></ul><p><strong>便携式设备（Portable computers）</strong>为针对人体工程学进行设置，所以学习的时候要注意</p><ul><li>笔记本电脑：提高屏幕高度，或者连接外部键盘</li><li>平板：常休息，使用支架，外接键盘</li><li>智能手机：头部向上，肩旁伸直。</li></ul><h2 id="Unit7-Secondary-Storage"><a href="#Unit7-Secondary-Storage" class="headerlink" title="Unit7 Secondary Storage"></a>Unit7 Secondary Storage</h2><h3 id="Storage-储存"><a href="#Storage-储存" class="headerlink" title="Storage 储存"></a>Storage 储存</h3><p><strong>主存（Primary storage）</strong>是临时的，当计算机断电的时候丢失信息。</p><p><strong>外存（Secondary storage）</strong>可以永久保存信息。</p><p>外存的特性：</p><ul><li><strong>媒介（Media）</strong>：保存数据和程序的实际物理材料</li><li><strong>容量（Capacity）</strong>：衡量存储介质可以容纳的信息多少</li><li><strong>访问速度（Access speed）</strong>：测量存储设备检索数据和程序所需要的时间</li><li><strong>存储设备（Storage devices）</strong>：从媒介读取和写入到媒介的硬件</li></ul><h3 id="Solid-Stage-Storage-固态存储"><a href="#Solid-Stage-Storage-固态存储" class="headerlink" title="Solid Stage Storage 固态存储"></a>Solid Stage Storage 固态存储</h3><p><strong>固态存储（Solid Stage Storage）</strong>设备没有移动的部件</p><ul><li><strong>固态硬盘（Solid state drives）</strong>比普通硬盘更快更耐用，并且需要更少的电量。</li><li><strong>闪存卡（Flash memory cards）</strong>是一种固态硬盘，被用于数码相机，ipods等设备。闪存比一般的内存慢，但比其他的SSD快。</li><li>USB驱动器也叫<strong>闪存驱动器（Flash drives）</strong>连接USB端口</li></ul><h3 id="Hard-Disks-机械硬盘"><a href="#Hard-Disks-机械硬盘" class="headerlink" title="Hard Disks 机械硬盘"></a>Hard Disks 机械硬盘</h3><p><strong>硬盘（Hard disks）</strong>通过改变磁盘表面的磁荷来保存文件，以表示 1 和 0。密度（Density）是指这些电荷在磁盘上彼此相邻的包装程度。</p><p>由金属圆盘组成。</p><ul><li><strong>盘片（Platter）</strong>是一种刚性金属，一个一个的堆叠起来</li><li><strong>磁道（Track）</strong>是金属盘上一个一个的环</li><li><strong>扇区（sectors）</strong>从圆心向外呈放射状地产生分割线（扇骨），将每个磁道等分为若干弧段，每个弧段就是一个扇区。每个扇区的大小是固定的，为 512Byte。扇区也是磁盘的最小存储单位。</li><li><strong>柱面（cylinder）</strong>磁道从外向内由0开始编号，多个盘片编号相同的磁道自上而下形成一个圆柱，称为柱面。</li></ul><p>格式化硬盘的时候，将分配磁道扇区和柱面</p><p>硬盘的类型有：</p><ul><li><strong>内置硬盘（Internal Hard Disks）</strong>位于系统单元内部，能够快速存储和检索信息。用于储存信息和数据文件</li><li><strong>外部硬盘（External Hard Disks）</strong>访问速度较慢，通常会连接到系统单元的USB端口或者雷电接口。易于拆卸，有固定的储存量</li><li><strong>网络驱动器（Network Drives）</strong>当网络中电脑的磁盘作为共享数据区域允许网络用户访问时，该驱动器就变成了网络驱动器了。</li></ul><p>硬盘的性能增强技术</p><ul><li><strong>磁盘缓存（Disk caching）</strong>使用硬件和软件来预测需求，执行类似于RAM缓存的功能。充当硬盘和CPU之间的高速缓存区</li><li><strong>磁盘阵列（Redundant arrays of inexpensive disks ，RAID）</strong>，把相同的数据储存在多个硬盘的不同地方。提高了存取速度。常用于互联网服务器和大型组织</li><li><strong>文件压缩和解压（File compressionand decompression）</strong>可以增加储存容量，提高文件传输速度，减少储存所需空间</li></ul><h3 id="Optical-Disks-光盘"><a href="#Optical-Disks-光盘" class="headerlink" title="Optical Disks 光盘"></a>Optical Disks 光盘</h3><p>光盘是紧凑高容量（50G）的永久存储形式。</p><p>光盘由<strong>光驱（optical disc drive）</strong>读取</p><p>激光束通过创建<strong>凹区（pits）</strong>和<strong>平区（lands）</strong>来写入数据。</p><p>激光通过凹坑和平坦区域的反射来读取数据。也是使用磁道和扇区来组织和存储文件，但是只能使用单个磁道。</p><p>光盘格式种类：</p><ul><li>CD—曾经的光盘标准</li><li>DVD—现在的标准</li><li>BD—高清形式，由更大的容量</li><li>支持4K视频</li></ul><p>光盘类别</p><ul><li><strong>只读光盘（ROM，read-only memory）</strong>只能读不能写</li><li><strong>一次性写入光盘（Write-once，R，recordable）</strong>只能被写入一次，之后只能读。</li><li><strong>可重写光盘（Rewritable，RW，RAM，random-access memory discs）</strong>可以重写，可以更改。</li></ul><h3 id="Cloud-Storage云存储"><a href="#Cloud-Storage云存储" class="headerlink" title="Cloud Storage云存储"></a>Cloud Storage云存储</h3><p>将程序放在云服务器上本机服务器只显示结果。类似云计算（cloud computing）</p><ul><li>云服务商提供存储，内存，计算</li><li>优点是占用用户更少的存储，内存和算力</li><li>缺点是运算速度慢，文件安全性受到威胁。</li></ul><h3 id="Mass-Storage-Devices-大容量存储设备"><a href="#Mass-Storage-Devices-大容量存储设备" class="headerlink" title="Mass Storage Devices 大容量存储设备"></a>Mass Storage Devices 大容量存储设备</h3><p><strong>大容量存储（Mass Storage）</strong>是指大型组织需要的大容量外存。</p><p><strong>企业存储系统（enterprise storage system）</strong>，大多数组织利用此系统来提高效率和数据的安全性。</p><p>支持此系统的设备：</p><ul><li><strong>文件服务器（File Servers）</strong></li><li>**网络连接存储（Networked attached storage ，NAS)**，适用于小型企业和家庭，更便宜，易于设置和管理。</li><li><strong>RAID系统</strong>，专用设备的更大版本</li><li><strong>组织云存储（Organizational cloud storage）</strong>，通过高速互联网连接到专用的远程存储设备。</li></ul><p><strong>存储区域网络（Storage area network）</strong>，用户的电脑提供文件系统，SAN提供存储区域。把数据放在远程位置。</p><h2 id="Unit8-Communication-and-Networks"><a href="#Unit8-Communication-and-Networks" class="headerlink" title="Unit8 Communication and Networks"></a>Unit8 Communication and Networks</h2><h3 id="communication-通信"><a href="#communication-通信" class="headerlink" title="communication 通信"></a>communication 通信</h3><p>电脑的交流是数据共享的过程。</p><ul><li><p><strong>连通（Connectivity）</strong>意味着你可以将电脑与其他的任何一台电脑连接</p></li><li><p><strong>无线革命（The Wireless Revolution）</strong></p></li><li><p><strong>通信系统（Communication System）</strong>是将数据从一个位置传输到另一个位置的电子系统，他的基本要素包括</p><p>（1）<strong>发送和接收设备（•Sending and receiving devices）</strong></p><p>（2）<strong>连接设备（•Connection devices）</strong>将传出的数据转换成可以跨通信信道传输的数据包</p><p>（3）<strong>数据传输规范（•Data transmission specifications）</strong>协调发送和接受设备的规则</p><p>（4）<strong>沟通渠道（Communication channel）</strong>承载消息，有有线和无线两种</p></li></ul><h3 id="communication-channels-信道"><a href="#communication-channels-信道" class="headerlink" title="communication channels 信道"></a>communication channels 信道</h3><p><strong>信道承载（Communication channel）</strong>从一个电脑到另一台电脑的数据。</p><p>有两类信道：</p><ul><li><p><strong>无线信道（Wirless Connection）</strong></p><p>（1）<strong>蓝牙技术（Bluetooth）</strong>短距离无线电通信标准</p><p>（2）Wi-Fi，短距离通信。高频电波</p><p>（3）<strong>微波（Microwave）</strong>使用高频电波</p><p>（4）<strong>WiMax</strong>，Wi-Fi技术的扩展，允许更远距离的Wi-Fi通信</p><p>（5）<strong>蜂窝（Cellular）</strong>使用多个天线进行通信。利用基站实现</p><p>（6）<strong>卫星（Satellite）</strong>使用卫星作为中继站进行通信。如GPS系统。<strong>上行链路（Uplink）</strong>向卫星发送数据，<strong>下行链路（Downlink）</strong>从卫星接收数据。</p><p>（7）<strong>红外线（Infared）</strong>短距离的光波。</p></li><li><p><strong>物理信道，有线信道（Physical Connections）</strong></p><p>（1）<strong>双绞线电缆（Twisted pair cable）</strong>将一对铜线绞合在一起。如电话线（telephone）和以太网（Ethernet）都是双绞线。以太网电缆由双绞线电缆组成，传输速度最慢，被更先进的媒介淘汰。</p><p>（2）<strong>同轴电缆（Coaxial cable）</strong>有单根实心铜芯。传输速度是双绞线的80倍。</p><p>（3）<strong>光纤（Fiber optic）</strong>以光脉冲的形式通过微小的玻璃管传输。更安全可靠;在限定的距离内效果最好比同轴电缆更轻、更可靠、更快</p></li></ul><h3 id="Connection-device-连接设备"><a href="#Connection-device-连接设备" class="headerlink" title="Connection device 连接设备"></a>Connection device 连接设备</h3><p>电话使用的是<strong>模拟信号（analog signals）</strong>，是连续的电子波。计算机接受和发送的是<strong>数字信号（digital signals）</strong>是不连续的。</p><p><strong>转换速率（Transfer Rate）</strong>是指<strong>调制解调器（Modems）</strong>转换数据的速度。</p><ul><li><p><strong>调制解调器（Modems）</strong>，<strong>调制（Modulation）</strong>是把数字信号转化为模拟信号，<strong>解调（Demodulation）</strong>是把模拟信号转化为数字信号。因为传输线路传输的是模拟信号，所以需要先调制成模拟信号，再解调成数字信号。传输速率用<strong>兆比特每秒（Mbps）</strong>作单位。调制解调器的种类有</p><p>（1）<strong>数字用户电路（DSL，digital subcsriber line）</strong>使用标准电话线创建高速连接。</p><p>（2）<strong>电缆（Cable）</strong>使用与电视相同的同轴电缆</p><p>（3）<strong>无线（Wireless）</strong>也叫做WWAN调制解调器或者<strong>无线广域网（wireless wide area network）</strong></p></li><li><p>连接服务</p><p>（1）<strong>蜂窝数据（cellular service）</strong>这些数据经历了4个时代，1G，使用模拟信号提供模拟语音传输业务；2G使用数字无线电信号；3G提供有效连接到互联网的服务，标志手机开始广泛使用；4G使用LTE（long term Evolution）连接，提供更快的互联网接入；5G，正在发展。</p><p>（2）<strong>拨号服务（Dial-up services）</strong>由电话公司·利用现存的电话线提供服务。已经被更告诉的连接服务取代。</p><p>（3）<strong>数字用户电路（Digital subscriber line service，DSL）</strong>使用现有的电话线提供高速连接。<strong>ADSL（asymmetric digital subscriber line）</strong>是使用最广泛的一种DSL。</p><p>（4）<strong>电缆（cable）</strong>，使用现有有线电视的电缆连接</p><p>（5）<strong>光纤服务（Fiber-optic service，FiOS）</strong>一种新技术，没有被广泛使用。</p><p>（6）<strong>卫星连接服务（Satellite connection services）</strong>，使用卫星进行无线连接</p></li></ul><h3 id="Data-Transmission-数据传输"><a href="#Data-Transmission-数据传输" class="headerlink" title="Data Transmission 数据传输"></a>Data Transmission 数据传输</h3><p>一些技术问题会影响数据的传输方式，包括带宽（Bandwidth）和协议（protocols）</p><ul><li><p><strong>带宽（Banwith）</strong>是指通信信道的宽度或者叫容量。他表示在给定时间内能通过信道的信息量。有以下类型：</p><p>（1）<strong>语音带宽（Voiceband）</strong>，也叫<strong>低带宽（low bandwidth）</strong>通过标准电话线传输，太慢。</p><p>（2）<strong>中频段带宽（Medium band）</strong>具有特殊的租用线路，用于连接小型计算机和大型机，以及长距离传输数据（对于较大的计算机系统）;通常不被个人使用</p><p>（3）<strong>宽带（Broadband）</strong>用于高容量传输（DSL，电缆，卫星连接），可以有效传输高质量视频。通常为1.5Mbps</p><p>（4）<strong>基带（Baseband）</strong>广泛用于连接彼此靠近的单个计算机</p></li><li><p><strong>协议（Protocols）</strong>表示计算机之间交换数据的规则。有<strong>HTTPS（超文本传输安全协议）</strong>和**传输控制协议（tranmission control protocol&#x2F;Internet protocol,TCP&#x2F;IP)**。协议有两个基本特征</p><p>（1）<strong>标识性（Identification）</strong>，互联网上的每台计算机都有唯一的数字地址，称为IP地址，<strong>域名服务器（Domain Name Server，DNS）</strong>可以将域名地址转化为IP地址。</p><p>（2）<strong>分组化（Packetization）</strong>可以将消息分解为<strong>数据包（packets）</strong>，使其更容易通过网络传输，并在目的地重新组合成信息。</p></li></ul><h3 id="Networks-网络"><a href="#Networks-网络" class="headerlink" title="Networks 网络"></a>Networks 网络</h3><p><strong>计算机网络（computer network）</strong>是连接两台或多台计算机以便它们可以交换信息和共享资源的通信系统。</p><p>在网络中的关键词：</p><ul><li><strong>节点（Nodes）</strong>—连接到网络的设备</li><li><strong>客户端（client）</strong>—从其他节点获取资源的节点</li><li><strong>服务商（server）</strong>—与其他节点分享资源的节点</li><li><strong>文件服务器（directory server）</strong>管理资源的专用服务器</li><li><strong>主机（Host）</strong>—网络上可以连接到的计算机系统</li><li><strong>路由器（Router）</strong>—在网络间起网关的作用，将一个网络中的数据包传送到另一个网络中的某个节点。</li><li><strong>交换机（Switch）</strong>协调数据流的中心节点</li><li><strong>网卡（Network interface cards，NIC）</strong>使一个电脑可以连接到网络的扩展卡</li><li><strong>网络操作系统（Network Operating System，NOS）</strong>，控制网络上所有计算机的活动</li><li><strong>网络管理员（Network，administrator）</strong>负责网络操作。</li></ul><h3 id="Network-Types-网络类型"><a href="#Network-Types-网络类型" class="headerlink" title="Network Types 网络类型"></a>Network Types 网络类型</h3><p>各种类型网络的适用范围不同。</p><ul><li><p><strong>局域网（Local area networks，LANs）</strong>再不到一英里的距离内连接的计算机和设备。通过电缆连接，经济灵活，使用网络网关（network gateways）局域网可以连接到其他的局域网或者各种网络。</p><p>（1）<strong>家庭局域网（HomeNetworks）</strong>，在家庭中的使用的局域网</p><p>（2）<strong>无线局域网（Wireless LAN，WLAN）</strong>，通过<strong>无线接入点（wireless access point）</strong>或者<strong>基站（base station）</strong>连接。<strong>热点（hotspot）</strong>是公众可以开启的无线接入点。</p><p>（3）<strong>个人局域网（personal Area networks）</strong>在非常小的区域内工作。</p></li><li><p><strong>城域网（metropolitan area network，MANs）</strong>，跨度最远可达100英里，在城市的地理范围内连接。</p></li><li><p><strong>广域网（wide area networks）</strong>全国和全球网络。因特网是最大的广域网。</p></li></ul><h3 id="Network-Architecture-网络架构"><a href="#Network-Architecture-网络架构" class="headerlink" title="Network Architecture 网络架构"></a>Network Architecture 网络架构</h3><p><strong>网络架构（Network Architecture）</strong>描述了网络的排列方式以及资源的协调和共享方式</p><p><strong>网络的拓扑结构（Network Topology ）</strong>描述了网络的物理安排方式。</p><p>网络的拓扑结构有</p><ul><li><strong>环形网络（Ring network）</strong>每个设备连接到另外两个设备，形成一个环，传输数据的时候就绕环依次传递</li><li><strong>总线网络（Bus network）</strong>每个设备连接到一个公共电缆上，称为<strong>总线（Bus）</strong></li><li><strong>星型结构（Star network）</strong>每个设备都直接连到中央网络交换机，每当节点发送消息时，都会将其路由到交换机，然后交换机将消息传递给预期的收件人。星形网络是当今使用最广泛的网络拓扑结构。</li><li><strong>树形结构（Tree Network）</strong>也叫<strong>分层网络（hierarchical network）</strong>，构成一棵树。</li><li><strong>网状结构（mesh network）</strong>不适用特定的物理布局，但是要求每个节点与其他节点有多个连接，如果两个节点之间路径中断，则还可以使用另外的路径。</li></ul><p><strong>络策略（network Strategies）</strong>协调信息和资源共享的方式。有两种</p><ul><li><strong>客户端-服务器网络（Client&#x2F;Server Network）</strong>优点是可以高效处理大型网络，提供功能强大的网络管理软件来监视和控制网络活动。缺点是安装和维护成本高。</li><li><strong>点对点（Peer-to-Peer，P2P）</strong>，所有节点都是等价的。如<strong>比特种子（BitTorrent）</strong>，但是缺乏安全性。</li></ul><h3 id="Organizational-Network-组织网络"><a href="#Organizational-Network-组织网络" class="headerlink" title="Organizational Network 组织网络"></a>Organizational Network 组织网络</h3><p>类似于小型互联网。</p><ul><li><strong>Intranet</strong>，提供组织内部的网络沟通，如校园网</li><li><strong>Extranet</strong>，提供多个组织间的网络沟通</li></ul><h3 id="Network-Security-网络安全"><a href="#Network-Security-网络安全" class="headerlink" title="Network Security 网络安全"></a>Network Security 网络安全</h3><p>有三种常见的技术来保证网络安全</p><ul><li><strong>防火墙（Firewall）</strong>，利用<strong>代理服务器（proxy server）</strong>构建起防火墙，外部世界与组织内部的通信都必须通过代理服务器。</li><li><strong>入侵检测系统（Intrusion detection system ，IDS）</strong>，可以识别网络攻击的迹象，并且再入侵者造成损害之前禁止访问。</li><li><strong>虚拟专用网络（Virtual private network ，VPN）</strong>，再远程用户和内部网络之间创建安全的专用链接，在用户的家庭或者便携式计算机与公司服务器之间创建等效的专用网络。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;h3 id=&quot;主要参考书&quot;&gt;&lt;a href=&quot;#主要参考书&quot; class=&quot;headerlink&quot; title=&quot;主要参考书&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="http://example.com/2023/12/24/Linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/12/24/Linux%E5%9F%BA%E7%A1%80/</id>
    <published>2023-12-24T02:27:16.000Z</published>
    <updated>2023-12-24T02:27:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p><p>符号：『』❑ ➢ </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书"><a href="#主要参考书" class="headerlink" title="主要参考书"></a>主要参考书</h3><table><thead><tr><th>图书名称:</th><th>Ubuntu Linux应用技术教程</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2009-4</td><td></td></tr><tr><td>出版社:</td><td>清华大学出版社</td><td></td></tr><tr><td>图书作者:</td><td>陈明 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787302193289</td><td></td></tr></tbody></table><table><thead><tr><th>图书名称:</th><th>Linux就该这么学（第2版）</th><th></th></tr></thead><tbody><tr><td>封面图片:</td><td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td><td></td></tr><tr><td>出版印刷时间:</td><td>2021-9</td><td></td></tr><tr><td>出版社:</td><td>人民邮电出版社</td><td></td></tr><tr><td>图书作者:</td><td>刘遄 编著</td><td></td></tr><tr><td>ISBN:</td><td>9787115570116</td><td></td></tr></tbody></table><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Linux应用课程基础</p></li><li><p>Linux基础命令</p></li><li><p>文件系统</p></li><li><p>权限管理</p></li><li><p>Vi应用</p></li><li><p>进程管理</p></li><li><p>SHELL编程</p></li></ul><h2 id="Chapter-1-Linux-概述"><a href="#Chapter-1-Linux-概述" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述"><a href="#1-1-Linux-操作系统简述" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p><h4 id="强大好用的Shell"><a href="#强大好用的Shell" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p><p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p><p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p><p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p><p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p><p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p><blockquote><p>通过上下方向键来调取执行过的Linux命令；</p><p>命令或参数仅需输入前几位就可以用Tab键补全；</p><p>具有强大的批处理脚本；</p><p>具有实用的环境变量功能。</p></blockquote><h3 id="1-2-发展史"><a href="#1-2-发展史" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成"><a href="#1-3-Linux-的特点与组成" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p><p>Linux系统基本组成:</p><ul><li>Kernel 内核</li><li>SHELL（bash）</li><li>Applications 应用程序</li></ul><p>§ Kernel</p><p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p><p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p><p>§ Linux应用程序</p><p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p><h3 id="1-4-Linux-发行版本"><a href="#1-4-Linux-发行版本" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p><blockquote><p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p><p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p></blockquote><p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p><p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p><p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p><h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p><p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p><p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p><h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p><p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p><h4 id="Fedora-Linux"><a href="#Fedora-Linux" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p><p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p><h4 id="Debian-Linux"><a href="#Debian-Linux" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p><p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p><h4 id="Ubuntu-Linux"><a href="#Ubuntu-Linux" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p><p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p><h4 id="Kali-Linux"><a href="#Kali-Linux" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p><h3 id="开源共享精神"><a href="#开源共享精神" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p><p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p><p>开源许可证总览：<a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><h2 id="Chapter-2-Linux-基本命令"><a href="#Chapter-2-Linux-基本命令" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识"><a href="#执行命令的必备知识" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p><p>常见的执行Linux命令的格式是下面这样的。</p><blockquote><p>命令名称   [命令参数]   [命令对象]</p></blockquote><p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p><p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p><table><thead><tr><th>表2-1    Linux命令参数的长格式与短格式示例</th><th></th></tr></thead><tbody><tr><td>长格式</td><td>man –help</td></tr><tr><td>短格式</td><td>man -h</td></tr></tbody></table><p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p><blockquote><p><em>Tips</em></p><p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p></blockquote><h4 id="常用的按键"><a href="#常用的按键" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p><p>​在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p><p><code>&lt;ctrl+c&gt;</code>:</p><p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p><p><code>&lt;Ctrl+d&gt;</code>:</p><p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p><p><code>&lt;ctrl+l&gt;</code>:</p><p>​清空当前终端中已有的内容（相当于清屏操作）。</p><h3 id="2-1-常用系统工作命令"><a href="#2-1-常用系统工作命令" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">显示一串字符</td></tr><tr><td align="center">passwd</td><td align="center">修改密码</td></tr><tr><td align="center">clear</td><td align="center">清除显示器</td></tr><tr><td align="center">lpr</td><td align="center">打印</td></tr><tr><td align="center">shutdown</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启计算机</td></tr><tr><td align="center">ps</td><td align="center">查看目前程序执行情况</td></tr><tr><td align="center">top</td><td align="center">查看目前程序执行情景和内存使用情况</td></tr><tr><td align="center">kill</td><td align="center">终止一个进程</td></tr><tr><td align="center">date</td><td align="center">更改或者查看目前时间</td></tr></tbody></table><h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p><p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p><h4 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p><h4 id="timedatectl命令"><a href="#timedatectl命令" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p><h4 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p><p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p><h4 id="poweroff命令"><a href="#poweroff命令" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p><p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p><h4 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p><p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h4 id="history命令"><a href="#history命令" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p><p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p><h3 id="2-2-文件管理"><a href="#2-2-文件管理" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令"><a href="#管理文件和目录的命令" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pwd</td><td align="center">显示当前工作目录</td></tr><tr><td align="center">cd</td><td align="center">将活动目录更改为指定的路径</td></tr><tr><td align="center">ls</td><td align="center">显示指定工作目录的内容</td></tr><tr><td align="center">cat</td><td align="center">显示文件的内容</td></tr><tr><td align="center">grep</td><td align="center">在文件中查找某字符</td></tr><tr><td align="center">cp</td><td align="center">复制文件</td></tr><tr><td align="center">touch</td><td align="center">创建文件</td></tr></tbody></table><p>•locate命令用于查找符合条件的文件。</p><p>•whereis命令也用于查找文件。</p><p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p><p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p><p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p><h5 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p><h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p><h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-d 只列出目录（不递归列出目录内的文件）。</li><li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li><li>-r 倒序显示文件和目录。</li><li>-R 递归显示目录中的所有文件和子目录。</li><li>-t 将按照修改时间排序，最新的文件在最前面。</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-s 大小(size)，按文件大小排序。</li></ul><h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><p><strong>重定向</strong>:<code>&gt;</code>符号</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 **-**，则 grep 指令会从标准输入设备读取数据。</p><p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure><h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p><h5 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure><h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令"><a href="#文件阅读命令" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">head</td><td align="center">查看文件开头部分</td></tr><tr><td align="center">tail</td><td align="center">查看文件结尾的10行</td></tr><tr><td align="center">less</td><td align="center">分页工具，一页一页查看信息</td></tr><tr><td align="center">more</td><td align="center">分页工具，一页一页查看信息</td></tr></tbody></table><h4 id="文件备份和压缩命令"><a href="#文件备份和压缩命令" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bzip2&#x2F;bunzip2</td><td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td></tr><tr><td align="center">gzip&#x2F;gunzip</td><td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td></tr><tr><td align="center">zip&#x2F;unzip</td><td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td></tr><tr><td align="center">tar</td><td align="center">创建备份和归档</td></tr></tbody></table><h4 id="有关磁盘空间的命令"><a href="#有关磁盘空间的命令" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mount</td><td align="center">挂上文件系统</td></tr><tr><td align="center">umount</td><td align="center">卸下已经挂上的文件系统</td></tr><tr><td align="center">df</td><td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td></tr><tr><td align="center">du</td><td align="center">显示文件目录或大小</td></tr><tr><td align="center">fsck</td><td align="center">主要是检查和修复Linux文件系统</td></tr></tbody></table><h3 id="2-3-权限管理"><a href="#2-3-权限管理" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">chmod</td><td align="center">改变权限</td></tr><tr><td align="center">useradd</td><td align="center">增加用户</td></tr><tr><td align="center">su</td><td align="center">修改用户</td></tr></tbody></table><h3 id="2-4-进程管理"><a href="#2-4-进程管理" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p><p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><blockquote><p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p><p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p><p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p><p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p><p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p></blockquote><h4 id="pstree命令"><a href="#pstree命令" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p><p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p><p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p><h4 id="nice命令"><a href="#nice命令" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p><p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p><h4 id="pidof命令"><a href="#pidof命令" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p><p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p><h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p><h4 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p><h3 id="2-5-有关网络操作的命令"><a href="#2-5-有关网络操作的命令" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">传送文件</td></tr><tr><td align="center">telnet</td><td align="center">远程登陆</td></tr><tr><td align="center">bye</td><td align="center">结束连线并结束程序</td></tr><tr><td align="center">rlogin</td><td align="center">远端登入</td></tr><tr><td align="center">ping</td><td align="center">检查主机</td></tr><tr><td align="center">netstat</td><td align="center">显示网络状态</td></tr></tbody></table><h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p><p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>总共发送次数</td></tr><tr><td>-l</td><td>指定网卡名称</td></tr><tr><td>-i</td><td>每次间隔时间（秒）</td></tr><tr><td>-W</td><td>最长等待时间（秒）</td></tr></tbody></table><h4 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p><p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p><p>表2-12                         netstat命令中的参数以及作用</p><table><thead><tr><th>-a</th><th>显示所有连接中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用的Socket信息</td></tr><tr><td>-t</td><td>显示TCP协议的连接状态</td></tr><tr><td>-u</td><td>显示UDP协议的连接状态</td></tr><tr><td>-n</td><td>使用IP地址，不使用域名</td></tr><tr><td>-l</td><td>仅列出正在监听的服务状态</td></tr><tr><td>-i</td><td>显示网卡列表信息</td></tr><tr><td>-r</td><td>显示路由表信息</td></tr></tbody></table><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p><p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p><blockquote><p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p><p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p><p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p></blockquote><p>输入重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>输出重定向中用到的符号及其作用</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h3 id="管道命令符"><a href="#管道命令符" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p><h3 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p><p>4个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p><p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p><p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p><p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p></blockquote><h2 id="Chapter-3-Linux-文件系统"><a href="#Chapter-3-Linux-文件系统" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>  要透彻理解文件系统，需要明确以下几个名词：</p><p>存储介质</p><p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p><p>磁盘的分割</p><p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p><p>创建文件系统</p><p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p><p><strong>挂载</strong></p><p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p><p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p><h3 id="文件和文件类型"><a href="#文件和文件类型" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p><p>从用户应用软件到文件系统介质示意图</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p><p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p><h4 id="文件命名规则"><a href="#文件命名规则" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p><p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p><p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p><p>❑隐藏文件一般是以“.”符号开头；</p><p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p><p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p><p>❑大小写敏感</p><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p><p>普通文件（regular file）</p><ul><li><p>二进制文件</p><p>以二进制形式存储在电脑中<br>用户一般只有通过相应的软件才能将其显示出来<br>一般是可执行程序、图形、图像、声音等</p></li><li><p>文本(txt)文件</p><p>以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>以“行”为基本结构的信息组织和存储方式</p></li></ul><p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p><p>目录文件（directory）</p><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p><p>设备文件</p><p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p><p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p><p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p><ol><li>普通文件（-）<ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li><li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li></ol></li><li>目录文件（d，directory file）<ol><li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li><li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li><li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li></ol></li><li>符号链接（l，symbolic link）<ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li>块设备文件（b，block）和字符设备文件（c，char）<ol><li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li></ol></li><li>FIFO（p，pipe）<ol><li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li></ol></li><li>套接字（s，socket）<ol><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li><li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li></ol></li></ol><p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p><p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p><p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li><li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p></blockquote><h3 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p><p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p><p>在 linux 中支持多种不同的文件系统</p><p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p><p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p><p>文件系统-相关基本概念</p><p>§当前目录即当前工作目录、环境变量PWD</p><p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p><p>§绝对路径</p><p>§相对路径</p><p>§符号链接（可跨文件系统）</p><p>§软链接（不可跨文件系统）</p><h4 id="路径：绝对路径和相对路径"><a href="#路径：绝对路径和相对路径" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p><p>§路径名分为两种：绝对路径和相对路径</p><p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p><p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p><p>• “.”，代表当前目录</p><p>• “..”，代表当前目录的父目录</p><h4 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p><blockquote><p>具体用法是：<code>ln -s 源文件 目标文件</code></p><p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p><p>-s 是代号（symbolic）的意思。</p></blockquote><p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p><p><img src="/img/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-1.png"></p><p><img src="/img/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-2.png"></p><h2 id="Chapter-4-Linux-权限管理"><a href="#Chapter-4-Linux-权限管理" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p><p>§直接表示会使得权限的表示、判断效率低下。</p><p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p><p>q保证每个人的隐私权–&gt;文件所有者 </p><p>q资源共享，团队开发–&gt;文件所属用户组</p><p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p><h3 id="4-1-用户身份与能力"><a href="#4-1-用户身份与能力" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p><p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p><p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p><blockquote><p><strong>管理员UID为0</strong>：系统的管理员用户。</p><p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p><p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p></blockquote><p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p><p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p><p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p><blockquote><p><em>Tips</em></p><p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p></blockquote><p> 在设定文件权限时，用字符表示用户类型：</p><p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p><h3 id="4-2-文件权限与归属"><a href="#4-2-文件权限与归属" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><p> 对文件和目录的三种权限</p><p>•读（r）<br>•写（w）<br>•执行 （x）</p><p> 十进制表示</p><p>•用三个十进制数字表示文件权限：xyz</p><p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p><p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p><p><img src="/img/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-1.png"></p><p><img src="/img/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-2.png"></p><p><img src="/img/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-3.png"></p><p><strong>重要</strong>：</p><p> !IMPORTANT 命令执行对文件权限的限制</p><p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p><p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p><p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p><p><img src="/img/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-4.png"></p><h2 id="Chapter-5-Linux-常用工具"><a href="#Chapter-5-Linux-常用工具" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit"><a href="#gedit" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p><p>❑ 基本语法：<br>    vi [-options] [+n] [file]</p><p>❑常用选项：</p><p>-r 恢复系统突然崩溃时正在编辑的文件。</p><p>-R 以只读方式打开文件</p><p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p><p>如果该文件不存在，会自动建立新文件。</p><p>❑基本上 vi&#x2F;vim 共分为三种模式:</p><blockquote><p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><p><strong>输入模式</strong>：正常的文本录入。</p><p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p></blockquote><ul><li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li></ul><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p><blockquote><p><strong>x</strong> – 删除当前光标所在处的字符。</p><p><strong>dd</strong> – 删除当前行。</p><p><strong>yy</strong> – 复制当前行。</p><p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p><p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p><p><strong>u</strong> – 撤销上一次操作。</p><p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p><p>nG跳到第 n 行</p><p>0跳到行首</p><p>$跳到行尾</p><p>ctrl+b 前移一页</p><p>ctrl+f 后移一页  </p></blockquote><p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←)</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓)</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→)</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">+</td><td align="center">光标移动到非空格符的下一行</td></tr><tr><td align="center">-</td><td align="center">光标移动到非空格符的上一行</td></tr><tr><td align="center">n<space></td><td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n<Enter></td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><p>➢ 搜索替换 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="center">N</td><td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><p>➢ 复制、删除、粘贴 ：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x, X</td><td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">ndd</td><td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="center">d1G</td><td align="center">删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td align="center">删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td align="center">复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G</td><td align="center">复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td align="center">复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td align="center">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td align="center">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p, P</td><td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="center">J</td><td align="center">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td align="center">复原前一个动作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td align="center">重做上一个动作。(常用)</td></tr><tr><td align="center">.</td><td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><ul><li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li></ul><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p><p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p><p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><ul><li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li></ul><p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p><blockquote><p><strong>:w</strong> – 保存文件。</p><p><strong>:q</strong> – 退出 Vim 编辑器。</p><p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p><p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p><p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p><p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p></blockquote><p><img src="/img/vim-vi-workmodel.png" alt="img"></p><h5 id="命令模式和输入模式切换"><a href="#命令模式和输入模式切换" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i, I</td><td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td></tr><tr><td align="center">r, R</td><td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td align="center">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p><h5 id="命令模式和底线命令模式切换"><a href="#命令模式和底线命令模式切换" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">切换到底线命令模式，以在最底一行输入命令。</td></tr></tbody></table><p><img src="/img/Vim-introduction.jpg"></p><table><thead><tr><th align="left">vim 环境的变更</th><th></th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p><p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p><h3 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理"><a href="#Chapter-6-Linux-进程管理" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p><p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p><p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p><p>❑ 进程和程序不同：</p><ul><li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li><li>进程是动态的，是 Linux 系统的基本调度单位。</li></ul><p>❑ 父进程和子进程</p><ul><li>一个进程创建新进程称为创建了子进程(child process)。</li><li>创建子进程的进程称为父进程。</li></ul><p>❑ 进程号</p><ul><li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li><li>PPID：Parent Process ID。进程的父进程号。</li></ul><h2 id="Chapter-7-Linux-Shell"><a href="#Chapter-7-Linux-Shell" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell"><a href="#各种shell" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p><p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p><p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p><p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p><p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p><p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p><h3 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p><blockquote><p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p><p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p></blockquote><p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p><h3 id="Shell脚本练习"><a href="#Shell脚本练习" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="linux下普通用户变为root权限的三种方法"><a href="#linux下普通用户变为root权限的三种方法" class="headerlink" title="linux下普通用户变为root权限的三种方法"></a>linux下普通用户变为root权限的三种方法</h3><p><a href="https://blog.csdn.net/weixin_43886632/article/details/108244302">Linux下普通用户变为root权限的三种方法_19.如何从普通用户xiaoming切换到root?-CSDN博客</a></p><p><strong>方法3</strong></p><p>修改 &#x2F;etc&#x2F;passwd 文件，找到xiaoming，把用户ID修改为 0 </p><h2 id="Linux-一些概念"><a href="#Linux-一些概念" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p><ol><li><p>管理程序运行，为系统分配资源，处理程序间的通信</p></li><li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p></li><li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p></li><li><p>管理输入输出，将设备映射成设备文件</p></li><li><p>管理网络</p></li></ol><p>Shell</p><p>是一个命令解释器，是内核和用户之间的接口</p><p>是一个编程语言</p><blockquote><p>Shell 和内核的关系<br>Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>保护内核以免用户误操作造成危害。</p></blockquote><p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p><p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p><p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p><p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p><p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p><p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p><p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p><p>文件系统：<br>  指文件存在的物理空间。</p><p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p><p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p><p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p><p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p><blockquote><p>程序与进程的不同：<br>程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>进程：进程是动态的，是 Linux 系统的基本调度单位</p></blockquote><h2 id="Linux-常见目录说明"><a href="#Linux-常见目录说明" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量"><a href="#Linux-环境变量" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h2 id="考试复习"><a href="#考试复习" class="headerlink" title="考试复习"></a>考试复习</h2><p><a href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d&quot;&gt;VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/12/19/Machine-Learing/Regression/"/>
    <id>http://example.com/2023/12/19/Machine-Learing/Regression/</id>
    <published>2023-12-19T07:22:47.498Z</published>
    <updated>2023-12-19T07:25:37.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter-10-Regression"><a href="#Chapter-10-Regression" class="headerlink" title="Chapter 10 Regression"></a>Chapter 10 Regression</h2><p>本章概述<br>本章讲解的是线性模型，首先介绍了线性模型的基本定义和它的特点，并介绍了线性模型在回归和分类任务上如何使用。就线性判别分析这一经典模型介绍了其思想。接着，我们将二分类学习拓展到多分类学习，针对类别不平衡问题，给出了现在常用的方法。<br>3.1<br>基本定义<br>3.1.1<br>线性模型的形式<br>线性模型<br>：试图学得一个（通过属性的线性组合来预测输出值的）函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chapter-10-Regression&quot;&gt;&lt;a href=&quot;#Chapter-10-Regression&quot; class=&quot;headerlink&quot; title=&quot;Chapter 10 Regression&quot;&gt;&lt;/a&gt;Chapter 10 Regression&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/12/19/Machine-Learing/Lagrange-multiplier/"/>
    <id>http://example.com/2023/12/19/Machine-Learing/Lagrange-multiplier/</id>
    <published>2023-12-19T06:18:05.559Z</published>
    <updated>2023-12-19T06:20:53.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拉格朗日乘数简介"><a href="#拉格朗日乘数简介" class="headerlink" title="拉格朗日乘数简介"></a>拉格朗日乘数简介</h1><h3 id="作者：Steuard-Jensen"><a href="#作者：Steuard-Jensen" class="headerlink" title="作者：Steuard Jensen"></a>作者：Steuard Jensen</h3><p>拉格朗日乘子在多变量微积分中用于查找 受约束的函数的最大值和最小值（如“查找 沿给定路径的最高海拔“或”最小化成本 包含给定体积的盒子的材料“）。这是一个有用的 技术，但很多时候它教得很差，而且很差 理解。幸运的是，这个概述将有助于实现这个概念 它的应用更清晰一些。</p><p>以下是本次讨论的基本概述：</p><ul><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Basics">拉格朗日乘数何时为 有用？</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Milkmaid">一个典型的例子：“挤奶女工 问题”</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Graphical">图形灵感 方法</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Method">拉格朗日的数学 乘数</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Mathematical">形式化的数学 灵感</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#SeveralConstraints">几个约束条件 一次</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Meaning">乘数的含义</a>（受物理学和经济学的启发）</li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Examples">拉格朗日乘数的例子 行动</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#CalcVari">微积分中的拉格朗日乘子 变化（通常在物理学中）</a></li><li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#NoSlip">举个例子：滚动没有 滑 倒</a></li></ul><h2 id="拉格朗日乘数何时为-有用？"><a href="#拉格朗日乘数何时为-有用？" class="headerlink" title="拉格朗日乘数何时为 有用？"></a>拉格朗日乘数何时为 有用？</h2><p>最常见的一种 微积分的问题是求最大值或最小值（在 一般，“extrema”）的函数，但通常很难为被极端化的函数找到一个封闭形式。这样 当人们希望最大化或最小化时，往往会出现困难功能受固定外部条件或约束的约束。拉格朗日乘子法是解决这一类问题的有力工具 ，无需显式解决 条件，并使用它们来消除额外的变量。</p><p>更简单地说，问“我该怎么做”通常是不够的 尽量减少制造这个罐头所需的铝？（答案 这显然是“做一个非常非常小的罐头！你需要 问，“我如何在<em>确保罐头的同时尽量减少铝 能装10盎司的汤</em>吗？或者类似地，“我该怎么做 最大化我工厂的利润，<em>因为我只有 15,000 美元 投资</em>？或者举一个更复杂的例子，“如何 假设过山车会很快<em>到达地面 留在赛道上</em>？一般来说，拉格朗日乘数是 当某些变量在最简单的描述中很有用 问题因约束而变得多余。</p><h2 id="一个典型的例子：-“挤奶女工问题”"><a href="#一个典型的例子：-“挤奶女工问题”" class="headerlink" title="一个典型的例子： “挤奶女工问题”"></a>一个典型的例子： “挤奶女工问题”</h2><p>为了给出这种具体、直观的例证 问题，我们将考虑一个经典的例子，我相信是 被称为“挤奶女工问题”。可以这样表述：</p><p><img src="http://www.slimy.com/~steuard/teaching/tutorials/Milkmaid1.gif" alt="挤奶女工和河边奶牛的照片。"></p><p>现在是农场的挤奶时间，挤奶女工已经 被送到田里去拿当天的牛奶。她急于 回来和一个英俊的年轻牧羊人约会，所以她 想尽快完成自己的工作。但是，在之前 她可以收集牛奶，她必须冲洗掉她的桶 附近的河流。</p><p>就在她到达 <strong>M</strong> 点时，我们的女主角发现了 牛，在<strong>C</strong>点向下。因为时间匆忙，所以她 想从她所在的地方走最短的路径 河，然后是牛。那么<strong>P</strong>上的最佳点是什么 河岸让她冲洗水桶？（为了简单起见， 我们假设场是平坦均匀的，并且所有点 在河岸上同样好。</p><p>用更数学的术语来说，挤奶女工想要 求总距离 <strong>f</strong>（<strong>P</strong>） 的点 P 是最小值，其中 f（<strong>P</strong>） 是距离的总和 d（<strong>M，P</strong>） 从 <strong>M</strong> 到 <strong>P</strong> 和距离 d（<strong>P，C</strong>） 从 <strong>P</strong> 到 <strong>C</strong>（一条直线是 平坦场地上两点之间的最短距离）。 然而，事情并没有那么简单：如果这就是全部 问题，那么我们可以在线上的任何位置选择 <strong>P</strong> 在<strong>M</strong>和<strong>C</strong>之间，挤奶女工会笔直地走 对奶牛。但是我们必须施加<em>一个约束</em>，<strong>即 P</strong> 是河岸上的一个点。</p><p>为了在方程中表达该约束，我们可以描述 河岸的形状作为曲线满足一些 函数 g（x，y） &#x3D; 0。（例如，如果河流是 我们可能选择的抛物线 g（x，y） &#x3D; y - x2.如果是相反的 我们可以选择半径为R的圆形湖泊 g（x，y） &#x3D; x 2 + y 2 - r2.） 因此，从形式上讲，我们必须最小化功能 f（<strong>P</strong>） &#x3D; d（<strong>M，P</strong>） + d（<strong>P</strong>， <strong>C</strong>），受以下约束 g（<strong>P</strong>） &#x3D; 0.</p><h2 id="图形灵感-方法"><a href="#图形灵感-方法" class="headerlink" title="图形灵感 方法"></a>图形灵感 方法</h2><p>我们对这个问题的第一种思考方式可以得到 直接来自图片本身。我们想想象一下 挤奶女工可以得到任何固定的总距离 f（<strong>P</strong>），并且 使用该可视化来定位最佳点 <strong>P</strong>。如果我们 只关心 <strong>P</strong> 到 <strong>M</strong> 的距离，我们可能 将其想象为一组同心圆（常数曲线 距离d（<strong>M，P</strong>）：5米、10米、15米、 等）。一旦其中一个圆圈大到足以触及 河流，我们会认出它接触的点是最近的 河岸指向 <strong>M</strong>（其半径为最小值 距离）。</p><p>当然，对于大多数问题，常数 f（<strong>P</strong>） 的曲线 比一堆同心圆还要复杂！（通常要复杂<em>得多</em>。但是我们的具体例子是 几何学中一个晦涩难懂的事实使它变得简单：对于给定椭圆上的每一个点 <strong>P</strong>，与一个焦点的总距离 椭圆到 <strong>P</strong>，然后到另一个焦点正好是 相同。（你不需要知道这个事实从何而来 理解这个例子！但是你可以看到它为自己工作 在两个钉子的帮助下画出一个近乎完美的椭圆，一个 铅笔和一圈绳子。</p><p>在我们的问题中，这意味着挤奶女工可以到达 牛通过给定椭圆上任意点的相同数量 时间：椭圆是常数 f（<strong>P</strong>） 的曲线。因此 要在河岸上找到所需的点 <strong>P</strong>，我们必须 只需找到最小的椭圆，<strong>M</strong> 和 <strong>C</strong> 为 与河流曲线相交的焦点。需要明确的是， 只有曲线的“常数 f（<strong>P</strong>）”属性才是真正的 重要;这些曲线是椭圆这一事实只是一个幸运 方便（椭圆很容易绘制）。同样的想法会奏效 无论常数 f（<strong>P</strong>） 的曲线发生在什么形状 是。</p><p><img src="http://www.slimy.com/~steuard/teaching/tutorials/Milkmaid.gif" alt="相同的图片，但周围有省略号  挤奶女工和奶牛。"></p><p>右图显示了一系列较大的椭圆 和较大的尺寸，其病灶是 <strong>M</strong> 和 <strong>C</strong>，结束 与河岸<em>相切</em>的那个。 这是一个非常有意义的词！从图片中可以明显看出 “完美”的椭圆和河流是真正切线的 在理想点 <strong>P</strong> 处相互对立。从数学上讲， 这意味着椭圆的法向量位于同一位置 方向作为河岸的法向量。几分钟 想想这样的照片会让你相信这 事实并非特定于此问题：它是一个一般属性 每当你有限制时。这就是洞察力 将我们引向拉格朗日乘数的方法。</p><h2 id="拉格朗日的数学-乘数"><a href="#拉格朗日的数学-乘数" class="headerlink" title="拉格朗日的数学 乘数"></a>拉格朗日的数学 乘数</h2><p>在多变量微积分中，函数 h 的梯度 （写成 ∇h） 是曲线的法向量（分为两个 尺寸）或表面（在更高的维度上），其中 h 位于 常数：<strong>n</strong> &#x3D; ∇h（<strong>P</strong>）。法线的长度 向量无关紧要：∇h（<strong>P</strong>） 的任何常数倍数 也是一个正常的向量。在我们的例子中，我们有两个函数，其 法向量是平行的，所以</p><p>∇f（<strong>P</strong>） &#x3D; λ ∇g（<strong>P</strong>）。</p><p>未知常数乘数 λ 为 是必要的，因为两个梯度的大小可能是 不同。（请记住，我们只知道他们的方向是 相同。</p><p>在 D 维中，我们现在有 D+1 未知数中的 D+1 方程。D 未知数是 <strong>P</strong> 的坐标（例如 x、y、 和 z 表示 D &#x3D; 3），另一个是新的未知数 常数 λ。上面推导的梯度公式为 一个向量方程，因此它提供了 D 个约束方程。我 一旦在这一点上卡在考试中：不要让它发生 你！原始约束方程 g（<strong>P</strong>） &#x3D; 0 为 系统中的最后一个方程。因此，一般来说，一个独特的 解决方案存在。</p><p>与许多最大&#x2F;最小问题一样，确实存在以下情况 多种解决方案。甚至可以有无限数量的 如果约束条件特别退化，则解决方案：想象一下 如果挤奶女工和奶牛都已经站在 例如，一条笔直的河岸。在许多情况下， 拉格朗日乘数的实际值并不有趣，但是 在某些情况下，它可以提供有用的信息 （<a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html#Meaning">如下</a>所述）。</p><p>就是这样：这就是拉格朗日乘数的全部内容。只 将要极化的函数的梯度设置为等于 约束函数的梯度。你会得到一个矢量的 （代数）方程的价值，以及原始 约束方程 它们决定了解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拉格朗日乘数简介&quot;&gt;&lt;a href=&quot;#拉格朗日乘数简介&quot; class=&quot;headerlink&quot; title=&quot;拉格朗日乘数简介&quot;&gt;&lt;/a&gt;拉格朗日乘数简介&lt;/h1&gt;&lt;h3 id=&quot;作者：Steuard-Jensen&quot;&gt;&lt;a href=&quot;#作者：Steuard-J</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Machine-Learing SVM</title>
    <link href="http://example.com/2023/12/19/Machine-Learing/Machine-Learing-SVM/"/>
    <id>http://example.com/2023/12/19/Machine-Learing/Machine-Learing-SVM/</id>
    <published>2023-12-19T06:06:44.000Z</published>
    <updated>2023-12-19T06:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习的一般框架：<br>训练集 &#x3D;&gt; 提取特征向量 &#x3D;&gt; 结合一定的算法（分类器：比如决策树、KNN）&#x3D;&gt;得到结果</p><h2 id="Chapter-9-Support-Vector-Machines（SVM）"><a href="#Chapter-9-Support-Vector-Machines（SVM）" class="headerlink" title="Chapter 9 Support Vector Machines（SVM）"></a>Chapter 9 Support Vector Machines（SVM）</h2><p>支持向量机（support vector machines，SVM）是一种二分类模型，它将实例的特征向量映射为空间中的一些点，SVM 的目的就是想要画出一条线，以 “最好地” 区分这两类点，以至如果以后有了新的点，这条线也能做出很好的分类。SVM 适合中小型数据样本、非线性、高维的分类问题。</p><p>SVM 最早是由 Vladimir N. Vapnik 和 Alexey Ya. Chervonenkis 在1963年提出，目前的版本（soft margin）是由 Corinna Cortes 和 Vapnik 在1993年提出，并在1995年发表。深度学习（2012）出现之前，SVM 被认为机器学习中近十几年来最成功，表现最好的算法。</p><h3 id="SVM-基本概念"><a href="#SVM-基本概念" class="headerlink" title="SVM 基本概念"></a>SVM 基本概念</h3><p>将实例的特征向量（以二维为例）映射为空间中的一些点，如下图的实心点和空心点，它们属于不同的两类。SVM 的目的就是想要画出一条线，以“最好地”区分这两类点，以至如果以后有了新的点，这条线也能做出很好的分类。</p><p>Q1：能够画出多少条线对样本点进行区分？<br>答：线是有无数条可以画的，区别就在于效果好不好，每条线都可以叫做一个划分超平面。比如上面的绿线就不好，蓝线还凑合，红线看起来就比较好。我们所希望找到的这条效果最好的线就是具有 “最大间隔的划分超平面”。</p><p>Q2：为什么要叫作“超平面”呢？<br>答：因为样本的特征很可能是高维的，此时样本空间的划分就不是一条线了。</p><p>Q3：画线的标准是什么？&#x2F; 什么才叫这条线的效果好？&#x2F; 哪里好？<br>答：SVM 将会寻找可以区分两个类别并且能使间隔（margin）最大的划分超平面。比较好的划分超平面，样本局部扰动时对它的影响最小、产生的分类结果最鲁棒、对未见示例的泛化能力最强。</p><p>Q4：间隔（margin）是什么？<br>答：对于任意一个超平面，其两侧数据点都距离它有一个最小距离（垂直距离），这两个最小距离的和就是间隔。比如下图中两条虚线构成的带状区域就是 margin，虚线是由距离中央实线最近的两个点所确定出来的（也就是由支持向量决定）。但此时 margin 比较小，如果用第二种方式画，margin 明显变大也更接近我们的目标。</p><p>Q5：为什么要让 margin 尽量大？<br>答：因为大 margin 犯错的几率比较小，也就是更鲁棒啦。</p><p>Q6：支持向量是什么？<br>答：从上图可以看出，虚线上的点到划分超平面的距离都是一样的，实际上只有这几个点共同确定了超平面的位置，因此被称作 “支持向量（support vectors）”，“支持向量机” 也是由此来的。</p><h2 id="拉格朗日乘子法："><a href="#拉格朗日乘子法：" class="headerlink" title="拉格朗日乘子法："></a>拉格朗日乘子法：</h2><ul><li>拉格朗日乘子法（Lagrange multipliers）是一种寻找多元函数<strong>在一组约束下</strong>的<strong>极值</strong>的方法。</li><li>通过引入拉格朗日乘子，可将有 <code>d</code> 个变量与 <code>k</code> 个约束条件的最优化问题转化为具有 �+� 个变量的无约束优化问题求解。</li></ul><p>举个例子：</p><ul><li>这是一个等式约束，即约束条件是等式。当然约束条件也可以是不等式。</li><li>像这种需要<strong>在约束条件下求极值</strong>的问题，我们就可以用拉格朗日乘子法来做。</li></ul><h3 id="线性可分的SVM"><a href="#线性可分的SVM" class="headerlink" title="线性可分的SVM"></a>线性可分的SVM</h3><p>SVM的终极目标还是要解决数据线性不可分的情况。解决这种线性不可分的情况基本的思路有两种：</p><ul><li>加入松弛变量和惩罚因子，找到相对“最好”超平面，这里的“最好”可以理解为尽可能地将数据正确分类；</li><li>使用核函数，将低维的数据映射到更高维的空间，使得在高维空间中数据是线性可分的，那么在高维空间使用线性分类模型即可；</li></ul><ol><li>松弛变量和惩罚因子<br>1.1 定义<br>所谓线性不可分，说得形象一些，就是“你中有我，或者我中有你”，我们找不到一个超平面，恰好能把两类数据严格地分开。举个例子，Fig.1(a)中，白色数据元组中有一个点比较“另类”（我用文字标了出来），它跑到人家黑色元组的区域中去了，显然，如果这个点直接被忽略掉，那么分类效果是很好的（比如Fig.1(a)中的蓝色虚线），但是现在的情况就让人很难受，因为我们找不到一个超平面，恰好能把黑白两类数据分开。</li></ol><p>还有一种情况也比较有意思，就是现在数据还是线性可分的，比如Fig.1(b)，但是存在一个“异常点”（SVM中称之为outlier），如果忽略它，最佳分离超平面的效果非常好，但是如果按正常的套路训练的话，我们只能得到一个“差强人意”的结果。如Fig.1(b)所示，有它或没它，超平面的训练效果是有很鲜明对比的。</p><p>针对上面这两种情况，最直接的解决思路就是能不能适当的放宽数据点和边缘侧面之间的关系？还记得之前线性可分情况下的约束条件是这样的：</p><h3 id="总体线性可分，存在噪点使得线性不可分-x2F-局部采样线性不可分"><a href="#总体线性可分，存在噪点使得线性不可分-x2F-局部采样线性不可分" class="headerlink" title="总体线性可分，存在噪点使得线性不可分&#x2F;局部采样线性不可分"></a>总体线性可分，存在噪点使得线性不可分&#x2F;局部采样线性不可分</h3><h3 id="线性不可分的SVM"><a href="#线性不可分的SVM" class="headerlink" title="线性不可分的SVM"></a>线性不可分的SVM</h3><p>非线性 SVM： 特征空间 </p><p>总体思路：原始输入空间可以映射到某个高维特征空间，其中训练集是可分离的</p><p><img src="/../img/Machine-Learning/Non-linear-svm.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;机器学习的一般框架：&lt;br&gt;训练集 &amp;#x3D;&amp;gt; 提取特征向量 &amp;#x3D;&amp;gt; 结合一定的算法（分类器：比如决策树、KNN）&amp;#x3D;&amp;gt;得到结果&lt;/p&gt;
&lt;h2 id=&quot;Chapter-9-Support-Vector-Machines（SVM）&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学原理与实践实验</title>
    <link href="http://example.com/2023/12/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2023/12/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-12-06T03:12:41.000Z</published>
    <updated>2023-12-06T03:12:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.byhy.net/">白月黑羽 (byhy.net)</a></p><h3 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>本课程实验跟过去有所不同，因为是基于新设备的实验，所以没有往届可以参考的内容。</p><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><ol><li>基于密码实验实践教学工具套件，结合软件工程，分析该系统存在的设计与实现问题，提出修改和改进完善的方案。</li><li>通过一系列密码算法的独立编码接口封装实现（可借助于开源代码），熟悉并掌握常规的分组对称密码算法、序列对称密码算法、HASH函数、MAC函数、数字签名算法的接口编制方法，并能够利用可用编程接口针对文件加解密实现一个实用工具设计，要求体现：</li></ol><p>（1）各种密码技术在方案设计中得到正确、合理、合适的集成应用；</p><p>（2）方案设计体现安全性与方便性的结合与平衡。</p><p>（3）可以针对任意类型、任意大小的文件操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.byhy.net/&quot;&gt;白月黑羽 (byhy.net)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;实验介绍&quot;&gt;&lt;a href=&quot;#实验介绍&quot; class=&quot;headerlink&quot; title=&quot;实验介绍&quot;&gt;&lt;/a&gt;实验介绍&lt;/h3&gt;&lt;h4 id</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件工程复习</title>
    <link href="http://example.com/2023/12/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2023/12/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/</id>
    <published>2023-12-04T02:19:01.000Z</published>
    <updated>2023-12-04T02:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://blog.csdn.net/m0_52100140/article/details/122176673">山东大学软件工程期末复习知识点总结-CSDN博客</a></p><p><a href="https://www.kdocs.cn/l/ctpzm2DAMXy6">09_软件工程_山软智库知识见解_V1.1(1) (kdocs.cn)</a></p><p><a href="https://so.csdn.net/so/search?q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B&t=blog&u=weixin_45781228">软件工程- CSDN搜索</a></p><p><a href="https://blog.csdn.net/qq_50740678/article/details/125111898">2022软件工程期末复习笔记_Stephen Haw King的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_44220394/article/details/111315161">山东大学软件学院2020-2021 软件工程考试纲要与考题回忆_山东大学软件学院考试大纲-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_37989980/article/details/104470064">UML一一 类图关系 (泛化、实现、依赖、关联、聚合、组合)_uml类图关系-CSDN博客</a></p><p><a href="https://luckyray-fan.github.io/2019/12/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#SE">软件工程 | luckyray (luckyray-fan.github.io)</a></p><h2 id="Chapter-1-软件工程概述"><a href="#Chapter-1-软件工程概述" class="headerlink" title="Chapter 1 软件工程概述"></a>Chapter 1 软件工程概述</h2><h3 id="1-软件工程的定义、目标、方法"><a href="#1-软件工程的定义、目标、方法" class="headerlink" title="1.软件工程的定义、目标、方法"></a>1.软件工程的定义、目标、方法</h3><p>定义：两个关键词</p><p>理解问题的<strong>本质（nature）</strong>，并给出<strong>解决方案（solution）</strong>。</p><p>也就是说，用系统科学的方法解决问题（problem-solution）。</p><p>目标：设计和开发高质量的软件。（付出较低开发成本；达到要求的功能；取得较好的性能；开发的软件易于移植；只需较低的维护费用；能按时完成开发任务，及时交付使用）</p><p>方法：面向过程、面向对象等</p><h3 id="2-错误（error）、缺陷（fault）、失效-x2F-故障（Failure）"><a href="#2-错误（error）、缺陷（fault）、失效-x2F-故障（Failure）" class="headerlink" title="2.错误（error）、缺陷（fault）、失效&#x2F;故障（Failure）"></a>2.错误（error）、缺陷（fault）、失效&#x2F;故障（Failure）</h3><p>错误(error)：是在软件开发过程中人为产生的错误（需求说明中的错误，代码中的错误）。</p><p>故障(fault)：软件功能实现过程中产生的问题，是错误导致的结果，是软件中一个错误的表现（一个错误可能产生多个故障，静态存在）。</p><p>失效(failure)：系统违背了它应有的行为（在系统交付前或交付后被发现，动态存在）。</p><p>联系：人为原因导致程序错误；该错误编译到系统中导致系统故障；用户使用该系统时，因故障导致失效。故障是系统内部视图，从开发者的角度看待问题；失效是系统外部视图，从用户角度看到的问题。而且并不是所有的故障会导致失效，只要不执行故障代码，或者不进入某个特定状态，那么故障就不会使代码失效。</p><p>A fault: occurs when a human makes a mistake, called an error, in performing some software activities （误解需求&gt;与意图不符&gt;其他故障）<br>A failure: is a departure from the system’s required behavior（交付前&#x2F;交付后&#x2F;测试&#x2F;维护）</p><h3 id="3-软件质量从哪几个方面进行评价？什么是好的软件"><a href="#3-软件质量从哪几个方面进行评价？什么是好的软件" class="headerlink" title="3.软件质量从哪几个方面进行评价？什么是好的软件"></a>3.软件质量从哪几个方面进行评价？什么是好的软件</h3><h4 id="软件质量（quality-of-software）"><a href="#软件质量（quality-of-software）" class="headerlink" title="软件质量（quality of software）"></a>软件质量（quality of software）</h4><ul><li>The quality of the product 软件产品的质量(用户、开发者)</li><li>The quality of the process 过程的质量(CMM和ISO9000)</li><li>The quality of the product in the context of the business environment 商业环境下的质量 (RoI)</li></ul><p>从三个方面考虑软件的质量：产品的质量、生产该产品的过程的质量以及在产品将使用的商业环境背景下的质量。<br>3.1 产品(product)的质量</p><p>用户：从失效的数目和类型等外部特性进行评价，如果软件具有足够的功能，并且易于学习和使用；或者虽然难以学习和使用，但是由于功能值得这些付出，用户就断定软件是高质量的。<br>开发者：从故障的数目和类型等内部特征来作为产品质量的依据。</p><p>3.2 过程(process)的质量</p><p>有很多过程都会影响到最终的产品质量，只要有活动出了差错，产品的质量就会受到影响；开发和维护过程的质量与产品的质量是同等重要的。<br>几个量化模型：CMM、ISO 9000、SPICE（了解）</p><p>3.3 商业(business)环境背景下的质量</p><p>(1) 技术价值与商业价值的联系与区别：<br>技术价值：技术指标（速度，正确的运行时间，维护成本等）。<br>商业价值：机构对软件是否与其战略利益相吻合的一种价值评估。误区：技术质量不会自动转化为商业价值。<br>(2) 目标<br>将技术价值和商业价值统一起来，改进过程所带来的商业价值。</p><h3 id="4-现代软件工程包含的阶段："><a href="#4-现代软件工程包含的阶段：" class="headerlink" title="4.现代软件工程包含的阶段："></a>4.现代软件工程包含的阶段：</h3><p>现代软件工程大致包含的几个阶段及各个阶段文档：</p><p>（1）需求分析与定义：包括问题定义、可行性研究、需求分析【《SRS》即《软件需求规格说明书》】与复审（所有人）。</p><p>（2）系统设计：包括用户界面的设计【《SAD》即《软件系统结构图》：如何制作软件】与复审（开发者与客户）。</p><p>（3）程序设计：包括模块功能算法与数据描述设计【相关文档】与复审（开发者）。</p><p>（4）程序实现：包括编程与 debug【源代码和注释】与复审（开发者、码农）。</p><p>（5）单元测试：模块功能测试与性能测试【测试报告】与复审（测试团队）。</p><p>（6）集成测试：按照结构图进行测试【测试报告】与复审（测试团队）。</p><p>（7）系统测试：系统级功能的正确性。按《SRS》对系统总体功能进行测试与复审（开发者与客户）。</p><p>（8）系统交付：直接交付&#x2F;逐渐交付。交付产品【用户手册和操作手册】与复审。</p><p>（9）系统维修：修改软件的过程，为改错或满足新需求【维修报告】与复审（维修团队）。</p><h3 id="5-使现代软件工程变化的关键因素："><a href="#5-使现代软件工程变化的关键因素：" class="headerlink" title="5.使现代软件工程变化的关键因素："></a>5.使现代软件工程变化的关键因素：</h3><p>1.Time to market 软件交付市场的紧迫性<br>2.计算成本的下降<br>3.桌面计算机性能的提高<br>4.网络技术的发展<br>5.面向对象技术的发展<br>6.用户图形界面系统的普及<br>7.瀑布模型存在的问题<br><img src="/img/reason.png"></p><p>◆使现代软件工程实践发生变化的七个关键因素(by Wasserman)<br>（1）商用产品投入市场时间的紧迫性<br>（2）计算技术在经济中的转变：更低的硬件成本，更高的开发、维护成本<br>（3）功能强大的桌面计算的可用性<br>（4）广泛的局域网和广域网<br>（5）面向对象技术的采用及其有效性<br>（6）使用窗口、图标、菜单和指示器的图形用户界面<br>（7）软件开发瀑布模型的不可预测性<br>说明（了解）：瀑布模型沿袭了传统系统工程的大规模批发制造的理念，假定生产活动为线性，这与现代软件的生产方式相矛盾。不再是有足够的灵活性和适应性来满足并行开发或并行运行这样的商业软件需求，因此不可预测。<br>结论（了解）：对一个系统进行划分，以便并行地开发其子系统，需要一个与瀑布模型有很大不同的开发模型。</p><h3 id="6-软件工程的-Wasserman-规范解决软件工程面临的挑战"><a href="#6-软件工程的-Wasserman-规范解决软件工程面临的挑战" class="headerlink" title="6.软件工程的 Wasserman 规范解决软件工程面临的挑战"></a>6.软件工程的 Wasserman 规范解决软件工程面临的挑战</h3><p>(1) 抽象(abstraction)：基于某种概念层次上对问题的描述。它使我们将注意力集中在问题的关键方面而非细节。<br>(2) 分析、设计方法和符号描述系统：<br>使用标准表示来对程序进行描述。利于交流，利于建模并检查其完整性和一致性，利于对需求和设计部件进行重用。<br>(3) 用户界面原型化(prototyping)：<br>建立系统的小型版, 通常具有有限的关键功能,以利于用户评价和选择，证明设计或方法的可行性。<br>(4) 软件体系结构：定义一组体系结构单元及其相互关系集来描述软件系统。<br>单元分解的方法<br>（以下了解）<br>（1）基于功能的模块化分解: 基于指派到模块的功能。（2）基于数据的分解: 基于外部数据结构。<br>（3）面向事件的分解：基于系统必须处理的事件。（4）由外到内的分解：基于系统用户的输入。<br>（5）面向对象的设计：基于标识的对象的类以及它们之间的相互关系。<br>(5) 软件过程：软件开发活动中的各种组织及规范方法。<br>（以下了解）<br>因应用类型和组织文化之间的巨大差异,故难以对软件过程本身进行预先指定,也就是说:使过程本身规范化是不可能的.软件过程不可能以抽象和模块化的方式作为软件工程的基础。</p><p>(6) 重用或复用(reuse)：重复采用以前开发的软件系统中具有共性的部件, 用到新的开发项目中去 (注: 这里的重用绝不仅仅是源代码的重用)。<br>(7) 测度或度量(measurement)：通用的评价方法和体系，有助于使过程和产品的特定特性更加可见，包括量化描述系统、量化审核系统。<br>(8) 工具和集成环境：通过框架比较软件工程环境提供的服务，以决定其好坏。工具：由于厂商很少针对整个开发生命周期，因此对于工具的比较集中于小的活动集，例如测试或设计。<br>（以下了解）<br>工具集成中必须处理的五个问题：(by Wasserman)<br>平台集成、表示继承、过程集成、数据集成、控制集成。<br>总结：以上八个概念将软件工程作为一门科学学科，也是本书的八个线索。</p><h2 id="Chapter-2-建模过程和生命周期"><a href="#Chapter-2-建模过程和生命周期" class="headerlink" title="Chapter 2 建模过程和生命周期"></a>Chapter 2 建模过程和生命周期</h2><h3 id="1-软件过程："><a href="#1-软件过程：" class="headerlink" title="1.软件过程："></a>1.软件过程：</h3><p>什么是过程（process）？软件过程的重要性是什么？软件生命周期？</p><p>过程：软件开发过程中产生某种期望结果的一系列有序任务，涉及活动、约束和资源。</p><p>重要性：</p><p>1、通用性：软件过程可以让一系列开发活动保持一致性和结构性，因而具有了通用性。</p><p>2、指导性：软件过程使我们可以分析、检查、理解、控制和改善软件开发活动。</p><p>3、可以把获得的经验传递给其他人。</p><p>定义：<br>一组有序的任务，它涉及活动、约束和资源使用的一系列步骤，用于产生某种想要的输出。</p><p>重要性：</p><p>（1）它强制活动具有一致性和一定的结构。<br>（2）过程结构帮助开发人员分析、理解、控制和改进开发过程。<br>（3）有助于开发人员获取经验并把经验传授给他人。</p><h3 id="2-软件生命周期："><a href="#2-软件生命周期：" class="headerlink" title="2.软件生命周期："></a>2.软件生命周期：</h3><p>软件开发过程描述了软件产品从概念到实现、交付、使用和维护的整个过程，因此，有时把软件开发过程称为软件生命周期。</p><h3 id="3-软件过程模型："><a href="#3-软件过程模型：" class="headerlink" title="3.软件过程模型："></a>3.软件过程模型：</h3><h4 id="3-1-瀑布模型："><a href="#3-1-瀑布模型：" class="headerlink" title="3.1 瀑布模型："></a>3.1 瀑布模型：</h4><p>线性的安排每一个阶段，将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段。一个开发阶段必须在另一个开发阶段开始之前完成。</p><p>过程：</p><p><img src="/img/software-engineering/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png"></p><p>优点：</p><p>1、<strong>简单性</strong>：很容易向用户解释。</p><p>2、基础性：是其他更复杂模型的基础（通过加入额外的开发活动和循环）。</p><p>3、<strong>过程可观，方便监控</strong>。每一个过程活动都有与其相关联的里程碑和可交付产品，<strong>便于评估项目进度</strong>。</p><p>缺点：<br>（1）用户可能并不清楚所有的需求。<br>（2）没有迭代。软件是一个创造的过程, 不是一个制造的过程。软件变动时, 该模型无法处理实际过程中的重复开发问题。<br>（2）文档转换有困难。它说明了每一个活动的产品（例如，需求、设计或代码），但没有揭示一个活动如何把一种制品转化为另外一种制品（例如，从需求文档转化为设计文档）。</p><h4 id="3-2阶段化开发模型"><a href="#3-2阶段化开发模型" class="headerlink" title="3.2阶段化开发模型"></a>3.2阶段化开发模型</h4><p>定义：<br>系统被设计成部分提交, 每次用户只能得到部分功能, 而其他部分处于开发过程中。<br>产品 -&gt; 分阶段&#x2F;分功能 -&gt; 一部分一部分的交付</p><p>特点：<br>（1）大幅度缩短开发周期。从需求到系统交付的时间短 快速抢占市场 早些获得反馈，可以对产品进行修改。</p><p>（2）因为一边开发一边交付，所以有两个系统在并行运行。<br>运行系统&#x2F;产品系统：当前正在被客户和用户使用的系统。开发系统：准备代替现行产品系统的下一个版本。</p><p>分类：增量开发和迭代开发<br>①增量开发：系统需求按照功能分成若干子系统，开始建造的版本是规模小的、部分功能的系统，后续版本添加包含新功能的子系统，最后版本是包含全部功能的子系统集。<br>②迭代开发：系统开始就提供了整体框架，但是各部分功能都不够完善，后续版本会完善各部分的功能。</p><h4 id="3-3螺旋模型"><a href="#3-3螺旋模型" class="headerlink" title="3.3螺旋模型"></a>3.3螺旋模型</h4><p>含义：</p><p>有些类似于迭代开发模型，结合了迭代的思想，同时也结合了原型化的思想。将开发活动与风险管理结合起来, 以降低和控制风险。</p><p>适用范围于较大型软件工程项目。</p><p><img src="/img/software-engineering/spiral-model.png"></p><p>第一轮迭代产生操作概念，第二轮是需求，后面依次是设计和测试。<br>每轮都进行风险分析，评估不同选择，通过原型验证可行性，并决定如何消除或降低风险。<br>一圈代表一次迭代 。每一次迭代都根据需求和约束进行风险分析，以权衡不同选择，并且在确定选择之前，通过原型化验证可行性和期望度。</p><p><em><strong>*螺旋模型四个象限的任务及四重循环的含义？*</strong></em></p><p>螺旋模型每次迭代有四个任务，依次是（四个象限）：</p><p>计划、目标&#x2F;可选方案、风险评估、 开发与测试。</p><p>螺旋模型共有四次迭代，依次是（每个象限的四重循环）：</p><p>操作概念、软件需求、软件设计、开发与测试。</p><h4 id="3-4敏捷开发："><a href="#3-4敏捷开发：" class="headerlink" title="3.4敏捷开发："></a>3.4敏捷开发：</h4><p>敏捷方法的四条原则：<br>①个体和交互的价值胜过过程和工具。<br>②可以工作的软件胜过面面俱到的文档。<br>③客户合作胜过合同谈判。<br>④响应变化胜过遵循计划。</p><p>强调敏捷方法的四个特性：交流、简单性、勇气以及反馈</p><p>敏捷开发过程的几种方法：<br>①极限编程(XP)：激发人员创造性，使管理负担最小的一组技术，是敏捷方法中最主<br>要的流派。（稍后有详细介绍）<br>②Crystal （水晶球法）：每一个不同的项目都需要一套不同的策略、约定和方法论。<br>③SCRUM（并列争球法）：使用迭代的方法，其中把每 30 天一次的迭代称为一个“冲刺”，并按需求的优先级别来实现产品。<br>④Adaptive Software Development(ASD) (自适应软件开发)</p><h4 id="3-5-统一软件开发过程（Rational-Unified-Process-RUP"><a href="#3-5-统一软件开发过程（Rational-Unified-Process-RUP" class="headerlink" title="3.5 统一软件开发过程（Rational Unified Process,RUP)"></a>3.5 统一软件开发过程（Rational Unified Process,RUP)</h4><p>迭代开发的一种变体模型。</p><p>描述了如何有效利用商业的、可靠的方法开发和deploy，是一种重量级的过程。</p><p>什么是UP， RUP，进化式迭代等市场流行的过程模型?</p><p>UP模型即统一过程模型，是一种用例驱动的，以基础架构为中心的，迭代式，增量式的软件开发模型。</p><p>该模型的四个阶段：</p><p>开始阶段、确立阶段、构建阶段和移交阶段。</p><p>该模型的六道核心工序：</p><p>业务模型工序、需求工序、分析设计工序、实现工序、测试工序和部署工序。</p><p>RUP模型是IBM提出的提供支持和包装的UP模型。</p><p>迭代开发是统一过程模型（RUP）的关键实践。</p><p>开发被组织成一系列固定的短期小项目。</p><p>每次迭代都产生经过测试、集成并可执行的局部系统。</p><p>每次迭代都具有各自的需求分析、设计、实现和测试。</p><p>随着时间和一次次迭代，系统增量式完善。</p><h2 id="Chapter-3-计划和管理项目"><a href="#Chapter-3-计划和管理项目" class="headerlink" title="Chapter 3 计划和管理项目"></a>Chapter 3 计划和管理项目</h2><h3 id="1-关键概念介绍"><a href="#1-关键概念介绍" class="headerlink" title="1.关键概念介绍"></a>1.关键概念介绍</h3><p><strong>项目进度（Project Schedule）</strong><br>列举项目各个阶段 -&gt; 分解成离散的任务或者活动，来描述特定项目的软件开发周期。以及对各个活动完成时间及整个项目完成时间的初步估算。</p><p><strong>活动</strong><br>是项目的一部分，在一段时间内发生。</p><p><strong>里程碑</strong><br>是活动的完成，就是每一个特定的时刻，向开发人员和客户指明项目已经进展到了可测量的级别。</p><p>按照活动和里程碑的概念，可以把开发分为阶段，阶段包含步骤，步骤包含活动。<br>每个活动都是一个可测量事件，这样我们可以确定活动完成的客观标准。<br>任何一个活动的终止都可以是一个里程碑。</p><h3 id="2-项目活动图"><a href="#2-项目活动图" class="headerlink" title="2.项目活动图"></a>2.项目活动图</h3><p>含义：描述了不同活动之间的依赖性，表明了活动的执行顺序。</p><p><img src="/img/software-engineering/%E9%A1%B9%E7%9B%AE%E6%B4%BB%E5%8A%A8%E5%9B%BE.png"></p><ul><li><p>Real time (actual time) 真实时间：完成活动所需要的时间</p></li><li><p>Available time 可用时间：完成活动可用的时间量</p></li></ul><p><strong>关键路径</strong>：从起点到终点花费最长时间的路径。</p><p>冗余时间：在不耽误总体进度的前提下，最早开始工作和最晚开始工作时间的差值。</p><p>求关键路径：先求每个结点的最早开始时间，求出整个项目的最长花费时间。再用最长花费时间倒退，从最后一个结点开始，求每个结点的最晚开始时间。用最晚开始时间减去最短开始时间得到时间差，时间差为0的在关键路径上。</p><h3 id="3-团队组织的构成"><a href="#3-团队组织的构成" class="headerlink" title="3.团队组织的构成"></a>3.团队组织的构成</h3><p>(1) 主程序员负责制（Chief Programmer Team）<br>由一个主程序员负责系统设计和开发，其他的成员向其汇报，主程序员对每一个决定有绝对决策权。<br>优势：<br>使交流最小化<br>迅速做出决定</p><p>缺点：<br>创造性低<br>对主程序员要求高，个人主观性强<br>(2) 忘我方法（Egoless Approach）<br>每个成员平等的承担责任，而且过程与个人是分开的；批评是针对产品和结果的，不针对个人的。</p><h3 id="4-工作量估算"><a href="#4-工作量估算" class="headerlink" title="4.工作量估算"></a>4.工作量估算</h3><p><strong>COCOMO 模型</strong>的三个阶段的基本工作原理和含义：</p><p>构建成本模型。COCOMO 模型的关键在于针对项目开发的不同阶段来设置工作量的衡量标准，逐步细化，逐渐准确。: E &#x3D; bSc m(X)</p><p>阶段一：应用组合&#x2F;组装。用原型化项目来解决高风险相关的活动。通常构建原型以解决包含用户界面、软件和系统交互、性能和技术成熟性等方面在内的高风险问题。在阶段一，COCOMOⅡ用<strong>应用点</strong>来估算规模。<br>阶段二：早期设计阶段。探索几种可选的体系结构和操作的概念。在阶段二，COCOMOⅡ使用<strong>功能点</strong>对规模进行测量。<br>阶段三：即后体系结构阶段，开发已经开始，而且已经知道了更多的信息。在这个阶段，可以根据功能点或<strong>代码行</strong>来进行规模估算，而且可以较为轻松地估算很多成本因素。</p><h3 id="5-软件风险"><a href="#5-软件风险" class="headerlink" title="5.软件风险"></a>5.软件风险</h3><p>概念：软件生产过程中不希望看到的，有负面结果的事件<br>方面：风险损失，风险概率（相乘为风险暴露（Risk Exposure），即数学期望）</p><h4 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h4><p>风险评估：风险识别（checklist），风险分析，风险优先级分配<br>风险控制：风险降低，风险管理计划，风险化解</p><p>降低风险的策略：</p><p>1、避免风险：改变功能和性能需求，使风险没机会发生。</p><p>2、转移风险：通过把风险分配到其他系统中，或者购买保险以便在风险成为事实时弥补经济上的损失。</p><p>3、假设风险：用项目资源，接受并控制风险。比如在开发时主动有意识地进行测试。</p><h3 id="典型例题："><a href="#典型例题：" class="headerlink" title="典型例题："></a>典型例题：</h3><p>a.名词解释：<br>项目进度（Project Schedule）<br>b. 简述题：<br>COCOMO2 模型的工作原理<br>主程序员负责制的优缺点<br>c. 综合应用题：<br>找出关键路径，最早，最晚开始时间（解析见重点内容解析部分）</p><h2 id="Chapter-4-需求获取"><a href="#Chapter-4-需求获取" class="headerlink" title="Chapter 4 需求获取"></a>Chapter 4 需求获取</h2><h3 id="1-需求的含义"><a href="#1-需求的含义" class="headerlink" title="1.需求的含义"></a>1.需求的含义</h3><p>定义：需求是对****来自用户*<em><strong>的</strong></em>*关于软件系统的期望行为****的综合描述，涉及系统的对象、状态、 约束、功能等。<br>任务：理解客户的问题和需求，针对的是客户和问题，不是问题和实现</p><h3 id="2-需求过程"><a href="#2-需求过程" class="headerlink" title="2.需求过程"></a>2.需求过程</h3><p><img src="/img/software-engineering/capture-requirement-process.png"></p><p>①原始需求获取：客户给出的需求<br>②问题分析：理解需求并通过建模或模型化方式进行描述<br>③规格说明草稿：利用符号描述系统将定义规范化表示<br>④需求核准：开发人员与客户进行核准<br>⑤形成<strong>软件规格说明</strong>（SRS）</p><h3 id="3-需求的优先级划分"><a href="#3-需求的优先级划分" class="headerlink" title="3.需求的优先级划分"></a>3.需求的优先级划分</h3><p><em><strong>*举例说明获取需求时，若有冲突发生时，如何考虑*</strong></em></p><p>当进行需求的引出时，可能会碰到大家对“需求是什么”存在分歧，此时采用对需求进行优先级划分的方法是有效的</p><p>①必须要被满足的需求<br>②非常值得做但是不是必须的需求<br>③可选的需求（可做可不做）</p><h3 id="4-需求的分类"><a href="#4-需求的分类" class="headerlink" title="4.需求的分类"></a>4.需求的分类</h3><p>①功能需求：描述系统<strong>内部功能</strong>或系统与<strong>外部功能</strong>的交互作用，涉及系统输入应对、实体状态变化、输出结果、设计约束、过程约束等。<br>②设计约束：已经做出的设计决策或限制问题解决方案集的设计决策。涵盖<strong>物理环境、接口、用户</strong>等方面。<br>③过程约束：对用于构建系统的技术和资源的限制，涵盖<strong>资源、文档</strong>等方面。<br>④非功能需求：描述软件方案必须具备的某些质量特征，例如<strong>系统性能、安全性、响应时间</strong>等。</p><h3 id="5-需求文档分类"><a href="#5-需求文档分类" class="headerlink" title="5.需求文档分类"></a>5.需求文档分类</h3><p>(1) 需求定义<br>完整罗列了客户期望的需求</p><p>(2) 需求规格说明（SRS）<br>将需求重述为关于<strong>要构建的系统将如何运转</strong>的规格说明。</p><h3 id="6-UML图"><a href="#6-UML图" class="headerlink" title="6. UML图"></a>6. UML图</h3><h4 id="1-数据流图"><a href="#1-数据流图" class="headerlink" title="1.数据流图"></a>1.数据流图</h4><p>数据流图（DFD）：<br>目标：描述数据进入、转换、离开系统，重点在于<strong>数据流</strong>，而不是控制流</p><p>图符：</p><p>椭圆表示一个加工或功能，它转换数据。<br>箭头表示数据流，其中，进入椭圆的箭头表示其功能的输入，从椭圆输出的箭头表示其功能的输出。<br>持久性数据保存在数据存储中，它是一个正式的库或信息库，表示为两个平行线。<br>数据源或者数据接收器表示为矩形，称为参与者，提供输入数据或接受输出结果的实体。</p><p><img src="/img/software-engineering/DFD-%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png"></p><h4 id="2-UML活动图"><a href="#2-UML活动图" class="headerlink" title="2.UML活动图"></a>2.UML活动图</h4><p>用于系统功能建模，强调的是对象间的<strong>控制流</strong>。</p><h4 id="3-UML类图"><a href="#3-UML类图" class="headerlink" title="3. UML类图"></a>3. UML类图</h4><p>强调系统结构的图形表示范型，对系统的词汇建模，简单协作以及对逻辑数据库模式进行建模</p><h4 id="4-UML状态图"><a href="#4-UML状态图" class="headerlink" title="4. UML状态图"></a>4. UML状态图</h4><p>展示对象可能的状态，以及由于各种原因的状态转移。</p><p>对接口、类、协作行为进行建模。</p><h4 id="5-掌握用例图的组成和画法，用例的几个要素的含义。-x2F-x2F-掌握用例图的实例解析方法"><a href="#5-掌握用例图的组成和画法，用例的几个要素的含义。-x2F-x2F-掌握用例图的实例解析方法" class="headerlink" title="5.掌握用例图的组成和画法，用例的几个要素的含义。 &#x2F;&#x2F;掌握用例图的实例解析方法"></a>5.掌握用例图的组成和画法，用例的几个要素的含义。 &#x2F;&#x2F;掌握用例图的实例解析方法</h4><p>用例图：表示一个用户、外部系统或其他实体和在开发系统的关系<br>①用例<br>描述系统提供的特定功能，用椭圆表示：<br>②执行者<br>和系统交互的实体（用户、设备或其他），用小人表示：<br>③包含<br>对已定义用例的复用，用以提取公共行为，用带箭头的实线表示：<br>④扩展<br>对一个用例的扩展使用，用以下图标</p><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>短暂的非结构画的使用关系。只有在调用方法时才存在依赖关系，也就是说其生命周期在软件运行期间才存在。</p><ul><li>依赖关系：指的是类与类之间的联接。依赖关系表示<code>一个类依赖于另一个类的定义</code>。一般而言，依赖关系在Java语言中体现为<code>成员变量、局域变量、方法的形参、方法返回值</code>，或者对<strong>静态方法的调用。</strong></li></ul><p>对象约束语言（OCL）<br>定义：表述对象模型（例如，ER 图）上的约束<br>示例：此处 OCL 要求 pno&gt;&#x3D;0</p><h3 id="Chapter-5-设计体系结构"><a href="#Chapter-5-设计体系结构" class="headerlink" title="Chapter 5 设计体系结构"></a>Chapter 5 设计体系结构</h3><h4 id="1-软件体系结构"><a href="#1-软件体系结构" class="headerlink" title="1. 软件体系结构"></a>1. 软件体系结构</h4><p>软件体系结构：一种软件的解决方案，用于将系统分解为单元子系统，以及这些单元如何相互关联，还包括这些单元所有的外部特性。</p><p><em>IEEE610. 12—1990：体系结构是以构件、构件之间的关系、构件与环境之间的关系为内容的某一系统的基本组织以及指导上述内容设计与演化的原理，即*<em>软件体系结构&#x3D;{构件，连接件，环境，原理}</em></em></p><p><em>Bass的定义：系统的一个或多个结构，包括*<em>软件构件、构件的外部可视属性和构件之间的关系</em></em></p><p>*国内普遍认可的看法：可以将体系结构定义为构件、连接件和约束。软件体系结构指可预制和可重构的软件框架结构。<br><strong>体系结构(Architecture)&#x3D;构件(Components)+连接件(Connectors)+约束(Constraints)</strong></p><h4 id="2-设计模式？设计公约？设计？"><a href="#2-设计模式？设计公约？设计？" class="headerlink" title="2. 设计模式？设计公约？设计？"></a>2. 设计模式？设计公约？设计？</h4><p>设计：将需求中的问题转变成软件解决方案的创造性过程。</p><p>设计模式：针对单个软件模块给出的一般性解决方案，提供较低层次的设计决策。</p><p>设计公约：一系列设计和决策的集合，用于提高系统某方面的设计质量。</p><p>创造性设计：脑海中突然闪现的idea</p><p>设计原则：对好的设计的特征描述，而不是如何进行设计的说明性建议。</p><h4 id="3-软件设计过程模型的几个阶段"><a href="#3-软件设计过程模型的几个阶段" class="headerlink" title="3. 软件设计过程模型的几个阶段"></a>3. 软件设计过程模型的几个阶段</h4><p><img src="/img/software-engineering/SAD.png"></p><p>1、建模：尝试可能的分解，根据需求描述的系统的关键特性等确定软件体系结构。</p><p>2、分析：分析初步的体系结构，主要关注系统级别的决策，如软件的质量、性能等。</p><p>3、文档化：确定各个不同的模型视图。</p><p>4、复审：检查文档是否满足了所有需求。<strong>（意义：大幅降低软件开发的维修成本）</strong></p><p>5、最终产出：软件体系结构文档，即SAD。用来和开发团队中其他人员交流系统级别设计决策的有力工具。</p><h5 id="软件过程中复审的概念，设计复审的重要性。"><a href="#软件过程中复审的概念，设计复审的重要性。" class="headerlink" title="软件过程中复审的概念，设计复审的重要性。"></a>软件过程中复审的概念，设计复审的重要性。</h5><p>复审定义：检查文档是否满足所有功能及质量需求。</p><p>(1) 验证 verification：确保设计遵循良好的设计原则，设计文档满足阅读者的需要。验证检查某样东西是否符合之前已定好的标准，就是要用数据证明我们是不是在正确的制造产品。更注重过程正确性，强调做得正确</p><p>(2)确认 validation：确认设计能够满足用户需求。确认检查软件在最终的运行环境上是否达到预期的目标，就是要用数据证明我们是不是制造了正确的产品。更注重结果正确性，强调做的东西正确。</p><p>(3) 验证更多是从开发商角度来做评审、测试来验证产品需求、架构设计等方面是否和用户要求一致，确认更多是从用户的角度或者可以是模拟用户角度来验证产品是否和自己想要的一致。</p><p>重要性：</p><p>(1) 复审中批评和讨论是“忘我”的，能将开发人员更好地团结在一起，提倡并增强了成员之间的交流</p><p>(2) 在评审过程中故障的改正还比较容易，成本还不高，在这时候发现故障和问题会使每一个人受益。</p><p>重要性：</p><p>1、可以和用户一起检查软件的概要设计。</p><p>2、可以向开发者呈现并明确软件的技术设计。</p><p>3、程序员通过复审可以在下一阶段的工程实施前得到本阶段工作的反馈。</p><h4 id="4-论述设计用户界面应考虑的问题。-非重要"><a href="#4-论述设计用户界面应考虑的问题。-非重要" class="headerlink" title="4. 论述设计用户界面应考虑的问题。*非重要"></a>4. 论述设计用户界面应考虑的问题。*非重要</h4><p>设计界面要注意解决的要素:</p><p>1、隐喻：可识别和学习的基本术语、图像和概念等。</p><p>2、思维模型：数据、功能、任务的组织与表示。</p><p>3、模型的导航规则：怎样在数据、功能、活动和角色中移动及切换。</p><p>4、外观：系统向用户传输信息的外观特征。</p><p>5、感觉：向用户提供有吸引力的体验的交互技术。</p><p>文化问题：</p><p>设计界面时需要考虑使用系统的用户的信仰、价值观、道德规范和传统等因素。</p><p>1、使用国际设计&#x2F;无偏见设计，排除特定的文化参考或偏见。</p><p>2、采用定制界面，使不同用户看到不同的界面 。</p><p>用户偏好：</p><p>为具有不同偏好的人选择备选界面。</p><h3 id="Chapter-6-模块设计"><a href="#Chapter-6-模块设计" class="headerlink" title="Chapter 6 模块设计"></a>Chapter 6 模块设计</h3><h4 id="1-面向对象设计的基本原则"><a href="#1-面向对象设计的基本原则" class="headerlink" title="1. 面向对象设计的基本原则"></a>1. 面向对象设计的基本原则</h4><ul><li>Modularity 模块化（耦合、内聚）</li><li>Interfaces 接口</li><li>Information hiding 信息隐藏</li><li>Incremental development 增量式开发</li><li>Abstraction 抽象</li><li>Generality 通用性</li></ul><h4 id="2-模块独立性、耦合与内聚的概念及各个层次划分？"><a href="#2-模块独立性、耦合与内聚的概念及各个层次划分？" class="headerlink" title="2.模块独立性、耦合与内聚的概念及各个层次划分？"></a>2.模块独立性、耦合与内聚的概念及各个层次划分？</h4><p>模块的独立性取决于两个部分：内聚和耦合，我们追求的是高内聚低耦合。</p><p>内聚是软件内部组成成分的关联程度。</p><p>耦合指的是两个软件间的关联程度。</p><h4 id="3-举例说明耦合与内聚的基本分类。以及各个分类的含义与特征"><a href="#3-举例说明耦合与内聚的基本分类。以及各个分类的含义与特征" class="headerlink" title="3.举例说明耦合与内聚的基本分类。以及各个分类的含义与特征"></a>3.举例说明耦合与内聚的基本分类。以及各个分类的含义与特征</h4><p>内聚：</p><p><img src="/img/software-engineering/Cohesion.png"></p><p>1、偶然内聚：模块各部分不相关，只为方便或偶然性原因放入同一模块。比如强行放入一个类中没有任何关系的方法。</p><p>2、逻辑内聚：模块中各部分只通过代码的逻辑结构相关联，会共享程序状态和代码结构，但相对于数据、功能和目标的内聚比较弱。 比如因为有相同的某个计算步骤而放在?一起的两个没有关系的计算。</p><p>3、时间内聚：部件各部分要求在同一时间完成或被同一任务使用而形成联系。比如初始化模块中需要完成变量赋值、打开某文件等工作。</p><p>4、过程内聚：要求必须按照某个确定的顺序执行一系列功能，模块内功能组合在一起只是为了确保这个顺序。其与时间性内聚相比优点在于其功能总是涉及相关活动和针对相关目标，如写数据-&gt;检查数据-&gt;操作数据这一过程。</p><p>5、通讯内聚：各部分访问和操作同一数据集，如来自于同一传感器的所有不相干数据。</p><p>6、顺序内聚 ：各部分有输入输出关系，操作同一数据集，并且操作有顺序。</p><p>7、功能内聚：理想情况，各部分组成单一功能，且每个处理元素对功能都是必须的，每个元素执行且只执行设计功能，如一个简单的输出程序。</p><p>8、信息内聚：在功能内聚的基础上，进行数据抽象化和基于对象的设计。</p><p>耦合：</p><p><img src="/img/software-engineering/coupling.png"></p><p>1、内容耦合：A模块实际上修改了B模块，B模块完全依赖于A模块。</p><p>2、公共耦合：不同模块可以从公共数据存储区来访问和修改数据。</p><p>3、控制耦合：一个模块通过传递参数或返回代码来控制另一个模块的活动。</p><p>4、标记&#x2F;特征耦合：使用一个复杂的数据结构进行模块间传递消息，并且传递的是该数据结构本身。比如将一个数组传递给另一个模块，数组仅用于计算而非控制。</p><p>5、数据耦合：模块间传递的是数据值，是最受欢迎的耦合。</p><p>6、非耦合：模块相互之间没有信息传递，但是不太现实。</p><p>什么是设计模式？</p><p>设计模式：</p><p>一种针对软件模块给出的一般性解决方案，提供较低层次的设计决策。</p><p>面向对象设计模式分为：</p><p>模板方法模式 抽象类定义模板方法来实现一个操作中共同的步骤，并声明抽象的原语操 作来表示变化的部分</p><p>工厂方法模式 封装创建对象的代码</p><p>策略模式 在运行时选择算法。运行结束根据结果选择最好的算法</p><p>装饰者模式 运行时扩展对象的功能。给对象添加的新功能放入装饰者类</p><p>观察者模式 类似于管程思想</p><p>组合模式 异构的对象的汇集</p><p>访问者模式  将组合对象的新功能集中并封装于自身的类中</p><p>OO设计的基本原则？</p><p>1、单一职责原则</p><p>2、重用原则</p><p>3、开闭原则</p><p>4、里氏替换原则</p><p>5、依赖倒转原则</p><p>6、接口隔离原则</p><p>7、迪米特法则</p><p>OO开发有何优势？</p><p>1、语言的一致性：</p><p>采用相同的语义结构（类、对象、接口、属性、行为）描述问题和解决方案。</p><p>2、软件开发过程的一致性：</p><p>从需求分析和定义、高层设计、底层设计到编码和测试等，所有的过程都采用相同的语义结构。</p><p>OO开发过程有几个步骤？</p><p>1、面向对象需求分析。</p><p>2、面向对象高层设计。</p><p>3、面向对象底层设计。</p><p>4、面向对象编程。OOP</p><p>5、面向对象测试。</p><h3 id="Chapter-7-编写程序"><a href="#Chapter-7-编写程序" class="headerlink" title="Chapter 7 编写程序"></a>Chapter 7 编写程序</h3><h4 id="1-一般性的编程原则应该从哪三个方面考虑？"><a href="#1-一般性的编程原则应该从哪三个方面考虑？" class="headerlink" title="1. 一般性的编程原则应该从哪三个方面考虑？"></a>1. 一般性的编程原则应该从哪三个方面考虑？</h4><p>编程原则应该从控制结构，算法和数据结构三方面来考虑。</p><p>控制结构：程序如何传递数据。</p><p>算法：程序如何处理数据。</p><p>数据结构：程序如何储存数据。</p><h4 id="2-在编写程序内部文档时，除了HCB头注释块header-comment-block外，还应添加什么注释信息？注意什么？"><a href="#2-在编写程序内部文档时，除了HCB头注释块header-comment-block外，还应添加什么注释信息？注意什么？" class="headerlink" title="2. 在编写程序内部文档时，除了HCB头注释块header comment block外，还应添加什么注释信息？注意什么？"></a>2. 在编写程序内部文档时，除了HCB头注释块header comment block外，还应添加什么注释信息？注意什么？</h4><p>（1） 头注释块（header comment block，HCB）<br>将一组注释信息放在每个构件的开始部分，包含构件名，作者，配置在整个系统设计的哪个部分上，何时编写和修改的，为什么要有该构件，构件是如何使用数据结构，算法和控制的。</p><p>（2） 其他程序注释——</p><ul><li>解释性注释：本段源代码是在做什么的注释。</li><li>分解性注释：通过注释将代码分解成多个段。</li><li>版本注释：随着时间进行修改的记录。</li></ul><p>（3） 有意义的变量名和语句标记<br>命名时尽量用有意义的变量名进行命名</p><p>（4） 排版格式以增强理解<br>注意缩进和间隔来反映基本的控制结构。</p><p>（5）文档化数据</p><p>注意的问题：</p><p>1、分段注释</p><p>2、注释和代码要一并更改。</p><p>3、注释要有意义。</p><p>4、一边写代码一边写注释，不要写完代码回过头来添加注释。</p><h4 id="3-什么是极限编程-XP-以及派对编程？"><a href="#3-什么是极限编程-XP-以及派对编程？" class="headerlink" title="3. 什么是极限编程(XP)? 以及派对编程？"></a>3. 什么是极限编程(XP)? 以及派对编程？</h4><p>极限编程：</p><p>极限编程（XP）是一种<strong>轻量级的软件开发方法</strong>，属于敏捷开发方法。</p><p>主要特征：适应环境变化和需求变化，充分发挥开发人员的主动精神。</p><p>它将复杂的开发过程分解为一个个相对比较简单的小周期，通过交流、反馈等方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。</p><p>派对编程：</p><p>主要的敏捷开发方法之一，其开发方式是<strong>两个程序员共同开发程序，且角色分工明确</strong>。一个负责编写程序，另一个负责复审与测试。两人<strong>定期交换角色</strong>。</p><h3 id="Chapter-8-测试程序"><a href="#Chapter-8-测试程序" class="headerlink" title="Chapter 8  测试程序"></a>Chapter 8  测试程序</h3><h4 id="1-产生缺陷的原因"><a href="#1-产生缺陷的原因" class="headerlink" title="1. 产生缺陷的原因"></a>1. 产生缺陷的原因</h4><p>(1)软件本身：错误的设计、错误的代码、错误的设计实现。</p><p>(2)客户不清晰的需求：需求错误、Missing需求、不可实现的需求；</p><p>(3)其他原因，如项目的规模，众多的参与者导致的复杂性。</p><h4 id="2-有几种主要的缺陷类型？"><a href="#2-有几种主要的缺陷类型？" class="headerlink" title="2. 有几种主要的缺陷类型？"></a>2. 有几种主要的缺陷类型？</h4><p>1、算法缺陷</p><p>算法的某些处理步骤或逻辑有问题，以至于软件部件对给定的输入数据无法产生正确的输出。</p><p>2、计算和精度缺陷</p><p>算法或公式在实现时出现错误，或计算结果的精度达不到要求。</p><p>3、文档缺陷</p><p>文档和实际实现程序不一致。</p><p>4、过载缺陷&#x2F;压力缺陷</p><p>程序运行时，对数据结构的使用超过了其承载能力。（数组越界、缓冲区溢出等）</p><p>5、能力缺陷&#x2F;边界缺陷</p><p>程序活动到达极限时，系统性能会变得不可接受。</p><p>6、计时缺陷&#x2F;协调缺陷</p><p>多个同时执行或者一个仔细定义的顺序执行的进程之间（管理）协调不当。</p><p>7、硬件和系统软件缺陷</p><p>提供的硬件或者系统软件并没有按照文档中的操作条件或步骤运作。</p><p>8、代码的标准和过程缺陷。</p><p>代码没有遵循组织机构的标准和过程。</p><h4 id="3-什么是正交缺陷分类？"><a href="#3-什么是正交缺陷分类？" class="headerlink" title="3. 什么是正交缺陷分类？"></a>3. 什么是正交缺陷分类？</h4><p>被分类的任何一项故障都只属于一个类别，则分类方案是正交的。如果故障属于不止一个类，则失去了度量的意义。</p><h4 id="4-测试的各个阶段及其任务？"><a href="#4-测试的各个阶段及其任务？" class="headerlink" title="4. 测试的各个阶段及其任务？"></a>4. 测试的各个阶段及其任务？</h4><p>1、单元测试：将每个程序构件与系统中的其他构件隔离，对其本身进行测试。</p><p>2、集成测试：验证系统构件是否能够按照系统和程序设计规格说明中描述的那样共同工作的过程。</p><p>3、功能测试：对系统进行评估，以确定集成的系统是否确实执行了需求规格说明中描述的功能，其结果是一个可运转的系统。</p><p>4、性能测试：测试系统的软硬件性能是否符合需求规格说明文档。 其结果是一个确认的系统。</p><p>5、验收测试：确定系统是按照用户的期望运转的。</p><p>6、安装测试：确保系统在实际环境中按照应有的方式运转。</p><p>7、系统测试：功能测试、性能测试、验收测试和安装测试统称为系统测试。</p><p><img src="/img/software-engineering/Testing-step.png"></p><h4 id="5-黑盒、白盒测试"><a href="#5-黑盒、白盒测试" class="headerlink" title="5.黑盒、白盒测试"></a>5.黑盒、白盒测试</h4><p><img src="/img/software-engineering/Testing-method.png"></p><p>（1）黑盒测试：将测试的对象看作是一个密闭的黑盒，我们的测试就是向闭盒提供输入的数据，并记录产生的输出。测试的目标是确保针对每种输入，观察到的输出与预期的输出相匹配。黑盒测试参考的文档是系统设计和程序设计阶段的文档。</p><p>优点：偏向于功能性的测试。不受内部逻辑约束。</p><p>缺点：不完备。黑盒法以 SRS 为依据，有一定的盲目性和不确定性，不可能揭示所有的错误。</p><p>黑盒测试方法：</p><p>1、<strong>等价分类法</strong>：将输入域划分为若干等价类。每个测试用例都代表了一类与它等价的其他例子。</p><p>2、<strong>边界值分析法</strong>：把测试值选在等价类的边界上进行测试。</p><p>3、错误猜测法：猜测程序中哪些地方容易出错，并据此设计测试用例。</p><p>4、因果图法：适用于被测试程序有很多输入条件，程序的输出又依赖输入条件的各种组 合的情况。</p><p>（2）白盒测试：将测试对象看作一个白盒，然后根据测试对象的结构用不同的方式进行测试。（已知结构）</p><p>优点：测试面广，可以测试一个模块的细节。</p><p>缺点：工作量大。</p><p>白盒测试方法:</p><ul><li>语句覆盖 + 判定(分支)覆盖一个判断 + 条件覆盖：要求判定中的每个条件均按照“真”、“假”两种结果至少执行一次。</li><li>条件组合覆盖：要求所有条件结果的组合都至少出现一次(比如 A&amp;&amp;B，两个条件，那么就有四种条件的组合)。</li><li>路径测试法</li></ul><h4 id="6-测试用例"><a href="#6-测试用例" class="headerlink" title="6. 测试用例"></a>6. 测试用例</h4><p>测试用例(Test Case)，是以测试程序为目标而挑选的输入数据，包括对应的期望结果。以便测试某个程序路径或核实是否满足某个特定需求。</p><p>是一组四元偶**&lt;输入数据、前置条件、测试步骤、预期输出&gt;**。</p><h4 id="7-传统测试和OO测试有何不同"><a href="#7-传统测试和OO测试有何不同" class="headerlink" title="7.传统测试和OO测试有何不同"></a>7.传统测试和OO测试有何不同</h4><p>（1）需求分析与验证不同</p><p>（2）测试用例的生成不一样</p><p>（3）源代码分析不一样</p><p>（4）覆盖分析不一样</p><h4 id="8-集成测试及其主要方法的分类？"><a href="#8-集成测试及其主要方法的分类？" class="headerlink" title="8.集成测试及其主要方法的分类？"></a>8.集成测试及其主要方法的分类？</h4><p>1、自底向上集成</p><p>先测试系统最底层的模块，接着测试调用这些底层模块的模块，直到测试完毕。</p><p>2、自顶向下集成</p><p>先测试系统最上层的模块，接着测试顶层模块调用的下层模块，直到测试完毕。</p><p>3、一次性集成</p><p>先测试每一个模块，之后将所有模块一并集成。</p><p>4、三明治集成</p><p>将系统分成三层，目标层处于中间、目标层上有一层，目标层下有一层。在顶层采用自顶向下的方式集成，在较低层采用自底向上的方式集成，测试集中于目标层。</p><p><strong>课件例题：</strong></p><p><strong>某城市的电话号码由 3 部分组成。这 3 个部分的名称与内容分别是:</strong><br><strong>地区码：空白或 3 位数字；前缀：非’0’或’1’开头的 3 位数字；后缀：4 位数字。</strong><br><strong>假定被测程序能接受一切符合上述规定的电话号码，拒绝所有不符合规定的号码，请使 用等价类的思路设计测试用例。</strong></p><p>驱动，桩的概念</p><p>驱动程序：调用特定构件并向其传递测试用例的程序，即代替上层模块的调用程序。</p><p>桩：一种专用程序，用于模拟测试时缺少构件时的活动。桩应答调用序列，并传回输出数据，使测试能够正常的进行下去，即代替下级模块的仿真程序。</p><p>什么是单元测试？ 什么是走查和检查？</p><p>将每个程序构件与系统中的其他构件隔离，对其本身进行测试。</p><p>走查：不正式的的代码评审。</p><p>检查：正式的代码评审，事先准备问题清单，依据清单比对代码和文档的一致性。</p><h3 id="Chapter-9-系统测试"><a href="#Chapter-9-系统测试" class="headerlink" title="Chapter 9 系统测试"></a>Chapter 9 系统测试</h3><h4 id="1-系统测试的主要步骤及各自含义？"><a href="#1-系统测试的主要步骤及各自含义？" class="headerlink" title="1. 系统测试的主要步骤及各自含义？"></a>1. 系统测试的主要步骤及各自含义？</h4><p>1、功能测试：根据SRS测试系统功能。</p><p>2、性能测试：根据SRS测试系统性能。</p><p>3、验收测试：根据客户的需求定义，由客户和用户一起测试。</p><p>4、安装测试：在用户环境下进行测试。</p><h4 id="2-什么是回归测试？"><a href="#2-什么是回归测试？" class="headerlink" title="2. 什么是回归测试？"></a>2. 什么是回归测试？</h4><p>回归测试是用于新的版本或者改进版本的一种测试，以验证与旧版本相比，软件是否仍然以同样的方式执行同样的功能。</p><h4 id="3-确认测试概念，确认测试分类？（基准测试、引导测试、并行测试）"><a href="#3-确认测试概念，确认测试分类？（基准测试、引导测试、并行测试）" class="headerlink" title="3.确认测试概念，确认测试分类？（基准测试、引导测试、并行测试）"></a>3.确认测试概念，确认测试分类？（基准测试、引导测试、并行测试）</h4><p>确认测试：由用户检查软件系统是否满足了他们的需求的测试。</p><p>Pilot test: install on experimental basis<br>Alpha test: in-house test<br>Beta test: customer pilot<br>Parallel testing: new system operates in parallel with old system</p><p>1、基准测试：</p><p>由用户准备典型测试用例，在实际安装后的系统运作并由用户对系统执行情况进行评估。</p><p>2、引导测试：</p><p>在假设系统已经永久安装的前提下执行系统。它依赖系统的日常工作进行测试，相对基准测试不是非常的正式与结构化。</p><h4 id="4-什么是alpha测试？β测试？"><a href="#4-什么是alpha测试？β测试？" class="headerlink" title="4. 什么是alpha测试？β测试？"></a>4. 什么是alpha测试？β测试？</h4><p>α测试：内部测试。客户进行实际的测试前，先自己组织团队（或者委托其他团队）测试这个系统。</p><p>β测试：公测。客户实际进行的测试。</p><p><img src="/img/software-engineering/alpha-beta-test.png"></p><ol><li>α测试</li></ol><p>就是把用户请到公司内部进行测试使用。</p><p>α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试；</p><p>目的：是评价软件产品的FLURPS(即功能、局域化、可使用性、可靠性、性能和支持)。</p><p>注意！α测试不能由程序员或测试员完成。</p><ol start="2"><li>β测试</li></ol><p>用户在不同场所进行测试。</p><p>β测试是一种验收测试。β测试由软件的终用户们在一个或多个场所进行。</p><h3 id="考试题型"><a href="#考试题型" class="headerlink" title="考试题型"></a>考试题型</h3><p>1.名词解释（10&#x2F;20分）</p><p>2.判断题（10&#x2F;10分）</p><p>3.选择题（20&#x2F;20分）</p><p>4.综合题（2&#x2F;20分）</p><p>5.简述题（5&#x2F;30分根据理解解释）</p><p>16周考试</p><p>老师联系地址：科研楼 215</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考网站&quot;&gt;&lt;a href=&quot;#参考网站&quot; class=&quot;headerlink&quot; title=&quot;参考网站&quot;&gt;&lt;/a&gt;参考网站&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_52100140/article/details/122</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学整合</title>
    <link href="http://example.com/2023/11/22/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B4%E5%90%88/"/>
    <id>http://example.com/2023/11/22/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B4%E5%90%88/</id>
    <published>2023-11-22T07:05:46.000Z</published>
    <updated>2023-11-22T07:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前已经学过密码相关的课程：</p><p>1.信息安全导论</p><p>2.信息安全数学基础</p><p>3.密码学原理与实践</p><p>4.Python与密码学</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>为什么写这样一篇整合性的文章，因为看书时突发奇想，发现之前学过的内容之间都存在不小的联系，如果能将脑中混杂的理论盒思想整合一下，即可以给自己之后的复习与重温产生极大的效益，同时也能发布到网络上，让他人受益，并在其他人的审视下纠正我的错误。</p><h2 id="密码学综述"><a href="#密码学综述" class="headerlink" title="密码学综述"></a>密码学综述</h2><h3 id="密码的起源"><a href="#密码的起源" class="headerlink" title="密码的起源"></a>密码的起源</h3><p>从远古时代起，人类就能感知身边各种自然现象所隐含的信息。在狩猎和劳作的过程中，人类开发出属于自己的各种复杂系统——语言、数字、文字系统，用来表示一些抽象的概念，创造出人类最初的密码。例如，云的特征隐藏了不同的信息，远古人类通过观察云的特征来解密天气信息，以预测是否会刮风或下雨；狩猎时人类学习“解密“信息最初的实践之一，猎人在狩猎的过程中，会根据猎物遗留的足印、活动痕迹、啃食的草木等迹象，解读其中隐藏的信息，以判断猎物的种类、踪迹和活动规律等。</p><h3 id="密码学的发展"><a href="#密码学的发展" class="headerlink" title="密码学的发展"></a>密码学的发展</h3><p>古代岩画，将一些象征性图案以莫重方式排列组合来传达不同的信息，这是人类通过图形化符号来传递信息的最早手段之一。著名的有法国拉斯科洞窟壁画，挪威的阿尔塔岩画，我国宁夏银川的贺兰山岩画，古人类将当时人类的生活和劳动信息隐藏于岩画之中，现代才得以通过解读这些信息，还原远古人类所处的生活环境和一系列生活场景。技术与书写的抽象思维使得人类的发展史得以记载流传，玛雅数字，巴比伦数字，阿拉伯数字，罗马数字，楔形文字，还有菲斯托斯圆盘上记载的古希腊文字，这些抽象的符号表达记录着当时人类的生活。</p><p>早在公元前7世纪，密码棒就在古希腊的军事重镇斯巴达得到广泛应用。这就是斯巴达密码棒。古斯巴达人用一条带子缠绕在一根木棍上，沿木棍纵轴方向写好明文，解下来的带子上就只有杂乱无章的密文字母。解密者只需找到相同直径的木棍，再把带子缠上去，沿木棍纵轴方向即可读出有意义的明文。这种方式在现代密码学中仍有体现——行列变换。</p><p>密码史与人类文明发展史相生相伴，从古人类的符号标记，古文字的形成与解读，再到斯巴达密码棒等等，这些五彩斑斓的创作，体现了古人在秘密传递上的智慧，将密码学一步一步推向了以数学为基础的古典密码时代。</p><h4 id="古典密码："><a href="#古典密码：" class="headerlink" title="古典密码："></a>古典密码：</h4><p>这一时期的密码学更像是一门艺术，其核心手段是代换和置换。代换是指明文中的每一个字符被替换成密文中的另一个字符，接收者对密文做反向替换便可恢复出明文；置换是密文和明文字母保持相同，但顺序被打乱。代换密码的著名例子有古罗马的凯撒密码（公元前1世纪）和法国的维吉尼亚密码（16世纪）。</p><h5 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h5><p>公元前1世纪，著名的凯撒密码，被用于高卢战争中，这是一种简单易行的单字母替代密码，这种加密方法就是将明文的字母按照字母顺序，往后依次递推相同的字母，就可以得到加密的密文，而解密的过程正好和加密的过程相反。</p><h5 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h5><p>维吉尼亚密码是多表置换密码的一个典型代表，这种方法即一个明文字母可以表示为多个密文字母，多表密码加密算法结果将使得对单表置换用的简单频率分析方法失效。维吉尼亚密码使用一个词组（语句）作为密钥，词组中每一个字母都作为移位替换密码密钥确定一个替换表，维吉尼亚密码循环的使用每一个替换表完成明文字母到密文字母的变换，最后所得到的密文字母序列即为加密得到的密文。维吉尼亚是古典密码理论发展上的一个重要里程碑。</p><p>置换密码也是古典密码的重要一员，通过一定的规则重新排列明文，打破明文的结构，而不改变明文的内容，仅仅是对明文字母的重新排序，就可以实现加密。虽然设计思想简单，但其贡献不可磨灭。</p><p>一次一密费纳姆密码作为绝对安全密码，其保密性在理论意义上绝对安全，虽然真正实现困难，但它对现代序列密码的设计的影响意义深远。</p><p>中国古代兵书《六韬》中的阴符和阴书:《六韬》又称《太公六韬》或《太公兵法》,据说是由西周的开国功臣太公望(又名吕尚或姜子牙,约公元前1128—公元前1015)所著。书中以周文王和周武王与太公问答的形式阐述军事理论,其中《龙韬•阴符》篇和《龙韬•阴书》篇,讲述了君主如何在战争中与在外的将领进行保密通信。</p><p>以下是关于“阴符”使用方法对话的译文。</p><p>武王问太公说:领兵深入敌国境内,军队突然遇到紧急情况,战事或有利,或失利。我要与各军远近相通,内外相应,保持密切的联系,以便及时应对战场上军队的需求,应该怎么办呢?</p><p>太公回答说:国君与主将之间用阴符秘密联络。阴符共有八种:一种长一尺,表示大获全胜,摧毁敌人;一种长九寸,表示攻破敌军,杀敌主将;一种长八寸,表示守城的敌人已投降,我军已占领该城;一种长七寸,表示敌军已败退,远传捷报;一种长六寸,表示我军将誓死坚守城邑;一种长五寸,表示请拨运军粮,增派援军;一种长四寸,表示军队战败,主将阵亡;一种长三寸,表示战事失利,全军伤亡惨重。如奉命传递阴符的使者延误传递,则处死;如阴符的秘密被泄露,则无论无意泄密者或有意传告者也处死。只有国君和主将知道这八种阴符的秘密。这就是不会泄露朝廷与军队之间相互联系内容的秘密通信语言。敌人再聪明也不能识破它。</p><p>在计算机时代来临之前，古典密码的破译还是一个困难问题，但随着计算机的发明，破译这些古典密码在今天看来轻而易举，但古典密码的设计思想给现代密码的设计产生了不可磨灭的影响，其工作原理——代换和置换，仍然是构造现代对称密码算法的最重要核心技术。</p><h4 id="近代密码"><a href="#近代密码" class="headerlink" title="近代密码"></a>近代密码</h4><p>近代密码是指从第一次世界大战、第二次世界大战到1976年这段时期密码的发展阶段。</p><p>电报的出现第一次使远距离快速传递信息成为可能,事实上,它增强了西方各国的通讯能力;20世纪初,意大利物理学家奎里亚摩•马可尼发明了无线电报,让无线电波成为新的通讯手段,它实现了远距离通讯的即时传输,但是通过无线电波送出的每条信息不仅传给了己方,也传送给了敌方,因此这就意味着必须给每条信息加密,随着第一次世界大战的爆发,对密码和解码人员的需求急剧上升,一场秘密通讯的全球战役打响了。</p><p>公元20世纪初,第一次世界大战进行到关键时刻,英国破译密码的专门机构“40号房间”利用缴获的德国密码本破译了著名的“齐默尔曼电报”,促使美国放弃中立参战,改变了战争进程。</p><p>随着计算机科学的发展,快速电子计算机和现代数学方法一方面为加密技术提供了新的方法、新的概念和新的工具,另一方面也为破译者提供了有力的武器。计算机和电子时代的到来给密码设计者们带来了前所未有的自由,他们可以轻松地减少原先用铅笔和纸在做手工设计时易犯的错误,也不用再担心使用电子机械方式实现密码机的高额费用。总之,利用电子和计算机技术可以设计出更加复杂的密码体系。</p><p>这一阶段真正开始源于香农在20世纪40年代末发表的一系列论文，特别是1949年的《保密系统通信理论》，把已有数千年历史的密码学推向了基于信息论的科学轨道。近代密码发展中一个重要突破是“数据加密标准”（DES）的出现。DES密码的意义在于，首先，其出现使密码学得以从政府走向民间，其设计主要由IBM公司完成，国家安全局等政府部门只是参与其中，最终经美国国家标准局公开征集遴选后，确定为联邦信息处理标准。其次，DES密码设计中的很多思想（Feistel结构、S盒等），被后来大多数分组密码所采用。再次，DES出现之后，不仅在美国联邦部门中使用，而且风行世界，并在金融等商业领域广泛使用。</p><p>密码学的发展直接影响了二战的战局。Arthur Scherbius于1919年设计出了历史上最著名的密码机—德国的Enigma机,它的设计结合了机械系统与电子系统。它被证明是有史以来最为可靠的加密系统之一,从而使得二战期间德军的保密通讯技术处于当时的领先地位。随着Enigma的破译,人们意识到其实真正保证密码安全的往往不是算法,而是密钥。即使算法外泄,但只要密钥保密,密码就不会失效。</p><p>荷兰密码学家Kerckhoffs于1883年在其名著作《军事密码学》中提出密码学的基本假设:密码系统中的算法即使为密码分析者所知,对推导出明文或密钥也没有帮助。也就是说,密码系统的安全性应只取决于可随时改变的密钥,而不应取决于不易被改变的事物(算法)。</p><p>在二次世界大战中,印第安纳瓦霍土著语言被美军用作密码,美国二战时候特别征摹使用印第安纳瓦霍通信兵。在二次世界大战日美的太平洋战场上,美国海军军部让北墨西哥和亚历桑那印第安纳瓦霍族人使用纳瓦霍语进行情报传递。纳瓦霍语的语法、音调及词汇都极为独特,不为世人所知道,当时纳瓦霍族以外的美国人中,能听懂这种语言的也就一二十人。这是密码学和语言学的成功结合,纳瓦霍语密码成为历史上从未被破译的密码。</p><h4 id="现代密码"><a href="#现代密码" class="headerlink" title="现代密码"></a>现代密码</h4><p>现代密码学的发展与计算机技术、电子通信技术密切相关。在这一阶段,密码理论得到了蓬勃发展,密码算法的设计与分析互相促进,从而出现了大量的加密算法和各种分析方法。除此之外,密码的使用扩张到各个领域,而且出现了许多通用的加密标准,从而促进了网络和技术的发展。</p><p>现代密码学有两个重要标志：一是美国制定并于1977年1月15日批准公布了公用数据加密标准DES。二是1976年，美国密码学家迪菲和赫尔曼在“密码学的新方向”的文章，首次提出公钥密码体制的构想和理论方法。即不仅加密算法本身可以公开，甚至加密用的密钥也可以公开，但这并不意味着保密程度的降低，因为加密密钥和解密密钥不一样，将解密密钥保密就可以，这就是著名的公钥密码体制。若存在这样的公钥体制，都可以将加密密钥像电话簿一样公开，任何用户想经其他用户传送一加密信息时，都可以从这本密钥薄中查到该 用户的公开密钥，用它来加密，而接收者能用只有它所具有的 解密密钥得到明文，任何第三者不能获得明文。1978年，美国麻省理工学院的里维斯特、沙米尔和阿德曼提出了RSA公钥密码体制，它是第一个成熟的、迄今为止理论上最成功的公钥密码体制。它的安全性是基于数论中的大整数因子分解。该问题是数论中的一个困难问题，至今没有有效的算法，这使得该体制具有较高的保密性。在现代密码学中，除了信息保密外，还有另一方面的要求，即信息安全体制还要能抵抗对手的主动攻击。所谓主动 攻击指的是攻击者可以在信息通道中注入自己伪造的消息，以骗取合法接收者的相信。主动攻击可能窜改信息，也可能冒名顶替，这就产生了现代密码学中的认证体制。该体制的 目的就是保证用户收到一个信息时，能验证消息是否来自 合法发送者，同时还能验证该信息是否被窜改。在许多场合中，如电子汇款，能对抗主动攻击的认证体制甚至比信息保密还重要。</p><h3 id="编码与密码"><a href="#编码与密码" class="headerlink" title="编码与密码"></a>编码与密码</h3><h5 id="摩尔斯电码"><a href="#摩尔斯电码" class="headerlink" title="摩尔斯电码"></a>摩尔斯电码</h5><p><a href="https://morsecode.bmcx.com/">摩尔斯电码对照表</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前已经学过密码相关的课程：&lt;/p&gt;
&lt;p&gt;1.信息安全导论&lt;/p&gt;
&lt;p&gt;2.信息安全数学基础&lt;/p&gt;
&lt;p&gt;3.密码学原理与实践&lt;/p&gt;
&lt;p&gt;4.Python与密码学&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>近来的苦恼</title>
    <link href="http://example.com/2023/11/02/%E8%BF%91%E6%9D%A5%E7%9A%84%E8%8B%A6%E6%81%BC/"/>
    <id>http://example.com/2023/11/02/%E8%BF%91%E6%9D%A5%E7%9A%84%E8%8B%A6%E6%81%BC/</id>
    <published>2023-11-02T08:26:01.000Z</published>
    <updated>2023-11-02T08:26:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近的烦心事不可谓不多，写这篇也是临时起意，将这些事情记录下来，也是给自己这大学两年多以来的经历进行总结教训。</p><p>总说大学大学，大不了自学。听起来很对，但真要到身体力行，则深感道阻且长，学习上的事，从小学以来基本都是老师讲，我听，我记，我做，不断重复然后形成知识体系，于我，上课听懂多少基本就是我学了多少；但到了大学，老师讲的东西，要么听不懂，要么听懂一部分，剩下就茫然了，尝试看书，有时会有很好的发现，可一旦落笔，则又瞬间什么又不懂了。我不知道怎么做，我不知道怎么学，我不知道怎么问，我不知道怎么解决。</p><p>大二转了专业，到了软院，数据结构瞬间打回原形，大一学的只有一节课相关，但本身上课就稀里糊涂，而且还不是一个版本，数据结构用C++编程，只学了一点C，连PPT的示例代码都看不懂，更别说自己写了。于是重新走上老路，上课不听去自学C++ Prime plus，但这本书将近千页，平时还有别的课程，没时间一次看完，一次看一点的方式完全行不通。这就是第一个烦心事。</p><p>接下来说说最近的，认识实习，原定第八周，推迟到了第九周，也就是本周，这周也马上过去了，明天也有web课程设计的考试，可项目又停滞了一个多月，当了团队的leader，一开始三番五次向其他成员说明，让他们要报告自己的进展，好安排任务，但是，他们完全没有团队意识，而我又很忙，9月底还找了一份实习的工作，已经做了一个多月了，该怎么办？第十四周就要提交了，本周末肯定要抓紧完成初步的项目，但还有别的任务，别的实验课，别的考试，我该怎么办？这就是第二个烦心事。</p><p>认识实习这几天，学校的安排给我感觉很差劲，先是把我们班级拆成两个组，并到其他组里去，然后和我同组的另一个班，计划变更也不说明，也不能按时抵达（有时是我们班其他人），联系的时候还联系不上，不提前站队查人，导致上车后等半天，虽然这些都是小事，但给我的感受就是很不好受，行政管理低下导致的问题。这些其实都不是什么重点，重点是即将结束的大学生活，课程设计、实验、毕业设计、考研还是找工作？考研自然毫不必问，可问题是方向还有能力，就目前而言，我有很多想做的事情，可这些需要时间，还有指导！大学以来，很少在学习上有过指点，坑是自己踩的，活是自己干的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近的烦心事不可谓不多，写这篇也是临时起意，将这些事情记录下来，也是给自己这大学两年多以来的经历进行总结教训。&lt;/p&gt;
&lt;p&gt;总说大学大学，大不了自学。听起来很对，但真要到身体力行，则深感道阻且长，学习上的事，从小学以来基本都是老师讲，我听，我记，我做，不断重复然后形成知识</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/24/net-attack&amp;defence-doc/bof-password/"/>
    <id>http://example.com/2023/10/24/net-attack&amp;defence-doc/bof-password/</id>
    <published>2023-10-24T03:36:42.819Z</published>
    <updated>2023-10-24T03:36:33.333Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/24/net-attack&amp;defence-doc/x-windows/"/>
    <id>http://example.com/2023/10/24/net-attack&amp;defence-doc/x-windows/</id>
    <published>2023-10-24T03:35:43.113Z</published>
    <updated>2023-10-24T00:59:56.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="X-windows"><a href="#X-windows" class="headerlink" title="X-windows"></a>X-windows</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p> X Windows 是 UNIX 和所有类 UNIX （包括Linux）操作系统的标准图形接口，有时也称为X Windows、X Window 或者 X。由于它是在 W 窗口系统之后开发成功的，故称为 X 系统。X Window 系统可以在许多系统上运行，具有可移植性、对彩色处理的多样性，以及在网络上操作的透明性等特点，使得 X 成为一个工业标准。因此，严格来说，X Window 系统并不是一个软件，而是一个协议（protocal），定义了一个系统成品必须具备的功能。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.bilibili.com/read/cv8087543/">【Linux图形环境】何为X Windows系统（图形环境）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;X-windows&quot;&gt;&lt;a href=&quot;#X-windows&quot; class=&quot;headerlink&quot; title=&quot;X-windows&quot;&gt;&lt;/a&gt;X-windows&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/23/web-doc/vue-%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/"/>
    <id>http://example.com/2023/10/23/web-doc/vue-%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/</id>
    <published>2023-10-23T03:27:58.434Z</published>
    <updated>2023-10-24T03:18:58.630Z</updated>
    
    <content type="html"><![CDATA[<h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p><code>暗黑模式/白天模式</code>的主题切换功能</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/7134594122391748615">前端主题切换方案 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;想法&quot;&gt;&lt;a href=&quot;#想法&quot; class=&quot;headerlink&quot; title=&quot;想法&quot;&gt;&lt;/a&gt;想法&lt;/h3&gt;&lt;p&gt;&lt;code&gt;暗黑模式/白天模式&lt;/code&gt;的主题切换功能&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;hea</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/23/web-doc/vue-markdown/"/>
    <id>http://example.com/2023/10/23/web-doc/vue-markdown/</id>
    <published>2023-10-23T03:02:44.369Z</published>
    <updated>2023-10-23T03:27:39.306Z</updated>
    
    <content type="html"><![CDATA[<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>首先需要使用npm引入三个包</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i markdown-loader html-loader marked --save</span><br></pre></td></tr></table></figure><p>说明：<code>markdown-loader</code>、<code>html- loader</code>是为了让<code>vue</code>能够解析<code>md</code>格式的文件，读取出来，然后使用<code>marked</code>将读取出来的数据转换成<code>html</code>格式渲染到页面上。使用<code>marked</code>是为了使用更方便。</p><p>下一步准备引入 *.md 文件，但是引入之前还需要做一个规则配置，如果没有配置的话会报无法解析“#”的错误。配置好后就可以引入md文件了。</p><h4 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h4><p>在vue.config.js里进行配置,<strong>如果使用的是 vue-cli 3 以上版本则在vue.config.js中配置</strong></p><p>webpack.base.conf.js 配置：在 module &gt; rules 中添加一条规则</p><figure class="highlight javascript"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        <span class="comment">// 配置读取 *.md 文件的规则</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.md$/</span>,</span><br><span class="line">             <span class="attr">use</span>: [</span><br><span class="line">                &#123; <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">loader</span>: <span class="string">&#x27;markdown-loader&#x27;</span>, <span class="attr">options</span>: &#123;&#125; &#125;</span><br><span class="line">             ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vue.config.js 配置：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        // 配置读取 *.md 文件的规则</span><br><span class="line">        &#123;</span><br><span class="line">          test: /\.md$/,</span><br><span class="line">          use: [</span><br><span class="line">            &#123; loader: &quot;html-loader&quot; &#125;,</span><br><span class="line">            &#123; loader: &quot;markdown-loader&quot;, options: &#123;&#125; &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="页面引入和渲染"><a href="#页面引入和渲染" class="headerlink" title="页面引入和渲染"></a>页面引入和渲染</h4><p>在需要使用的地方，引入 marked，再将 md 文档交给它来解析，获得到解析后的 HTML 格式内容，再将解析后的内容渲染到页面上</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;文档&lt;/div&gt;</span><br><span class="line">    &lt;div v-html=&quot;articalContent&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">​</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const marked = require(&quot;marked&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      articalContent: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.$axios.get(&quot;/articles/test.md&quot;).then(res =&gt; &#123;</span><br><span class="line">        const htmlMD = marked(res.data);</span><br><span class="line">​</span><br><span class="line">        this.articalContent = htmlMD;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这时，md格式的数据就被解析成了html格式的数据，我们只需要将html格式的数据渲染上去就行了。</p><h4 id="MD样式未渲染"><a href="#MD样式未渲染" class="headerlink" title="MD样式未渲染"></a>MD样式未渲染</h4><p>到现在为止，只是将文档正确解析并显示到了页面上，但是没有任何样式，我们可以再给渲染的内容加上样式，比如使用 github 的样式：</p><p>这时候就需要我们下载另外一个依赖</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install github-markdown-css</span><br></pre></td></tr></table></figure><p>然后在main.js中将md文件的样式引入</p><figure class="highlight arduino"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;github-markdown-css&#x27;</span>;</span><br></pre></td></tr></table></figure><p>最后给页面的div盒子加上样式的class</p><figure class="highlight css"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> v-<span class="selector-tag">html</span>=&quot;md&quot; class=&quot;markdown-<span class="selector-tag">body</span>&quot; &gt;</span><br><span class="line"> </span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p>注：可能页面有些不一样因为样式不同</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/weixin_44702572/article/details/107321909">Vue解析 markdown 文件_vue 解析markdown-CSDN博客</a></p><p><a href="https://juejin.cn/post/7034048009000189960">vue引入并解析md文件 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;依赖&quot;&gt;&lt;a href=&quot;#依赖&quot; class=&quot;headerlink&quot; title=&quot;依赖&quot;&gt;&lt;/a&gt;依赖&lt;/h4&gt;&lt;p&gt;首先需要使用npm引入三个包&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;input class=&quot;b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/23/assets/markdownhere/"/>
    <id>http://example.com/2023/10/23/assets/markdownhere/</id>
    <published>2023-10-23T02:31:49.970Z</published>
    <updated>2023-10-23T02:36:14.051Z</updated>
    
    <content type="html"><![CDATA[/*markdown here 的全局配置*/.markdown-here-wrapper {    font-size: 16px;    line-height: 1.8em;    /*em指的是相对单位，当前对象内字体的尺寸，默认浏览器16px*/    /*http://www.w3school.com.cn/cssref/css_units.asp*/    letter-spacing: 0.1em;  }    pre, code {       /*,逗号连接是并集选择器*/    font-size: 14px;    font-family: Roboto, 'Courier New', Consolas, Inconsolata, Courier, monospace;    margin: auto 5px;  }    /*设置pre 和code的整体属性，pre可以把div中的/r/n保存下来显示，而code则用浏览器的方式渲染*/  code {    white-space: pre-wrap;    border-radius: 2px;    display: inline;  }  /*display 的属性为指定元素框的类型*/  /*margin： 0为默认值，auto为浏览器自动计算的外边距，外边距属性*/  /*border-radius: div元素的圆角框*/  /*write-space:如何处理元素内空白行，回车or忽略,nowrap不换行，pre-wrap换行*/  /*http://www.w3school.com.cn/cssref/pr_text_white-space.asp*/      pre {      /*pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。*/    font-size: 15px;    line-height: 1.4em;    display: block; !important;  /*在ie6以上的浏览器中，设置优先级，覆盖预先设置的属性 !important*/  }    pre code {  /*空格连接是后代选择器，外层在前内层在后； >连接是子元素选择器*/    white-space: pre;    overflow: auto;   /*内容益处元素框时候的行为*/    border-radius: 3px;    padding: 1px 1px;    display: block !important;  }    /*各种选择器：https://blog.csdn.net/m0_38070602/article/details/69950795*/  /*pre code 的解释：http://www.cnblogs.com/lizonghui/archive/2012/09/18/2692355.html*/  strong, b{      /*strong表示强调，用<b>粗体显示，也可以自定义自己的强调方式*/    color: #BF360C;  }    em, i {      /*em表示强调，用<i>标签斜体显示，也可以自定义自己的强调方式*/    color: #009688;  }    hr {       /*水平线分割---*/    border: 1px solid #BF360C;    margin: 1.5em auto;  }    p {      /*段落选择器*/    margin: 1.5em 5px !important;    /*颜色*/    /*color:#d6a841;*/       /*字体*/    font-family:'微软雅黑';    /*字号*/    font-size:15px;    /*行间距，可用百分比，数值倍数，像素设置，还包括text-indent缩进、letter-spacing字间距、*/    line-height:100%  2  100px;    /*段间距，一般用margin属性调整*/    margin-bottom:20px;    /*页边距用padding属性调整*/  }    /*表格和*/  table, pre, dl, blockquote, q, ul, ol {    margin: 10px 5px;    /*并集选择器：表格、预格式化、定义列表、块引用、短引用、无序列表、有序列表*/  }    ul, ol {      /*无序、有序列表*/    padding-left: 15px;  }    li {      /* 定义列表中的项目*/    margin: 10px;  }    li p {      /*li列表元素中的后代选择器，包含选择器，应用于li中的p*/    margin: 10px 0 !important;  }    ul ul, ul ol, ol ul, ol ol {        /*各个后代选择器一起添加属性*/    margin: 0;    padding-left: 10px;  }    ul {    list-style-type: circle;  }  /*无序列表的前缀，circle,square,好多种,同样有序列表ol也可以设置不同的标记*/  /*http://www.w3school.com.cn/cssref/pr_list-style-type.asp*/    dl {    padding: 0;  }    dl dt {    font-size: 1em;    font-weight: bold;      /*加粗  意大利斜体*/    font-style: italic;  }    dl dd {    margin: 0 0 10px;    padding: 0 10px;  }  /*各种表格的包含选择器定义，用空格连接*/      blockquote, q {    border-left: 2px solid #009688;    padding: 0 10px;      /*上右下左的排序，可输入四个值*/    color: #777;    quotes: none;    margin-left: 1em;  }  /*块引用和短引用的样式*/    blockquote::before, blockquote::after, q::before, q::after {    content: none;  }  /*before 和after属于css伪元素，:before在元素之前插入相应。：after在之后插入*/  /*伪元素用::，伪类用：参考ref。。https://blog.csdn.net/qq_25292481/article/details/52577320*/      /*--------同时设置六级标题的属性，其中！important用于指定优先级>ie6--------------*/  h1, h2, h3, h4, h5, h6 {    margin: 20px 0 10px;    padding: 0;    font-style: bold !important;    color: #009688 !important;    text-align: center !important;    margin: 1.5em 5px !important;    padding: 0.5em 1em !important;  }    h1 {    font-size: 24px !important;    border-bottom: 1px solid #ddd !important;  }    h2 {    font-size: 20px !important;    border-bottom: 1px solid #B3B3B3 !important;  }    h3 {    font-size: 18px;  }    h4 {    font-size: 16px;    /*可以针对自己的标题做出个性化设置*/    color:#d6a841   /*16进制颜色*/    font-style: bold /*加粗？倾斜*/    /*---------各种居中方式---------*/    margin: 0, auto;        /*块级元素居中*/    text-align: center;    /*行内居中*/    justify-content: center;  /*对齐*/    vertical-align: middle;  /*垂直居中*/    /*ref:   https://www.jianshu.com/p/61c431fd924a*/    }    /*-------------表格元素的设置-----------------*/  table {    padding: 0;    border-collapse: collapse;  /*合并边框属性*/    border-spacing: 0;      font-size: 1em;    font: inherit;    border: 0;    margin: 0 auto;  }    tbody {    margin: 0;    padding: 0;    border: 0;  }    table tr {    border: 0;    border-top: 1px solid #CCC;    background-color: white;    margin: 0;    padding: 0;  }    table tr:nth-child(2n) {    background-color: #F8F8F8;  }    table tr th, table tr td {    font-size: 16px;    border: 1px solid #CCC;    margin: 0;    padding: 5px 10px;  }    table tr th {  /*表格。tableraw，tableheader*/    font-weight: bold;    color: #eee;    border: 1px solid #009688;    background-color: #009688;  }      /* ----------  可根据markdown的实现自己的**个性化**标记 */  @strong-char: "**";  /*可以将着重符号替换为自己的个性化符号*/  strong:before, strong:after {      content: @strong-char;      display: inline;  }  @em-char: "*";     em:before, em:after {      content: @em-char;      display: inline;  }    ]]></content>
    
    
      
      
    <summary type="html">/*markdown here 的全局配置*/
.markdown-here-wrapper {
    font-size: 16px;
    line-height: 1.8em;
    /*em指的是相对单位，当前对象内字体的尺寸，默认浏览器16px*/
    /*h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Web前端框架</title>
    <link href="http://example.com/2023/10/19/Web%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2023/10/19/Web%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</id>
    <published>2023-10-19T13:18:02.000Z</published>
    <updated>2023-10-19T13:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue 的核心功能是声明式渲染：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应该是什么样子的。当状态改变时，HTML 会自动更新。</p><h3 id="plugin-插件"><a href="#plugin-插件" class="headerlink" title="plugin 插件"></a>plugin 插件</h3><p><a href="https://juejin.cn/post/6966106927990308872">Volar - vue终极开发神器！ - 掘金 (juejin.cn)</a></p><p><a href="https://cn.vitejs.dev/config/">配置 Vite | Vite 官方中文文档 (vitejs.dev)</a></p><p>能在改变时触发更新的状态被认为是响应式的(AJAX)。在 Vue 中，响应式状态被保存在组件中。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">  // 组件选项</span><br><span class="line">  // 此处声明一些响应式状态</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello World!&#x27;,</span><br><span class="line">      // 复合属性用对象表示 &#x27;x.x_value&#x27;</span><br><span class="line">      counter: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Count is: &#123;&#123; counter.count &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>message 属性可以在模板中使用。下面展示了我们如何使用双花括号法，根据 message 的值来渲染动态文本。</p><p>在 Vue 中，mustache 语法 (即双大括号) 只能用于文本插值。为了给 attribute 绑定一个动态值，需要使用 <code>v-bind</code> 指令：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line">// 简写写法</span><br></pre></td></tr></table></figure><p>指令是由 v- 开头的一种特殊 attribute。它们是 Vue 模板语法的一部分。和文本插值类似，指令的值是可以访问组件状态的 JavaScript 表达式。<br>冒号后面的部分 (:id) 是指令的“参数”。此处，元素的 id <code>attribute</code> 将与组件状态里的 <code>dynamicId</code> 属性保持同步。<br><strong>v-bind绑定属性变量dynamicId，属性变量的值才是实际的class</strong></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      titleClass: &#x27;title&#x27; //titleClass是属性变量，title是属性值</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 :class=&quot;titleClass&quot;&gt;&#123;&#123;titleClass&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">// 跟属性值相同</span><br><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/torchstar/p/11799394.html">vue中v-on支持的事件总结</a><br>我们可以使用 <code>v-on</code> 指令监听 DOM 事件：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">// 简写写法</span><br><span class="line">&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>此处，increment 引用了一个使用 methods 选项声明的函数</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 组件选项 方法体</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      // 更新组件状态</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><strong>表单绑定</strong><br>我们可以同时使用 v-bind 和 v-on 来在表单的输入元素上创建双向绑定：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input :value=&quot;text&quot; @input=&quot;onInput&quot;&gt;</span><br></pre></td></tr></table></figure><p>这里，我们使用 v-bind:value 将 text 属性绑定到 <code>&lt;input&gt;</code> 元素的 value 属性上。每当用户在 <code>&lt;input&gt;</code> 元素中输入时，浏览器都会触发 input 事件并调用 onInput 方法。在这个方法中，我们更新组件状态的 text 属性。</p><p>为了简化双向绑定，Vue 提供了一个 <code>v-model</code> 指令，它实际上是上述操作的语法糖：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;text&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      text: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onInput(e) &#123;</span><br><span class="line">      this.text = e.target.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input :value=&quot;text&quot; @input=&quot;onInput&quot; placeholder=&quot;Type here&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>试着在文本框里输入——你会看到 <code>&lt;p&gt;</code> 里的文本也随着你的输入更新了。</p><p>我们可以使用 <code>v-if</code> 指令来有条件地渲染元素：<br>这个 <code>&lt;h1&gt;</code> 标签只会在 awesome 的值为真值 (Truthy) 时渲染。若 awesome 更改为假值 (Falsy)，它将被从 DOM 中移除。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p><strong>列表渲染</strong><br>我们可以使用 <code>v-for</code> 指令来渲染一个基于源数组的列表：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>这里的 todo 是一个局部变量，表示当前正在迭代的数组元素。它只能在 v-for 所绑定的元素上或是其内部访问，就像函数的作用域一样。</p><p>注意，我们还给每个 todo 对象设置了唯一的 id，并且将它作为特殊的 key attribute 绑定到每个 <code>&lt;li&gt;</code>。key 使得 Vue 能够精确的移动每个 <code>&lt;li&gt;</code>，以匹配对应的对象在数组中的位置。这个 key attribute 也是 Vue 为了性能而做的一个必要的优化。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 给每个 todo 对象一个唯一的 id</span><br><span class="line">let id = 0</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      newTodo: &#x27;&#x27;,</span><br><span class="line">      todos: [</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn HTML&#x27; &#125;,</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn JavaScript&#x27; &#125;,</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn Vue&#x27; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodo() &#123;</span><br><span class="line">      this.todos.push(&#123; id: id++, text: this.newTodo &#125;)</span><br><span class="line">      this.newTodo = &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeTodo(todo) &#123;</span><br><span class="line">      this.todos = this.todos.filter((t) =&gt; t !== todo)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;form @submit.prevent=&quot;addTodo&quot;&gt;</span><br><span class="line">    &lt;input v-model=&quot;newTodo&quot;&gt;</span><br><span class="line">    &lt;button&gt;Add Todo&lt;/button&gt;    </span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">      &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>(t) &#x3D;&gt; t !&#x3D;&#x3D; todo 可以转变成以下形式</p><p>function(t){<br>    return t!&#x3D;&#x3D;todo<br>}</p><p>介绍一个新概念：计算属性。我们可以使用 computed 选项声明一个响应式的属性，它的值由其他属性计算而来：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: &#123;</span><br><span class="line">    filteredTodos() &#123;</span><br><span class="line">      // 根据 `this.hideCompleted` 返回过滤后的 todo 项目</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">let id = 0</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      newTodo: &#x27;&#x27;,</span><br><span class="line">      hideCompleted: false,</span><br><span class="line">      todos: [</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn HTML&#x27;, done: true &#125;,</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn JavaScript&#x27;, done: true &#125;,</span><br><span class="line">        &#123; id: id++, text: &#x27;Learn Vue&#x27;, done: false &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    filteredTodos() &#123;</span><br><span class="line">      return this.hideCompleted</span><br><span class="line">        ? this.todos.filter((t) =&gt; !t.done)</span><br><span class="line">        : this.todos</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodo() &#123;</span><br><span class="line">      this.todos.push(&#123; id: id++, text: this.newTodo, done: false &#125;)</span><br><span class="line">      this.newTodo = &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeTodo(todo) &#123;</span><br><span class="line">      this.todos = this.todos.filter((t) =&gt; t !== todo)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;form @submit.prevent=&quot;addTodo&quot;&gt;</span><br><span class="line">    &lt;input v-model=&quot;newTodo&quot;&gt;</span><br><span class="line">    &lt;button&gt;Add Todo&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;todo in filteredTodos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;</span><br><span class="line">      &lt;span :class=&quot;&#123; done: todo.done &#125;&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;button @click=&quot;hideCompleted = !hideCompleted&quot;&gt;</span><br><span class="line">    &#123;&#123; hideCompleted ? &#x27;Show all&#x27; : &#x27;Hide completed&#x27; &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.done &#123;</span><br><span class="line">  text-decoration: line-through;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>怎么实现的隐藏？</p><p>手动操作 DOM。</p><p>这时我们需要使用模板引用——也就是指向模板中一个 DOM 元素的 ref。我们需要通过这个特殊的 ref attribute 来实现模板引用：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p ref=&quot;pElementRef&quot;&gt;hello&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>此元素将作为 this.$refs.pElementRef 暴露在 this.$refs 上。然而，你只能在组件挂载之后访问它。</p><p>要在挂载之后执行代码，我们可以使用 mounted 选项：<br>这被称为生命周期钩子——它允许我们注册一个在组件的特定生命周期调用的回调函数。还有一些其他的钩子如 created 和 updated。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 此时组件已经挂载。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.$refs.pElementRef.textContent = &#x27;mounted!&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p ref=&quot;pElementRef&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>侦听器<br>有时我们需要响应性地执行一些“副作用”——例如，当一个数字改变时将其输出到控制台。我们可以通过侦听器来实现它：<br>一个比在控制台输出更加实际的例子是当 ID 改变时抓取新的数据。在下边的例子中就是这样一个组件。该组件被挂载时，会从模拟 API 中抓取 todo 数据，同时还有一个按钮可以改变要抓取的 todo 的 ID。</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      todoId: 1,</span><br><span class="line">      todoData: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async fetchData() &#123;</span><br><span class="line">      this.todoData = null</span><br><span class="line">      const res = await fetch(</span><br><span class="line">        `https://jsonplaceholder.typicode.com/todos/$&#123;this.todoId&#125;`</span><br><span class="line">      )</span><br><span class="line">      this.todoData = await res.json()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.fetchData()</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    todoId() &#123;</span><br><span class="line">      this.fetchData()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;Todo id: &#123;&#123; todoId &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button @click=&quot;todoId++&quot;&gt;Fetch next todo&lt;/button&gt;</span><br><span class="line">  &lt;p v-if=&quot;!todoData&quot;&gt;Loading...&lt;/p&gt;</span><br><span class="line">  &lt;pre v-else&gt;&#123;&#123; todoData &#125;&#125;&lt;/pre&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>组件<br>目前为止，我们只使用了单个组件。真正的 Vue 应用往往是由嵌套组件创建的。</p><p>父组件可以在模板中渲染另一个组件作为子组件。要使用子组件，我们需要先导入它：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要使用 components 选项注册组件。这里我们使用对象属性的简写形式在 ChildComp 键下注册 ChildComp 组件。</p><p>然后我们就可以在模板中使用组件，就像这样：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComp /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;Child component&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>Props<br>子组件可以通过 props 从父组件接受动态数据。首先，需要声明它所接受的 props：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在子组件中</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦声明，msg prop 就会暴露在 this 上，并可以在子组件的模板中使用。</p><p>父组件可以像声明 HTML attributes 一样传递 props。若要传递动态值，也可以使用 v-bind 语法：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComp :msg=&quot;greeting&quot; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      greeting: &#x27;Hello from parent&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp :msg=&quot;greeting&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123; msg || &#x27;No props passed yet&#x27; &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>Emits<br>除了接收 props，子组件还可以向父组件触发事件：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  // 声明触发的事件</span><br><span class="line">  emits: [&#x27;response&#x27;],</span><br><span class="line">  created() &#123;</span><br><span class="line">    // 带参数触发</span><br><span class="line">    this.$emit(&#x27;response&#x27;, &#x27;hello from child&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.$emit() 的第一个参数是事件的名称。其他所有参数都将传递给事件监听器。</p><p>父组件可以使用 v-on 监听子组件触发的事件——这里的处理函数接收了子组件触发事件时的额外参数并将它赋值给了本地状态：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp @response=&quot;(msg) =&gt; childMsg = msg&quot; /&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; childMsg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>插槽<br>除了通过 props 传递数据外，父组件还可以通过插槽 (slots) 将模板片段传递给子组件：</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComp&gt;</span><br><span class="line">  This is some slot content!</span><br><span class="line">&lt;/ChildComp&gt;</span><br></pre></td></tr></table></figure><p>在子组件中，可以使用 <slot> 元素作为插槽出口 (slot outlet) 渲染父组件中的插槽内容 (slot content)：<br><slot> 插口中的内容将被当作“默认”内容：它会在父组件没有传递任何插槽内容时显示</p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在子组件的模板中 --&gt;</span><br><span class="line">&lt;slot&gt;Fallback content&lt;/slot&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;from parent&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/ChildComp&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;slot&gt;Fallback content&lt;/slot&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;script setup&gt;</code> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。当同时使用 SFC 与组合式 API 时该语法是默认推荐。相比于普通的 <code>&lt;script&gt;</code> 语法，它具有更多优势：<br>里面的代码会被编译成组件 setup() 函数的内容。这意味着与普通的 <script> 只在组件被首次引入的时候执行一次不同，<script setup> 中的代码会在每次组件实例被创建的时候执行。</p><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h2&gt;&lt;p&gt;Vue 的核心功能是声明式渲染：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络防范</title>
    <link href="http://example.com/2023/10/19/%E7%BD%91%E7%BB%9C%E9%98%B2%E8%8C%83/"/>
    <id>http://example.com/2023/10/19/%E7%BD%91%E7%BB%9C%E9%98%B2%E8%8C%83/</id>
    <published>2023-10-19T03:31:30.000Z</published>
    <updated>2023-10-19T03:31:30.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>CE修改器入门</title>
    <link href="http://example.com/2023/10/19/CE%E4%BF%AE%E6%94%B9%E5%99%A8%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2023/10/19/CE%E4%BF%AE%E6%94%B9%E5%99%A8%E5%85%A5%E9%97%A8/</id>
    <published>2023-10-19T00:53:08.000Z</published>
    <updated>2023-10-19T00:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新手教程"><a href="#新手教程" class="headerlink" title="新手教程"></a>新手教程</h2><p><a href="https://cheatengine.org/">cheat engine 官网</a></p><p>附加<code>Tutorial-i386.exe进程</code>后,我们点击教程的下一步按钮，接着继续第二关，第二关的作用还是很简单的，主要目的是遍历出我们想要的动态数据，比如角色的生命，人物的魔法等，都会用到精确扫描，可以说这一关是既简单又实用的东西，也是今后制作中最常用的环节，接着我们看下<code>Tutorial-i386.exe程序</code>对这一关通关流程的描述:</p><blockquote><p>步骤 2: 精确值扫描 (密码&#x3D;090453)</p><p>现在你已经在 Cheat Engine 中打开了训练程序，为我们下一步的练习做好了准备。<br>本窗口的左下方显示的”健康:XXX”，在你每次点击”打我”按钮时，它的值便会减少。<br>要进入下一关，你必须找到这个数值并把它改成 1000 。<br>很多方法都可以找到这个数值的位置，但我将告诉你一个最简单的方法，”精确数值”扫描：</p></blockquote><p>上面的简单描述的意思就是,需要将100这个数值修改为1000则本关就算通过，看下面具体的步骤</p><p>1.首先游戏规则是每次我们点击<code>打我</code>按钮则健康值则会减一,我们首先搜索这个<code>100</code>看能不能找到些什么.</p><p><img src="/img/CE/CE-simple-scan-1.png"></p><p>现在开始搜索精确数值 <code>100</code>  数值中<code>输入100</code> 点击 <code>首次扫描</code> 按钮</p><p><img src="/img/CE/CE-simple-scan-2.png"></p><p>默认情况下一般游戏就是4字节，这里不需要改动<code>扫描类型和数值类型</code>，默认就好了.</p><p>这次扫描我们得到 35 个结果，里面肯定有我们要找的那个血值，不过好像太多了,没关系继续往下看.</p><p><img src="/img/CE/CE-simple-scan-3.png"></p><p>关键一步：为了找到更加精确的数据，我们回到 Tutorial 点击 <code>打我</code> 按钮，此时血值已有变化了：</p><p><img src="/img/CE/CE-simple-scan-4.png"></p><p>我们再输入 <code>95</code> 点击 <code>再次扫描</code> 按钮 结果只剩1个（这就是我们要找的），我们双击此地址将其添加到地址栏：</p><p><img src="/img/CE/CE-simple-scan-5.png"></p><p>此时地址栏里面只有1个结果了，这个就是我们要找的内存地址，双击将其加入到地址栏</p><p><img src="/img/CE/CE-simple-scan-6.png"></p><p>在数值95上面双击，并修改把 95 改成 1000 点击<code>确定</code>按钮,此时通关.</p><p><img src="/img/CE/CE-simple-scan-7.png"></p><p>此时回到Tutorial-i386.exe程序，会发现教程的 <code>下一步</code> 按钮变成可用,再次点击打我按钮，数值变大了，继续点击下一步进入第三关…</p><p><img src="/img/CE/CE-simple-scan-8.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新手教程&quot;&gt;&lt;a href=&quot;#新手教程&quot; class=&quot;headerlink&quot; title=&quot;新手教程&quot;&gt;&lt;/a&gt;新手教程&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://cheatengine.org/&quot;&gt;cheat engine 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>外挂分析与实现</title>
    <link href="http://example.com/2023/10/19/%E5%A4%96%E6%8C%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/10/19/%E5%A4%96%E6%8C%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-10-19T00:39:59.000Z</published>
    <updated>2023-10-19T00:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PVZ辅助"><a href="#PVZ辅助" class="headerlink" title="PVZ辅助"></a>PVZ辅助</h2><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/tree/main">PlantsVsZombies-Cheat: 植物大战僵尸逆向分析与辅助开发系列教程(github.com)</a></p><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><h4 id="OnlyDbg使用"><a href="#OnlyDbg使用" class="headerlink" title="OnlyDbg使用"></a>OnlyDbg使用</h4><p><a href="https://www.bilibili.com/video/BV1cE411f7sE/?p=6&spm_id_from=pageDriver&vd_source=206a091077ff783d662b49e64cc9589d">06.常用断点之硬件断点原理解析_哔哩哔哩_bilibili</a></p><p><a href="https://www.cnblogs.com/xueyoo/articles/4938538.html">OllyDBG完美教程(超强入门级) - xueyoo - 博客园 (cnblogs.com)</a></p><p><strong>OllyDBG界面认识</strong><br><img src="/img/Network-attack/OB-desktop.png"></p><ul><li><p>反汇编窗口：显示被调试程序的反汇编代码。用鼠标左键点击注释标签可以切换注释显示的方式。如果需要修改代码，直接在这里在修改，比如“使用NOP填充”。</p></li><li><p>寄存器窗口：显示当前所选线程的CPU寄存器内容。点击标签寄存器(FPU)可以切换显示寄存器的方式。</p></li><li><p>信息窗口：显示反汇编窗口中当前选中的第一条命令的参数及一些跳转目标地址、字串等（一般动态加密解密字串等会在此出现）。</p></li><li><p>数据窗口：显示内存或文件的内容。直接点击ASCII数据可以切换编码显示方式。</p></li><li><p>堆栈窗口：显示当前线程的堆栈数据。比如程序初始化的一些常量、变量之类的数据。</p></li><li><p>菜单窗口：一些常用调试命令以及操作。一般把鼠标移到菜单窗口的某按钮后，界面最左下角会出现一些命令提示，比如单步步入（F7），单步步过F8，运行程序（F9）等。</p></li><li><p>命令行窗口：用来下断点等相关命令。</p></li></ul><p><strong>调试方法</strong></p><p><img src="/img/Network-attack/debug-shortcut-key.png"></p><p>F2：设置断点。只要在光标定位的位置（上图中灰色条）按F2键即可，再按一次F2键则会删除断点。（相当于 SoftICE 中的 F9）<br>F8：单步跳过。每按一次这个键执行一条反汇编窗口中的一条指令，遇到 CALL 等子程序不进入其代码。（相当于 SoftICE 中的 F10）<br>F7：单步步入。功能同单步步过(F8)类似，区别是遇到 CALL 等子程序时会进入其中，进入后首先会停留在子程序的第一条指令上。（相当于 SoftICE 中的 F8）<br>F4：运行到选定位置。作用就是直接运行到光标所在位置处暂停。（相当于 SoftICE 中的 F7）<br>F9：运行。按下这个键如果没有设置相应断点的话，被调试的程序将直接开始运行。（相当于 SoftICE 中的 F5）<br>CTR + F9：执行到返回。此命令在执行到一个 ret (返回指令)指令时暂停，常用于从系统领空返回到我们调试的程序领空。（相当于 SoftICE 中的 F12）<br>ALT + F9：执行到用户代码。可用于从系统领空快速返回到我们调试的程序领空。（相当于 SoftICE 中的 F11） </p><p><strong>常用断点</strong></p><p><a href="https://www.cnblogs.com/LyShark/p/13071792.html">Windows 下的常用调试API断点 - lyshark - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq1084283172/article/details/47733849">OD调试程序常用断点大全_od 创建进程 断点-CSDN博客</a></p><p>[<a href="https://cloud.tencent.com/developer/article/1910265">系统安全] 二十四.逆向分析之OD调试INT3断点、反调试、硬件断点与内存断点-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><strong>汇编指令</strong></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cmp a,b 比较a与b</span><br><span class="line"></span><br><span class="line">mov a,b 把b的值送给a</span><br><span class="line"></span><br><span class="line">ret 返回主程序</span><br><span class="line"></span><br><span class="line">nop 无作用,英文“no operation”的简写，意思是“do nothing”(机器码90)</span><br><span class="line">(解释:ultraedit打开编辑exe文件时你看到90,等同于汇编语句nop)</span><br><span class="line"></span><br><span class="line">call 调用子程序</span><br><span class="line"></span><br><span class="line">je 或jz 若相等则跳(机器码74 或0F84)</span><br><span class="line"></span><br><span class="line">jne或jnz 若不相等则跳(机器码75或0F85)</span><br><span class="line"></span><br><span class="line">jmp 无条件跳(机器码EB)</span><br><span class="line"></span><br><span class="line">jb 若小于则跳</span><br><span class="line"></span><br><span class="line">ja 无符-若大于则跳</span><br><span class="line"></span><br><span class="line">jg 有符-若大于则跳</span><br><span class="line"></span><br><span class="line">jge 若大于等于则跳</span><br><span class="line"></span><br><span class="line">jl 若小于则跳</span><br><span class="line"></span><br><span class="line">jle 若小于等于则跳</span><br><span class="line"></span><br><span class="line">pop 出栈</span><br><span class="line"></span><br><span class="line">push 压栈</span><br></pre></td></tr></table></figure><p>1.E语言在OD里面的入口特征（OEP）<br>E语言的入口其实和VC++基本差不多，所以 在OD里面Ctrl+B 输入 FF 25<br>​2.E语言的按钮事件<br>FF 55 FC 5F 5E，这个就是E语言的按钮在OD中的特征码，搜索它就直接可以找到按钮事件在OD的Call的位置<br>3.E语言常用断点</p><ul><li>MessageBoxA  消息框断点</li><li>ShellExecuteA&#x2F;W   WinExec    弹网页</li><li>CreateProcessA&#x2F;W  创建进程</li><li>ExitProcess       退出进程</li></ul><h4 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h4><p><a href="https://www.52pojie.cn/thread-1646466-1-1.html">练习笔记之手撕常见压缩壳 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.52pojie.cn/thread-1641368-1-1.html">关于压缩壳脱壳步骤详解！看这一篇足够。 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.cnblogs.com/hongren/p/12633232.html">ESP定律脱壳——NsPack3.x脱壳 - 红刃 - 博客园 (cnblogs.com)</a><br><a href="https://www.52pojie.cn/thread-941671-1-1.html">手脱NsPack 壳，新手看看</a><br>什么是壳：<br>壳是一种概念上的东西，人们为了保护软件不会被轻易的修改或者反编译，希望软件能够获得一种保护，能如同乌龟壳保护乌龟一般，能有一个东西保护自己，于是壳就出现了。<br>关于壳的作用：<br>壳的初始作用是保护软件，但后来发展的方向不一就出现了各种各样的壳，大致有压缩壳、加密壳、VM 壳的分类。压缩壳故名思意，主要作用是用于压缩方面，可以有效的减小软件的大小；加密壳，其主要作用是保护软件；VM 壳是一种很特殊的壳，它利用了虚拟机技术，可以很有效的保护指定地址代码，但很大的牺牲了效率，所以一般只在关键代码处使用。</p><p><strong>ESP定律法 （80%的压缩壳可脱）</strong><br>ESP 定律法是脱壳的利器，是应用频率最高的脱壳方法之一。ESP 定律的原理在于程序中堆栈平衡的合理利用。由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器内容压栈，如使用 pushad，在解压结束后，会将之前的寄存器值出栈，如使用 popad。因此在寄存器出栈时，往往程序代码被自动恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的 OEP 位置。</p><p>具体操作步骤：pushad开头，F8一次以后，8个寄存器只有ESP是红色时候，就可以使用该定律。<br>右键ESP 选择数据窗口跟随，数据窗口下硬件访问断点，F9运行，此时已经接近OEP。<br><img src="/img/Network-attack/pvz-shell.png"></p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>可以看到这个辅助的功能有很多，接下来就跟我一起解密这些按钮在点击后发生了什么。</p><blockquote><p>之前分析的时候一直没开游戏只对辅助od，结果破壳破了好久也没成功，但就算破壳也无法直接获取到源码，只能看汇编，破解还是要在游戏中去进行，辅助修改游戏的内存，只要对写内存操作打断点就可以观察具体的修改。踩了这样一个坑，希望引以为戒。</p></blockquote><p><img src="/img/Network-attack/PVZ-analysis-1.png"></p><h4 id="阳光修改"><a href="#阳光修改" class="headerlink" title="阳光修改"></a>阳光修改</h4><p>1.首先我们找出阳光的动态地址，找到之后我们双击这个地址，将其加入到地址列表中，阳光的查找技巧相信你已经能够掌握了，这里就不再罗嗦了。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718105016029-754750877.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718105016029-754750877.png" alt="img"></a></p><p>2.接着我们选择最下方的地址列表，然后按下<code>F6键</code>，也就是下一个硬件写入断点，然后回到游戏等待阳光出现并点击阳光，此时CE会出现以下代码，我们只需要记下<code>00430A11</code>这个内存地址，然后直接关闭CE吧，短期内用不到了。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718105234187-230098721.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718105234187-230098721.png" alt="img"></a></p><p>3.打开OD，然后我们直接附加植物大战僵尸的游戏进程，点击<code>文件</code>然后点击<code>附加</code>选择植物大战僵尸进程就好。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110121994-224028383.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110121994-224028383.png" alt="img"></a></p><p>4.附加完成后，我们的游戏会被OD暂停运行，此时我们直接按下<code>F12</code>让游戏正常的运行，默认情况下会停在系统领空，我们直接按下<code>Ctrl + G</code>输入<code>00401000</code>来到程序领空。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110558599-2081305956.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110558599-2081305956.png" alt="img"></a></p><p>5.接着我们按下<code>Ctrl + G</code>输入<code>00430A11</code>跳转到刚才找到的代码位置，过去以后直接<code>F2</code>下一个断点</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110754502-1706128416.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110754502-1706128416.png" alt="img"></a></p><p>6.紧接着我们回到游戏，然后等待阳光的出现，当阳光出现后我们点击阳光，OD会自动断在00430A11的位置，其中ecx就是要增加的阳光数。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718111426062-1841073246.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718111426062-1841073246.png" alt="img"></a></p><p>上图并没有CALL调用，应该是在外部，我们直接回朔到上一层<code>Ctrl+F9</code>执行到返回，<code>F8</code>直接出CALL.</p><p>7.我们在JNZ和CALL的两处位置下断点，然后运行程序，当我们点击阳光时会断在JNZ的位置，如果把JNZ用NOP填充的话，会发现当我们再次点击阳光的时候阳光会迅速的被回收没有了动画。</p><p>也就是说，JNZ如果成立的话则会有回收阳光的动画，当不成立的时候则会执行<code>call 004309d0</code>显然这就是回收阳光的关键CALL，但我们可猜测，再回收阳光的时候一定会判断是否回收，所以回收的判断应该在上一层。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718111754966-828351196.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718111754966-828351196.png" alt="img"></a></p><p>8.首先我们回到游戏，等待出现阳光然后点击阳光，OD会断下，断下后我们取消这两处的断点，然后跟着OD单步<code>F8</code>向下走，直接出这个CALL，出CALL后会看到如下代码，我们直接下三个断点。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718112814057-159772692.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718112814057-159772692.png" alt="img"></a></p><p>9.下好断点，回到游戏等待阳光下落我们回收，此时OD会断下，我们运行OD发现会一直被断在<code>0043158F</code>只要阳光没有收回就会一直断下，此处的跳转并没有实现，因为我们没有去点击阳光，这里可以得出如果点击了阳光JNZ则会跳转成立，否则不成立等待用户点击回收阳光。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718113135132-2026175107.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718113135132-2026175107.png" alt="img"></a></p><p>10.我们取消所有的断点，然后尝试把JNZ跳转改成JMP无条件跳转，让其只要一出现阳光就自动的触发回收的CALL试试。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718113425831-2135275106.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718113425831-2135275106.png" alt="img"></a></p><p>改完以后我们回到游戏，会发现只要阳光出现了会被立即回收。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718130615227-2143845712.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718130615227-2143845712.png" alt="img"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PVZ辅助&quot;&gt;&lt;a href=&quot;#PVZ辅助&quot; class=&quot;headerlink&quot; title=&quot;PVZ辅助&quot;&gt;&lt;/a&gt;PVZ辅助&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/follow-the-vine-to-get-to-the-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>外挂分析与实现</title>
    <link href="http://example.com/2023/10/19/net-attack&amp;defence-doc/%E5%A4%96%E6%8C%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/10/19/net-attack&amp;defence-doc/%E5%A4%96%E6%8C%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-10-19T00:39:59.000Z</published>
    <updated>2023-10-19T00:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PVZ辅助"><a href="#PVZ辅助" class="headerlink" title="PVZ辅助"></a>PVZ辅助</h2><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/tree/main">PlantsVsZombies-Cheat: 植物大战僵尸逆向分析与辅助开发系列教程(github.com)</a></p><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><h4 id="OnlyDbg使用"><a href="#OnlyDbg使用" class="headerlink" title="OnlyDbg使用"></a>OnlyDbg使用</h4><p><a href="https://www.bilibili.com/video/BV1cE411f7sE/?p=6&spm_id_from=pageDriver&vd_source=206a091077ff783d662b49e64cc9589d">06.常用断点之硬件断点原理解析_哔哩哔哩_bilibili</a></p><p><a href="https://www.cnblogs.com/xueyoo/articles/4938538.html">OllyDBG完美教程(超强入门级) - xueyoo - 博客园 (cnblogs.com)</a></p><p><strong>OllyDBG界面认识</strong><br><img src="/img/Network-attack/OB-desktop.png"></p><ul><li><p>反汇编窗口：显示被调试程序的反汇编代码。用鼠标左键点击注释标签可以切换注释显示的方式。如果需要修改代码，直接在这里在修改，比如“使用NOP填充”。</p></li><li><p>寄存器窗口：显示当前所选线程的CPU寄存器内容。点击标签寄存器(FPU)可以切换显示寄存器的方式。</p></li><li><p>信息窗口：显示反汇编窗口中当前选中的第一条命令的参数及一些跳转目标地址、字串等（一般动态加密解密字串等会在此出现）。</p></li><li><p>数据窗口：显示内存或文件的内容。直接点击ASCII数据可以切换编码显示方式。</p></li><li><p>堆栈窗口：显示当前线程的堆栈数据。比如程序初始化的一些常量、变量之类的数据。</p></li><li><p>菜单窗口：一些常用调试命令以及操作。一般把鼠标移到菜单窗口的某按钮后，界面最左下角会出现一些命令提示，比如单步步入（F7），单步步过F8，运行程序（F9）等。</p></li><li><p>命令行窗口：用来下断点等相关命令。</p></li></ul><p><strong>调试方法</strong></p><p><img src="/img/Network-attack/debug-shortcut-key.png"></p><p>F2：设置断点。只要在光标定位的位置（上图中灰色条）按F2键即可，再按一次F2键则会删除断点。（相当于 SoftICE 中的 F9）<br>F8：单步跳过。每按一次这个键执行一条反汇编窗口中的一条指令，遇到 CALL 等子程序不进入其代码。（相当于 SoftICE 中的 F10）<br>F7：单步步入。功能同单步步过(F8)类似，区别是遇到 CALL 等子程序时会进入其中，进入后首先会停留在子程序的第一条指令上。（相当于 SoftICE 中的 F8）<br>F4：运行到选定位置。作用就是直接运行到光标所在位置处暂停。（相当于 SoftICE 中的 F7）<br>F9：运行。按下这个键如果没有设置相应断点的话，被调试的程序将直接开始运行。（相当于 SoftICE 中的 F5）<br>CTR + F9：执行到返回。此命令在执行到一个 ret (返回指令)指令时暂停，常用于从系统领空返回到我们调试的程序领空。（相当于 SoftICE 中的 F12）<br>ALT + F9：执行到用户代码。可用于从系统领空快速返回到我们调试的程序领空。（相当于 SoftICE 中的 F11） </p><p><strong>常用断点</strong></p><p><a href="https://www.cnblogs.com/LyShark/p/13071792.html">Windows 下的常用调试API断点 - lyshark - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq1084283172/article/details/47733849">OD调试程序常用断点大全_od 创建进程 断点-CSDN博客</a></p><p>[<a href="https://cloud.tencent.com/developer/article/1910265">系统安全] 二十四.逆向分析之OD调试INT3断点、反调试、硬件断点与内存断点-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><strong>汇编指令</strong></p><figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cmp a,b 比较a与b</span><br><span class="line"></span><br><span class="line">mov a,b 把b的值送给a</span><br><span class="line"></span><br><span class="line">ret 返回主程序</span><br><span class="line"></span><br><span class="line">nop 无作用,英文“no operation”的简写，意思是“do nothing”(机器码90)</span><br><span class="line">(解释:ultraedit打开编辑exe文件时你看到90,等同于汇编语句nop)</span><br><span class="line"></span><br><span class="line">call 调用子程序</span><br><span class="line"></span><br><span class="line">je 或jz 若相等则跳(机器码74 或0F84)</span><br><span class="line"></span><br><span class="line">jne或jnz 若不相等则跳(机器码75或0F85)</span><br><span class="line"></span><br><span class="line">jmp 无条件跳(机器码EB)</span><br><span class="line"></span><br><span class="line">jb 若小于则跳</span><br><span class="line"></span><br><span class="line">ja 无符-若大于则跳</span><br><span class="line"></span><br><span class="line">jg 有符-若大于则跳</span><br><span class="line"></span><br><span class="line">jge 若大于等于则跳</span><br><span class="line"></span><br><span class="line">jl 若小于则跳</span><br><span class="line"></span><br><span class="line">jle 若小于等于则跳</span><br><span class="line"></span><br><span class="line">pop 出栈</span><br><span class="line"></span><br><span class="line">push 压栈</span><br></pre></td></tr></table></figure><p>1.E语言在OD里面的入口特征（OEP）<br>E语言的入口其实和VC++基本差不多，所以 在OD里面Ctrl+B 输入 FF 25<br>​2.E语言的按钮事件<br>FF 55 FC 5F 5E，这个就是E语言的按钮在OD中的特征码，搜索它就直接可以找到按钮事件在OD的Call的位置<br>3.E语言常用断点</p><ul><li>MessageBoxA  消息框断点</li><li>ShellExecuteA&#x2F;W   WinExec    弹网页</li><li>CreateProcessA&#x2F;W  创建进程</li><li>ExitProcess       退出进程</li></ul><h4 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h4><p><a href="https://www.52pojie.cn/thread-1646466-1-1.html">练习笔记之手撕常见压缩壳 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.52pojie.cn/thread-1641368-1-1.html">关于压缩壳脱壳步骤详解！看这一篇足够。 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.cnblogs.com/hongren/p/12633232.html">ESP定律脱壳——NsPack3.x脱壳 - 红刃 - 博客园 (cnblogs.com)</a><br><a href="https://www.52pojie.cn/thread-941671-1-1.html">手脱NsPack 壳，新手看看</a><br>什么是壳：<br>壳是一种概念上的东西，人们为了保护软件不会被轻易的修改或者反编译，希望软件能够获得一种保护，能如同乌龟壳保护乌龟一般，能有一个东西保护自己，于是壳就出现了。<br>关于壳的作用：<br>壳的初始作用是保护软件，但后来发展的方向不一就出现了各种各样的壳，大致有压缩壳、加密壳、VM 壳的分类。压缩壳故名思意，主要作用是用于压缩方面，可以有效的减小软件的大小；加密壳，其主要作用是保护软件；VM 壳是一种很特殊的壳，它利用了虚拟机技术，可以很有效的保护指定地址代码，但很大的牺牲了效率，所以一般只在关键代码处使用。</p><p><strong>ESP定律法 （80%的压缩壳可脱）</strong><br>ESP 定律法是脱壳的利器，是应用频率最高的脱壳方法之一。ESP 定律的原理在于程序中堆栈平衡的合理利用。由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器内容压栈，如使用 pushad，在解压结束后，会将之前的寄存器值出栈，如使用 popad。因此在寄存器出栈时，往往程序代码被自动恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的 OEP 位置。</p><p>具体操作步骤：pushad开头，F8一次以后，8个寄存器只有ESP是红色时候，就可以使用该定律。<br>右键ESP 选择数据窗口跟随，数据窗口下硬件访问断点，F9运行，此时已经接近OEP。<br><img src="/img/Network-attack/pvz-shell.png"></p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>可以看到这个辅助的功能有很多，接下来就跟我一起解密这些按钮在点击后发生了什么。</p><blockquote><p>之前分析的时候一直没开游戏只对辅助od，结果破壳破了好久也没成功，但就算破壳也无法直接获取到源码，只能看汇编，破解还是要在游戏中去进行，辅助修改游戏的内存，只要对写内存操作打断点就可以观察具体的修改。踩了这样一个坑，希望引以为戒。</p></blockquote><p><img src="/img/Network-attack/PVZ-analysis-1.png"></p><h4 id="阳光修改"><a href="#阳光修改" class="headerlink" title="阳光修改"></a>阳光修改</h4><p>1.首先我们找出阳光的动态地址，找到之后我们双击这个地址，将其加入到地址列表中，阳光的查找技巧相信你已经能够掌握了，这里就不再罗嗦了。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718105016029-754750877.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718105016029-754750877.png" alt="img"></a></p><p>2.接着我们选择最下方的地址列表，然后按下<code>F6键</code>，也就是下一个硬件写入断点，然后回到游戏等待阳光出现并点击阳光，此时CE会出现以下代码，我们只需要记下<code>00430A11</code>这个内存地址，然后直接关闭CE吧，短期内用不到了。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718105234187-230098721.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718105234187-230098721.png" alt="img"></a></p><p>3.打开OD，然后我们直接附加植物大战僵尸的游戏进程，点击<code>文件</code>然后点击<code>附加</code>选择植物大战僵尸进程就好。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110121994-224028383.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110121994-224028383.png" alt="img"></a></p><p>4.附加完成后，我们的游戏会被OD暂停运行，此时我们直接按下<code>F12</code>让游戏正常的运行，默认情况下会停在系统领空，我们直接按下<code>Ctrl + G</code>输入<code>00401000</code>来到程序领空。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110558599-2081305956.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110558599-2081305956.png" alt="img"></a></p><p>5.接着我们按下<code>Ctrl + G</code>输入<code>00430A11</code>跳转到刚才找到的代码位置，过去以后直接<code>F2</code>下一个断点</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718110754502-1706128416.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718110754502-1706128416.png" alt="img"></a></p><p>6.紧接着我们回到游戏，然后等待阳光的出现，当阳光出现后我们点击阳光，OD会自动断在00430A11的位置，其中ecx就是要增加的阳光数。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718111426062-1841073246.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718111426062-1841073246.png" alt="img"></a></p><p>上图并没有CALL调用，应该是在外部，我们直接回朔到上一层<code>Ctrl+F9</code>执行到返回，<code>F8</code>直接出CALL.</p><p>7.我们在JNZ和CALL的两处位置下断点，然后运行程序，当我们点击阳光时会断在JNZ的位置，如果把JNZ用NOP填充的话，会发现当我们再次点击阳光的时候阳光会迅速的被回收没有了动画。</p><p>也就是说，JNZ如果成立的话则会有回收阳光的动画，当不成立的时候则会执行<code>call 004309d0</code>显然这就是回收阳光的关键CALL，但我们可猜测，再回收阳光的时候一定会判断是否回收，所以回收的判断应该在上一层。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718111754966-828351196.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718111754966-828351196.png" alt="img"></a></p><p>8.首先我们回到游戏，等待出现阳光然后点击阳光，OD会断下，断下后我们取消这两处的断点，然后跟着OD单步<code>F8</code>向下走，直接出这个CALL，出CALL后会看到如下代码，我们直接下三个断点。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718112814057-159772692.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718112814057-159772692.png" alt="img"></a></p><p>9.下好断点，回到游戏等待阳光下落我们回收，此时OD会断下，我们运行OD发现会一直被断在<code>0043158F</code>只要阳光没有收回就会一直断下，此处的跳转并没有实现，因为我们没有去点击阳光，这里可以得出如果点击了阳光JNZ则会跳转成立，否则不成立等待用户点击回收阳光。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718113135132-2026175107.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718113135132-2026175107.png" alt="img"></a></p><p>10.我们取消所有的断点，然后尝试把JNZ跳转改成JMP无条件跳转，让其只要一出现阳光就自动的触发回收的CALL试试。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718113425831-2135275106.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718113425831-2135275106.png" alt="img"></a></p><p>改完以后我们回到游戏，会发现只要阳光出现了会被立即回收。</p><p><a href="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/blob/main/image/1379525-20190718130615227-2143845712.png"><img src="https://github.com/follow-the-vine-to-get-to-the-melon/PlantsVsZombies-Cheat/raw/main/image/1379525-20190718130615227-2143845712.png" alt="img"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PVZ辅助&quot;&gt;&lt;a href=&quot;#PVZ辅助&quot; class=&quot;headerlink&quot; title=&quot;PVZ辅助&quot;&gt;&lt;/a&gt;PVZ辅助&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/follow-the-vine-to-get-to-the-</summary>
      
    
    
    
    
  </entry>
  
</feed>
