
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 8.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>Linux基础 - H1S97X</title>

  
    <meta name="description" content="VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili 符号：『』❑ ➢  参考资料主要参考书   图书名称: Ubuntu Linux应用技术教程     封面图片:     出版印刷时间: 2009-4    出版社: 清华大学出版社    图书作者: 陈明 编著    ISBN: 9787302193289       图书名称: Linux就该这么">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux基础">
<meta property="og:url" content="https://h1s97x.github.io/2023/12/24/Linux%E5%9F%BA%E7%A1%80/">
<meta property="og:site_name" content="H1S97X">
<meta property="og:description" content="VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili 符号：『』❑ ➢  参考资料主要参考书   图书名称: Ubuntu Linux应用技术教程     封面图片:     出版印刷时间: 2009-4    出版社: 清华大学出版社    图书作者: 陈明 编著    ISBN: 9787302193289       图书名称: Linux就该这么">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://h1s97x.github.io/images/calf.png">
<meta property="article:published_time" content="2023-12-24T02:27:16.000Z">
<meta property="article:modified_time" content="2023-12-24T02:27:16.000Z">
<meta property="article:author" content="H1S97X">
<meta property="article:tag" content="技术博客,编程,开发,运维,游戏,学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://h1s97x.github.io/images/calf.png">
  
  
  
  <meta name="keywords" content="技术博客,编程,开发,运维,游戏,学习">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="H1S97X" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.1">


  
    <link rel="shortcut icon" href="/favicon.ico?v=20240507">
  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"H1S97X","sameAs":[],"image":"https://h1s97x.github.io/images/calf.png"},"dateCreated":"2023-12-24T10:27:16+08:00","dateModified":"2023-12-24T10:27:16+08:00","datePublished":"2023-12-24T10:27:16+08:00","description":"","headline":"Linux基础","mainEntityOfPage":{"@type":"WebPage","@id":"https://h1s97x.github.io/2023/12/24/Linux%E5%9F%BA%E7%A1%80/"},"publisher":{"@type":"Organization","name":"H1S97X","sameAs":[],"image":"https://h1s97x.github.io/images/calf.png","logo":{"@type":"ImageObject","url":"https://h1s97x.github.io/images/calf.png"}},"url":"https://h1s97x.github.io/2023/12/24/Linux%E5%9F%BA%E7%A1%80/","image":[]}</script>
  
</head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/calf.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main">H1S97X</div><div class="sub normal cap">技术分享与生活记录</div><div class="sub hover cap" style="opacity:0"> 或有月下赏花人 应无所憾</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>



<widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/%E9%AD%823%E8%B4%B4%E5%90%A7/"><span class="title">魂3贴吧</span></a><a class="item title" href="/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/%E9%AD%82%E5%AD%A6/"><span class="title">魂学</span></a><a class="item title" href="/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4/%E8%A7%A3%E8%B0%9C/"><span class="title">解谜</span></a><a class="item title" href="/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/%E6%88%98%E7%BD%91/"><span class="title">战网</span></a><a class="item title" href="/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/%E6%94%BB%E7%95%A5-%E6%9D%80%E6%88%AE%E5%B0%96%E5%A1%94/"><span class="title">攻略 杀戮尖塔</span></a><a class="item title" href="/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/%E6%94%BB%E7%95%A5-%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4%E5%86%92%E9%99%A9/"><span class="title">攻略 炉石传说冒险</span></a><a class="item title" href="/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/%E6%B8%B8%E6%88%8F%E6%8A%80%E5%B7%A7/%E4%B9%9D%E5%AE%AB%E6%A0%BC/"><span class="title">九宫格</span></a><a class="item title" href="/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/%E6%B8%B8%E6%88%8F%E6%8A%80%E5%B7%A7/%E6%95%B0%E7%8B%AC/"><span class="title">数独</span></a><a class="item title" href="/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/%E6%B8%B8%E6%88%8F%E6%8A%80%E5%B7%A7/%E5%9B%B4%E6%A3%8B/"><span class="title">围棋</span></a><a class="item title" href="/2025/12/27/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/%E6%96%87%E6%98%8E%E5%85%AD/%E5%9D%90%E5%9F%8E/"><span class="title">坐城</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2023-12-24T02:27:16.000Z">2023-12-24</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2023-12-24T02:27:16.000Z">2023-12-24</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Linux基础</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YY4y1n75r/?vd_source=206a091077ff783d662b49e64cc9589d">VIM 快速入门之常用命令解析1,VIM复制，粘贴，剪切，替换，查找_哔哩哔哩_bilibili</a></p>
<p>符号：『』❑ ➢ </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="主要参考书"><a href="#主要参考书" class="headerlink" title="主要参考书"></a>主要参考书</h3><table>
<thead>
<tr>
<th>图书名称:</th>
<th>Ubuntu Linux应用技术教程</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>封面图片:</td>
<td><img src="https://www.tup.com.cn/upload/bigbookimg/031209-02.jpg" alt="img"></td>
<td></td>
</tr>
<tr>
<td>出版印刷时间:</td>
<td>2009-4</td>
<td></td>
</tr>
<tr>
<td>出版社:</td>
<td>清华大学出版社</td>
<td></td>
</tr>
<tr>
<td>图书作者:</td>
<td>陈明 编著</td>
<td></td>
</tr>
<tr>
<td>ISBN:</td>
<td>9787302193289</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>图书名称:</th>
<th>Linux就该这么学（第2版）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>封面图片:</td>
<td><img src="https://img1.doubanio.com/view/subject/s/public/s34016388.jpg" alt="Linux就该这么学（第2版）"></td>
<td></td>
</tr>
<tr>
<td>出版印刷时间:</td>
<td>2021-9</td>
<td></td>
</tr>
<tr>
<td>出版社:</td>
<td>人民邮电出版社</td>
<td></td>
</tr>
<tr>
<td>图书作者:</td>
<td>刘遄 编著</td>
<td></td>
</tr>
<tr>
<td>ISBN:</td>
<td>9787115570116</td>
<td></td>
</tr>
</tbody></table>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a target="_blank" rel="noopener" href="https://www.linuxprobe.com/chapter-00.html">第0章 咱们先来谈谈学习方法和红帽系统。 | 《Linux就该这么学》 (linuxprobe.com)</a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><p>Linux应用课程基础</p>
</li>
<li><p>Linux基础命令</p>
</li>
<li><p>文件系统</p>
</li>
<li><p>权限管理</p>
</li>
<li><p>Vi应用</p>
</li>
<li><p>进程管理</p>
</li>
<li><p>SHELL编程</p>
</li>
</ul>
<h2 id="Chapter-1-Linux-概述"><a href="#Chapter-1-Linux-概述" class="headerlink" title="Chapter 1 Linux 概述"></a>Chapter 1 Linux 概述</h2><h3 id="1-1-Linux-操作系统简述"><a href="#1-1-Linux-操作系统简述" class="headerlink" title="1.1 Linux 操作系统简述"></a>1.1 Linux 操作系统简述</h3><p>操作系统是计算机系统的基本系统软件。操作系统是所有软件的核心。操作系统负责控制、管理计算机的所有软件、硬件资源，是惟一直接和硬件系统打交道的软件，是整个软件系统的基础部分，同时还为计算机用户提供良好的界面。因此，操作系统直接面对所有硬件、软件和用户，它是协调计算机各组成部分之间、人机之间关系的重要软件系统。</p>
<h4 id="强大好用的Shell"><a href="#强大好用的Shell" class="headerlink" title="强大好用的Shell"></a>强大好用的Shell</h4><p>一台完整的计算机是由运算器、控制器、存储器、输入&#x2F;输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。Linux系统的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。</p>
<p>与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。</p>
<p>如图所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。</p>
<p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/05/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%A1%AC%E4%BB%B6-1.jpg" alt="第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令"></p>
<p>讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。</p>
<p>看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。</p>
<p>Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：</p>
<blockquote>
<p>通过上下方向键来调取执行过的Linux命令；</p>
<p>命令或参数仅需输入前几位就可以用Tab键补全；</p>
<p>具有强大的批处理脚本；</p>
<p>具有实用的环境变量功能。</p>
</blockquote>
<h3 id="1-2-发展史"><a href="#1-2-发展史" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3><h3 id="1-3-Linux-的特点与组成"><a href="#1-3-Linux-的特点与组成" class="headerlink" title="1.3 Linux 的特点与组成"></a>1.3 Linux 的特点与组成</h3><p>Linux是多用户、多任务、抢占式操作系统，原作者Linus，是开源操作系统。</p>
<p>Linux系统基本组成:</p>
<ul>
<li>Kernel 内核</li>
<li>SHELL（bash）</li>
<li>Applications 应用程序</li>
</ul>
<p>§ Kernel</p>
<p>  1、 管理程序的运行，为程序分派资源，处理程序之间的通信<br>  2、 管理对文件系统的读写<br>  3、 把对文件系统的操作映射成对磁盘或其他设备的操作<br>  4、 管理输入，输出，将设备映射成设备文件<br>  5、 管理网络<br>§ Shell</p>
<p>  1、 Shell:是一个命令解释器，是内核和用户之间的接口。<br>  2、 Shell:是一个编程语言。(Shell script)<br>  3、 系统的启动过程：init-&gt; login -&gt; passwd -&gt; shell</p>
<p>§ Linux应用程序</p>
<p>• 标准的Linux系统都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等。</p>
<h3 id="1-4-Linux-发行版本"><a href="#1-4-Linux-发行版本" class="headerlink" title="1.4 Linux 发行版本"></a>1.4 Linux 发行版本</h3><p>在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。</p>
<blockquote>
<p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序。</p>
<p>Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。</p>
</blockquote>
<p>Linux 发行版是由包含 Linux 内核和软件包管理系统的软件集合组成的操作系统。Linux 用户通常通过下载其中一个 Linux 发行版来获取他们的操作系统，这些发行版可用于各种系统，从嵌入式设备（例如，OpenWrt）和个人计算机（例如，Linux Mint）到强大的超级计算机（例如，Rocks Cluster Distribution）。</p>
<p>典型的 Linux 发行版包括一个（通常经过修改的）Linux 内核、一个初始化系统（如 systemd、OpenRC 或 runit）、GNU 工具和库、文档和许多其他软件（如 IP 网络配置实用程序和 getty TTY 安装程序等）。（可选）提供桌面体验（最常见的是 Mesa 用户空间图形驱动程序）、显示服务器（最常见的是 X.org Server，或者最近的 Wayland 合成器，如 Sway、KDE 的 KWin 或 GNOME 的 Mutter）、桌面环境、声音服务器（通常是 PulseAudio 或最近的 PipeWire）），其他相关程序可能包含在发行版中，也可以由用户安装。</p>
<p>大多数包含的软件都是免费的开源软件，既可以作为编译的二进制文件提供，也可以以源代码形式提供，允许对原始软件进行修改。通常，Linux 发行版可以选择性地包含一些可能不以源代码形式提供的专有软件，例如某些设备驱动程序所需的二进制 Blob。</p>
<h4 id="红帽企业版系统（RHEL-RedHatEnterpriseLinux）"><a href="#红帽企业版系统（RHEL-RedHatEnterpriseLinux）" class="headerlink" title="红帽企业版系统（RHEL,RedHatEnterpriseLinux）"></a>红帽企业版系统（RHEL,RedHatEnterpriseLinux）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p>
<p>前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1993年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。</p>
<p>红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。</p>
<p>红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。</p>
<h4 id="CentOS社区企业操作系统（Community-Enterprise-Operating-System）"><a href="#CentOS社区企业操作系统（Community-Enterprise-Operating-System）" class="headerlink" title="CentOS社区企业操作系统（Community Enterprise Operating System）"></a>CentOS社区企业操作系统（Community Enterprise Operating System）</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p>
<p>顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。</p>
<p>从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL 8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。</p>
<h4 id="Fedora-Linux"><a href="#Fedora-Linux" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p>
<p>Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。</p>
<p>Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows 10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。</p>
<h4 id="Debian-Linux"><a href="#Debian-Linux" class="headerlink" title="Debian Linux"></a>Debian Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p>
<p>一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人Ian Murdock和他女朋友Debra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。</p>
<p>Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。</p>
<h4 id="Ubuntu-Linux"><a href="#Ubuntu-Linux" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p>
<p>ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。</p>
<p>Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。</p>
<h4 id="Kali-Linux"><a href="#Kali-Linux" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p>
<p>跟上面的呆萌大蜥蜴相比，Kali Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。</p>
<h3 id="开源共享精神"><a href="#开源共享精神" class="headerlink" title="开源共享精神"></a><strong>开源共享精神</strong></h3><p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p>
<p><img src="https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License.png" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"></p>
<p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p>
<p>开源许可证总览：<a target="_blank" rel="noopener" href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p>
<h2 id="Chapter-2-Linux-基本命令"><a href="#Chapter-2-Linux-基本命令" class="headerlink" title="Chapter 2 Linux 基本命令"></a>Chapter 2 Linux 基本命令</h2><h3 id="执行命令的必备知识"><a href="#执行命令的必备知识" class="headerlink" title="执行命令的必备知识"></a>执行命令的必备知识</h3><p>既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。</p>
<p>常见的执行Linux命令的格式是下面这样的。</p>
<blockquote>
<p>命令名称   [命令参数]   [命令对象]</p>
</blockquote>
<p><strong>命令名称</strong>：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。</p>
<p><strong>命令参数</strong>：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“–”与“-”作为前缀（示例请见表2-1）。</p>
<table>
<thead>
<tr>
<th>表2-1    Linux命令参数的长格式与短格式示例</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>长格式</td>
<td>man –help</td>
</tr>
<tr>
<td>短格式</td>
<td>man -h</td>
</tr>
</tbody></table>
<p><strong>命令对象</strong>：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。</p>
<blockquote>
<p><em>Tips</em></p>
<p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。</p>
</blockquote>
<h4 id="常用的按键"><a href="#常用的按键" class="headerlink" title="常用的按键"></a>常用的按键</h4><p>Tab键：</p>
<p>​	在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：</p>
<p><code>&lt;ctrl+c&gt;</code>:</p>
<p>​     当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+C组合键，命令行终端的控制权会立刻回到我们手中。</p>
<p><code>&lt;Ctrl+d&gt;</code>:</p>
<p>​     表示键盘输入结束，中断当前的通信或从文件中退出。</p>
<p><code>&lt;ctrl+l&gt;</code>:</p>
<p>​	清空当前终端中已有的内容（相当于清屏操作）。</p>
<h3 id="2-1-常用系统工作命令"><a href="#2-1-常用系统工作命令" class="headerlink" title="2.1 常用系统工作命令"></a>2.1 常用系统工作命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">echo</td>
<td align="center">显示一串字符</td>
</tr>
<tr>
<td align="center">passwd</td>
<td align="center">修改密码</td>
</tr>
<tr>
<td align="center">clear</td>
<td align="center">清除显示器</td>
</tr>
<tr>
<td align="center">lpr</td>
<td align="center">打印</td>
</tr>
<tr>
<td align="center">shutdown</td>
<td align="center">关机</td>
</tr>
<tr>
<td align="center">reboot</td>
<td align="center">重启计算机</td>
</tr>
<tr>
<td align="center">ps</td>
<td align="center">查看目前程序执行情况</td>
</tr>
<tr>
<td align="center">top</td>
<td align="center">查看目前程序执行情景和内存使用情况</td>
</tr>
<tr>
<td align="center">kill</td>
<td align="center">终止一个进程</td>
</tr>
<tr>
<td align="center">date</td>
<td align="center">更改或者查看目前时间</td>
</tr>
</tbody></table>
<h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为<code>echo [字符串] [$变量]</code>。</p>
<p>这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行<code>echo 字符串</code>或<code>echo $变量</code>就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。</p>
<h4 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示或设置系统的时间与日期，语法格式为<code>date [+指定的格式]</code>。</p>
<h4 id="timedatectl命令"><a href="#timedatectl命令" class="headerlink" title="timedatectl命令"></a>timedatectl命令</h4><p>timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为<code>timedatectl [参数]</code>。</p>
<h4 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，输入该命令后按回车键执行即可。</p>
<p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。</p>
<h4 id="poweroff命令"><a href="#poweroff命令" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，输入该命令后按回车键执行即可。</p>
<p>与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑</p>
<h4 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。</p>
<p>借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>后台下载模式</td>
</tr>
<tr>
<td>-P</td>
<td>下载到指定目录</td>
</tr>
<tr>
<td>-t</td>
<td>最大尝试次数</td>
</tr>
<tr>
<td>-c</td>
<td>断点续传</td>
</tr>
<tr>
<td>-p</td>
<td>下载页面内所有资源，包括图片、视频等</td>
</tr>
<tr>
<td>-r</td>
<td>递归下载</td>
</tr>
</tbody></table>
<h4 id="history命令"><a href="#history命令" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示执行过的命令历史，语法格式为“history [-c]”。</p>
<p>history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义&#x2F;etc&#x2F;profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。</p>
<h3 id="2-2-文件管理"><a href="#2-2-文件管理" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h3><h4 id="管理文件和目录的命令"><a href="#管理文件和目录的命令" class="headerlink" title="管理文件和目录的命令"></a>管理文件和目录的命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pwd</td>
<td align="center">显示当前工作目录</td>
</tr>
<tr>
<td align="center">cd</td>
<td align="center">将活动目录更改为指定的路径</td>
</tr>
<tr>
<td align="center">ls</td>
<td align="center">显示指定工作目录的内容</td>
</tr>
<tr>
<td align="center">cat</td>
<td align="center">显示文件的内容</td>
</tr>
<tr>
<td align="center">grep</td>
<td align="center">在文件中查找某字符</td>
</tr>
<tr>
<td align="center">cp</td>
<td align="center">复制文件</td>
</tr>
<tr>
<td align="center">touch</td>
<td align="center">创建文件</td>
</tr>
</tbody></table>
<p>•locate命令用于查找符合条件的文件。</p>
<p>•whereis命令也用于查找文件。</p>
<p>•which命令会在环境变量$PATH设置的目录里查找符合条件的文件。 </p>
<p>•mkdir是make directory（创建目录）的缩写，用于创建新的目录。</p>
<p>•rmdir用来删除一个空的目录，rm 命令来删除非空目录。</p>
<h5 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h5><p>pwd是Print Working Directory（打印工作目录）的缩写，其功能是显示当前工作目录。</p>
<h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><p>cd是Change Directory（更改目录）的缩写，其功能是将活动目录更改为指定的路径。</p>
<h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><p>ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含的文件及子目录)。</p>
<ul>
<li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li>
<li>-d 只列出目录（不递归列出目录内的文件）。</li>
<li>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等。</li>
<li>-r 倒序显示文件和目录。</li>
<li>-R 递归显示目录中的所有文件和子目录。</li>
<li>-t 将按照修改时间排序，最新的文件在最前面。</li>
<li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li>
<li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li>
<li>-s 大小(size)，按文件大小排序。</li>
</ul>
<h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p>
<p><strong>重定向</strong>:<code>&gt;</code>符号</p>
<p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure>

<p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure>

<h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p>
<p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p>
<p>1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt</span><br></pre></td></tr></table></figure>

<h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><p>•cp: 复制文件或目录，语法为“cp 源文件 目标文件”</p>
<h5 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h5><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>
<p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file            #创建一个名为“file”的新的空白文件 </span><br></pre></td></tr></table></figure>

<h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h5><h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><h4 id="文件阅读命令"><a href="#文件阅读命令" class="headerlink" title="文件阅读命令"></a>文件阅读命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">head</td>
<td align="center">查看文件开头部分</td>
</tr>
<tr>
<td align="center">tail</td>
<td align="center">查看文件结尾的10行</td>
</tr>
<tr>
<td align="center">less</td>
<td align="center">分页工具，一页一页查看信息</td>
</tr>
<tr>
<td align="center">more</td>
<td align="center">分页工具，一页一页查看信息</td>
</tr>
</tbody></table>
<h4 id="文件备份和压缩命令"><a href="#文件备份和压缩命令" class="headerlink" title="文件备份和压缩命令"></a>文件备份和压缩命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bzip2&#x2F;bunzip2</td>
<td align="center">扩展文件名为bz2的压缩&#x2F;解压工具</td>
</tr>
<tr>
<td align="center">gzip&#x2F;gunzip</td>
<td align="center">扩展文件名为gz的压缩&#x2F;解压工具</td>
</tr>
<tr>
<td align="center">zip&#x2F;unzip</td>
<td align="center">扩展文件名为zip的压缩&#x2F;解压工具</td>
</tr>
<tr>
<td align="center">tar</td>
<td align="center">创建备份和归档</td>
</tr>
</tbody></table>
<h4 id="有关磁盘空间的命令"><a href="#有关磁盘空间的命令" class="headerlink" title="有关磁盘空间的命令"></a>有关磁盘空间的命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mount</td>
<td align="center">挂上文件系统</td>
</tr>
<tr>
<td align="center">umount</td>
<td align="center">卸下已经挂上的文件系统</td>
</tr>
<tr>
<td align="center">df</td>
<td align="center">检查个硬盘分区和已挂上来的文件系统的磁盘空间</td>
</tr>
<tr>
<td align="center">du</td>
<td align="center">显示文件目录或大小</td>
</tr>
<tr>
<td align="center">fsck</td>
<td align="center">主要是检查和修复Linux文件系统</td>
</tr>
</tbody></table>
<h3 id="2-3-权限管理"><a href="#2-3-权限管理" class="headerlink" title="2.3 权限管理"></a>2.3 权限管理</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">chmod</td>
<td align="center">改变权限</td>
</tr>
<tr>
<td align="center">useradd</td>
<td align="center">增加用户</td>
</tr>
<tr>
<td align="center">su</td>
<td align="center">修改用户</td>
</tr>
</tbody></table>
<h3 id="2-4-进程管理"><a href="#2-4-进程管理" class="headerlink" title="2.4 进程管理"></a>2.4 进程管理</h3><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。</p>
<p>估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示所有进程（包括其他用户的进程）</td>
</tr>
<tr>
<td>-u</td>
<td>用户以及其他详细信息</td>
</tr>
<tr>
<td>-x</td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody></table>
<p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p>
<blockquote>
<p><strong>R（运行）</strong>：进程正在运行或在运行队列中等待。</p>
<p><strong>S（中断）</strong>：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。</p>
<p><strong>D（不可中断）</strong>：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p>
<p><strong>Z（僵死）</strong>：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p>
<p><strong>T（停止）</strong>：进程收到停止信号后停止运行。</p>
</blockquote>
<h4 id="pstree命令"><a href="#pstree命令" class="headerlink" title="pstree命令"></a>pstree命令</h4><p>pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。</p>
<p>前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令。</p>
<h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。</p>
<p>前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。</p>
<h4 id="nice命令"><a href="#nice命令" class="headerlink" title="nice命令"></a>nice命令</h4><p>nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。</p>
<p>在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。</p>
<h4 id="pidof命令"><a href="#pidof命令" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令</p>
<p>每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。</p>
<h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。</p>
<h4 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。</p>
<h3 id="2-5-有关网络操作的命令"><a href="#2-5-有关网络操作的命令" class="headerlink" title="2.5 有关网络操作的命令"></a>2.5 有关网络操作的命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ftp</td>
<td align="center">传送文件</td>
</tr>
<tr>
<td align="center">telnet</td>
<td align="center">远程登陆</td>
</tr>
<tr>
<td align="center">bye</td>
<td align="center">结束连线并结束程序</td>
</tr>
<tr>
<td align="center">rlogin</td>
<td align="center">远端登入</td>
</tr>
<tr>
<td align="center">ping</td>
<td align="center">检查主机</td>
</tr>
<tr>
<td align="center">netstat</td>
<td align="center">显示网络状态</td>
</tr>
</tbody></table>
<h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。</p>
<p>即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>总共发送次数</td>
</tr>
<tr>
<td>-l</td>
<td>指定网卡名称</td>
</tr>
<tr>
<td>-i</td>
<td>每次间隔时间（秒）</td>
</tr>
<tr>
<td>-W</td>
<td>最长等待时间（秒）</td>
</tr>
</tbody></table>
<h4 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。</p>
<p>只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。</p>
<p>表2-12                         netstat命令中的参数以及作用</p>
<table>
<thead>
<tr>
<th>-a</th>
<th>显示所有连接中的Socket</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>显示正在使用的Socket信息</td>
</tr>
<tr>
<td>-t</td>
<td>显示TCP协议的连接状态</td>
</tr>
<tr>
<td>-u</td>
<td>显示UDP协议的连接状态</td>
</tr>
<tr>
<td>-n</td>
<td>使用IP地址，不使用域名</td>
</tr>
<tr>
<td>-l</td>
<td>仅列出正在监听的服务状态</td>
</tr>
<tr>
<td>-i</td>
<td>显示网卡列表信息</td>
</tr>
<tr>
<td>-r</td>
<td>显示路由表信息</td>
</tr>
</tbody></table>
<h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。</p>
<p>简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。</p>
<blockquote>
<p><strong>标准输入重定向（STDIN，文件描述符为0）</strong>：默认从键盘输入，也可从其他文件或命令中输入。</p>
<p><strong>标准输出重定向（STDOUT，文件描述符为1）</strong>：默认输出到屏幕。</p>
<p><strong>错误输出重定向（STDERR，文件描述符为2）</strong>：默认输出到屏幕。</p>
</blockquote>
<p>输入重定向中用到的符号及其作用</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>命令 &lt; 文件</td>
<td>将文件作为命令的标准输入</td>
</tr>
<tr>
<td>命令 &lt;&lt; 分界符</td>
<td>从标准输入中读入，直到遇见分界符才停止</td>
</tr>
<tr>
<td>命令 &lt; 文件1 &gt; 文件2</td>
<td>将文件1作为命令的标准输入并将标准输出到文件2</td>
</tr>
</tbody></table>
<p>输出重定向中用到的符号及其作用</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>命令 &gt; 文件</td>
<td>将标准输出重定向到一个文件中（清空原有文件的数据）</td>
</tr>
<tr>
<td>命令 2&gt; 文件</td>
<td>将错误输出重定向到一个文件中（清空原有文件的数据）</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件</td>
<td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td>
</tr>
<tr>
<td>命令 2&gt;&gt; 文件</td>
<td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td>
<td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td>
</tr>
</tbody></table>
<h3 id="管道命令符"><a href="#管道命令符" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“<strong>把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</strong>”。</p>
<h3 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。</p>
<p>4个最常用的转义字符如下所示。</p>
<blockquote>
<p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符。</p>
<p><strong>单引号（’ ‘）</strong>：转义其中所有的变量为单纯的字符串。</p>
<p><strong>双引号（” “）</strong>：保留其中的变量属性，不进行转义处理。</p>
<p><strong>反引号（<code> </code>）</strong>：把其中的命令执行后返回结果。</p>
</blockquote>
<h2 id="Chapter-3-Linux-文件系统"><a href="#Chapter-3-Linux-文件系统" class="headerlink" title="Chapter 3 Linux 文件系统"></a>Chapter 3 Linux 文件系统</h2><h3 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><p>  文件系统是对一个存储设备上的数据和元数据进行组织的机制，其目的是易于实现数据的查询和存取。不同的操作系统具有不同的文件系统，一个操作系统可能无法兼容所有的文件系统。Linux文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分开。</p>
<p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p>
<p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p>
<p>Linux 最经典的一句话是：<strong>「一切皆文件」</strong>，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p>
<p>  要透彻理解文件系统，需要明确以下几个名词：</p>
<p>存储介质</p>
<p>用以存储数据的物理设备，如软盘、硬盘、光盘、磁带、网络存储设备等。</p>
<p>磁盘的分割</p>
<p>对于容量较大的存储介质来说，通常是硬盘。在使用时，需要合理地规划分区。常用的Linux磁盘分割工具有fdisk、cfdisk、parted等。此外，还有PQ等第三方工具。</p>
<p>创建文件系统</p>
<p>创建新的文件系统是一个过程，通常成为初始化或格式化，整个过程是针对存储介质进行的。一般情况下，操作系统都有自己相应的工具。创建文件系统是在分割磁盘空间的基础上进行的。</p>
<p><strong>挂载</strong></p>
<p>在Linux或Unix系统中，没有磁盘分区的逻辑概念（如C盘、D盘等），仍和一个种类的文件系统被创建后，都需要挂载到某个特定的目录才能使用，这个过程相当于激活一个文件系统，使它能够使用。</p>
<p>Windows的文件系统挂载使用其内部机制完成，用户基本无法探知其过程。而Linux使用mount工具对文件系统进行挂载。挂载文件系统时，需要明确挂载点。在创建文件系统后，操作系统会提示将此文件系统挂载至哪个位置，这个位置就是挂载点，通常选择“&#x2F;”即根目录。挂载点的实质是一个空的目录。</p>
<h3 id="文件和文件类型"><a href="#文件和文件类型" class="headerlink" title="文件和文件类型"></a>文件和文件类型</h3><p><strong>怎样将“散落”存在磁盘等存储介质上的二进制数据，变换、映射为拿名字即可访问的“信息”是文件系统要解决的问题。</strong></p>
<p>从用户应用软件到文件系统介质示意图</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>文件：是Linux用来存储信息的基本结构， 它是被命名（称为文件名）的、存储在某种媒介（如磁盘、光盘和磁带等）上的一组信息的集合。</p>
<p>文件系统：文件系统实现数据存储的物理（介质）独立性。</p>
<h4 id="文件命名规则"><a href="#文件命名规则" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><p>❑Linux 文件名的最大长度为 256 个字符</p>
<p>❑通常由字母、数字、“.”（点号）、“_”（下划线）或“-”（减号）组成，文件名中不能含有“&#x2F;”符号。</p>
<p>❑避免使用具有特别意义的字符：? * @ # $ &amp; () \ | ; ‘ “ &#96; &lt; &gt; [ ]等（大括号{}不是？）</p>
<p>❑隐藏文件一般是以“.”符号开头；</p>
<p>❑在文件名中的空格或制表符，在引用文件时必须用引号将其括起来；</p>
<p>❑避免使用 ‘+’和‘-‘符号作为文件名的第一个字符</p>
<p>❑大小写敏感</p>
<h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>那就先简单说说Linux中的文件类型，主要关注普通文件、目录文件和符号连接文件。<br>三种基本的文件类型</p>
<p>普通文件（regular file）</p>
<ul>
<li><p>二进制文件</p>
<p>以二进制形式存储在电脑中<br>用户一般只有通过相应的软件才能将其显示出来<br>一般是可执行程序、图形、图像、声音等</p>
</li>
<li><p>文本(txt)文件</p>
<p>以文本的ASCII码形式存储在电脑中，其内容都是可读字符。<br>以“行”为基本结构的信息组织和存储方式</p>
</li>
</ul>
<p>从本质上来说他们之间没有什么区别，因为他们在硬盘上都有一种的存放方式–二进制。<br>但是如果要对他们有些区分的话，那可以这样理解。<br>我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。<br>如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件，可见，文本文件只是二进制文件中的一种特例，<br>为了与文 本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，<br>由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门 用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件 </p>
<p>目录文件（directory）</p>
<p>是一个包含文件的容器，用于存放目录中文件列表信息。</p>
<p>设备文件</p>
<p>块设备（block device）：是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的</p>
<p>  ◆ 以块为单位进行随机存取。<br>  ◆ 常见块设备：软盘、光盘、硬盘。</p>
<p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。</p>
<p>  ◆ 以单个字符为单位进行顺序存取。<br>  ◆ 常见的字符设备：打印机、终端、键盘、鼠标</p>
<ol>
<li>普通文件（-）<ol>
<li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li>
<li>Linux用户可以根据访问权限对普通文件进行查看、更改和删除</li>
</ol>
</li>
<li>目录文件（d，directory file）<ol>
<li>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种</li>
<li>目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们</li>
<li>虽然不能修改，但是我们能够通过vim去查看目录文件的内容</li>
</ol>
</li>
<li>符号链接（l，symbolic link）<ol>
<li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li>
</ol>
</li>
<li>块设备文件（b，block）和字符设备文件（c，char）<ol>
<li>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到</li>
<li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li>
<li>系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</li>
</ol>
</li>
<li>FIFO（p，pipe）<ol>
<li>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</li>
</ol>
</li>
<li>套接字（s，socket）<ol>
<li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li>
<li>这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在</li>
</ol>
</li>
</ol>
<p>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。</p>
<p>不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。</p>
<p>所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p>
<p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和 <strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p>
<ul>
<li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li>
<li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li>
</ul>
<p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p>
<blockquote>
<p>目录项和目录是一个东西吗？<br>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。<br>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。<br>那文件数据是如何存储在磁盘的呢？<br>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p>
</blockquote>
<h3 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>文件系统指文件存在的物理空间</p>
<p>Linux 文件系统由一组普通文件、目录文件、设备文件和链接（符号链接、硬链接）组成。</p>
<p>在 linux 中支持多种不同的文件系统</p>
<p>Linux 将分属不同分区的、单独的文件系统整理形成一个系统的，总的目录层次结构，也即树状、层次结构。</p>
<p>树状层次结构使得 Linux 核心的其它部分及系统中运行的程序会看到统一的文件系统，为用户提供了一种组织、检索和管理信息的便捷、高效的方法。 </p>
<p>文件系统-相关基本概念</p>
<p>§当前目录即当前工作目录、环境变量PWD</p>
<p>§用户主目录：&#x2F;home&#x2F;<username>; 环境变量HOME、~</p>
<p>§绝对路径</p>
<p>§相对路径</p>
<p>§符号链接（可跨文件系统）</p>
<p>§软链接（不可跨文件系统）</p>
<h4 id="路径：绝对路径和相对路径"><a href="#路径：绝对路径和相对路径" class="headerlink" title="路径：绝对路径和相对路径"></a>路径：绝对路径和相对路径</h4><p>§linux系统中每个文件都有一个唯一的路径名。路径名表明了文件的位置。</p>
<p>§路径名分为两种：绝对路径和相对路径</p>
<p>§绝对路径指出从根目录到此文件的路径，一般来说由&#x2F;符号开始。</p>
<p>§相对路径指明从当前目录到此文件的路径，相对路径名以下列方式开始.</p>
<p>• “.”，代表当前目录</p>
<p>• “..”，代表当前目录的父目录</p>
<h4 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p>
<p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p>
<p><img src="https://pic2.zhimg.com/80/v2-b2866c48f36144950a2cc40a7b457c0d_720w.webp" alt="img"></p>
<h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
<p>软连接的功能是为某一个文件在另外一个位置建立一个同步的链接，这个命令最常用的参数是-s。</p>
<blockquote>
<p>具体用法是：<code>ln -s 源文件 目标文件</code></p>
<p>例如：ln -s &#x2F;bin&#x2F;less &#x2F;usr&#x2F;local&#x2F;bin&#x2F;less</p>
<p>-s 是代号（symbolic）的意思。</p>
</blockquote>
<p>这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接有软链接和硬链接两种，软链接就是ln -s ** **,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ** **,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p>
<p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p>
<p><img src="https://pic1.zhimg.com/80/v2-6a18f8aabfdd0e31f3c53f355483cee0_720w.webp" alt="img"></p>
<p><img src="/img/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-1.png"></p>
<p><img src="/img/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-2.png"></p>
<h2 id="Chapter-4-Linux-权限管理"><a href="#Chapter-4-Linux-权限管理" class="headerlink" title="Chapter 4 Linux 权限管理"></a>Chapter 4 Linux 权限管理</h2><p>§多用户、多任务系统必须进行权限控制，权限控制就是确定用户（或者说代表用户执行的程序）对某资源有或无某种操作的权利。</p>
<p>§直接表示会使得权限的表示、判断效率低下。</p>
<p>q多用户、多任务的操作系统决定了常常会有多人同时使用这部主机工作 </p>
<p>q保证每个人的隐私权–&gt;文件所有者 </p>
<p>q资源共享，团队开发–&gt;文件所属用户组</p>
<p>Linux中每个用户都至少属于一个用户组，以保证对一个用户组中的所有用户进行集中管理</p>
<h3 id="4-1-用户身份与能力"><a href="#4-1-用户身份与能力" class="headerlink" title="4.1 用户身份与能力"></a>4.1 用户身份与能力</h3><p>受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加&#x2F;删除用户、启动&#x2F;关闭服务进程、开启&#x2F;禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的命令，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。</p>
<p>开发人员推荐使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。</p>
<p>Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。</p>
<blockquote>
<p><strong>管理员UID为0</strong>：系统的管理员用户。</p>
<p><strong>系统用户UID为1～999</strong>：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。</p>
<p><strong>普通用户UID从1000开始</strong>：是由管理员创建的用于日常工作的用户。</p>
</blockquote>
<p>需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。</p>
<p>为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p>
<p>另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p>
<blockquote>
<p><em>Tips</em></p>
<p>基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。</p>
</blockquote>
<p> 在设定文件权限时，用字符表示用户类型：</p>
<p>u 文件的所有者<br>g 同组用户<br>o 其它用户<br>a all&#x3D;ugo,即所有用户</p>
<h3 id="4-2-文件权限与归属"><a href="#4-2-文件权限与归属" class="headerlink" title="4.2 文件权限与归属"></a>4.2 文件权限与归属</h3><p>在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p>
<p> 对文件和目录的三种权限</p>
<p>•读（r）<br>•写（w）<br>•执行 （x）</p>
<p> 十进制表示</p>
<p>•用三个十进制数字表示文件权限：xyz</p>
<p>•x、y、z 分别代表文件所有者、同组用户和其他用户的文件权限值（一个数<br>字对应一种人）。</p>
<p>•文件权限值为该类型用户对文件的读、写、执行权限值的累加：<br>读(r)：4 写(w)：2 执行(x)：1 禁止(-)：0</p>
<p><img src="/img/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-1.png"></p>
<p><img src="/img/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-2.png"></p>
<p><img src="/img/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-3.png"></p>
<p><strong>重要</strong>：</p>
<p> !IMPORTANT 命令执行对文件权限的限制</p>
<p>➢ 在移动文件时不需要被移动文件的权限，但需其所在目录具有写权限。<br>➢ 在目录下增删文件、子目录时要有目录的写权限（touch,rm,mkdir,rmdir）<br>➢ 用 ls 列目录要有目录的读权限</p>
<p>➢ 进入目录或将该目录作路径分量时(cd)要有目录的执行权限，故要使用任一个<br>文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。<br>➢ 仅当要打开一个文件时，即执行涉及到文件内容的操作时，才需要文件的许可。</p>
<p>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息</p>
<p><img src="/img/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-4.png"></p>
<h2 id="Chapter-5-Linux-常用工具"><a href="#Chapter-5-Linux-常用工具" class="headerlink" title="Chapter 5 Linux 常用工具"></a>Chapter 5 Linux 常用工具</h2><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><h4 id="gedit"><a href="#gedit" class="headerlink" title="gedit"></a>gedit</h4><h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h4><p>❑ vi 是一个较大的 Linux 命令，在启动的时候也有它自己的选项和参数</p>
<p>❑ 基本语法：<br>	vi [-options] [+n] [file]</p>
<p>❑常用选项：</p>
<p>-r 恢复系统突然崩溃时正在编辑的文件。</p>
<p>-R 以只读方式打开文件</p>
<p>+[n] 指明进入 vi 后直接位于文件的第 n 行，如果只有“+”而不指定 n，则光标位于文本的最后一行</p>
<p>如果该文件不存在，会自动建立新文件。</p>
<p>❑基本上 vi&#x2F;vim 共分为三种模式:</p>
<blockquote>
<p><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p>
<p><strong>输入模式</strong>：正常的文本录入。</p>
<p><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。</p>
</blockquote>
<ul>
<li><strong>命令模式（Command Mode）</strong>:光标移动，搜寻、字符和字符串删除、粘贴、取代</li>
</ul>
<p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p>
<p>以下摘要了一些常用的命令，更详细的命令在后面可以自行查看。</p>
<blockquote>
<p><strong>x</strong> – 删除当前光标所在处的字符。</p>
<p><strong>dd</strong> – 删除当前行。</p>
<p><strong>yy</strong> – 复制当前行。</p>
<p><strong>p</strong>（小写） – 粘贴剪贴板内容到光标下方。</p>
<p><strong>P</strong>（大写）– 粘贴剪贴板内容到光标上方。</p>
<p><strong>u</strong> – 撤销上一次操作。</p>
<p><strong>Ctrl + r</strong> – 重做上一次撤销的操作。</p>
<p>nG	跳到第 n 行</p>
<p>0	跳到行首</p>
<p>$	跳到行尾</p>
<p>ctrl+b 前移一页</p>
<p>ctrl+f 后移一页  </p>
</blockquote>
<p>➢ 移动光标 ：最简单的方式是按键盘的上、下、左、右方向键</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">h 或 向左箭头键(←)</td>
<td align="center">光标向左移动一个字符</td>
</tr>
<tr>
<td align="center">j 或 向下箭头键(↓)</td>
<td align="center">光标向下移动一个字符</td>
</tr>
<tr>
<td align="center">k 或 向上箭头键(↑)</td>
<td align="center">光标向上移动一个字符</td>
</tr>
<tr>
<td align="center">l 或 向右箭头键(→)</td>
<td align="center">光标向右移动一个字符</td>
</tr>
<tr>
<td align="center">[Ctrl] + [f]</td>
<td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td align="center">[Ctrl] + [b]</td>
<td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td align="center">[Ctrl] + [d]</td>
<td align="center">屏幕『向下』移动半页</td>
</tr>
<tr>
<td align="center">[Ctrl] + [u]</td>
<td align="center">屏幕『向上』移动半页</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">光标移动到非空格符的下一行</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">光标移动到非空格符的上一行</td>
</tr>
<tr>
<td align="center">n<space></td>
<td align="center">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td>
</tr>
<tr>
<td align="center">0 或功能键[Home]</td>
<td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td align="center">$ 或功能键[End]</td>
<td align="center">移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td align="center">G</td>
<td align="center">移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td align="center">nG</td>
<td align="center">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td align="center">gg</td>
<td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td>
</tr>
<tr>
<td align="center">n<Enter></td>
<td align="center">n 为数字。光标向下移动 n 行(常用)</td>
</tr>
</tbody></table>
<p>➢ 搜索替换 ：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x2F;word</td>
<td align="center">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td>
</tr>
<tr>
<td align="center">?word</td>
<td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td align="center">N</td>
<td align="center">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
<tr>
<td align="center">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td>
<td align="center">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td>
</tr>
<tr>
<td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td>
<td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td>
</tr>
<tr>
<td align="center"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td>
<td align="center">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td>
</tr>
</tbody></table>
<p>➢ 复制、删除、粘贴 ：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x, X</td>
<td align="center">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td align="center">nx</td>
<td align="center">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td>
</tr>
<tr>
<td align="center">ndd</td>
<td align="center">n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td>
</tr>
<tr>
<td align="center">d1G</td>
<td align="center">删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td align="center">dG</td>
<td align="center">删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td align="center">d$</td>
<td align="center">删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td align="center">d0</td>
<td align="center">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td align="center">yy</td>
<td align="center">复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td align="center">nyy</td>
<td align="center">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td>
</tr>
<tr>
<td align="center">y1G</td>
<td align="center">复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td align="center">yG</td>
<td align="center">复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td align="center">y0</td>
<td align="center">复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td align="center">y$</td>
<td align="center">复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td align="center">p, P</td>
<td align="center">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td>
</tr>
<tr>
<td align="center">J</td>
<td align="center">将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td align="center">u</td>
<td align="center">复原前一个动作。(常用)</td>
</tr>
<tr>
<td align="center">[Ctrl]+r</td>
<td align="center">重做上一个动作。(常用)</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td>
</tr>
</tbody></table>
<ul>
<li><strong>输入模式（Insert Mode）</strong>: 编辑文本</li>
</ul>
<p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到命令模式。</p>
<blockquote>
<p><strong>字符按键以及Shift组合</strong>，输入字符</p>
<p><strong>ENTER</strong>，回车键，换行</p>
<p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p>
<p><strong>DEL</strong>，删除键，删除光标后一个字符</p>
<p><strong>方向键</strong>，在文本中移动光标</p>
<p><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</p>
<p><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</p>
<p><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</p>
<p><strong>ESC</strong>，退出输入模式，切换到命令模式</p>
</blockquote>
<ul>
<li><strong>底线命令模式（Last Line Mode）</strong>: 读取、保存文件及其他额外功能</li>
</ul>
<p>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。使用 Esc 键可随时退出底线命令模式。</p>
<blockquote>
<p><strong>:w</strong> – 保存文件。</p>
<p><strong>:q</strong> – 退出 Vim 编辑器。</p>
<p><strong>:wq</strong> – 保存文件并退出 Vim 编辑器。</p>
<p><strong>:q!</strong> – 强制退出Vim 编辑器，不保存修改。</p>
<p>➢正向搜索（&#x2F;）：从光标所在位置起向文件末尾方向搜索。<br>➢反向搜索（?）：从光标所在位置起向文件开头方向搜索。<br>➢搜索得到结果后，可以使用重复命令 n 或 N 沿着相同或相反的方向重复上一次的搜索</p>
<p>➢字符串替换（substitute）<br>语法：<br>[n1, n2]s&#x2F;str1&#x2F;str2&#x2F;[g][c]<br>在第 n1 行到 n2 行的范围内将字符串 str1 用 str2 代替:<br>c 每次替换都由用户确认<br>g 对行中搜索字符串的每次出现进行替换。<br>不加 g 只对行中搜索字符串的首次出现进行替换；<br>例子：<br>:s&#x2F;str1&#x2F;str2&#x2F;<br>用字符串 str2 替换该行中首次出现的字符串 str1<br>:s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换该行中所有出现的字符串 str1<br>:.,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1<br>:1,$s&#x2F;str1&#x2F;str2&#x2F;g<br>用字符串 str2 替换正文中所有出现的字符串 str1</p>
</blockquote>
<p><img src="/img/vim-vi-workmodel.png" alt="img"></p>
<h5 id="命令模式和输入模式切换"><a href="#命令模式和输入模式切换" class="headerlink" title="命令模式和输入模式切换"></a>命令模式和输入模式切换</h5><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i, I</td>
<td align="center">进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td>
</tr>
<tr>
<td align="center">a, A</td>
<td align="center">进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="center">o, O</td>
<td align="center">进入输入模式(Insert mode)：o 为『在目前光标所在的下一行处输入新的一行』； O 为『在目前光标所在的上一行处输入新的一行！』(常用)</td>
</tr>
<tr>
<td align="center">r, R</td>
<td align="center">进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td>
</tr>
<tr>
<td align="center">[Esc]</td>
<td align="center">退出编辑模式，回到一般模式中(常用)</td>
</tr>
</tbody></table>
<p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 </p>
<h5 id="命令模式和底线命令模式切换"><a href="#命令模式和底线命令模式切换" class="headerlink" title="命令模式和底线命令模式切换"></a>命令模式和底线命令模式切换</h5><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:</td>
<td align="center">切换到底线命令模式，以在最底一行输入命令。</td>
</tr>
</tbody></table>
<p><img src="/img/Vim-introduction.jpg"></p>
<table>
<thead>
<tr>
<th align="left">vim 环境的变更</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">:set nu</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td align="left">:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
<p>▪:.+5 将光标移动到当前行往下的第 5 行。<br>▪:345 将光标移到第 345 行</p>
<p>❑ Vim 和 gvim 的高级特色<br>• Vim 代表 Vi IMproved，如同其名称所暗示的那样，Vim 作为标准 UNIX系统 vi 编辑器的提高版而存在。 Vim 除提供和 vi 编辑器一样强大的功能外，还提供有多级恢复、命令行历史以及命令及文件名补全等功能。<br>• gvim 是 vi 的 X Window 版本，该版本支持鼠标选中，一些高级的光标移动功能，并且带有菜单和工具按钮。</p>
<h3 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h3><h3 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h3><h2 id="Chapter-6-Linux-进程管理"><a href="#Chapter-6-Linux-进程管理" class="headerlink" title="Chapter 6 Linux 进程管理"></a>Chapter 6 Linux 进程管理</h2><p>概念：一个进程是一个程序的一次执行的过程。</p>
<p>❑ 操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在CPU 上运行哪个程序、运行多久。</p>
<p>❑ Linux 系统的一个重要特点：可以同时启动多个进程。</p>
<p>❑ 进程和程序不同：</p>
<ul>
<li>程序是静态的，是保存在磁盘上的可执行代码和数据的集合；</li>
<li>进程是动态的，是 Linux 系统的基本调度单位。</li>
</ul>
<p>❑ 父进程和子进程</p>
<ul>
<li>一个进程创建新进程称为创建了子进程(child process)。</li>
<li>创建子进程的进程称为父进程。</li>
</ul>
<p>❑ 进程号</p>
<ul>
<li>PID：Process Identity number。一个 PID 唯一地标识一个进程。</li>
<li>PPID：Parent Process ID。进程的父进程号。</li>
</ul>
<h2 id="Chapter-7-Linux-Shell"><a href="#Chapter-7-Linux-Shell" class="headerlink" title="Chapter 7 Linux Shell"></a>Chapter 7 Linux Shell</h2><h3 id="各种shell"><a href="#各种shell" class="headerlink" title="各种shell"></a>各种shell</h3><p>Bourne shell (sh) UNIX 最初使用，且在每种 UNIX 上都可以使用。在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。 sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</p>
<p>C shell (csh) csh，一个语法上接近于C语言的shell。 sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p>
<p>Korn shell (ksh) 完全向上兼容 Bourne shell 并包含了 C shell 的很多特性。</p>
<p>Bourne Again shell (bash) 因为Linux 操作系统缺省的 shell。即 bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。在 Bourne shell 的基础上增加、增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能。包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p>
<p>Debian Almquist shell (dash) 原来bash是GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 的符号连接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p>
<p>zsh zsh配置复杂，所以很多人都不会使用。直到有一天出了Oh My Zsh项目（<a target="_blank" rel="noopener" href="https://github.com/robbyrussell/oh-my-zsh%EF%BC%89%EF%BC%8C%E6%89%8D%E8%AE%A9%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8zsh%E3%80%82%E6%9C%89%E4%BA%BA%E8%AF%B4zsh%E6%98%AF%E7%BB%88%E6%9E%81shell%E3%80%82zsh%E5%BE%88%E6%BC%82%E4%BA%AE%EF%BC%8C%E5%BE%88%E7%82%AB%E9%85%B7%EF%BC%8C%E4%BB%A5%E5%89%8D%E6%98%AF%E6%9E%81%E5%AE%A2%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%8F%E7%99%BD%E9%80%9A%E8%BF%87oh-my-zsh%E5%8F%AF%E4%BB%A5%E7%82%AB%E8%80%80%E3%80%82">https://github.com/robbyrussell/oh-my-zsh），才让更多人发现并开始使用zsh。有人说zsh是终极shell。zsh很漂亮，很炫酷，以前是极客使用，现在小白通过oh-my-zsh可以炫耀。</a></p>
<h3 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p>
<blockquote>
<p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p>
<p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p>
</blockquote>
<p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p>
<h3 id="Shell脚本练习"><a href="#Shell脚本练习" class="headerlink" title="Shell脚本练习"></a>Shell脚本练习</h3><p>脚本1:输入一个正整数，输出0到这个正整数的平方数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入一个正整数&quot; n</span><br><span class="line">i=0</span><br><span class="line">While [ $i -le $n ]</span><br><span class="line"> do</span><br><span class="line"> j= $((i*i))</span><br><span class="line"> echo $j</span><br><span class="line"> i=((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>脚本2:输出序列的最大数、次最大数、最小数、次最小数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Read -p &quot;请输入系列正整数，0结束&quot; n</span><br><span class="line">max=n; min=n; sMax= n;sMin=n</span><br><span class="line">While [ $n -ne 0 ]</span><br><span class="line"> do</span><br><span class="line"> read n</span><br><span class="line"> if [ $n -gt $max ] ;then</span><br><span class="line"> sMax=max; max= $n;</span><br><span class="line"> elif[$n -gt sMax];then</span><br><span class="line"> sMax=$n</span><br><span class="line"> fi</span><br><span class="line"> if [ $n -It $min ] ;then</span><br><span class="line"> sMin= $min; min= $n;</span><br><span class="line"> elif[$n-ItsMin];then</span><br><span class="line"> sMin= $n</span><br><span class="line"> fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="linux下普通用户变为root权限的三种方法"><a href="#linux下普通用户变为root权限的三种方法" class="headerlink" title="linux下普通用户变为root权限的三种方法"></a>linux下普通用户变为root权限的三种方法</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43886632/article/details/108244302">Linux下普通用户变为root权限的三种方法_19.如何从普通用户xiaoming切换到root?-CSDN博客</a></p>
<p><strong>方法3</strong></p>
<p>修改 &#x2F;etc&#x2F;passwd 文件，找到xiaoming，把用户ID修改为 0 </p>
<h2 id="Linux-一些概念"><a href="#Linux-一些概念" class="headerlink" title="Linux 一些概念"></a>Linux 一些概念</h2><p>Kernel 内核：</p>
<ol>
<li><p>管理程序运行，为系统分配资源，处理程序间的通信</p>
</li>
<li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其他设备的操作</p>
</li>
<li><p>管理存储器，为程序分配内存，并且管理虚拟内存</p>
</li>
<li><p>管理输入输出，将设备映射成设备文件</p>
</li>
<li><p>管理网络</p>
</li>
</ol>
<p>Shell</p>
<p>是一个命令解释器，是内核和用户之间的接口</p>
<p>是一个编程语言</p>
<blockquote>
<p>Shell 和内核的关系<br>Shell 是内核的保护层，对用户屏蔽内核的复杂性。<br>保护内核以免用户误操作造成危害。</p>
</blockquote>
<p>Linux<br>  标准的 linux 系统都具有一套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet 工具和数据库等。</p>
<p>文件<br>  文件是 Linux 用来存储信息的基本结构，它是被命名的，存储在某种媒介（如磁盘、光盘和磁带等）上的一种信息集合。</p>
<p>文件系统<br>  Linux 文件系统实现数据存储（物理）介质独立性</p>
<p>目录文件<br>  目录文件存储一组相关文件的位置、大小等与文件有关的信息，但是并不包含文件的具体内容。目录文件中的每一项主要表示的是一个文件名（或子目录名）以及文件的索引节点号。</p>
<p>索引节点<br>  一个文件的索引节点能够指向该文件内容所在的数据块的位置，除此以外它还记录了该文件的属性。目录文件就是通过 i-node 表与文件之间建立对应关系的。</p>
<p>块设备：<br>  以块为单位进行随机存取。如：软盘、光盘、硬盘。</p>
<p>字符设备：<br>  以单个字符为单位进行顺序存取。如：打印机、终端、键盘、鼠标。</p>
<p>文件系统：<br>  指文件存在的物理空间。</p>
<p>树状层次结构<br>  Linux 将分属不同分区的、单独的文件系统整理成一个系统的，总的目录层次结构，即树状结构。</p>
<p>挂接<br>  Linux 通过挂接一个文件系统将该新文件系统加入它的文件系统树中，所有的文件系统，不管是什么类型，都挂接在文件系统树的一个目录上并且该文件系统之上的文件将会掩盖掉这个挂接目录中原有的内容。这个目录称为挂接目录或挂接点。</p>
<p>链接<br>  目录中每一对文件名称名和索引节点号称为一个链接。</p>
<p>进程：<br>  一个进程是一个程序的一次执行的过程。<br>  操作系统通过进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定CPU 上运行哪个程序、运行多久。</p>
<blockquote>
<p>程序与进程的不同：<br>程序：程序是静态的，是保存在磁盘上的可执行代码和数据的集合。<br>进程：进程是动态的，是 Linux 系统的基本调度单位</p>
</blockquote>
<h2 id="Linux-常见目录说明"><a href="#Linux-常见目录说明" class="headerlink" title="Linux 常见目录说明"></a>Linux 常见目录说明</h2><h2 id="Linux-环境变量"><a href="#Linux-环境变量" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>Linux系统中最重要的10个环境变量：</p>
<table>
<thead>
<tr>
<th>变量名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>HOME</td>
<td>用户的主目录（即家目录）</td>
</tr>
<tr>
<td>SHELL</td>
<td>用户在使用的Shell解释器名称</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>输出的历史命令记录条数</td>
</tr>
<tr>
<td>HISTFILESIZE</td>
<td>保存的历史命令记录条数</td>
</tr>
<tr>
<td>MAIL</td>
<td>邮件保存路径</td>
</tr>
<tr>
<td>LANG</td>
<td>系统语言、语系名称</td>
</tr>
<tr>
<td>RANDOM</td>
<td>生成一个随机数字</td>
</tr>
<tr>
<td>PS1</td>
<td>Bash解释器的提示符</td>
</tr>
<tr>
<td>PATH</td>
<td>定义解释器搜索用户执行命令的路径</td>
</tr>
<tr>
<td>EDITOR</td>
<td>用户默认的文本编辑器</td>
</tr>
</tbody></table>
<h2 id="考试复习"><a href="#考试复习" class="headerlink" title="考试复习"></a>考试复习</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/FGRboke/article/details/122095325">linux大学期末考试题库_linux期末考试题库-CSDN博客</a></p>
</article>
<div class="article-footer">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    

</div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2023/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BC%95%E8%AE%BA/">计算机引论</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2023/12/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/">软件工程复习</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">H1S97X</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8F%82%E8%80%83%E4%B9%A6"><span class="toc-text">主要参考书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-text">链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-1-Linux-%E6%A6%82%E8%BF%B0"><span class="toc-text">Chapter 1 Linux 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0"><span class="toc-text">1.1 Linux 操作系统简述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%A4%A7%E5%A5%BD%E7%94%A8%E7%9A%84Shell"><span class="toc-text">强大好用的Shell</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-text">1.2 发展史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Linux-%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E7%BB%84%E6%88%90"><span class="toc-text">1.3 Linux 的特点与组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Linux-%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC"><span class="toc-text">1.4 Linux 发行版本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E5%B8%BD%E4%BC%81%E4%B8%9A%E7%89%88%E7%B3%BB%E7%BB%9F%EF%BC%88RHEL-RedHatEnterpriseLinux%EF%BC%89"><span class="toc-text">红帽企业版系统（RHEL,RedHatEnterpriseLinux）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CentOS%E7%A4%BE%E5%8C%BA%E4%BC%81%E4%B8%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88Community-Enterprise-Operating-System%EF%BC%89"><span class="toc-text">CentOS社区企业操作系统（Community Enterprise Operating System）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fedora-Linux"><span class="toc-text">Fedora Linux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Debian-Linux"><span class="toc-text">Debian Linux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ubuntu-Linux"><span class="toc-text">Ubuntu Linux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kali-Linux"><span class="toc-text">Kali Linux</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E5%85%B1%E4%BA%AB%E7%B2%BE%E7%A5%9E"><span class="toc-text">开源共享精神</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-2-Linux-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">Chapter 2 Linux 基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-text">执行命令的必备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%89%E9%94%AE"><span class="toc-text">常用的按键</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">2.1 常用系统工作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#echo%E5%91%BD%E4%BB%A4"><span class="toc-text">echo命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#date%E5%91%BD%E4%BB%A4"><span class="toc-text">date命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#timedatectl%E5%91%BD%E4%BB%A4"><span class="toc-text">timedatectl命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reboot%E5%91%BD%E4%BB%A4"><span class="toc-text">reboot命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poweroff%E5%91%BD%E4%BB%A4"><span class="toc-text">poweroff命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wget%E5%91%BD%E4%BB%A4"><span class="toc-text">wget命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#history%E5%91%BD%E4%BB%A4"><span class="toc-text">history命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">2.2 文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">管理文件和目录的命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pwd-%E5%91%BD%E4%BB%A4"><span class="toc-text">pwd 命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cd%E5%91%BD%E4%BB%A4"><span class="toc-text">cd命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ls%E5%91%BD%E4%BB%A4"><span class="toc-text">ls命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cat%E5%91%BD%E4%BB%A4"><span class="toc-text">cat命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#grep%E5%91%BD%E4%BB%A4"><span class="toc-text">grep命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cp%E5%91%BD%E4%BB%A4"><span class="toc-text">cp命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#touch%E5%91%BD%E4%BB%A4"><span class="toc-text">touch命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mv%E5%91%BD%E4%BB%A4"><span class="toc-text">mv命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rm%E5%91%BD%E4%BB%A4"><span class="toc-text">rm命令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%98%85%E8%AF%BB%E5%91%BD%E4%BB%A4"><span class="toc-text">文件阅读命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E5%92%8C%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4"><span class="toc-text">文件备份和压缩命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">有关磁盘空间的命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">2.3 权限管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text">2.4 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ps%E5%91%BD%E4%BB%A4"><span class="toc-text">ps命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pstree%E5%91%BD%E4%BB%A4"><span class="toc-text">pstree命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#top%E5%91%BD%E4%BB%A4"><span class="toc-text">top命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nice%E5%91%BD%E4%BB%A4"><span class="toc-text">nice命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pidof%E5%91%BD%E4%BB%A4"><span class="toc-text">pidof命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kill%E5%91%BD%E4%BB%A4"><span class="toc-text">kill命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#killall%E5%91%BD%E4%BB%A4"><span class="toc-text">killall命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%9C%89%E5%85%B3%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">2.5 有关网络操作的命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ping%E5%91%BD%E4%BB%A4"><span class="toc-text">ping命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#netstat%E5%91%BD%E4%BB%A4"><span class="toc-text">netstat命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">输入输出重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E5%91%BD%E4%BB%A4%E7%AC%A6"><span class="toc-text">管道命令符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-text">常用的转义字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">Chapter 3 Linux 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-text">文件系统概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">文件和文件类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-text">文件命名规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">文件类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-text">文件系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%EF%BC%9A%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-text">路径：绝对路径和相对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-text">软链接和硬链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-text">软链接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-4-Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">Chapter 4 Linux 权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E8%83%BD%E5%8A%9B"><span class="toc-text">4.1 用户身份与能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E5%BD%92%E5%B1%9E"><span class="toc-text">4.2 文件权限与归属</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-5-Linux-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">Chapter 5 Linux 常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-text">文本编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gedit"><span class="toc-text">gedit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vi"><span class="toc-text">vi</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2"><span class="toc-text">命令模式和输入模式切换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BA%95%E7%BA%BF%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2"><span class="toc-text">命令模式和底线命令模式切换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-text">软件包管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Samba"><span class="toc-text">Samba</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-6-Linux-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text">Chapter 6 Linux 进程管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-7-Linux-Shell"><span class="toc-text">Chapter 7 Linux Shell</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8Dshell"><span class="toc-text">各种shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell%E8%84%9A%E6%9C%AC"><span class="toc-text">Shell脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell%E8%84%9A%E6%9C%AC%E7%BB%83%E4%B9%A0"><span class="toc-text">Shell脚本练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E4%B8%8B%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%8F%98%E4%B8%BAroot%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">linux下普通用户变为root权限的三种方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-text">Linux 一些概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E"><span class="toc-text">Linux 常见目录说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">Linux 环境变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0"><span class="toc-text">考试复习</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"closeEnable":true,"closeText":"关闭提示","originalHost":null,"officialHosts":["localhost"],"encoded":""};
  window.canonical["param"] = {"permalink":"https://h1s97x.github.io/2023/12/24/Linux%E5%9F%BA%E7%A1%80/","checklink":"/js/plugins/video.js"};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        if ($(el).find('.loading-wrap').length == 0){
          $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
        }
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.chat-file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
