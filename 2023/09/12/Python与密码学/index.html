
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Python与密码学 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="编码与密码摩尔斯电码摩尔斯电码对照表
密码分析：唯密文攻击：密码分析者尽可能多的恢复出明文来
已知明文攻击：密码分析者根据明文和密文的对应关系来推出加密密钥或推导出算法
选择明文攻击：使算法可以对用,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">
<link rel="stylesheet" href="/css/site.css">


    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="Python与密码学 - Hexo"/>
    <meta name="twitter:description" content="编码与密码摩尔斯电码摩尔斯电码对照表
密码分析：唯密文攻击：密码分析者尽可能多的恢复出明文来
已知明文攻击：密码分析者根据明文和密文的对应关系来推出加密密钥或推导出算法
选择明文攻击：使算法可以对用,"/>
    
    
    
    
    <meta property="og:site_name" content="Hexo"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="Python与密码学 - Hexo"/>
    <meta property="og:description" content="编码与密码摩尔斯电码摩尔斯电码对照表
密码分析：唯密文攻击：密码分析者尽可能多的恢复出明文来
已知明文攻击：密码分析者根据明文和密文的对应关系来推出加密密钥或推导出算法
选择明文攻击：使算法可以对用,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">

    <!-- 代码块复制 -->
    <script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard@latest/dist/clipboard.js"></script>

    <!-- 点击效果 -->
    
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script type="text/javascript" src="//cdn.jsdelivr.net/gh/5MayRain/5MayRain.github.io@latest/js/fireworks.js"></script>
    

    <!-- live2d -->
    <script src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Python与密码学</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <!-- 帖子视图 -->

    <div class="post_cover" >
        
            <img src="/img/img1.jpg,/img/welcome-cover.jpg" />
        
        <div class="post_cover_mask"></div>
        <div class="post_text">
            <h1>Python与密码学</h1>
            <div>
                <span>九月 12, 2023</span>

                

            </div>
        </div>
    </div>


<div class="article">
    <div class='main'>
        <!-- 帖子视图 -->
        

        <!-- 更新时间 -->
        <div class="updated">
            <div></div>
            <span>该文章更新于 2023.09.12</span>
        </div>

        <h1 class="title">Python与密码学</h1>
        <div class="stuff">
            <span>九月 12, 2023</span>
            

        </div>
        <div class="content markdown">
            <h3 id="编码与密码"><a href="#编码与密码" class="headerlink" title="编码与密码"></a>编码与密码</h3><h5 id="摩尔斯电码"><a href="#摩尔斯电码" class="headerlink" title="摩尔斯电码"></a>摩尔斯电码</h5><p><a target="_blank" rel="noopener" href="https://morsecode.bmcx.com/">摩尔斯电码对照表</a></p>
<h3 id="密码分析："><a href="#密码分析：" class="headerlink" title="密码分析："></a>密码分析：</h3><p>唯密文攻击：密码分析者尽可能多的恢复出明文来</p>
<p>已知明文攻击：密码分析者根据明文和密文的对应关系来推出加密密钥或推导出算法</p>
<p>选择明文攻击：使算法可以对用于同一密钥加密得到的任何密文进行解密</p>
<p>选择密文攻击：能选择不同的密文，而且能得到与之对应的明文</p>
<p>一、唯密文攻击（Ciphtext Only Attack，COA）<br>定义：唯密文攻击(COA)是指仅仅知道密文的情况下进行分析，求解明文或密钥的密码分析方法。</p>
<p>假定密码分析者拥有密码算法及明文统计特性，并截获了一个或者多个用同一密钥加密的密文，通过对这些密文进行分析求出明文或密钥。COA已知条件最少，经不起唯密文攻击的密码是被认为不安全的。</p>
<p>简单理解：只知道密文，推出明文或密钥，一般用穷举攻击。</p>
<p>方法：<br>频率分析解密法。</p>
<p>这难不倒解密者，以英文字母为例，为了确定每个英文字母的出现频率，分析一篇或者数篇普通的英文文章，英文字母出现频率最高的是e，接下来是t，然后是a……，然后检查要破解的密文，也将每个字母出现的频率整理出来，假设密文中出现频率最高的字母是j，那么就可能是e的替身，如果密码文中出现频率次高的但是P，那么可能是t的替身，以此类推便就能解开加密信息的内容。这就是频率分析法。</p>
<ul>
<li>将明文字母的出现频率与密文字母的频率相比较的过程</li>
<li>通过分析每个符号出现的频率而轻易地破译代换式密码</li>
<li>在每种语言中，冗长的文章中的字母表现出一种可对之进行分辨的频率。</li>
<li>e是英语中最常用的字母，其出现频率为八分之一</li>
</ul>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数(Hash):将一种任意长度的输入变换为固定长度输出的不可逆的密码体制。<br>11.1 安全 Hash 函数需要具有那些特性<br>H能用于任何大小的数据分组;<br>H产生定长输出;<br>对任意给定的x, H(x)要相对易于计算,使得软硬件实现都实际可行;<br>单向性：对任意给定的码y, 寻求x使得H(x)&#x3D;y在计算上不可行;<br>弱抗碰撞性：任意给定分组x, 寻求不等于x的x’, 使得H(x)&#x3D; H(x’)在计算上不可行;<br>强抗碰撞性：寻求任何的(x,x’)对，使得H(x)&#x3D;H(x’)在计算上不可行;<br>11.2 弱抗碰撞性和强抗碰撞性的区别是什么<br>弱抗碰撞性是任意给定分组x, 寻求不等于x的x’, 使得H(x)&#x3D; H(x’)在计算上不可行;强抗碰撞性是寻求任何的(x,x’)对，使得H(x)&#x3D;H(x’)在计算上不可行; 前者的x是给定的，而后者是不给定的，因而强抗碰撞性的要求要比弱抗碰撞性的要求的要高。</p>
<p>11.3 Hash 函数中的压缩函数的作用是什么<br>压缩函数将一个较长的，固定长度的输入处理后，返回一个较短的，固定长度的输出。Hash函数是一种基于压缩函数的不断重复压缩输入的分组和前次压缩处理的结果，知道整个消息都被压缩完毕的过程，最后的输出作为整个消息的hash值。在这个过程中，任意长度的消息被破碎成一定长度的分组，分组的长度取决于压缩函数。并且出于安全的角度，对未填充满的分组作相应的数据填充</p>
<p>生日悖论<br>如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%</p>
<h4 id="彩虹表"><a href="#彩虹表" class="headerlink" title="彩虹表"></a>彩虹表</h4><p>什么是彩虹表？<br>    一言以蔽之，彩虹表是一种破解用户密码的辅助工具。彩虹表以时空折中理论为基础，但并不是简单地“以空间换时间”，而是一种“双向交易”，在二者之间达到平衡。1980年，公钥密码学的提出者之一Hellman针对DES算法（一种对称加密算法）提出了一种时空折中算法，即彩虹表的前身：预先计算的散列链集。2003年瑞典的Philippe Oechslin在其论文Making a Faster Cryptanalytic Time-Memory Trade-Off（参考博客2）中对Hellman的算法进行了改进，并命名为彩虹表。当时是针对Windows Xp开机认证的LM散列算法。当然，目前除了破解开机密码，彩虹表目前还能用于SHA、MD4、MD5等散列算法的破译，速度快、破解率高，正如Philippe在论文中提到的：“1.4G的彩虹表可以在13.6s内破解99.9%的数字字母混合型的Windows密码“。实际上，Philippe所做的改进本质上是减少了散列链集中可能存在的重复链，从而使空间的有效利用率更高。<br>    以MD5作为明文的散列算法H，加密后的密文为q，明文为p。彩虹表的作用就是在已知散列算法H和散列后的密文q的情况下，快速地得到明文p。<br>    针对LM、NTLM和SHA1等算法对应的彩虹表。整个破解过程为：根据密文q所使用的散列算法H，生成或者下载针对该算法的彩虹表，然后再基于彩虹表对密文进行破解，最终得到明文p。<br>不可逆的散列算法（HASH）<br>    本质上，MD5是将明文对应的二进制值与四个特定的32位的二进制值进行多轮的与、或、非、异或等运算，最终将明文对应的二进制转换成新的二进制。由于运算过程中存在进位丢失，导致人们无法根据MD5的计算过程和最终结果逆向计算出对应的明文。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1903492">深入浅出彩虹表原理</a></p>
<h3 id="课程参考书"><a href="#课程参考书" class="headerlink" title="课程参考书"></a>课程参考书</h3><p><a target="_blank" rel="noopener" href="https://cryptography.io/en/latest/">cryptography</a><br><a target="_blank" rel="noopener" href="https://www.pycryptodome.org/">pycryptodome</a></p>
<h2 id="课程实验"><a href="#课程实验" class="headerlink" title="课程实验"></a>课程实验</h2><h3 id="实验一：凯撒密码与仿射密码"><a href="#实验一：凯撒密码与仿射密码" class="headerlink" title="实验一：凯撒密码与仿射密码"></a>实验一：凯撒密码与仿射密码</h3><h4 id="caesar密码python实现"><a href="#caesar密码python实现" class="headerlink" title="caesar密码python实现"></a>caesar密码python实现</h4><p><a target="_blank" rel="noopener" href="https://www.w3schools.cn/cryptography_with_python/cryptography_with_python_affine_cipher.html">Python 密码学教程 - w3schools</a></p>
<figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def caesar_encrypt(k):</span><br><span class="line">    message = input(&#x27;请输入需要加密的字符串：&#x27;)</span><br><span class="line">    ciphertext = &#x27;&#x27;</span><br><span class="line">    for i in message:</span><br><span class="line">        ciphertext += (chr(ord(i) + k)) # 将明文汉字转换为对应ASCLL数值或Unicode数值（ord函数），然后在此数值上+3，再将该值返回汉字（chr函数）</span><br><span class="line">    print(ciphertext)</span><br><span class="line">def caesar_decrypt(k):</span><br><span class="line">    message = input(&#x27;请输入需要解密的字符串：&#x27;)</span><br><span class="line">    plaintext = &#x27;&#x27;</span><br><span class="line">    for i in message:</span><br><span class="line">        plaintext += (chr(ord(i) - k)) # 将明文汉字转换为对应ASCLL数值或Unicode数值（ord函数），然后在此数值上-3，再将该值返回汉字（chr函数）</span><br><span class="line">    print(plaintext)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    k = 3</span><br><span class="line">    caesar_encrypt(k)</span><br><span class="line">    caesar_decrypt(k)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def caesar_encrypt(key,text = &#x27;abcxyzABCXYZ&#x27;):</span><br><span class="line">    ciphertext = &#x27;&#x27;</span><br><span class="line">    for i in range(len(text)):</span><br><span class="line">        char = text[i]</span><br><span class="line">        if (char.isupper()):</span><br><span class="line">            ciphertext += chr((ord(char) + key - ord(&#x27;a&#x27;)) % 26 + ord(&#x27;a&#x27;))</span><br><span class="line">        else:</span><br><span class="line">            ciphertext += chr((ord(char) + key - ord(&#x27;A&#x27;)) % 26 + ord(&#x27;A&#x27;))</span><br><span class="line">    return ciphertext</span><br><span class="line">def caesar_decrypt(key,text = &#x27;abcxyzABCXYZ&#x27;):</span><br><span class="line">    key = -key</span><br><span class="line">    plaintext = &#x27;&#x27;</span><br><span class="line">    for i in range(len(text)):</span><br><span class="line">        char = text[i]</span><br><span class="line">        if (char.isupper()):</span><br><span class="line">            plaintext += chr((ord(char) + key - ord(&#x27;a&#x27;)) % 26 + ord(&#x27;a&#x27;))</span><br><span class="line">        else:</span><br><span class="line">            plaintext += chr((ord(char) + key - ord(&#x27;A&#x27;)) % 26 + ord(&#x27;A&#x27;))</span><br><span class="line">    return plaintext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    k = 3</span><br><span class="line">    # text = input(&quot;请输入需要加密的字符串：&quot;)</span><br><span class="line">    print(caesar_encrypt(k))</span><br><span class="line">    print(caesar_decrypt(k))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def caesar_encrypt(mode, message, key):</span><br><span class="line">    if mode[0] == &#x27;d&#x27;:</span><br><span class="line">        key = -key</span><br><span class="line">    ciphertext = &#x27;&#x27;</span><br><span class="line">    for symbol in message:</span><br><span class="line">        if symbol.isalpha():</span><br><span class="line">          num = ord(symbol)+key</span><br><span class="line">          if symbol.isupper():  # 所有密文字母是大写</span><br><span class="line">              if num &gt; ord(&#x27;Z&#x27;):</span><br><span class="line">                  num -= 26</span><br><span class="line">              elif num &lt; ord(&#x27;A&#x27;):</span><br><span class="line">                  num += 26</span><br><span class="line">          elif symbol.islower():</span><br><span class="line">              if num &gt; ord(&#x27;z&#x27;):</span><br><span class="line">                  num -= 26</span><br><span class="line">              elif num &lt; ord(&#x27;a&#x27;):</span><br><span class="line">                  num += 26</span><br><span class="line">        ciphertext += chr(num)</span><br><span class="line">        else:</span><br><span class="line">            ciphertext += symbol</span><br><span class="line">    return ciphertext</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    key = int(input(&quot;请输入偏移量：&quot;)) % 26</span><br><span class="line">    message = input(&#x27;请输入需要加密的字符串：&#x27;)</span><br><span class="line">    mode = input(&#x27;请输入加密或解密(e/d)：&#x27;)</span><br><span class="line">    print(&quot;加密或解密后的结果为：&quot;, caesar_encrypt(mode, message, key))</span><br></pre></td></tr></table></figure>
<p>暴力破解</p>
<figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def caesar_decrypt(message):</span><br><span class="line">    LETTERS = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span><br><span class="line">    letters = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">    for key in range(26):</span><br><span class="line">        translated = &#x27;&#x27;</span><br><span class="line">        for symbol in message:</span><br><span class="line">            if symbol in LETTERS:</span><br><span class="line">                num = LETTERS.find(symbol)</span><br><span class="line">                num = num - key</span><br><span class="line">                if num &lt; 0:</span><br><span class="line">                    num = num + len(LETTERS)</span><br><span class="line">                translated = translated + LETTERS[num]</span><br><span class="line">            elif symbol in letters:</span><br><span class="line">                num = letters.find(symbol)</span><br><span class="line">                num = num - key</span><br><span class="line">                if num &lt; 0:</span><br><span class="line">                    num = num + len(letters)</span><br><span class="line">                translated = translated + letters[num]</span><br><span class="line">            else:</span><br><span class="line">                translated = translated + symbol</span><br><span class="line">        print(&#x27;Hacking key #%s: %s&#x27; % (key, translated))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/clwsec/p/10198428.html">仿射密码Python实现</a><br>仿射密码是一种替换密码。它是利用加密函数一个字母对一个字母的加密。</p>
<p>加密函数是E(x)&#x3D; (ax + b) (mod m)，其中，a和m互质，m是字符集的大小。<br>（例如，26即是以26个字母作为编码，当m是26时，a必须是1，3，5，7，9，11，15，17，19，21，23，25其中之一）</p>
<p>解密函数为D(x) &#x3D; a<sup>-1</sup>(x - b) (mod m)，其中a<sup>-1</sup>是a在Zm群的乘法逆元。</p>
<blockquote>
<p><strong>乘法逆元</strong><br>群G中任意一个元素a，都在G中有唯一的逆元a’，具有性质aa’ &#x3D; a’a &#x3D; e，其中e为群的单位元。</p>
</blockquote>
<figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">仿射密码</span><br><span class="line">(a,b)</span><br><span class="line">m = 26，字符集为小写字母</span><br><span class="line">加密函数是E(x)= (ax + b) (mod m)</span><br><span class="line">解密函数为D(x) = (a^-1)(x - b) (mod m)，其中a^-1是a的乘法逆元</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">#通过一个简单的遍历得到a的乘法逆元，也可以通过gmpy2库中的invert函数实现</span><br><span class="line">def get_inverse(a):</span><br><span class="line">    for i in range(1,27):</span><br><span class="line">        if a*i%26==1:</span><br><span class="line">            return i</span><br><span class="line"></span><br><span class="line">#加密</span><br><span class="line">def encipher(a, b, p):</span><br><span class="line">    c=[]</span><br><span class="line">    for i in p:</span><br><span class="line">        temp=((ord(i)-97)*a+b)%26+97</span><br><span class="line">        c.append(chr(temp))</span><br><span class="line">    print(&#x27;&#x27;.join(c))</span><br><span class="line"></span><br><span class="line">#解密</span><br><span class="line">def decipher(a, b, c):</span><br><span class="line">    a_inv = get_inverse(a)</span><br><span class="line">    p=[]</span><br><span class="line">    for i in c:</span><br><span class="line">        temp=(((ord(i)-97)-b)*a_inv)%26+97</span><br><span class="line">        p.append(chr(temp))</span><br><span class="line">    print(&#x27;&#x27;.join(p))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    a = 11</span><br><span class="line">    b = 6</span><br><span class="line">    message = &#x27;sorcery&#x27;</span><br><span class="line">    encipher(a,b,message)</span><br><span class="line">    #decipher(a,b,message)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">仿射密码</span><br><span class="line">m = 52</span><br><span class="line">字符集为小写和大写字母</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">import string</span><br><span class="line">def encrypt(k1,k2,message):</span><br><span class="line">    dic = string.ascii_letters</span><br><span class="line">    c = []</span><br><span class="line">    for i in message:</span><br><span class="line">        if i.islower():</span><br><span class="line">            num = ord(i)-ord(&#x27;a&#x27;)</span><br><span class="line">            c.append(dic[(num*k1+k2)%52])</span><br><span class="line">        elif i.isupper():</span><br><span class="line">            num = ord(i)-ord(&#x27;A&#x27;)+26</span><br><span class="line">            c.append(dic[(num*k1+k2)%52])</span><br><span class="line">        else:</span><br><span class="line">            c.append(i)</span><br><span class="line">    print(&#x27;&#x27;.join(c))</span><br><span class="line"></span><br><span class="line">def decrypt(k1,k2,message):</span><br><span class="line">    for i in range(52):</span><br><span class="line">        if k1*i%52==1:</span><br><span class="line">            inv = i</span><br><span class="line">            break</span><br><span class="line">    dic = string.ascii_letters</span><br><span class="line">    m = []</span><br><span class="line">    for i in message:</span><br><span class="line">        if i.islower():</span><br><span class="line">            num = ord(i)-ord(&#x27;a&#x27;)</span><br><span class="line">            m.append(dic[inv*(num-k2)%52])</span><br><span class="line">        elif i.isupper():</span><br><span class="line">            num = ord(i)-ord(&#x27;A&#x27;)+26</span><br><span class="line">            m.append(dic[inv*(num-k2)%52])</span><br><span class="line">        else:</span><br><span class="line">            m.append(i)</span><br><span class="line">    print(&#x27;&#x27;.join(m))</span><br><span class="line"></span><br><span class="line">message = &#x27;gVEXGT iDIT&#x27; #待加密或解密的消息</span><br><span class="line">a = 5 # key的范围0~51之间</span><br><span class="line">b = 29 # key的范围0~51之间</span><br><span class="line"># encrypt(a,b,message)</span><br><span class="line">decrypt(a,b,message)</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Affine(object):</span><br><span class="line">    DIE = 128</span><br><span class="line">    KEY = (7, 3, 55)</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def encryptChar(self, char):</span><br><span class="line">        K1, K2, kI = self.KEY</span><br><span class="line">        return chr((K1 * ord(char) + K2) % self.DIE)</span><br><span class="line"></span><br><span class="line">    def encrypt(self, string):</span><br><span class="line">        return &quot;&quot;.join(map(self.encryptChar, string))</span><br><span class="line"></span><br><span class="line">    def decryptChar(self, char):</span><br><span class="line">        K1, K2, KI = self.KEY</span><br><span class="line">        return chr(KI * (ord(char) - K2) % self.DIE)</span><br><span class="line"></span><br><span class="line">    def decrypt(self, string):</span><br><span class="line">        return &quot;&quot;.join(map(self.decryptChar, string))</span><br><span class="line"></span><br><span class="line">affine = Affine()</span><br><span class="line">print(affine.encrypt(&#x27;Affine Cipher&#x27;))</span><br><span class="line">print(affine.decrypt(&#x27;*18?FMT&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实验二：哈希函数"><a href="#实验二：哈希函数" class="headerlink" title="实验二：哈希函数"></a>实验二：哈希函数</h3><p>1、	编程实现生成空字符串、‘Alice’、‘Bob’的md5、sha256的哈希值；</p>
<figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">def hash_md5():</span><br><span class="line">    alice = hashlib.md5(b&quot;Alice&quot;)</span><br><span class="line">    bob = hashlib.md5(b&quot;Bob&quot;)</span><br><span class="line">    print(&#x27;&quot;Alice&quot; md5:&#x27; + alice.hexdigest())</span><br><span class="line">    print(&#x27;&quot;Bob&quot; md5:&#x27; + bob.hexdigest())</span><br><span class="line"></span><br><span class="line">def hash_sha256():</span><br><span class="line">    alice = hashlib.sha256(b&quot;Alice&quot;)</span><br><span class="line">    bob = hashlib.sha256(b&quot;Bob&quot;)</span><br><span class="line">    print(&#x27;&quot;Alice&quot; sha256:&#x27; + alice.hexdigest())</span><br><span class="line">    print(&#x27;&quot;Bob&quot; sha256:&#x27; + bob.hexdigest())</span><br></pre></td></tr></table></figure>
<p>2、	编程实现生成自己名字的哈希值，注意编码的转换；</p>
<figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def myhash(str = &quot;Yangjiaqing&quot;):</span><br><span class="line">    res = hashlib.md5(str.encode(encoding=&quot;utf-8&quot;))</span><br><span class="line">    print(str + &quot; md5: &quot; + res.hexdigest())</span><br></pre></td></tr></table></figure>
<p>3、	编写体现哈希雪崩的代码，哈希值用二进制表示； 参考Listing2-5 代码；<br><a target="_blank" rel="noopener" href="https://huaweicloud.csdn.net/63807e39dacf622b8df88c1c.html#:~:text=%23%20%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%20%23%20author%3Amarxycj%20%23%20date%3A2021-10-29%20from%20hashlib,%27__main__%27%20%3A%20md5_value%20%3D%20input%20%28%29%20brute_md5%20%28md5_value%29">Python 哈希函数与消息认证实验</a><br><a target="_blank" rel="noopener" href="https://www.wolfram.com/language/12/cryptography/demonstrate-the-avalanche-effect-of-a-hash-function.html.zh">展示散列函数的雪崩效应</a></p>
<figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def cmpcount(str1, str2):</span><br><span class="line">    count = 0</span><br><span class="line">    for i in range(0, len(str1)):</span><br><span class="line">        if str1[i] != str2[i]:</span><br><span class="line">            count += 1</span><br><span class="line">    return count</span><br><span class="line"></span><br><span class="line">def avalanche(str1 = &#x27;bob&#x27;, str2 = &#x27;aob&#x27;):</span><br><span class="line">    bin1 = str1.encode(&#x27;utf-8&#x27;)</span><br><span class="line">    bin2 = str2.encode(&#x27;utf-8&#x27;)</span><br><span class="line">    hexstring1 = hashlib.md5(bin1).hexdigest()</span><br><span class="line">    binstring1 = &#x27;&#123;:08b&#125;&#x27;.format(int(hexstring1, 16))</span><br><span class="line">    # binstring1 = bin(int(hexstring1, 16))</span><br><span class="line">    hexstring2 = hashlib.md5(bin2).hexdigest()</span><br><span class="line">    binstring2 = &#x27;&#123;:08b&#125;&#x27;.format(int(hexstring2, 16))</span><br><span class="line">    # binstring2 = bin(int(hexstring2, 16))</span><br><span class="line">    print(int(hexstring1, 16))</span><br><span class="line">    print(int(hexstring2, 16))</span><br><span class="line">    print(str1 + &quot; md5:&quot; + binstring1)</span><br><span class="line">    print(str2 + &quot; md5:&quot; + binstring2)</span><br><span class="line">    print(&quot;两个哈希值不同的位数：&quot; + str(cmpcount(binstring1, binstring2)))</span><br></pre></td></tr></table></figure>
<p>4、	利用scrypt密钥派生函数，实现口令加盐，生成更加安全的密钥（口令）；<br><a target="_blank" rel="noopener" href="https://deepinout.com/python/python-qa/169_python_creating_a_salt_in_python.html#:~:text=Python%203.6%2B%20%E7%9A%84%20secrets%20%E6%A8%A1%E5%9D%97%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E7%A7%8D%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E3%80%82%20%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BD%BF%E7%94%A8%20secrets%20%E6%A8%A1%E5%9D%97%E7%94%9F%E6%88%90%E7%9B%90%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A,16%20salt%20%3D%20secrets.token_hex%28salt_length%29%20print%28salt%29%20%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E5%B0%86%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E9%95%BF%E5%BA%A6%E4%B8%BA%2016%20%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E7%9B%90%E3%80%82">创建一个 Python 盐</a><br>Scrypt介绍<br>Scrypt 是一个强大的密钥派生函数，其通过内存密集的计算方式来抵抗 GPU、ASIC、FPGA 这类密码破解硬件的攻击。</p>
<p>Scrypt 接收多个输入参数，进行计算后输出密钥：</p>
<p>key &#x3D; Scrypt(password, salt, N, r, p, derived-key-len)<br>其中的参数被称为” Scrypt 配置参数”，说明如下：</p>
<blockquote>
<p>N - 迭代次数，将影响 CPU 和内存用量，例：16384 、2048 ；<br>r - 块大小，将影响 CPU 和内存用量，例：8 ；<br>p - 并行因数 （并行运行的线程数，将影响 CPU 和内存用量），通常为 1 ；<br>password - 输入的密码（推荐至少为 8 - 10 个字符）；<br>salt - 安全产生的随机字节序列（最小为 64 位，推荐 128 位）；<br>derived-key-len - 输出的密钥要有多少字节长，例如 32 （256 位）<br>Scrypt 的输出密钥长度可以是 128 位到 512 位，但是通常为 256 位。</p>
</blockquote>
<p>Salt 用使用 secrets 模块生成，也可以用os.urandom()随机生成</p>
<figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def hash_password(password = b&#x27;p@$Sw0rD~7&#x27;):</span><br><span class="line">    salt_length = 16</span><br><span class="line">    salt = secrets.token_bytes(salt_length)</span><br><span class="line">    key = pyscrypt.hash(password, salt, 2048, 8, 1, 32)</span><br><span class="line">    return key.hex()</span><br></pre></td></tr></table></figure>
<p>5、	实现区块链中的工作量证明编程，通过设置不同的难度，体会生成符合要求哈希值需要时间长短的不同；<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29903461">从零开始构建一个区块链（二）： 工作量证明</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaobing1994/article/details/87967693">使用python实现简版区块链-工作量证明</a><br><a target="_blank" rel="noopener" href="https://github.com/xiaobing94/pysimpleblockchain/tree/part2">区块链的简单实现 - github</a></p>
<figure class="highlight plaintext"><input class="btn-copy" type="image" src="/img/icon/copy.svg" alt="复制" /><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import hashlib</span><br><span class="line">class NonceNotFoundError(Exception):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def encode(str, code=&#x27;utf-8&#x27;):</span><br><span class="line">    return str.encode(code)</span><br><span class="line"></span><br><span class="line">def decode(bytes, code=&#x27;utf-8&#x27;):</span><br><span class="line">    return bytes.decode(code)</span><br><span class="line"></span><br><span class="line">def sum256_hex(*args):</span><br><span class="line">    m = hashlib.sha256()</span><br><span class="line">    for arg in args:</span><br><span class="line">        if isinstance(arg, str):</span><br><span class="line">            m.update(arg.encode())</span><br><span class="line">        else:</span><br><span class="line">            m.update(arg)</span><br><span class="line">    return m.hexdigest()</span><br><span class="line"></span><br><span class="line">def sum256_byte(*args):</span><br><span class="line">    m = hashlib.sha256()</span><br><span class="line">    for arg in args:</span><br><span class="line">        if isinstance(arg, str):</span><br><span class="line">            m.update(arg.encode())</span><br><span class="line">        else:</span><br><span class="line">            m.update(arg)</span><br><span class="line">    return m.digest()</span><br><span class="line"></span><br><span class="line">class ProofOfWork(object):</span><br><span class="line">    _N_BITS = 20</span><br><span class="line">    MAX_BITS = 256</span><br><span class="line">    MAX_SIZE = sys.maxsize</span><br><span class="line">    def __init__(self, n_bits=_N_BITS):</span><br><span class="line">        self._n_bits = n_bits</span><br><span class="line">        self._target_bits = 1 &lt;&lt; (self.MAX_BITS - n_bits)</span><br><span class="line">    def _prepare_data(self, nonce):</span><br><span class="line">        data_lst = [str(nonce)]</span><br><span class="line">        return encode(&#x27;&#x27;.join(data_lst))</span><br><span class="line">    def run(self):</span><br><span class="line">        nonce = 0</span><br><span class="line">        found = False</span><br><span class="line">        hash_hex = None</span><br><span class="line">        print(&#x27;Mining a new block&#x27;)</span><br><span class="line">        while nonce &lt; self.MAX_SIZE:</span><br><span class="line">            data = self._prepare_data(nonce)</span><br><span class="line">            hash_hex = sum256_hex(data)</span><br><span class="line">            hash_val = int(hash_hex, 16)</span><br><span class="line">            sys.stdout.write(&quot;try nonce == %d hash_hex == %s \r&quot; % (nonce, hash_hex))</span><br><span class="line">            if (hash_val &lt; self._target_bits):</span><br><span class="line">                found = True</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            nonce += 1</span><br><span class="line">        if found: </span><br><span class="line">            print(&#x27;Found nonce == %d&#x27; % nonce)</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;Not Found nonce&#x27;)</span><br><span class="line">            raise NonceNotFoundError(&#x27;nonce not found&#x27;)</span><br><span class="line">        return nonce, hash_hex</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    bc = ProofOfWork()</span><br><span class="line">    bc.run()</span><br></pre></td></tr></table></figure>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="true"
        data-ae="false"
        data-ci="bf8247f1f66a43abd91f"
        data-cs="8151e71fe008a0f849031b72d321c20af8e897af"
        data-r="h1s97x.github.io"
        data-o="h1s97x"
        data-a="h1s97x"
        data-d="true"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>
<script src="/js/codeCopy.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
